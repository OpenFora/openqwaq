'From Croquet1.0beta of 11 April 2006 [latest update: #1] on 21 June 2010 at 5:12:53 pm'!"Change Set:		Mobile3517Date:			23 June 2010Author:			Howard StearnsCleanup 3.5.17 for mobile and improved recording for weak machines (which includes our test pool).Qwaq-Service-hrs.1827 auto-accept dialogs in mobile proxy	part of https://bugs.qwaq.com/view.php?id=2207Qwaq-Tools-hrs.1370, Croquet-Harness-hrs.556, 2533 poor performance when recording.	https://bugs.qwaq.com/view.php?id=2534Qwaq-Tools-hrs.1369 recording/webcast falling behind on low idle rates	https://bugs.qwaq.com/view.php?id=2532Qwaq-Sound-jcg.595 (just the delta, without intervening) Stop filling transcript with 'no device' messages.	The proxy has no audio devices, and so is subjected to these four messages/second in transcript."!TObject subclass: #TViewPane	instanceVariableNames: 'myEventMap space spaceColor camera bounds avatar window event eventPointer task taskStack entryPostcard mouseIsDriving frameCounter savedSceneForm lastCameraTransform isMiniScene isSessionCapture renderInterval useOGLForSavedScene renderWhenObscured transitionMutex frameSelectionTable captureIsCurrent'	classVariableNames: ''	poolDictionaries: 'OpenGLConstants'	category: 'Croquet-Harness'!!QAudioDeviceManager methodsFor: 'private' stamp: 'jcg 6/15/2010 23:53'!checkForDeviceChange: startTime	| msg flattened prefs pluginDevice playersChanged recordersChanged |	startTime == deviceCheckStart ifFalse: [^self "somebody else's problem now"].	"Don't check until we're back from away.  This avoids potential side-effects,	 such as inadvertently turning sound on."	audioSession ui isAway ifTrue: [		(self future: deviceCheckInterval) checkForDeviceChange: startTime.		^self	].	"Message that appears in QSoundDialog to explain to the user	 what sort of change has occurred."	msg := nil.	prefs := audioSession ui preferences.	"Check if the lists of audio-player/recorder devices have changed."	playerDevices := self class playerDevices.	flattened := QAudioDeviceManager flattenedDeviceList: playerDevices.	(playersChanged := prefs audioPlayers ~= flattened) ifTrue: [		msg := 'Available devices have changed'.		prefs audioPlayers: flattened.	].	recorderDevices := self class recorderDevices.	flattened := QAudioDeviceManager flattenedDeviceList: recorderDevices.	(recordersChanged := prefs audioRecorders ~= flattened) ifTrue: [		msg := 'Available devices have changed'.		prefs audioRecorders: flattened.	].	"Check if the selected audio-player/recorder devices have changed."	pluginDevice := SoundPlayer defaultPlayer.	playersChanged ifTrue:[		"If the player devices have changed, try to pick the last user-selected		device so that unplugging and replugging automatically picks the 'right' choice."		pluginDevice := playerDevices detect:[:any| any = selectedPlayerDevice] ifNone:[pluginDevice].	].	(pluginDevice notNil and: [defaultPlayer = pluginDevice]) ifFalse: [		pluginDevice ifNil: [			"Try to find a suitable device."			pluginDevice := QAudioDeviceManager 								reasonableDefaultDeviceFrom: playerDevices		].		pluginDevice 			ifNil: [QLogger logWarning: 'no player devices are available' every: 60000]			ifNotNil: [				self setDefaultPlayerDevice: pluginDevice.				"Don't change existing message... the first one set is more important."				msg ifNil: [msg := 'Computer speaker choice has been changed']].	].	pluginDevice := SoundRecorder defaultRecorder.	recordersChanged ifTrue:[		"If the recorder devices have changed, try to pick the last user-selected		device so that unplugging and replugging automatically picks the 'right' choice."		pluginDevice := recorderDevices detect:[:any| any = selectedRecorderDevice] ifNone:[pluginDevice].	].	(pluginDevice notNil and: [defaultRecorder = pluginDevice]) ifFalse: [		pluginDevice ifNil: [			"Try to find a suitable device."			pluginDevice := QAudioDeviceManager 								reasonableDefaultDeviceFrom: recorderDevices		].		pluginDevice 			ifNil: [QLogger logWarning: 'no recorder devices are available' every: 60000]			ifNotNil: [				self setDefaultRecorderDevice: pluginDevice.				"Don't change existing message... the first one set is more important."				msg ifNil: [msg := 'Computer microphone choice has been changed.']].	].	"Devices have changed... figure out how much resetting is necessary to do, and do it."	(playersChanged or:[recordersChanged]) ifTrue: [		(Smalltalk platformName = 'Win32') 			ifTrue: [				"We could slice this finer: if devices are only removed, not added,				 then the OpenAL reset is not necessary."				audioSession nextResetShouldUnloadOpenAL.				"Trigger the reset sound via the UI... 				 this will result in a #future send that we'll process shortly."				"The original idea was to immediately do just the QAudioSession parts 				 (since we're already in the correct event-loop), but ensuring that the UI 				 would be reset properly proved to be too complicated.  Anyway, there's 				 nothing really wrong with doing it this way".				audioSession ui 					signal: #resetSound 					with: 'detected change in list of available players/recorders'			]			ifFalse: [				"Something has changed, either the lists of available devices, or the 				 currently selected device.  We don't want to do a full reset-sound, so				 let's just reset the audio-interace."				audioSession 					stopMicrophoneRecordingDuring: [audioSession resetAudioInterface].			].	].		msg ifNotNil: [		"Something has changed, either the lists of available devices, or the 		 currently selected device.  Notify any interested parties... let them		 sort out the details."		audioSession ui			signal: #ensureOpenSoundDialog			with: msg.	].	(self future: deviceCheckInterval) checkForDeviceChange: startTime.! !!QForeignClientProxy methodsFor: 'initialize-release' stamp: 'hrs 6/15/2010 15:12'!participantUI: aParticipantUI uiPubID: aTObjectID	"Causes us to use aTObjectID as the streamID for the UI stream on aParticpantUI."	externalRelay ifNotNil: [self error: 'Reinitialization while connected to client.'].	participantUI := aParticipantUI.	uiPubID := aTObjectID.	debugID := TObjectID new.	"XML descriptions of streams we know about specially."	streamDataCache := Dictionary new.	self startScript: #handleDialog: when: { Smalltalk . #InformDialog }.	self startScript: #handleDialog: when: { Smalltalk . #ConfirmDialog }.! !!QSessionCapturePane methodsFor: 'capture' stamp: 'hrs 6/11/2010 17:58'!onCaptureFrame	"Capture a rendered frame. Push it into the encoder if there is one."	| form expectedFrame cView maxFrames didEncodeSomething |	<on: savedSceneChanged in: captureView>	captureView ifNotNil: [:cv | cView := cv "avoid race condition"] ifNil:[^self].	encoder ifNil:[^self].	"XXXX: Fixme. We need to set the camera here again since the viewpane will dump it when OpenGL changes (which it does upon the first frame). Consequently, we skip all the frames that have 'wrong' camera to avoid flickering."	captureCam ifNotNil: [		(captureCam := owner avatar camera) == cView camera ifFalse: [		cView camera: captureCam.		^self].	].	form := cView savedSceneForm ifNil:[^self].	expectedFrame := self expectedFrame.	"Amortize catching-up; no more than 2 frames per normal rendered frame.	 Encoding is costly, if we're behind, forcing more encoding 	 per rendered frame just drives everything further behind.	 But if the UI is in idle-render, we expect large gaps between frames, so allow more infill."	maxFrames := (owner isIdlingFrames ifTrue: [ 25 ] ifFalse: [ 2 ]).	didEncodeSomething := false.	1 to: maxFrames do: [ : i |		expectedFrame > capturedFrameCount ifTrue: [ 			"Don't push frames back to back, give a pause; otherwise the encoder	 		 tries to launch worker threads and often crashes in the MainConcept code."			i > 1 ifTrue: [ (Delay forMilliseconds: 10) wait ].			encoder ifNil: [ ^ self ].			encoder encode: form.			"Don't push them more than 4x  as fast as the frame-rate would indicate."			capturedFrameCount := capturedFrameCount + 1.			didEncodeSomething := true.		]].	"Tell the renderer if we're really consuming captures. For example, if the rendering rate	is higher than the the recording frame rate, there's no need for the renderer to be capturing	stuff we can't use (which is expensive). A consequence of this efficiency, though, is that	we can be recording at as much as one frame behind what is really rendering."	cView captureIsCurrent: didEncodeSomething.! !!TViewPane methodsFor: 'private-render' stamp: 'hrs 6/11/2010 11:40'!saveMiniScene: ogl	"Capture the current buffer state as savedSceneForm; 	 this creates the form we use to render miniScenes most of the time.	 This is the true-size capture; miniscenes are expected to be small."	(savedSceneForm isNil or: [ savedSceneForm extent ~= bounds extent ]) ifTrue: [		savedSceneForm := Form extent: (bounds extent) depth: 32.	].	"We only take the actual screenshot when the window is not obscured	or it's okay to render an obscured window. However, we do pretend that	a new scene was created for the sole benefit of the session recorder since	it needs to push video frames at a constant rate and can't catch up with	the situation when it lags significantly behind (for example when people 	switch to another app, work for a couple of minutes, then switch back to forums).	This is still not the 'right' solution but it sure as hell beats the garbage we	get when we try to capture a scene from a partiall occluded window."	(renderWhenObscured or:[Smalltalk isMainWindowObscured ~~ true]) ifTrue:[		"Similarly, we don't really take an actual screenshot if the previous result wasn't used.		Note that we never set captureIsCurrent to false. It is up to clients to do so."		captureIsCurrent ifTrue:[		ogl screenShot: bounds			into: savedSceneForm			flipped: (useOGLForSavedScene not).		"Flip it to 'normal' if the client is drawing the form"		].	].	frameCounter := 0.	self signal: #savedSceneChanged.! !!TViewPane methodsFor: 'accessing' stamp: 'hrs 6/11/2010 11:14'!captureIsCurrent: aBoolean	"If true, the next available frame should really be captured. 	E.g., a frame is due at the current encoding rate."	captureIsCurrent := aBoolean! !!TViewPane methodsFor: 'initialize' stamp: 'hrs 6/11/2010 11:13'!initialize	bounds := 0@0 extent: 320@240.	"Arbitrary, but handy for the fallbackPreview: default"	camera := TCamera new.	task := TTaskMain new.	task view: self.	eventPointer := TPointer new.	mouseIsDriving := false.	isMiniScene := false.	isSessionCapture := false.	captureIsCurrent := true.	renderInterval := 25.	"For miniscenes, render once every n frames"	useOGLForSavedScene := true.  	"Use drawpixels when re-rendering -the default for normal views."	renderWhenObscured := true. "by default, render always"	camera addChild: eventPointer.	transitionMutex := Mutex new.! !!QwaqParticipantUI methodsFor: 'logon-off' stamp: 'hrs 6/25/2010 13:36'!makeMobileProxy: portOrPubID	| dispatcher pubID |	<on: makeMobileProxy>	mobileProxy ifNotNil: [mobileProxy destroy].	portOrPubID isNumber ifTrue: [ "Originally launched interactively in dev menu."		"This allows foreign client testing of message relays and streams."		"mobileProxy := QStreamingRouterTest new setUpMockProxy: port participant: self."		dispatcher := HTTPSecureServiceDispatcher new.		dispatcher accessLog: QLogger; errorLog: QLogger.		dispatcher addFacetService: '/facet'.		mobileProxy := QForeignClientProxy setUpProxy: self dispatcher: dispatcher.		"UI streamID is hardcoded to QForeignClientProxy uiPubID / uiSubID."		dispatcher listenOn: portOrPubID.	] ifFalse: [  "We're given a pubID by Teleplace startup.  Clients connect to router, not us."		mobileProxy ifNotNil: [mobileProxy destroy].		TAnimationManager softwareAnimation. "In case QMachinePrefs is not already specifying it."		pubID  := TObjectID readHexFrom: portOrPubID.		QLogger logInfo: 'Creating proxy for ', portOrPubID.		mobileProxy := QForeignClientProxy participantUI: self  uiPubID: pubID.		login forumGoal ifNil: ["we're already there, and never will receive another signal"			mobileProxy startScript: #ensureHub.		] ifNotNil: [			mobileProxy runScript: #ensureHub  when: { self . #ready }.			mobileProxy runScript: #ensureHub  when: { self . #alreadyPresent }.		].		"for local proxy testing, listen for loginFacet on 9997"		self isSealedApplication ifFalse: [			dispatcher := HTTPSecureServiceDispatcher new.			QForeignClientProxy localListener: mobileProxy dispatcher: dispatcher.			dispatcher listenOn: 9997.			QForeignClientProxy uiPubID: pubID. "so QExampleForeignClient can test in same image"		].		"Kill the proxy if nothing happens after a bit:			- We don't want a load on server or for participants to be fooled.			- We do want an explicit check with logging in Transcript."		mobileProxy future: 180 action: #checkConnection.	]! !