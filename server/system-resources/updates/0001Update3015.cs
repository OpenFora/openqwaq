'From Croquet1.0beta of 11 April 2006 [latest update: #1] on 29 September 2009 at 10:27:18 pm'!!QFixedDisplay methodsFor: 'hierarchy' stamp: 'bgf 9/27/2009 12:29'!root: t1 	super root: t1.	sheet		ifNotNil: [t1				ifNil: [sheet contentCard unregisterContent]				ifNotNil: [sheet contentCard registerContent]]! !!QLogger methodsFor: 'logging' stamp: 'bgf 9/27/2009 12:29'!drainLogger	| t1 |	process		ifNil: [^ self].	t1 := process priority.	process suspend.	process priority: Processor activeProcess priority + 5.	process resume.	Processor yield.	(Delay forMilliseconds: 5) wait.	process suspend.	process priority: t1.	process resume! !!QLogger class methodsFor: 'log api' stamp: 'bgf 9/27/2009 12:29'!drainLogger	^ self default drainLogger! !!CroquetSession methodsFor: 'accessing' stamp: 'bgf 9/29/2009 13:38'!processMessages	| pending msg |	controllers isEmptyOrNil ifTrue: [ ^ self ].	eventQueue ifNil: [ ^ self ].	pending := eventQueue.	eventQueue := SharedQueue new.	[msg := pending nextOrNil.	msg == nil] whileFalse:[msg value].	 	controllers ifNotNil: [ controllers do:[:each| each mutex critical: [ each processMessages] ifLocked:[]]].! !!MView class methodsFor: 'label support' stamp: 'bgf 9/27/2009 12:29'!newLabel: t1 text: t2 extent: t3 brushed: t4 	| t5 |	t5 := t1 new extent: t3;				 contents: t2;				 material: QMaterials flatWhiteAlphaMaterial;				 checkAlpha;				 styleName: #SignStyle;				 margin: 0;				 cullFace: false;				 yourself.	t4		ifTrue: [t5 textColor: Color white;				 backgroundColor: Color lightGray;				 visible: false]		ifFalse: [t5 textColor: Color lightGray;				 backgroundColor: Color transparent;				 visible: true].	^ t5! !!QClientSpeaker methodsFor: 'initialize' stamp: 'bgf 9/27/2009 12:29'!initializeForRef	super initializeForRef.	transform := ref get: #globalTransformReal.	self		regionChanged: (ref get: #region).	self		onVolumeChanged: (ref get: #volume).	(ref get: #isPlaying)		ifTrue: [self play]		ifFalse: [self stop].	(ref get: #streamID)		ifNotNilDo: [:t1 | self streamID: t1]! !!QFixedDisplay methodsFor: 'events' stamp: 'bgf 9/27/2009 12:29'!onContentChanged	floatButton visible: sheet contentCard isApplicationContent.	self isDropEnabled		ifTrue: [self document				ifNotNilDo: [:t1 | t1 shortName						ifNotNilDo: [:t2 | self buttonLabel: t2]						ifNil: [self buttonLabel: 'Document']]				ifNil: ['Empty Display']].	sheet pickable: sheet isEmpty not.	self root		ifNotNil: [sheet contentCard registerContent].	self signal: #contentsChanged.	self shapeChanged! !!QMainViewPlayer methodsFor: 'initialize' stamp: 'bgf 9/29/2009 13:47'!view: aView	super view: aView.	self stopScript: #onRenderStart.	self stopScript: #onRenderEnd.	aView ifNotNil: [		self startScript: #onRenderStart when: { aView . #aboutToRender }.		self startScript: #onRenderEnd when: { aView . #endOfRender }.	].! !!QRFBTalker methodsFor: 'connecting' stamp: 'bgf 9/27/2009 12:29'!connect	self isConnected		ifTrue: [^ self error: 'This viewer is already connected.'].	(socket := RFBClientSocket connectedToServer) isNil		ifTrue: [^ self].	socket setOption: 'TCP_NODELAY' value: 1.	process := [self clientRunLoop]				forkAt: self clientPriority! !!QSessionCapturePane methodsFor: 'private' stamp: 'jcg 9/29/2009 10:57'!decoderConfigDataFor360x240	^ #(1 66 128 31 255 225 0 10 39 66 128 31 150 83 2 227 252 78 0) asByteArray! !!QSessionRecorderPane methodsFor: 'recording' stamp: 'bgf 9/27/2009 12:29'!stopRecording	| t1 t2 t3 |	self isRecording		ifFalse: [^ self].	t1 := self elapsedMSecs.	super stopRecording.	self recordButton label: 'Record'.	self title: 'Session Recorder'.	(t3 := self owner avatarReplica) isValidFarRef		ifTrue: [t3				futureDo: #isRecordingSession:				at: 0				args: {false}].	t2 := t1 // 240 max: 1500.	[t2 > 0]		whileTrue: [self owner statusInfo: 'Preparing MP4 from session recording...'.			(Delay				forMilliseconds: (1000 min: t2)) wait.			self owner readyForEvents				ifFalse: [^ nil].			t2 := t2 - 1000].	self owner readyForEvents		ifTrue: [self dropFileCard: self document.			self deleteCurrentRecording]! !!QSoundFramePlayer methodsFor: 'initialize' stamp: 'bgf 9/27/2009 12:29'!initializeForRef	super initializeForRef.	referenceDistance := ref get: #referenceDistance.	maxDistance := ref get: #maxDistance.	gain := ref get: #gain.	transform := ref get: #globalTransformReal.	isLooping := ref get: #isLooping.	self updateSampledSound! !!QSpeaker methodsFor: 'accessing' stamp: 'bgf 9/27/2009 12:29'!updateTransform	self root		ifNotNil: [super updateTransform.			self				region: (self root soundRegionContaining: self globalTransform translation)]! !!QTextEditPane methodsFor: 'initialize' stamp: 'bgf 9/27/2009 12:29'!onEnterKey	<on: enterPressed in: textEditor >	self textEditor readOnly		ifTrue: [^ self onCancel].	self okButton		borderColor: (Color gray: 0.3).	self visible: false.	self onOK! !!QUserPreferences methodsFor: 'initialize-release' stamp: 'bgf 9/27/2009 12:29'!initializeMachinePreferences	machinePreferences := QMachinePreferences new signalledObject: self.	[machinePreferences load]		on: Error		do: [:t1 | QLogger logWarning: 'Cannot read machine preference record: ' , t1 description]! !!QUsersPane methodsFor: 'extras' stamp: 'bgf 9/27/2009 12:29'!canTextUser: t1 	| t2 |	(t2 := self owner meetingState)		ifNotNil: [t2 isPrivateTextBlocked				ifTrue: [^ false]].	t1		ifNil: [^ false].	t1 isLoggedIn		ifFalse: [^ false].	t1 presenceRecord		ifNil: [^ false].	t1 presenceRecord isPrivateTextBlocked		ifTrue: [^ false].	(self owner servicesPane entryForUrl: t1 currentForumURL)		ifNotNilDo: [:t3 | | t4 | (t4 := t3 forumSession)				ifNotNil: [t4 isPrivateTextBlocked						ifTrue: [^ false]]].	^ true! !!QWall methodsFor: 'accessing' stamp: 'bgf 9/27/2009 12:29'!extent: t1 	extent = t1		ifTrue: [^ self].	extent := t1.	mesh		extentX: t1 x		y: t1 y		z: thickness;				translationX: 0		y: t1 y / 2		z: 0! !!QWall methodsFor: 'accessing' stamp: 'bgf 9/27/2009 12:29'!isPlacementLocked: t1 	super isPlacementLocked: t1! !!QWall methodsFor: 'initialize' stamp: 'bgf 9/27/2009 12:29'!initialize	super initialize.	thickness := self class defaultThickness.	mesh := TCube new.	self addChild: mesh.	self eventMask: EventPointerDown.	mesh material color: Color white! !!QwaqAudioSession methodsFor: 'accessing' stamp: 'bgf 9/27/2009 12:29'!step	self updateAllIslands! !!QwaqParticipantUI methodsFor: 'menu' stamp: 'bgf 9/27/2009 12:29'!showAboutBox	QActivityCapture countAction: #HelpMenuAbout.	self serviceMgr		ifNotNil: [self aboutBox serviceName value: 'Organization:	' , self serviceMgr orgName.			self aboutBox serviceHost value: 'Hosted At:	' , self login serviceHost.			self aboutBox tosLabel				value: (self class tosLabelForOrg: self serviceMgr currentOrg).			self userLogin				ifNotNilDo: [:t1 | self aboutBox userLogin value: 'Logged In As:	' , t1]				ifNil: [self aboutBox userLogin value: 'Not Logged In']].	self aboutBox versionLabel label: self aboutBox infoString.	self aboutBox position: self dialogCenter;		 layoutEverything.	self add: self aboutBox.	self aboutBox visible: true! !!QwaqParticipantUI methodsFor: 'error handling' stamp: 'bgf 9/27/2009 12:29'!fullReportFor: t1 error: t2 stack: t3 on: t4 	QLogger drainLogger.	self waitTick.	t4 nextPutAll: t1;		 cr.	t2		ifNotNil: [t4 nextPutAll: t2 description;				 cr].	t4 nextPutAll: 'Version: ' , QwaqVersion current infoString;		 cr.	[self isDemonic		ifTrue: [t4 nextPutAll: self myDemon infoString;				 cr;				 cr].	t4 nextPutAll: self login summaryString;		 cr;		 nextPutAll: 'Session duration: '			, (self session					ifNil: ['(no session)']					ifNotNil: [self session timeOnline]);		 cr;		 cr;		 nextPutAll: self statisticsPane reportString;		 cr;		 cr;		 nextPutAll: self usersPane loggedInUserSummaryString;		 cr;		 cr;		 nextPutAll: Python statusInformationString;		 cr;		 cr]		on: Error		do: [:t5 | t4 cr; nextPutAll: 'Session details truncated: ' , t5 description; cr].	t3		ifNotNil: [self printStackReport: t3 on: t4.			t4 cr].	t4 nextPutAll: '------- Transcript -------';		 cr;		 nextPutAll: self logView panel contents;		 cr;		 cr;		 nextPutAll: '------- Five Second ObjectID Log -------';		 cr.	TObjectID fiveSecondLogReport: t4.	t4 cr; cr; nextPutAll: '------- System Profile -------'; cr; nextPutAll: QwaqVersion sysProfile; cr! !!RFBClient methodsFor: 'connecting' stamp: 'bgf 9/27/2009 12:29'!connect	self isConnected		ifTrue: [^ self inform: 'This viewer is already connected.'].	(socket := RFBClientSocket connectedToServer) isNil		ifTrue: [^ self].	socket setOption: 'TCP_NODELAY' value: 1.	process := [self clientRunLoop]				forkAt: self clientPriority! !!RFBPixelFormat methodsFor: 'encoding' stamp: 'bgf 9/27/2009 12:29'!display: t1 on: t2 at: t3 	| t4 |	t2		fill: (t3 extent: t1 extent)		fillColor: Color black.	t4 := BitBlt toForm: t2.	t4 sourceForm: t1;		 combinationRule: Form paint;		 destOrigin: t3;		 colorMap: colourMap;		 copyBits.	t2 depth == 32		ifTrue: [t4 sourceForm: nil.			t4 combinationRule: 40.			t4				destRect: (t3 extent: t1 extent).			t4 copyBits]! !!TViewPane methodsFor: 'task' stamp: 'bgf 9/27/2009 12:29'!popTask	task		ifNotNil: [task deliverPending.			task taskEnded].	taskStack isEmptyOrNil		ifFalse: [task := taskStack removeLast]! !

!QBarChart methodsFor: 'accessing' stamp: 'bgf 9/30/2009 10:42'!isPlacementLocked: bLocked	super isPlacementLocked: bLocked.	base ifNotNil: [		bLocked ifFalse: [			motionGrip 				ifNotNil: [ motionGrip enable ]				ifNil: [ self makeMotionGrip ].		] ifTrue: [			motionGrip ifNotNil: [				motionGrip luggage: nil; grip: nil.				motionGrip := nil.			].		]].! !
!TWindowedSession methodsFor: 'event handling' stamp: 'bgf 9/27/2009 12:29'!doFastPick: t1 	| t2 |	t1 readyForEvents		ifFalse: [^ self].	self		allIslandsCritical: [t2 := Time millisecondClockValue.			ogl				ifNotNil: [[t1 fastPick: ogl]						on: Error						do: [:t4 | 							t1								ifNotNil: [t1 resetEventSelection].							QLogger logWarning: 'Curtailed pick: ' , t4]].			self countPickTime: t2]		ifLocked: [t1 resetEventSelection]! !