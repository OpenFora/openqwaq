'From Croquet1.0beta of 11 April 2006 [latest update: #1] on 13 February 2010 at 1:34:16 pm'!!QUserPreferences methodsFor: 'accessing' stamp: 'bgf 2/8/2010 16:12'!clearOrganizationInfo	"Notification that the user is changing the working organization.	 Some organizations are on servers with different file-storage."	inventoryXMLZip := nil.	avatarCostume := nil.	avatarXMLZip := nil.! !!PyPanelDocCS methodsFor: 'persist' stamp: 'bgf 2/13/2010 13:33'!persistOn: pStream	 super persistOn: pStream.	pStream resourceList ifNotNil: [ pStream addResource: self ].	pStream storeString: 'version' value: version default: nil.	pStream storeString: 'appName' value: appName default: nil.	pStream storeString: 'docName' value: docName default: nil.	pStream storeString: 'tpzName' value: tpzName default: nil.	pStream storeString: 'userSource' value: userSource default: nil.	pStream storeString: 'startupOwner' value: startupOwner default: nil.! !!QServiceChooser methodsFor: 'events' stamp: 'bgf 1/9/2010 13:29'!onOrgChanged	| newOrg |	" <on: cursorChanged in: orgChoices> 		-  trigger is set and cleared when the service manager is set.	 The org choice controls what forums (and users) are seen in the login list."	owner exitTripped ifTrue: [ ^ self ].	owner mouseCursor: (Cursor wait).	tosLabel label: ''; topLeft: (0@-30).	orgChoices disable.	buyButton visible: false.		"Until we know."	self clearDetails.	updateServicesButton disable.	updateUsersButton disable.	prefsButton disable.	owner usersPane stopListeningToOrgServices.		[	  self updateGMOButton.	  self clearServices. "Stops other updates."	  self stopPreviousOrgUpdate.	  self clearServices. "In case any completions slipped through."	  orgChoices disable.	  serviceManager ifNotNil: [		newOrg := serviceManager orgList						detect: [ : o | (o name) = (orgChoices selection) ]						ifNone: [ nil ].		serviceManager currentOrg = newOrg ifFalse:[			serviceManager switchToOrg: newOrg.			owner statusInfo: 'Authenticating with organization...'.			QLogger logInfo: 'Authenticating with ', (newOrg ifNil: [ 'provider'] ifNotNil: [ newOrg name]).			[serviceManager connect] on: Error 				do:[:ex|^self inform: ex description].			] ifTrue: [			QLogger logInfo: 'Org change finds same organization ', (newOrg name).		].		newOrg ifNotNil: [			QActivityCapture action: #LobbyEnter details:  newOrg name.		].		tosLabel label: (owner class tosLabelForOrg: newOrg).		buyButton visible: (self canBuyOrg). 				"A realm has been supplied or chosen;	 	 advertise the ready service manager to all tools."		owner preferences clearOrganizationInfo.		owner serviceManager: serviceManager forceChanges: true.		self showTemplates: (owner isAdministrator).		orgChoices disable.		[			QLogger logInfo: 'Org-entry list setup elapsed: ', ([				self updateCurrentList			  ] timeToRun), ' ms'.		] ensure:  [ 			orgChoices enable.		].		orgChoices selection ifNotNilDo: [ : orgName |			self saveOrgChoice:  orgName		].		"Pick a useful selection from the services list, so I can <enter> directly..."		self selectServiceForChosenOrg.	  ]	] ensure: [		owner mouseCursor: nil.		prefsButton enabled: (owner serviceMgr notNil).		updateServicesButton enabled: (owner serviceMgr notNil).		updateUsersButton enabled: (owner serviceMgr notNil).	].	self signal: #tosLabelChanged.	owner signal: #organizationChanged.! !!QServiceManagerV2 methodsFor: 'file requests' stamp: 'bgf 2/2/2010 11:37'!getStreaming: resourceName from: start to: stop do: dataBlock	"Get a resource from the service provider"	| req fileSize bucketSize buckets max fileID |	"fileID helps server to handle download request more efficiently"	fileID := TObjectID new hex.	fileSize := stop - start + 1.	bucketSize := 4096.	buckets := Array new: fileSize + bucketSize - 1 // bucketSize.	"Max is the maximum number of outstanding requests for pipelining.	This is currently set to 128k (32*4k) on the wire."	max := 32.	1 to: buckets size+max do:[:i|		i <= buckets size ifTrue:[			req := self createRequest: 'getPart' contents:[:writer|				writer tag: 'id' pcData: fileID.				writer tag: 'name' pcData: resourceName.				writer tag: 'offset' pcData: (i-1*bucketSize+start-1) asString.				i = buckets size ifTrue:[					writer tag: 'length' pcData: (fileSize - (i-1*bucketSize)) asString.				] ifFalse:[					writer tag: 'length' pcData: bucketSize asString.				].			].			self scheduleRequest: req.			buckets at: i put: req.		].		i > max ifTrue:[			req := buckets at: i-max.			req waitForResponse: standardTimeout.			req response name == #ok ifFalse:[^self error: req response contentString].			dataBlock value: req data.			req data: nil.	"Allow GC"		].	].! !!QStoreObjectJob class methodsFor: 'job handling' stamp: 'bgf 2/5/2010 20:38'!saveResources: resList asZip: archive forClient: aUI	"Save the data that backs the given list of resources (far-refs to textures and models)	 as separate named entities in the given ZIP archive.	 The data comes from the active session cache... 	 we assume it's already in play in the harness.	 Note there is a workalike of this routine in QInspector."	| absentList doneSet fname data |	absentList := OrderedCollection new.	doneSet := Set new.	resList value select: [:resRef|		resRef wait.		(resRef get:#isBundled) not   "Don't upload prepackaged resources." 	] thenDo:[:resRef|		fname := resRef get: #fileName.				"The same textures may be referenced multiple times, but we only write them once"		(fname isNil or: [doneSet includes: fname]) ifFalse:[			doneSet add: fname.			data := (resRef get:#class) getContent: resRef forClient: aUI.			data ifNil:["Texture not present; add it to the list"				absentList add: { (resRef get: #resourceType) .  fname}.			] ifNotNil:[				"Don't compress the texture again"				archive addString: data asByteArray as: fname.			]		].	].	^ absentList.! !!QWindowedSession methodsFor: 'resources' stamp: 'bgf 2/5/2010 20:43'!loadResources: resList zip: archive	"Import the given list of resouces from the given (c3z) archive,	 uploading them to the server as resources in this forum.	 Returns a list of pairs (type, name) for resources that were not found in the zip."	| absentList doneSet fname mbr data |	absentList := OrderedCollection new.	doneSet := Set new.	"Repeatedly wait for the resources since this is the place that blows up if	we get a disconnect during the scene construction above. Reconnect	will work fine but we need to make sure we pick up the right future send.	Of course, the user can always cancel this loop by hitting the cancel button."	resList do:[:resRef|		fname := resRef fileName.		"The same textures may be referenced multiple times, but we only read it once"		(fname notNil and: [ (doneSet includes: fname) not ])		 ifTrue: [			doneSet add: fname.			mbr := archive memberNamed: fname.			(mbr isNil and:[fname beginsWith: '/']) ifTrue:[				"The zip archive doesn't like absolute path names for some reason.				Try to find the texture again stripping of the leading slash"				mbr := archive memberNamed: fname allButFirst.			].			"We cannot update names in the model	 		 (as for all other resource-loading paths) as we have no access to the original.			 The best we can do right now is make sure paths aren't changed	 		 for all the resources the model depends on.			 (This is OK as all those resource uploads were sha-named in the first place.)"			(fname beginsWith: 'resources/') ifTrue: [ 				 fname := fname copyAfter: $/.			].			mbr 				ifNil:[absentList add: {resRef resourceType . fname} ]				ifNotNil:[					data := mbr contents.					self documentManager 						uploadResource: data 						shortName: fname 						sha: fname.   "Forces literal use of this name."					resRef sha ifNotNil: [ :  sha |						TContentManager default cacheManager cacheIfAbsent: data to: sha.					].				].		].	].	^absentList! !!QWindowedSession methodsFor: 'resource-fetch' stamp: 'bgf 2/8/2010 12:06'!processOneDelivery: docRequest	"Receiver for thumb-resource data requested from the document manager."	| thumb data |		owner session ifNil: [ ^ nil ].	contentManager ifNil: [ 		QLogger logWarning: 'Received delivery but CM is nil.'.		^ nil ].	"Destroyed "	(data := docRequest fetchedData) ifNil: [ 		docRequest isAppPreview ifFalse: [			QLogger logInfo: 'Empty delivery: ', (docRequest shortName).		].		^ nil ].	"Guard against invalid requestors e.g. after reconnect."	(thumb := docRequest requestor) isValidFarRef ifFalse:[		thumb ifNotNil: [	"I.e. not a prefetch"			QLogger logWarning: 'Requestor of ', (docRequest serviceManagerPath), ' is invalid'.		].		^nil].	"Guard against resources whose users have been destroyed."	((thumb class = TFarRef) and: [ thumb isStale ]) ifTrue: [		QLogger logWarning: 'Requestor of ', (docRequest serviceManagerPath), ' is stale'.		^nil].	docRequest refetch ifTrue: [		"Refetch -> Use the new even if we've already got something."		 contentManager flushTextureSHA: (docRequest cacheFileName).	].	contentManager dataArrived: data forThumb: thumb.! !!QwaqParticipantUI methodsFor: 'accessing' stamp: 'bgf 2/2/2010 12:03'!homeOrgName	"The organization name I should sign into, or return the service chooser to after place-logout."	^ (login areOptionalFieldsShowing	    or: [ preferences isNil ]	    or: [ login forumGoal notNil ]		"A directed login; processCmdLine or generalTeleport"	    or: [ preferences homeOrganization isEmptyOrNil ]	) ifTrue: [		login organization value asString	] ifFalse: [		preferences homeOrganization	]! !!QwaqParticipantUI methodsFor: 'notifier' stamp: 'bgf 2/10/2010 15:56'!uploadStart: aController for: clientName	"Notify the receiver that the given controller just started to upload a snapshot.	We only signal an event here as the method is called from a different thread."	self signal: #uploadStart with: clientName.	"Slow down the drive/render cycle to reduce message flow,	 which competes for bandwidth with the upload."	flowControlFlag := true.	"Give  a little chance for feedback to appear before freezing for the sync.."	(Delay forMilliseconds: 100) wait.! !!QwaqParticipantUI methodsFor: 'events' stamp: 'bgf 1/13/2010 11:59'!onAvatarEmbarked: placeName	<on: avatarEmbarked in: avatar>	DropAllButLastEvent signal.	"The avatar has started a goto sequence towards a named destination;	 this happens when we tab, or hit a goto button, or otherwise use a navigation shortcut.	 So we're not in keyboard input anymore.	 For sound effect,  rule out 'With ' place names, as those are used for Go With ... 	 when you follow an avatar around, and the embarked chimes are irksome then.)"	self readyForEvents ifTrue: [		"Forget keyboarding  if pulled away from an app by 'Follow Me' or other leader stuff."		avatar stopActivity: #Typing.		session keyboardDriving: true.	].	(placeName notNil and: [placeName beginsWith: 'With ']) ifFalse: [		self playSoundEffect: #warpPosition.	].! !!TAnimationManager methodsFor: 'resources' stamp: 'bgf 1/15/2010 09:03'!discardIsland: aStaleIslandRef	"Per-teleplace logout support."	resourceMap ifNotNilDo: [ : map |		map copy keysAndValuesDo: [ : key : figure |			figure ref island value = aStaleIslandRef value  ifTrue: [ 			figure destroy.			map removeKey: key ifAbsent: []		]]]! !!TFrame methodsFor: 'converting' stamp: 'bgf 2/4/2010 15:36'!flattenAllInforming: progressBar	"Replace this frame in the scene graph with single merged geometry...	 removes all group substructure, and combines meshes into  single geometry.	 (This is #flattenMesh, wrapped to preserve my current in-space position.)	 Returns the replacement."	| trans mom replacement |	self isGeometry ifTrue: [^self].		self boundsDepth:-1. "supress the boundsDepth computation"	self allUpdateShape.	trans := self localTransform.	mom := self parent.	self localTransform: (Matrix4x4 new).	replacement := self flattenMeshInforming: progressBar.	replacement boundsDepth: 2.	replacement localTransform: trans.	mom ifNotNil: [		mom addChild: replacement.	].	^ replacement! !!QAvatarReplica methodsFor: 'places' stamp: 'bgf 2/3/2010 10:14'!takeMeToFrame: frameRef	"If the  frame defines a destination for my avatar, go to it."	| xfm |	frameRef ifNil: [ ^ self ].	self allowedToMove ifFalse: [ 			self signal: #statusMessage with:  'The leader is controlling movement'.		^ self	].	self signal: #statusMessage with: 'Locating ', (frameRef labelForBrowser).	frameRef asPlace ifNotNilDo: [ :place | 		place destinationFrame ifNotNilDo: [ : destFrame |			destFrame visible ifFalse: [ 				"In case it is in an attaching-manager like a tabbed board."				destFrame surfaceAttachment ifNotNilDo: [ :sa |					sa asPlace ifNotNil: [ 						self signal: #alertMessage 							with: 'The ', (destFrame genericName), ' is not visible.'.						^ self takeMeToFrame: sa ] ].			]].		^ self goToPlace: place ].	frameRef visible ifFalse: [ 		self signal: #alertMessage with: 'The ', (frameRef genericName), ' is not visible.'.		"In case it is in an attaching-manager like a tabbed board."		frameRef surfaceAttachment ifNotNilDo: [ :sa |			sa asPlace ifNotNil: [ 				self signal: #alertMessage 					with: 'The ', (frameRef genericName), ' is not visible.'.				^ self takeMeToFrame: sa ] 		]].	"Fallthrough - no QPlace is defined, but there may be a destinationTransformFor:"	self clearCurrentPlace.	frameRef ifNil: [ ^ self ].	(frameRef root = self root) ifFalse: [		self signal: #alertMessage with: '', (frameRef labelForBrowser), ' is not visible.'.		^ self	].	(frameRef destinationStanceFor: self) ifNotNilDo: [ :stance|		xfm := stance transform.		self goto: xfm sticky: (self thirdPerson) label: (frameRef objectName)	] ifNil: [		(frameRef defaultDestinationTransform) ifNotNilDo: [ :xform|			self goto: xform sticky: (self thirdPerson) label: (frameRef objectName)		] ifNil: [			self signal: #alertMessage with: '', (frameRef labelForBrowser), ' is not visible.'.		].	].		! !!QTabbedWall methodsFor: 'protocol' stamp: 'bgf 2/12/2010 15:37'!dragHeightDelta: deltaY	|  bp  bo bio bh |	"When drag-resizing, we don't want the attachments to go astray,	 so we make an effort to reposition them relative to the edges and center of the board."	bh := board height.	bp := board globalPosition.	bo := board globalTransform orientation.	bio := board globalTransform inverseByTranspose orientation.	self extent: (self extent + (0 @ deltaY)).	self translation: (self translation  +  (self globalOrientation transformVector: (0@deltaY*0.5@0))).	board allNotes do: [ : note |		| ny nye  newy dy sa |		sa := note surfaceAttachment.		ny :=  (bio transformVector:  (note globalPosition - bp))  y.		nye :=  ((bh * 0.5) - (ny abs) )  * (ny sign).		newy := (nye + (deltaY *0.5 * (ny sign))) atLeast: (bh * -0.499) atMost: (bh * 0.499).		"Newy is the same distance to the new edge as nxe to the old."		dy := (newy - nye) * 0.75. 		note translation: (note translation + (bo transformVector: (0@dy@0))).		self root attach: note to: sa.	].	self allUpdateShape.! !!QTabbedWall methodsFor: 'protocol' stamp: 'bgf 2/12/2010 15:37'!dragLengthDelta: deltaX	| bw bp  bo bio |	"When drag-resizing, we don't want the attachments to go astray,	 so we make an effort to reposition them relative to the edges and center of the board."	bw := board width.	bp := board globalPosition.	bo := board globalTransform orientation.	bio := board globalTransform inverseByTranspose orientation.	self extent: ( (self extent + (deltaX @ 0)) max: (0.1@0)).	self translation: (self translation  +  (self globalOrientation transformVector: (deltaX*0.5@0@0))).	board allNotes do: [ : note |		| nx nxe  newx dx sa |		sa := note surfaceAttachment.		nx :=  (bio transformVector:  (note globalPosition - bp))  x.		nxe :=  ((bw * 0.5) - (nx abs) )  * (nx sign).		newx := (nxe + (deltaX *0.5 * (nx sign))) atLeast: (bw * -0.499) atMost: (bw * 0.499).		"newx is the same distance to the new as nxe to the old.	 	 But we don't want exact edge-pinning; do it proportionally."		dx := (newx - nxe) * 0.75. 		note translation: (note translation + (bo transformVector: (dx@0@0))).		self root attach: note to: sa.	].	self allUpdateShape.! !!TAvatarUser methodsFor: 'driving' stamp: 'jcg 1/24/2010 13:09'!spaceSpeed	^(replica isValidFarRef and: [replica isResolved])		ifTrue:[replica get: #spaceSpeed] 		ifFalse:[1.0]! !