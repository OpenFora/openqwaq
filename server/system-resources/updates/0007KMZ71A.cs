'From Croquet1.0beta of 11 April 2006 [latest update: #1] on 6 November 2009 at 2:34:10 pm'!Object subclass: #TLoadKMZ	instanceVariableNames: 'zip collada importer cache progress total done materialDict'	classVariableNames: ''	poolDictionaries: ''	category: 'Croquet-Import'!!TLoadKMZ methodsFor: 'parsing' stamp: 'das 10/28/2009 10:18'!import6: name	| modelNode tFrame group |	cache := Dictionary new.	ProgressNotification signal: 'Importing model'. 	modelNode := self inLibrary: 'visual_scenes' tag: #node id: 'Model'.	progress ifNotNil: [		total := (self nodeCount: modelNode) asFloat.		done := 0]. 	tFrame := self nodeFrom: modelNode.	tFrame objectName: name.	group := TGroup new.	tFrame addRotationAroundX:-90.	group addChild: tFrame.	^group! !!TLoadKMZ methodsFor: 'parsing' stamp: 'das 10/28/2009 11:17'!import7: name	| modelNode tFrame group |	cache := Dictionary new.	ProgressNotification signal: 'Importing model'. 	self importMaterials.	modelNode := self inLibrary: 'visual_scenes' tag: #node id: 'SketchUp'.	progress ifNotNil: [		total := (self nodeCount: modelNode) asFloat.		done := 0]. 	tFrame := self nodeFrom7: modelNode.	tFrame objectName: name.	group := TGroup new.	tFrame addRotationAroundX:-90.	group addChild: tFrame.	^group! !!TLoadKMZ methodsFor: 'parsing' stamp: 'das 10/30/2009 15:10'!importMaterials	| effects materials textureDict effectsDict id lighting material mid txtrLib txtrFName txtrPath txtrID opaque acolor |	textureDict := Dictionary new.	txtrLib := collada elementAt: 'library_images'.	txtrLib ifNotNil:[		txtrLib elementsDo:[:txtr |			id := txtr attributeAt: #id.			txtrFName := (txtr firstTagNamed: #'init_from')contentString.			textureDict at: id put: txtrFName.		].	].	effectsDict := Dictionary new.	effects := collada elementAt: 'library_effects'.	effects elementsDo:[:efct|		id := efct attributeAt: #id.		material := TMaterial new.		effectsDict at: id put: material.		lighting := efct firstTagNamed: #phong.		lighting ifNil: [lighting := efct firstTagNamed: #lambert].		lighting elementsDo: [:light |			light name caseOf: {				[#emission] -> [material emissiveColor: (self colorFrom: light)].				[#ambient] -> [material ambientColor: (self colorFrom: light)].				[#diffuse] -> [					light elements first name = #texture						ifTrue: [							material diffuseColor: (VectorColor r:  1 g: 1 b: 1 a: 1).							txtrID := (efct firstTagNamed: #'init_from')contentString.							txtrPath := textureDict at:txtrID ifAbsent:[nil].							txtrPath ifNotNil:[material texture: 								(self textureFromPath: 'models/', txtrPath)].												((txtrPath findTokens:'.') last asUppercase) = 'PNG' ifTrue:[								material opacity: 0.999.								material polygonOffsetFactor: 1.0 units: 1.0.							]. 							]						ifFalse: [material diffuseColor: (self colorFrom: light)].				].				[#specular] -> [material specularColor: (self colorFrom: light)].				[#shininess] -> [material shininess: (self floatFrom: light)].				[#reflectivity] -> [material shininess: (self floatFrom: light)].				[#transparent]->[ 					opaque := light attributeAt: #opaque.					opaque = 'A_ONE' ifTrue:[material opacity: material opacity * 0.999.].					opaque = 'RGB_ZERO' ifTrue:[						acolor := (self colorFrom: light).						material opacity: material opacity * (acolor r+acolor g+acolor b)/3.0.					].				].				[#transparency] -> [					opaque = 'A_ONE' ifTrue:["probably never gets here"						material opacity: material opacity *(1.0 - (self floatFrom: light))].					opaque = 'RGB_ZERO' ifTrue:[						material opacity: material opacity * (self floatFrom: light)].				].			} otherwise: [].		].		"Substitute an open-gl friendly ambient..."		material ambientColor: ((material diffuseColor / 3.0) 								alpha: (material diffuseColor alpha)).		material cullFace: (efct firstTagNamed: #'double_sided') isNil.		material uvScale: 1@-1.	"flip textures vertically"	].	materialDict := Dictionary new.	materials := collada elementAt: 'library_materials'.	materials elementsDo:[:mat |		id := mat attributeAt: #id.		mid := ((mat firstTagNamed: #'instance_effect') attributeAt: #url)allButFirst.		"matID := mat firstTagNamed: #material."		materialDict at: id put: (effectsDict at: mid ifAbsent:[ TMaterial new ]).	].	^ materialDict.! !!TLoadKMZ methodsFor: 'parsing' stamp: 'das 10/28/2009 17:34'!lines7From: mesh id: ref mat: matDict	"Build a TGeometry from a <mesh> node containing <triangles>"	| posArray strips materials indexTag indexArray geometry  elVal dict id sourceID array lineCount |	dict := Dictionary new.	strips := Array new writeStream.	materials := Array new writeStream.	mesh elementsDo:[:e |		e name = #source ifTrue:[			id := e attributeAt: #id.			array := self build: FloatArray float: (e firstTagNamed: #'float_array').			dict at: id put: array.		].		e name = #vertices ifTrue:[			id := e attributeAt: #id.			e elements do:[:element | 				elVal := (element valueFor:'semantic').				sourceID := (element valueFor: 'source')allButFirst.				array := (dict at: sourceID).				elVal = 'POSITION' ifTrue:[ 					posArray := Vector3Array new: array size/3.					posArray privateReplaceFrom: 1 to: posArray basicSize with: array startingAt:1.				].			].		].		e name = #lines ifTrue:[			lineCount := (e attributeAt: 'count') asInteger.			indexTag := e firstTagNamed: #p.			indexArray := self build: WordArray int: indexTag size: lineCount*2.			"indexArray has 3 indices per vertex, indexing into posArray, normArray, and uvArray"			materials nextPut: ((matDict at: (e attributeAt: 'material') ifAbsent:[TMaterial new])				polygonOffsetFactor: 1.0 units: 1.0;				yourself).			strips nextPut: (TStripData new data: indexArray; 				materialIndex: materials position; modeName: #GLLines; yourself).		].	].	geometry := TGeometry new.	geometry vertices:  posArray. 	geometry stripData: strips contents.	geometry materialList: materials contents.	geometry checkAlpha.	geometry objectName: ref.	^geometry.! !!TLoadKMZ methodsFor: 'parsing' stamp: 'das 10/29/2009 15:34'!nodeFrom7: aNode	"Read a <node> element as TGroup. Handles only <matrix> transforms which seems to be used exclusively by Sketchup"	| tFrame oName frame matDict matName matTarget |	oName := (aNode attributeAt: 'name').	"oName = 'instance_0' ifTrue:[^nil]." "don't add the character silhouette - if user removes character, model may fail to load."	tFrame := TGroup new.	tFrame objectName: oName.	aNode elementsDo: [:element |		element tag caseOf: {			[#matrix] -> 				[tFrame localTransform: (self build: Matrix4x4 float: element size: 16)].			[#node] -> 				[					frame :=  (self nodeFrom7: element).					frame ifNotNil:[tFrame addChild:frame.].				].			[#'instance_node'] -> 				[ | id |				id := (element attributeAt: 'url') allButFirst.				tFrame addChild: (self nodeFrom7: (self inLibrary: #nodes tag: #node id: id))].			[#'instance_geometry'] -> 				[ | id |				id := (element attributeAt: 'url') allButFirst.				matDict := Dictionary new.				element tagsNamed: #'instance_material' do:[:matBinding |					matName := matBinding attributeAt: #symbol.					matTarget := (matBinding attributeAt: #target)allButFirst.					matDict at: matName put: (materialDict at: matTarget ifAbsent:[TMaterial new]).				].								(self inLibrary: 'geometries' tag: #geometry id: id) tagsNamed: #mesh do: [:mesh |					"Apparently there are either triangles or lines but never both in one mesh. We keep it general."					(mesh firstTagNamed: #triangles) ifNotNil: [						tFrame addChild: (self triangles7From: mesh id: id mat: matDict).					].					(mesh firstTagNamed: #lines) ifNotNil: [						"Reusing triangle vertices would be more efficient, but we would have to do this on our own. Also, many line meshes could be collapsed into one."						tFrame addChild: (self lines7From: mesh id: id mat: matDict).					]]]		}		otherwise:[ ]].	progress ifNotNil: [progress value: (done := done + 1) / total].	^tFrame! !!TLoadKMZ methodsFor: 'parsing' stamp: 'das 10/29/2009 14:56'!textureFromPath: imagePath	"Build a TTexture from a <texture> element. We assume the image is named after the texture. The texture data is unzipped to a file because TContentManager doesn't support in-memory streams yet."	| zippedFile fileName texture fname |	zippedFile := zip memberNamed: imagePath."since Sketchup 7.1 uses an extremely uncreative naming convention, we really need to makethese file names as unique as possible to avoid collisions between imported files. Adding the CRC seems like a good quick and dirty way to do this."	fileName := zippedFile crc32String, (zippedFile splitFileName last).	zippedFile extractToFileNamed: fileName inDirectory: self texturesDirectory.	texture := TTextures find: (fname := self texturesDirectory fullPathFor: fileName).	texture 		ifNil:[importer missingResources add: fileName]		ifNotNil:[importer loadedResources at: fname put: texture].			^texture! !!TLoadKMZ methodsFor: 'parsing' stamp: 'das 10/29/2009 11:29'!triangles7From: mesh id: ref mat: matDict	"Build a TGeometry from a <mesh> node containing <triangles>"	| posArray normArray uvArray strips materials triCount indexTag indexArray geometry  elVal dict id sourceID array numElements sem offset vertOffset texOffset normOffset vertices positions normals uvs pi ni ti index indices |		dict := Dictionary new.	vertices := Dictionary new.	positions := (Vector3Array new: 1000) writeStream.	normals := (Vector3Array new: 1000) writeStream.	uvs := (Vector2Array new: 1000) writeStream.	strips := Array new writeStream.	materials := Array new writeStream.	mesh elementsDo:[:e |		e name = #source ifTrue:[			id := e attributeAt: #id.			array := self build: FloatArray float: (e firstTagNamed: #'float_array').			dict at: id put: array.		].		e name = #vertices ifTrue:[			id := e attributeAt: #id.			e elements do:[:element | 				elVal := (element valueFor:'semantic').				sourceID := (element valueFor: 'source')allButFirst.				array := (dict at: sourceID).				elVal = 'POSITION' ifTrue:[ 					posArray := Vector3Array new: array size/3.					posArray privateReplaceFrom: 1 to: posArray basicSize with: array startingAt:1.				].				elVal = 'NORMAL' ifTrue:[ 					normArray := Vector3Array new: array size/3.					normArray privateReplaceFrom: 1 to: normArray basicSize with: array startingAt:1.				].				elVal = 'TEXCOORD' ifTrue:[ 					uvArray := Vector2Array new: array size/2.					uvArray privateReplaceFrom: 1 to: uvArray basicSize with: array startingAt:1.				].			].		].		e name = #triangles ifTrue:[			triCount := (e attributeAt: 'count') asInteger.			numElements := 0.			e tagsNamed: #input do:[:input | "do we have textures interleaved?"				sem := input valueFor: #semantic.				offset := (input valueFor: #offset)asNumber.				sem = 'VERTEX'ifTrue:[numElements := numElements+1. vertOffset := offset. ].				sem = 'TEXCOORD' ifTrue:[					numElements := numElements+1. texOffset := offset.					sourceID := (input valueFor: 'source')allButFirst.					array := (dict at: sourceID).					uvArray := Vector2Array new: array size/2.					uvArray privateReplaceFrom: 1 to: uvArray basicSize with: array startingAt:1.				 ].				sem = 'NORMAL' ifTrue:[numElements := numElements+1. normOffset := offset.].			].			normOffset ifNil:[normOffset := vertOffset.].			indexTag := e firstTagNamed: #p.			indexArray := self build: WordArray int: indexTag size: triCount*3*numElements.			indices := (WordArray new: triCount * 3) writeStream.			1 to: indexArray size by: numElements do:[:i |				pi := indexArray at:i+vertOffset.				normArray ifNotNil:[ni := indexArray at:i+normOffset.].				uvArray ifNotNil:[ti := indexArray at: i+texOffset].				index := vertices at: {pi. ni. ti} ifAbsentPut:[					positions nextPut: (posArray at: pi+1).					normArray ifNotNil:[ normals nextPut: (normArray at: ni+1).].					uvArray ifNotNil:[uvs nextPut: (uvArray at:ti+1).].					vertices size.				].				indices nextPut:index.			].			"indexArray has 3 indices per vertex, indexing into posArray, normArray, and uvArray"			materials nextPut: ((matDict at: (e attributeAt: 'material') ifAbsent:[TMaterial new])				"polygonOffsetFactor: 1.0 units: 1.0;"				yourself).			strips nextPut: (TStripData new data: indices contents; 				materialIndex: materials position; modeGLTriangles; yourself).     		].	].	geometry := TGeometry new.	geometry vertices:  positions contents.	uvArray ifNotNil:[geometry texCoords: uvs contents.].	normArray ifNotNil:[geometry normals: normals contents.].	geometry stripData: strips contents.	geometry materialList: materials contents.	geometry checkAlpha.	geometry objectName: ref.	^geometry.! !!TLoadKMZ methodsFor: 'parsing' stamp: 'das 10/29/2009 16:28'!parseStream: aStream	"Parse a KMZ model from aStream. This happens to be a ZIP archive containing a Collada model and textures."	| zippedModel version |	ProgressNotification signal: 'Reading file'. 	[zip := ZipArchive new readFrom: aStream]		ifError: [^self inform: 'Not a valid Google Earth 4 file'].	zippedModel := zip members detect: [:each | 'models/*.dae' match: each fileName]		ifNone: [^self inform: 'No Collada content found'].	ProgressNotification signal: 'Parsing XML'. 	collada := XMLDOMParser parseDocumentFrom: zippedModel contents readStream.	collada := collada elementAt: #COLLADA.	"scale := ((collada firstTagNamed: #unit) attributeAt: 'meter') asNumber."	version := (((collada elementAt: #asset) elementAt:#contributor)elementAt: 'authoring_tool')contentString.	^ version >= 'Google SketchUp 7.1' ifTrue:[		self import7: aStream localName.	] ifFalse:[		self import6: aStream localName.	].! !!TLoadKMZ methodsFor: 'parsing' stamp: 'das 10/28/2009 14:03'!textureFrom: anElement	"Build a TTexture from a <texture> element. We assume the image is named after the texture. The texture data is unzipped to a file because TContentManager doesn't support in-memory streams yet."	| imageName image imagePath |	imageName := anElement elements first attributeAt: 'texture'.	(imageName endsWith: '-sampler')		ifTrue: [imageName := imageName copyUpToLast: $-].	image := self inLibrary: 'images' tag: #image id: imageName.	((image elements first contentString) first:3)= '../' ifTrue:[		imagePath := (image elements first contentString) allButFirst: 3. "strip ../"	]ifFalse:[		((image elements first contentString) first:2)= './' ifTrue:[			imagePath := (image elements first contentString) allButFirst: 2. "strip ./"		].	].	 	^ self textureFromPath: imagePath.! !!TLoadKMZ methodsFor: 'accessing' stamp: 'das 10/28/2009 10:20'!cache: aNode tag: aTag into: aDictionary	"Recursively search for <aTag id=...> in the named node and answer a dictionary id->node for all tags"	| id |	aNode localName == aTag ifTrue: [		id:= (aNode attributeAt: #id).		id ifNil:[ id := aNode attributeAt: #name].		aDictionary at: id put: aNode.	].	aNode elementsDo: [:each | self cache: each tag: aTag into: aDictionary].	^aDictionary! !