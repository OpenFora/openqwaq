'From Croquet1.0beta of 11 April 2006 [latest update: #1] on 1 May 2009 at 8:32:33 am'!"Change Set:		0002ReleaseFixesDate:			1 May 2009Author:			Howard Stearns and Andreas RaabAndreas Aero pshare, vnc; Brad docs; David graphics.Multiple adresses in Outlook:	Network.36: MailMessage	MAPI-Client.2: MAPIClientFilecard of offline-upload reflects the unique-name created during processing:	Qwaq-Tools.827: QCustomsPaneProtect long offline-import processings against multiple 'volunteers':	Qwaq-Objects:1289: QAutoImportJobProtect offline-import processing against teleporting:	Qwaq-Tools.828: QCustomsPane	Qwaq-Objecs.1291: QAutoImportJobCopy QRL: 	Qwaq-Client.2035: QwaqParticipantUI, QwaqVersion	Qwaq-Service.1012: QWebServices"!QAutoActionJob subclass: #QAutoImportJob	instanceVariableNames: 'avatar'	classVariableNames: ''	poolDictionaries: ''	category: 'Qwaq-Objects-Jobs'!!QAutoImportJob commentStamp: 'hrs 3/14/2009 12:28' prior: 0!Asks a volunteer to see if there are offline imports on the server to be processed.!!MailMessage methodsFor: 'initialize-release' stamp: 'hrs 4/24/2009 21:32'!addField: fieldName ofString: fieldValue	"add fieldValue as an additional value for fieldName (creating the field if it does not exist)"	(fields at: fieldName asLowercase ifAbsentPut: [OrderedCollection new: 1])		add: (MIMEHeaderValue forField: fieldName fromString: fieldValue)! !!QAutoImportJob methodsFor: 'job queue' stamp: 'hrs 4/24/2009 10:38'!confirmSaveBegin: aReplica	"There are two different flags:	pending is managed by the superclass and means that this round of the job is up for grabs.	It is true when a request is made and lasts until some participant says they've got the baton.	avatar is managed by us and means that this round has not yet completed, so that a new 	round is not started. It is non-nil once someone gets the baton and stays non-nil until the job	is finished or the partipant has left.	"		^self confirmSaveBegin ifTrue: [		(avatar notNil and: [avatar root isNil]) ifTrue: [avatar := nil].  "Don't wait if they've left."		avatar ifNotNil: [			false		] ifNil: [			avatar := aReplica.			true		]	] ifFalse: [false].! !!QAutoImportJob methodsFor: 'accessing' stamp: 'hrs 4/24/2009 10:28'!onIslandSaved	super onIslandSaved.	avatar := nil.! !!QAutoImportJob class methodsFor: 'as yet unclassified' stamp: 'hrs 4/24/2009 13:01'!startJob: job forClient: aParticipantUI	"Handle the autosave request, unless someone else got there first."	| avatar |	avatar := aParticipantUI avatar replica.	(avatar isValidRef and: [avatar island = job island]) ifFalse: ["eg., teleporting"^self].	(job future confirmSaveBegin: avatar) whenResolved: [ : yesNo |		yesNo ifTrue: [			aParticipantUI exitTripped ifFalse: [				aParticipantUI signal: self jobActionTrigger with: (job get:#requester).			]		].	].! !!QCustomsPane methodsFor: 'accessing' stamp: 'hrs 4/29/2009 16:28'!processingAvatar	"Answer the processingAvatar of the receiver"	<bewareOf: #processingAvatarChanged>	^self propertyValueAt: #processingAvatar! !!QCustomsPane methodsFor: 'accessing' stamp: 'hrs 4/29/2009 16:28'!processingAvatar: aValue	"Modify the receiver's processingAvatar"	^self propertyValueAt: #processingAvatar put: aValue with: #processingAvatarChanged! !!QCustomsPane methodsFor: 'accessing' stamp: 'hrs 4/29/2009 16:39'!processingForum	"Answer the processingForum of the receiver"	<bewareOf: #processingForumChanged>	^self propertyValueAt: #processingForum! !!QCustomsPane methodsFor: 'accessing' stamp: 'hrs 4/29/2009 16:39'!processingForum: aValue	"Modify the receiver's processingForum"	^self propertyValueAt: #processingForum put: aValue with: #processingForumChanged! !!QCustomsPane methodsFor: 'accessing' stamp: 'hrs 4/29/2009 15:49'!processingSpace	"Answer the processingSpace of the receiver"	<bewareOf: #processingSpaceChanged>	^self propertyValueAt: #processingSpace! !!QCustomsPane methodsFor: 'accessing' stamp: 'hrs 4/29/2009 15:49'!processingSpace: aValue	"Modify the receiver's processingSpace"	^self propertyValueAt: #processingSpace put: aValue with: #processingSpaceChanged! !!QWebServices class methodsFor: 'QRL-mangling' stamp: 'hrs 4/30/2009 10:06'!qrl: base go: placeName	"Armor a place query fragment and splice it onto a pre-armored qrl base."	^base, '?', self goFragmentKey, '=', (QWebServices qrlPlaceFrom: placeName)! !!QwaqParticipantUI methodsFor: 'menu' stamp: 'hrs 4/30/2009 10:10'!copyQRLForCurrentPlace	"Copy a QRL (go) page for the current form/place into the operating system clipboard."	| qrl place base |	place := placesPane currentStablePlaceName ifNil: ['Home'].	base := serviceMgr qrlFromForum: serviceSvc name.	qrl := QWebServices qrl: base go: place.	Clipboard clipboardText: qrl.	self inform: 'The URL 	', qrl, 'has been copied to the ', (QwaqVersion prettyOSFamily), ' clipboard.'.! !!QwaqVersion class methodsFor: 'accessing' stamp: 'hrs 4/30/2009 09:51'!prettyOSFamily	"Answer the name of the operating system family suitable for presentation to the user.	I.e., a more user-friendly way of refering to 'your operating system'."	^Smalltalk platformName caseOf: {		['Win32'] -> ['Windows'].		['Mac OS'] -> ['MacOS'].		['unix'] -> ['Unix'].	} otherwise: []. ! !!SystemDictionary methodsFor: 'system attributes' stamp: 'ar 4/28/2009 17:41'!primIsMainWindowObscured	<primitive: 'primitiveIsWindowObscured'>	^ nil! !!MAPIClient class methodsFor: 'message sending' stamp: 'hrs 4/24/2009 21:53'!send: messageText from: sender to: recipients subject: subject	"MAPIClient 			send: 'Hello World' 			from: 'Sender<sender@domain.com>'			to: 'Rcp1<receiver@domain.com>, Rcp2<receiver@domain2.com>'			subject: 'MAPI test message'"	| message |	message := MailMessage empty.	message setField: 'from' toString: sender.	(recipients findTokens: ', ') do: [:address | 		message addField: 'to' ofString: address	].	message setField: 'subject' toString: subject. 	message body: (MIMEDocument			contentType: 'text/plain'			content: messageText).	self sendMailMessage: message.! !!QCustomsPane methodsFor: 'events' stamp: 'hrs 5/1/2009 08:29'!updateItemList	"Trigger updates:	Get list of asynchronously imported items from server, and add to the space any that are	came in after the the last one it knows about. 	Adding items to the space's customs will, in turn, cause each participant's UI to be told about	the new entry.	Answers true if anything was processed, else false."	| replicatedCustoms lastKnown |	replicatedCustoms := nil.	"Each import can take a while and has future sends and serviceProvider references,	so the activeSpace, avatar, and forum may change if there is a teleport during all that."	self processingSpace: activeSpace.	self processingAvatar: owner avatar replica.	self processingForum: owner serviceSvc name.	[	self owner serviceMgr ifNotNilDo: [:mgr |		lastKnown := activeSpace get: #lastCustomsEntryServerTimestamp.		(mgr newImportsSinceSave: self owner serviceSvc name)  ifNotEmpty: [:imports |			replicatedCustoms := self processingSpace future customs.			imports do: [:import |				import timestamp > lastKnown ifTrue: [					(self importEntryData: import customsRef: replicatedCustoms) ifNil: [						"For now, we just abandon imports when these have changed. 						We could keep partial results in customs."						QLogger logWarning: 'Teleport abandoned offline import from ', 							self processingForum.						^false  "Do not consider any of these to be processed."					].				].			].		].	].	"Tell everybody so that they don't need to do it, too."	self processingSpace island future signal: #customsProcessed with: owner userLogin	] 	on: Error do: [:e | QLogger logWarning: 'Offline uploads: ', e description.].	^replicatedCustoms notNil! !!QCustomsPane methodsFor: 'life-cycle' stamp: 'hrs 5/1/2009 08:28'!importEntryData: aQCustomsEntryData customsRef: customsRef	"Handle a new import"	aQCustomsEntryData shortCircuitCustoms ifTrue: [		"PostProcessing can take a while and involves service provider messages, 		so the avatar replica might be different later."		(self postProcessEntryData: aQCustomsEntryData) ifNotNilDo: [:fileCard |			"Try to drop the card on place, otherwise impound in customs."			self processingSpace = activeSpace ifFalse: [^nil]. "for now. might impound later"			(self processingSpace future dropCard: fileCard at: aQCustomsEntryData place 								for: self processingAvatar) whenResolved: [:success |				customsRef isValidFarRef ifFalse: [^nil].				success 					ifTrue: [customsRef future lastEntryServerTimestamp: 									aQCustomsEntryData timestamp]					ifFalse: [self impound: aQCustomsEntryData card: fileCard in: customsRef]			].			^customsRef		].	].	self impound: aQCustomsEntryData card: nil in: customsRef.	^customsRef			! !!QCustomsPane methodsFor: 'life-cycle' stamp: 'hrs 5/1/2009 08:28'!postProcessEntryData: aQCustomsEntryData	"Answer a farRef to a replicated file card for the given import."	| card ext texture  document serviceFileName  path type sharedName |	owner statusInfo: 'Processing ', aQCustomsEntryData fileName.	"For several common cases, particularly documents, there are more	efficient things that can be done that do not require round trips through the Service Provider.	All of these assume that the entry item point to the file on the server."		card := nil.	ext := aQCustomsEntryData fileExtension asUppercase.	serviceFileName := aQCustomsEntryData serviceFileName.	"Getting the data from the service provider may take a while, so the active forum and space	could change if there are teleports."	path := owner serviceMgr internCustomsFile: serviceFileName in: self processingForum.	(QWebServices uploadableFileType: ext) ifTrue: [		"Currently, we always get the file (e.g., for computing sha), but we don't		always need to put it back."		(self getTempFile: path  "We only handle local files, not data.") ifNotNilDo: [:file |			[				sharedName := path copyFrom: (path indexOfSubCollection: 'sharedDocuments/')									to: path size.				type := QDocumentType forFile: file suffix: ext.				(card isNil and: [type notNil]) ifTrue: [					"We don't check droppedDocumentIsValid:forType: here because it's too late."					document := (type docClass) 						forLocalFile: file 						suffix: ext 						sharedName: sharedName						inClient: owner.					document ifNotNil: [						document							ctime: (QTimeStamp new							who: aQCustomsEntryData user							what: 'Upload'							utc: aQCustomsEntryData timestamp).						card := QFileCard forDocument: document.					].				].				(card isNil and: [QWebServices imageTypes includes: ext]) ifTrue: [					"texture := owner session importImageAsTexture: file."					texture := TContentManager default						loadTexture: file name						mipmap: true						shrinkFit: true						extension: (TTextures extensionForFile: file name).					texture fileName: sharedName.					card := QFileCard forTexture: texture.				].							]  ensure: [self cleanUpTempFile: file].		].	].	card ifNil: [		serviceFileName := sharedName copyAfter: $/.		QLogger logWarning: 'Cannot import ', serviceFileName.		self inform: 'The file ', serviceFileName, ' was uploaded from outside of Forumsbut the import cannot be completed.'.		^nil	].	^ TIslandCopier copy: card to: self processingSpace island.! !!QOpenDocExternalJob class methodsFor: 'job handling' stamp: 'bgf 4/30/2009 01:12'!doOpenPrivateCopy: document forClient: aUI	"Get a private (semi-hidden, in our private doc-tree) local copy of the file,	 and send it a shell-open request to run it in the user's normal app."	| fileName shortName |	document wait.	[		(document get: #isKeptLocally) ifTrue: [		 	fileName := FileDirectory pathFromURI: (document get:#asLocalFileUri).			(FileDirectory default fileExists: fileName) ifFalse: [				fileName := nil.			]].		fileName ifNil: [			fileName := aUI documentManager privateFileNameFor: document.			(FileDirectory default fileExists: fileName) ifTrue: [				self markFileReadWrite: fileName.	"So we can overrwrite on windows."				].			(FileDirectory default directoryExists: fileName) ifTrue: [				Smalltalk platformName ~= 'Win32' ifTrue: [					self markFileReadWrite: fileName.	"So we can remove slides on Mac."				]].			(shortName := ((document get:#class) 							saveDocument: document asFile: fileName forClient: aUI)						 ) ifNil: [							^ self	"Callee did the inform."						].			fileName := (fileName copyUpToLast: (FileDirectory pathNameDelimiter)), 							FileDirectory slash,							shortName.		].	] on: Error do: [ :exc|		self inform: ('Cannot make local copy of document file.\\', exc description) withCRs.		QLogger logError: exc from: self.		^ self	].		QActivityCapture action: #OpenPrivateCopy details: (QActivityCapture fileDetails: fileName).	self markFileReadOnly: fileName.	aUI shellOpen: fileName documentDescription: 'document' applicationDescription: 'application'.! !!QVNCApp methodsFor: 'events' stamp: 'ar 4/29/2009 11:02'!onMouseEvent: evtBuf	| evtType evtButtons |	super onMouseEvent: evtBuf.	evtType := evtBuf at: 1.	evtButtons := (evtBuf at: 3) bitAnd: 7.	evtType == #mouseDown ifTrue: [		self playSoundNamed: #softClick.		"Clumsy filter for left-button so driving doesn't trigger launch."		((evtBuf at: 4) = session userID and:[status == #failed and: [evtButtons = 4]]) ifTrue:[			self setDefaultPainterImage.			self statusMessage: 'Launching ', self displayName,'...'.			app future stopRunning.			app future startRunning: session sessionID.		].	].! !!QwaqParticipantUI methodsFor: 'menu' stamp: 'hrs 5/1/2009 08:13'!updateActionsMenu	"Query the space for the currently available user actions	 and update the menu to present them."	|  actions menu item |	menu := self menu subMenuNamed: 'Actions'.	menu ifNil: [ ^ self ].	menu menuItems removeAll.	self isReadonlyUser ifTrue: [		"See below also"		(menu add: 'Reset Tools To Factory Layout' target: self action: #restoreDefaultLayout)			enabled: (				 self floatingPanes anySatisfy: [ : fp | fp hasFactoryPlacement not]).		QStyles installMenuFontInMenu: menu.		^ self.	].	(menu add: 'Name this Place...' target: self action: #newPlaceMarker)		enabled: (self canModifyForum);		separator: true.	actions := (activeSpace get:#actionVerbs) ifNil: [#()].	(menu add: (preferences showMarkup ifTrue:['Hide Markups'] ifFalse: ['Show Markups'])				 target: self action: #toggleMarkups)		separator:true.	actions do: [:a|		(a first == #separator) ifTrue: [		 	(menu menuItems size > 0) ifTrue:[				menu menuItems last separator: true.			]		] ifFalse: [			item :=menu add: (a second) 					   target: self 					   action: #performActionInSpace: 					   argument: (a first).			item enabled:(a first ~= #noSuchAction).		].	].	false ifTrue: [		"Maybe append the Upgrade Forum action...  		  but only for us developers, this is not even suitable for Experimental customers		  as it is limited to upgrading the original hardcoded templates, 		  and can lose some imported content."		self isSealedApplication ifFalse: [			| sub | 			sub := self upgradeForumChoicesMenu.			sub ifNotNil: [				item ifNotNil: [ item separator: true ].				menu add: 'Rebuild Forum As ' subMenu: sub			]]].	"See up top also..."	menu menuItems last separator: true.	(menu add: 'Reset Tool Layout' target: self action: #restoreDefaultLayout)				enabled: (			 self floatingPanes anySatisfy: [ : fp | fp hasFactoryPlacement not]).	menu menuItems last separator: true.	self hasQrlSupport ifTrue: [		menu add: 'Check for Offline Uploads' target: customsPane 			action: #processOfflineUploadsWithNotice: arguments: {true}.	].	menu add: 'Copy QRL' target: self action: #copyQRLForCurrentPlace.	self hasSessionRecordingSupport ifTrue:[		item := menu add: 'Record Session...' target: recorderPane action: #toggle.		self linkItem: item toTool: recorderPane.	].	(menu add: 'Take Screen Shot' target: self action: #takeScreenShot)		enabled: (session notNil and: [session ogl notNil]).	QStyles installMenuFontInMenu: menu.! !!SystemDictionary methodsFor: 'system attributes' stamp: 'ar 4/28/2009 17:51'!isMainWindowObscured	"Do not use the primitive on Windows Vista since it always returns true"	((Smalltalk platformName = 'Win32') and:[Smalltalk osVersion >= '6.0']) ifTrue:[^false].	^self primIsMainWindowObscured! !!TStripData methodsFor: 'accessing' stamp: 'das 4/29/2009 14:37'!triangleMode

	self mode: GLTriangles.! !