/* Automatically generated by
	VMPluginCodeGenerator VMMaker-eem.524 uuid: 9b748596-0986-4ca7-ac5b-b7a050a08431
   from
	PythonPlugin Qwaq-Plugins-bgf.97 uuid: 15a615ba-3290-40a1-877d-f025b25fd3af
 */
static char __buildInfo[] = "PythonPlugin Qwaq-Plugins-bgf.97 uuid: 15a615ba-3290-40a1-877d-f025b25fd3af " __DATE__ ;




#include <math.h>
#include <stdio.h>
#include <stdlib.h>
#include <string.h>
#include <time.h>

/* Default EXPORT macro that does nothing (see comment in sq.h): */
#define EXPORT(returnType) returnType

/* Do not include the entire sq.h file but just those parts needed. */
/*  The virtual machine proxy definition */
#include "sqVirtualMachine.h"
/* Configuration options */
#include "sqConfig.h"
/* Platform specific definitions */
#include "sqPlatformSpecific.h"

#define true 1
#define false 0
#define null 0  /* using 'null' because nil is predefined in Think C */
#ifdef SQUEAK_BUILTIN_PLUGIN
#undef EXPORT
// was #undef EXPORT(returnType) but screws NorCroft cc
#define EXPORT(returnType) static returnType
#endif
#include "PyBridge.h"

#include "sqMemoryAccess.h"



/*** Constants ***/


/*** Function Prototypes ***/
static VirtualMachine * getInterpreter(void);
EXPORT(const char*) getModuleName(void);
static sqInt halt(void);
EXPORT(sqInt) initialiseModule(void);
static sqInt msg(char *s);
EXPORT(sqInt) primitivePyBridgeVersion(void);
EXPORT(sqInt) primitivePyCallbackGetArg(void);
EXPORT(sqInt) primitivePyCallbackGetArgCount(void);
EXPORT(sqInt) primitivePyCallbackReturn(void);
EXPORT(sqInt) primitivePyCallbackSetResult(void);
EXPORT(sqInt) primitivePyCallbackSetSemaphore(void);
EXPORT(sqInt) primitivePyCallMethod(void);
EXPORT(sqInt) primitivePyGetLastError(void);
EXPORT(sqInt) primitivePyLaunch(void);
EXPORT(sqInt) primitivePyLoadModule(void);
EXPORT(sqInt) primitivePyMapObject(void);
EXPORT(sqInt) primitivePyMappedObjects(void);
EXPORT(sqInt) primitivePySetObjectClass(void);
EXPORT(sqInt) primitivePyUnload(void);
EXPORT(sqInt) primitivePyUnmapObject(void);
EXPORT(sqInt) setInterpreter(struct VirtualMachine*anInterpreter);
EXPORT(sqInt) shutdownModule(void);
EXPORT(sqInt) testSigned64BitInts(void);


/*** Variables ***/

#ifdef SQUEAK_BUILTIN_PLUGIN
extern
#endif
struct VirtualMachine* interpreterProxy;
static const char *moduleName =
#ifdef SQUEAK_BUILTIN_PLUGIN
	"PyBridge Qwaq-Plugins-bgf.97 (i)"
#else
	"PyBridge Qwaq-Plugins-bgf.97 (e)"
#endif
;



/*	Note: This is coded so that plugins can be run from Squeak. */

static VirtualMachine *
getInterpreter(void) {
	return interpreterProxy;
}


/*	Note: This is hardcoded so it can be run from Squeak.
	The module name is used for validating a module *after*
	it is loaded to check if it does really contain the module
	we're thinking it contains. This is important! */

EXPORT(const char*)
getModuleName(void) {
	return moduleName;
}

static sqInt
halt(void) {
	;
	return 0;
}

EXPORT(sqInt)
initialiseModule(void) {
	return pyInit();
}

static sqInt
msg(char *s) {
	fprintf(stderr, "\n%s: %s", moduleName, s);
	return 0;
}


/*	Primitive. Answer the version string of the PyBridge. */

EXPORT(sqInt)
primitivePyBridgeVersion(void) {
    char*dstPtr;
    sqInt i;
    sqInt oop;
    char*srcPtr;
    sqInt sz;

	if (!((interpreterProxy->methodArgumentCount()) == 0)) {
		return interpreterProxy->primitiveFail();
	}
	srcPtr = pyBridgeVersion();
	sz = strlen(srcPtr);
	oop = interpreterProxy->instantiateClassindexableSize(interpreterProxy->classString(), sz);
	dstPtr = interpreterProxy->firstIndexableField(oop);
	for (i = 0; i <= (sz - 1); i += 1) {
		dstPtr[i] = (srcPtr[i]);
	}
	interpreterProxy->pop(1);
	interpreterProxy->push(oop);
}


/*	Primitive. Get the n-th argument from the last callback. */

EXPORT(sqInt)
primitivePyCallbackGetArg(void) {
    sqInt index;
    sqInt result;

	if (!((interpreterProxy->methodArgumentCount()) == 1)) {
		return interpreterProxy->primitiveFail();
	}
	index = interpreterProxy->stackIntegerValue(0);
	result = pyCallbackGetArg(index);
	if (result == 0) {
		return interpreterProxy->primitiveFail();
	}
	interpreterProxy->pop(2);
	interpreterProxy->push(result);
}


/*	Primitive. Answer the number of arguments in the current callback. */

EXPORT(sqInt)
primitivePyCallbackGetArgCount(void) {
    sqInt result;

	if (!((interpreterProxy->methodArgumentCount()) == 0)) {
		return interpreterProxy->primitiveFail();
	}
	result = pyCallbackGetArgCount();
	if (result < 0) {
		return interpreterProxy->primitiveFail();
	}
	interpreterProxy->pop(1);
	interpreterProxy->pushInteger(result);
}


/*	Primitive. Return from the last callback. */

EXPORT(sqInt)
primitivePyCallbackReturn(void) {
    sqInt result;

	if (!((interpreterProxy->methodArgumentCount()) == 0)) {
		return interpreterProxy->primitiveFail();
	}
	result = pyCallbackReturn();
	if (result == 0) {
		return interpreterProxy->primitiveFail();
	}
}


/*	Primitive. Set the result for a callback return. */

EXPORT(sqInt)
primitivePyCallbackSetResult(void) {
    sqInt result;

	if (!((interpreterProxy->methodArgumentCount()) == 1)) {
		return interpreterProxy->primitiveFail();
	}
	result = pyCallbackSetResult(interpreterProxy->stackValue(0));
	if (result == 0) {
		return interpreterProxy->primitiveFail();
	}
	interpreterProxy->pop(1);
}


/*	Primitive. Associate a Squeak callback semaphore with Python. */

EXPORT(sqInt)
primitivePyCallbackSetSemaphore(void) {
    sqInt result;
    sqInt semaIndex;

	if (!((interpreterProxy->methodArgumentCount()) == 1)) {
		return interpreterProxy->primitiveFail();
	}
	semaIndex = interpreterProxy->stackIntegerValue(0);
	if (interpreterProxy->failed()) {
		return null;
	}
	result = pyCallbackSetSemaphore(semaIndex);
	if (result == 0) {
		return interpreterProxy->primitiveFail();
	}
	interpreterProxy->pop(1);
}


/*	Call a python function. */

EXPORT(sqInt)
primitivePyCallMethod(void) {
    sqInt args;
    sqInt name;
    sqInt rcvr;
    sqInt result;

	if (!((interpreterProxy->methodArgumentCount()) == 2)) {
		return interpreterProxy->primitiveFail();
	}
	rcvr = interpreterProxy->stackValue(2);
	name = interpreterProxy->stackValue(1);
	args = interpreterProxy->stackValue(0);
	result = pyCallMethod(rcvr, name, args);
	if (result == 0) {
		return interpreterProxy->primitiveFail();
	}
	interpreterProxy->pop(3);
	interpreterProxy->push(result);
}


/*	Get the last error from the Python bridge */

EXPORT(sqInt)
primitivePyGetLastError(void) {
    char*dstPtr;
    sqInt i;
    sqInt oop;
    char*srcPtr;
    sqInt sz;

	if (!((interpreterProxy->methodArgumentCount()) == 0)) {
		return interpreterProxy->primitiveFail();
	}
	srcPtr = pyGetLastError();
	sz = strlen(srcPtr);
	oop = interpreterProxy->instantiateClassindexableSize(interpreterProxy->classString(), sz);
	dstPtr = interpreterProxy->firstIndexableField(oop);
	for (i = 0; i <= (sz - 1); i += 1) {
		dstPtr[i] = (srcPtr[i]);
	}
	interpreterProxy->pop(1);
	interpreterProxy->push(oop);
}


/*	Launch the Python interpreter */

EXPORT(sqInt)
primitivePyLaunch(void) {
    sqInt i;
    char*oopPtr;
    sqInt result;
    sqInt strOop;
    char*strPtr;
    sqInt sz;

	if (!((interpreterProxy->methodArgumentCount()) == 1)) {
		return interpreterProxy->primitiveFail();
	}
	strOop = interpreterProxy->stackValue(0);
	if (strOop == (interpreterProxy->nilObject())) {
		strPtr = null;
	}
	else {
		if (!(interpreterProxy->isBytes(strOop))) {
			return interpreterProxy->primitiveFail();
		}
		sz = interpreterProxy->byteSizeOf(strOop);
		strPtr = malloc(sz + 1);
		oopPtr = interpreterProxy->firstIndexableField(strOop);
		for (i = 0; i <= (sz - 1); i += 1) {
			strPtr[i] = (oopPtr[i]);
		}
		strPtr[sz] = 0;
	}
	result = pyLaunch(strPtr);
	if (!(strPtr == null)) {
		free(strPtr);
	}
	if (result == 0) {
		return interpreterProxy->primitiveFail();
	}
	interpreterProxy->pop(1);
}


/*	Load a python module. */

EXPORT(sqInt)
primitivePyLoadModule(void) {
    sqInt result;

	if (!((interpreterProxy->methodArgumentCount()) == 1)) {
		return interpreterProxy->primitiveFail();
	}
	result = pyLoadModule(interpreterProxy->stackValue(0));
	if (result == 0) {
		return interpreterProxy->primitiveFail();
	}
	interpreterProxy->pop(2);
	interpreterProxy->push(result);
}


/*	Map between Python and Squeak classes */

EXPORT(sqInt)
primitivePyMapObject(void) {
    sqInt pyOop;
    sqInt result;
    sqInt sqOop;

	if (!((interpreterProxy->methodArgumentCount()) == 2)) {
		return interpreterProxy->primitiveFail();
	}
	sqOop = interpreterProxy->stackValue(0);
	pyOop = interpreterProxy->stackValue(1);
	result = pyMapObjectTo(pyOop, sqOop);
	if (result == 0) {
		return interpreterProxy->primitiveFail();
	}
	interpreterProxy->pop(2);
}


/*	Answer a copy of all the currently mapped objects */

EXPORT(sqInt)
primitivePyMappedObjects(void) {
    sqInt result;

	if (!((interpreterProxy->methodArgumentCount()) == 0)) {
		return interpreterProxy->primitiveFail();
	}
	result = pyMappedObjects();
	if (result == 0) {
		return interpreterProxy->primitiveFail();
	}
	interpreterProxy->pop(1);
	interpreterProxy->push(result);
}


/*	Set class PyObject for the bridge */

EXPORT(sqInt)
primitivePySetObjectClass(void) {
    sqInt result;

	if (!((interpreterProxy->methodArgumentCount()) == 1)) {
		return interpreterProxy->primitiveFail();
	}
	result = pySetObjectClass(interpreterProxy->stackValue(0));
	if (result == 0) {
		return interpreterProxy->primitiveFail();
	}
	interpreterProxy->pop(1);
}


/*	Unload the Python interpreter */

EXPORT(sqInt)
primitivePyUnload(void) {
    sqInt result;

	if (!((interpreterProxy->methodArgumentCount()) == 0)) {
		return interpreterProxy->primitiveFail();
	}
	result = pyUnload();
	if (result == 0) {
		return interpreterProxy->primitiveFail();
	}
}


/*	Map between Python and Squeak classes */

EXPORT(sqInt)
primitivePyUnmapObject(void) {
    sqInt result;
    sqInt sqOop;

	if (!((interpreterProxy->methodArgumentCount()) == 1)) {
		return interpreterProxy->primitiveFail();
	}
	sqOop = interpreterProxy->stackValue(0);
	result = pyUnmapObject(sqOop);
	if (result == 0) {
		return interpreterProxy->primitiveFail();
	}
	interpreterProxy->pop(1);
}


/*	Note: This is coded so that is can be run from Squeak. */

EXPORT(sqInt)
setInterpreter(struct VirtualMachine*anInterpreter) {
    sqInt ok;

	interpreterProxy = anInterpreter;
	ok = interpreterProxy->majorVersion() == VM_PROXY_MAJOR;
	if (ok == 0) {
		return 0;
	}
	ok = interpreterProxy->minorVersion() >= VM_PROXY_MINOR;
	return ok;
}

EXPORT(sqInt)
shutdownModule(void) {
	return pyExit();
}

EXPORT(sqInt)
testSigned64BitInts(void) {
    sqInt oop;

	if (!((interpreterProxy->methodArgumentCount()) == 1)) {
		return interpreterProxy->primitiveFail();
	}
	oop = interpreterProxy->stackValue(0);
	oop = interpreterProxy->signed64BitIntegerFor(interpreterProxy->signed64BitValueOf(oop));
	if (!(interpreterProxy->failed())) {
		interpreterProxy->popthenPush(2, oop);
	}
}


#ifdef SQUEAK_BUILTIN_PLUGIN

void* PyBridge_exports[][3] = {
	{"PyBridge", "getModuleName", (void*)getModuleName},
	{"PyBridge", "initialiseModule", (void*)initialiseModule},
	{"PyBridge", "primitivePyBridgeVersion", (void*)primitivePyBridgeVersion},
	{"PyBridge", "primitivePyCallbackGetArg", (void*)primitivePyCallbackGetArg},
	{"PyBridge", "primitivePyCallbackGetArgCount", (void*)primitivePyCallbackGetArgCount},
	{"PyBridge", "primitivePyCallbackReturn", (void*)primitivePyCallbackReturn},
	{"PyBridge", "primitivePyCallbackSetResult", (void*)primitivePyCallbackSetResult},
	{"PyBridge", "primitivePyCallbackSetSemaphore", (void*)primitivePyCallbackSetSemaphore},
	{"PyBridge", "primitivePyCallMethod", (void*)primitivePyCallMethod},
	{"PyBridge", "primitivePyGetLastError", (void*)primitivePyGetLastError},
	{"PyBridge", "primitivePyLaunch", (void*)primitivePyLaunch},
	{"PyBridge", "primitivePyLoadModule", (void*)primitivePyLoadModule},
	{"PyBridge", "primitivePyMapObject", (void*)primitivePyMapObject},
	{"PyBridge", "primitivePyMappedObjects", (void*)primitivePyMappedObjects},
	{"PyBridge", "primitivePySetObjectClass", (void*)primitivePySetObjectClass},
	{"PyBridge", "primitivePyUnload", (void*)primitivePyUnload},
	{"PyBridge", "primitivePyUnmapObject", (void*)primitivePyUnmapObject},
	{"PyBridge", "setInterpreter", (void*)setInterpreter},
	{"PyBridge", "shutdownModule", (void*)shutdownModule},
	{"PyBridge", "testSigned64BitInts", (void*)testSigned64BitInts},
	{NULL, NULL, NULL}
};

#endif /* ifdef SQ_BUILTIN_PLUGIN */
