/* Automatically generated by
	VMPluginCodeGenerator * VMMaker-eem.606 uuid: 9b749eaa-be7d-4a66-8f6d-8c3c93fae9c1
   from
	QAudioPlugin * Qwaq-Plugins-eem.105 uuid: c3bb436e-a400-4611-8aa7-b7fd8b4917c4
 */
static char __buildInfo[] = "QAudioPlugin * Qwaq-Plugins-eem.105 uuid: c3bb436e-a400-4611-8aa7-b7fd8b4917c4 " __DATE__ ;




#include <math.h>
#include <stdio.h>
#include <stdlib.h>
#include <string.h>
#include <time.h>

/* Default EXPORT macro that does nothing (see comment in sq.h): */
#define EXPORT(returnType) returnType

/* Do not include the entire sq.h file but just those parts needed. */
/*  The virtual machine proxy definition */
#include "sqVirtualMachine.h"
/* Configuration options */
#include "sqConfig.h"
/* Platform specific definitions */
#include "sqPlatformSpecific.h"

#define true 1
#define false 0
#define null 0  /* using 'null' because nil is predefined in Think C */
#ifdef SQUEAK_BUILTIN_PLUGIN
#undef EXPORT
// was #undef EXPORT(returnType) but screws NorCroft cc
#define EXPORT(returnType) static returnType
#endif
#include "QAudioPlugin.h"

#include "sqMemoryAccess.h"


/*** Constants ***/


/*** Function Prototypes ***/
static VirtualMachine * getInterpreter(void);
EXPORT(const char*) getModuleName(void);
static sqInt halt(void);
EXPORT(sqInt) initialiseModule(void);
static sqInt msg(char *s);
EXPORT(sqInt) primitiveAudioAsyncEncode(void);
EXPORT(sqInt) primitiveAudioDecode(void);
EXPORT(sqInt) primitiveCreateAudioDecoder(void);
EXPORT(sqInt) primitiveCreateAudioEncoder(void);
EXPORT(sqInt) primitiveCreateFeedbackChannel(void);
EXPORT(sqInt) primitiveCreatePhoneUser(void);
EXPORT(sqInt) primitiveCreateSinkBufferedResampler(void);
EXPORT(sqInt) primitiveCreateSinkForDebugFeedback(void);
EXPORT(sqInt) primitiveCreateSinkMixer(void);
EXPORT(sqInt) primitiveCreateSinkOpenAL(void);
EXPORT(sqInt) primitiveCreateSinkPOTS(void);
EXPORT(sqInt) primitiveCreateSinkPortAudio(void);
EXPORT(sqInt) primitiveCreateSinkSpeex(void);
EXPORT(sqInt) primitiveDestroyAudioDecoder(void);
EXPORT(sqInt) primitiveDestroyAudioEncoder(void);
EXPORT(sqInt) primitiveDestroyFeedbackChannel(void);
EXPORT(sqInt) primitiveDestroyPhoneInterfaceIAX(void);
EXPORT(sqInt) primitiveDestroySink(void);
EXPORT(sqInt) primitiveFeedbackChannelPopEvent(void);
EXPORT(sqInt) primitiveFeedbackChannelReadEvent(void);
EXPORT(sqInt) primitiveFeedbackChannelSetLogging(void);
EXPORT(sqInt) primitiveGenerateTestPhoneEvents(void);
EXPORT(sqInt) primitiveGetLogVerbosity(void);
EXPORT(sqInt) primitiveHackPushGSM(void);
EXPORT(sqInt) primitiveIaxcAnswerCall(void);
EXPORT(sqInt) primitiveIaxcCall(void);
EXPORT(sqInt) primitiveIaxcHangupCall(void);
EXPORT(sqInt) primitiveIaxcInit(void);
EXPORT(sqInt) primitiveIaxcQuelchCall(void);
EXPORT(sqInt) primitiveIaxcRejectCall(void);
EXPORT(sqInt) primitiveIaxcSelectCall(void);
EXPORT(sqInt) primitiveIaxcSendBusyForCall(void);
EXPORT(sqInt) primitiveIaxcShutdown(void);
EXPORT(sqInt) primitiveIaxcUnquelchCall(void);
EXPORT(sqInt) primitiveLogMsg(void);
EXPORT(sqInt) primitiveOalCreateContext(void);
EXPORT(sqInt) primitiveOalDestroyContext(void);
EXPORT(sqInt) primitiveOalGetPluginError(void);
EXPORT(sqInt) primitiveOalSetAudioDevice(void);
EXPORT(sqInt) primitivePortAudioPrintDeviceInfo(void);
EXPORT(sqInt) primitivePortAudioResetDevice(void);
EXPORT(sqInt) primitiveSetLogFile(void);
EXPORT(sqInt) primitiveSetLogVerbosity(void);
EXPORT(sqInt) primitiveSinkAddSource(void);
EXPORT(sqInt) primitiveSinkControl(void);
EXPORT(sqInt) primitiveSinkGetEventTimings(void);
EXPORT(sqInt) primitiveSinkGetJitterbufferStats(void);
EXPORT(sqInt) primitiveSinkIsSpeexDebugRecording(void);
EXPORT(sqInt) primitiveSinkJitterbufferCtlSpeex(void);
EXPORT(sqInt) primitiveSinkPlayDebugAudioDirectlyViaOpenAL(void);
EXPORT(sqInt) primitiveSinkPushEncodedSpeex(void);
EXPORT(sqInt) primitiveSinkPushEncodedSpeexWithTimestamp(void);
EXPORT(sqInt) primitiveSinkPushRawAudio(void);
EXPORT(sqInt) primitiveSinkRemoveSource(void);
EXPORT(sqInt) primitiveSinkResetJitterbufferTimestamps(void);
EXPORT(sqInt) primitiveSinkSetBufferedFrameCount(void);
EXPORT(sqInt) primitiveSinkSetGainOpenAL(void);
EXPORT(sqInt) primitiveSinkSetInitialPropertiesOpenAL(void);
EXPORT(sqInt) primitiveSinkSetInputSamplingRate(void);
EXPORT(sqInt) primitiveSinkSetOutputSamplingRate(void);
EXPORT(sqInt) primitiveSinkSetTransformOpenAL(void);
EXPORT(sqInt) primitiveSinkStartSpeexDebugRecording(void);
EXPORT(sqInt) primitiveSinkStopSpeexDebugRecording(void);
EXPORT(sqInt) primitiveSpeexCreateHandle(void);
EXPORT(sqInt) primitiveSpeexDecode(void);
EXPORT(sqInt) primitiveSpeexDecodeToTestJB(void);
EXPORT(sqInt) primitiveSpeexDestroyHandle(void);
EXPORT(sqInt) primitiveSpeexEncode(void);
EXPORT(sqInt) primitiveTestBufferSize(void);
EXPORT(sqInt) primitiveTickerSetInterval(void);
EXPORT(sqInt) primitiveTickerSetVerbosity(void);
EXPORT(sqInt) primitiveTickerStart(void);
EXPORT(sqInt) primitiveTickerStop(void);
EXPORT(sqInt) primitiveTickerTickNow(void);
EXPORT(sqInt) setInterpreter(struct VirtualMachine*anInterpreter);
EXPORT(sqInt) shutdownModule(void);
static sqInt stackBooleanValue(sqInt index);
static void* stackPointerPointer(sqInt index);
static void * stackStringValue(sqInt index);
static sqInt validateArgCount(sqInt expectedArgCount);


/*** Variables ***/

#ifdef SQUEAK_BUILTIN_PLUGIN
extern
#endif
struct VirtualMachine* interpreterProxy;
static const char *moduleName =
#ifdef SQUEAK_BUILTIN_PLUGIN
	"QAudioPlugin * Qwaq-Plugins-eem.105 (i)"
#else
	"QAudioPlugin * Qwaq-Plugins-eem.105 (e)"
#endif
;



/*	Note: This is coded so that plugins can be run from Squeak. */

static VirtualMachine *
getInterpreter(void) {
	return interpreterProxy;
}


/*	Note: This is hardcoded so it can be run from Squeak.
	The module name is used for validating a module *after*
	it is loaded to check if it does really contain the module
	we're thinking it contains. This is important! */

EXPORT(const char*)
getModuleName(void) {
	return moduleName;
}

static sqInt
halt(void) {
	;
	return 0;
}

EXPORT(sqInt)
initialiseModule(void) {
	return qInitModule();
}

static sqInt
msg(char *s) {
	fprintf(stderr, "\n%s: %s", moduleName, s);
	return 0;
}

EXPORT(sqInt)
primitiveAudioAsyncEncode(void) {
    sqInt bufferOop;
    void*bufferPtr;
    unsigned handle;
    sqInt result;
    sqInt sampleCount;

	if (!(validateArgCount(2))) {
		return null;
	}
	handle = interpreterProxy->positive32BitValueOf(interpreterProxy->stackValue(1));
	bufferOop = interpreterProxy->stackObjectValue(0);
	interpreterProxy->success(interpreterProxy->isWords(bufferOop));
	if (interpreterProxy->failed()) {
		return null;
	}
	bufferPtr = interpreterProxy->firstIndexableField(bufferOop);

	/* number of 16-bit samples */

	sampleCount = ((sqInt) (interpreterProxy->byteSizeOf(bufferOop)) >> 1);
	if (interpreterProxy->failed()) {
		return interpreterProxy->primitiveFailFor(3);
	}
	;
	;
	;
	result = qAudioAsyncEncode(handle, (short*)bufferPtr, sampleCount);
	if (!(result == 0)) {
		return interpreterProxy->primitiveFailFor(result);
	}
	interpreterProxy->pop(2);
	return null;
}


/*	Answer the number of bytes decoded, or negative values upon error. */
/*	arguments: name(type, stack offset)
	handle	:	uint32			6
	input	:	ByteArray		5
	inSize :	uint32			4
	inOffset :	uint32			3	(in bytes)
	output	:	SoundBuffer	2
	outOffset :	integer			1	(in 16-bit samples)
	flags	:	uint32			0 */

EXPORT(sqInt)
primitiveAudioDecode(void) {
    unsigned int flags;
    unsigned int handle;
    sqInt inObj;
    unsigned int inOffset;
    unsigned char* input;
    unsigned int inSize;
    sqInt outObj;
    unsigned int outOffset;
    unsigned short* output;
    sqInt outSize;
    sqInt result;
    sqInt sizeOfShort;

	if (!(validateArgCount(7))) {
		return null;
	}
	sizeOfShort = sizeof(short);
	interpreterProxy->success(sizeOfShort == 2);
	if (interpreterProxy->failed()) {
		qLogFromC("primitiveAudioDecode() ERROR: sizeof(short) != 2\n");;
		return null;
	}
	handle = interpreterProxy->positive32BitValueOf(interpreterProxy->stackValue(6));
	inSize = interpreterProxy->positive32BitValueOf(interpreterProxy->stackValue(4));
	inOffset = interpreterProxy->positive32BitValueOf(interpreterProxy->stackValue(3));
	outOffset = interpreterProxy->positive32BitValueOf(interpreterProxy->stackValue(1));
	flags = interpreterProxy->positive32BitValueOf(interpreterProxy->stackValue(0));
	if (interpreterProxy->failed()) {
		qLogFromC("primitiveAudioDecode() ERROR: failed to read integers from stack\n");;
		return null;
	}
	inObj = interpreterProxy->stackObjectValue(5);
	input = interpreterProxy->firstIndexableField(inObj);
	interpreterProxy->success(interpreterProxy->isBytes(inObj));
	outObj = interpreterProxy->stackObjectValue(2);
	output = interpreterProxy->firstIndexableField(outObj);

	/* adjust for 16-bit samples */

	outSize = ((sqInt) (interpreterProxy->byteSizeOf(outObj)) >> 1);
	interpreterProxy->success(interpreterProxy->isWords(outObj));
	if (interpreterProxy->failed()) {
		qLogFromC("primitiveAudioDecode() ERROR: failed to read pointers from stack\n");;
		return null;
	}
	interpreterProxy->success(((interpreterProxy->byteSizeOf(inObj)) - inOffset) >= inSize);
	outSize -= outOffset;
	interpreterProxy->success(outSize >= 0);
	if (interpreterProxy->failed()) {
		qLogFromC("primitiveAudioDecode() ERROR: invalid offsets/sizes\n");;
		return null;
	}
	input += inOffset;

	/* Make compiler happy. */

	output += outOffset;
	;
	;
	result = qAudioDecode(handle, input, inSize, output, outSize, flags);;
	if (interpreterProxy->failed()) {
		qLogFromC("primitiveAudioDecode() ERROR: error in qAudioDecode()\n");;
		return null;
	}
	interpreterProxy->popthenPush(8, interpreterProxy->positive32BitIntegerFor(result));
	return null;
}


/*	Answer a handle (an integer) to a newly-created audio decoder. */
/*	arguments: name(type, stack offset)
	codecType	:	uint32			1
	configData	:	ByteArray		0 */

EXPORT(sqInt)
primitiveCreateAudioDecoder(void) {
    unsigned int codecType;
    unsigned char* config;
    sqInt configObj;
    unsigned int configSize;
    unsigned int result;

	if (!(validateArgCount(2))) {
		return null;
	}
	codecType = interpreterProxy->positive32BitValueOf(interpreterProxy->stackValue(1));
	configObj = interpreterProxy->stackValue(0);
	interpreterProxy->success(interpreterProxy->isBytes(configObj));
	configSize = interpreterProxy->byteSizeOf(configObj);
	config = interpreterProxy->firstIndexableField(configObj);
	if (interpreterProxy->failed()) {
		qLogFromC("primitiveCreateAudioDecoder() ERROR: bad args\n");;
		return null;
	}
	;
	;
	;
	result = qCreateAudioDecoder(codecType, config, configSize);;
	interpreterProxy->popthenPush(3, interpreterProxy->positive32BitIntegerFor(result));
	return null;
}


/*	Answer a handle (an integer) to a newly-created audio encoder. */
/*	arguments: name(type, stack offset)
	codecType	:		uint32						2
	feedbackChannel:	ExternalAddress-or-nil	1
	configData	:		ByteArray					0 */

EXPORT(sqInt)
primitiveCreateAudioEncoder(void) {
    unsigned int codecType;
    unsigned char*config;
    sqInt configOop;
    unsigned int configSize;
    void*feedbackChannel;
    sqInt feedbackChannelOop;
    unsigned int result;

	if (!(validateArgCount(3))) {
		return null;
	}

	/* Get a pointer the feedback-channel, if any. */

	codecType = interpreterProxy->positive32BitValueOf(interpreterProxy->stackValue(2));
	feedbackChannelOop = interpreterProxy->stackValue(1);
	interpreterProxy->success((interpreterProxy->isBytes(feedbackChannelOop))
	 || (feedbackChannelOop == (interpreterProxy->nilObject())));
	if (interpreterProxy->isBytes(feedbackChannelOop)) {
		feedbackChannel = interpreterProxy->firstIndexableField(feedbackChannelOop);
	}
	if (feedbackChannelOop == (interpreterProxy->nilObject())) {
		feedbackChannel = null;
	}
	configOop = interpreterProxy->stackValue(0);
	interpreterProxy->success(interpreterProxy->isBytes(configOop));
	configSize = interpreterProxy->byteSizeOf(configOop);
	config = interpreterProxy->firstIndexableField(configOop);
	if (interpreterProxy->failed()) {
		qLogFromC("primitiveCreateAudioEncoder() ERROR: bad args\n");;
		return interpreterProxy->primitiveFailFor(3);
	}
	;
	;
	;
	;
	result = qCreateAudioEncoder(codecType, feedbackChannel, config, configSize);;
	interpreterProxy->popthenPush(4, interpreterProxy->positive32BitIntegerFor(result));
	return null;
}


/*	Create a C++ FeedbackChannel object; stash a pointer to it in
	'externalAddress'. Answer 0 for success and a negative value for errors.
	If unsuccessful, the contents of 'externalAddress' will be unchanged. */
/*	arguments: name(type, stack offset)
	address(ExternalAddress, 1)
	semaphoreIndex(integer, 0) */

EXPORT(sqInt)
primitiveCreateFeedbackChannel(void) {
    void* addressPtr;
    sqInt result;
    sqInt semaphoreIndex;

	if (!((interpreterProxy->methodArgumentCount()) == 2)) {
		return interpreterProxy->primitiveFail();
	}
	addressPtr = stackPointerPointer(1);
	if (interpreterProxy->failed()) {
		return null;
	}
	semaphoreIndex = interpreterProxy->stackIntegerValue(0);
	if (interpreterProxy->failed()) {
		return null;
	}
	;
	;
	result = qCreateFeedbackChannel(addressPtr, semaphoreIndex);
	return interpreterProxy->popthenPush(3, interpreterProxy->positive32BitIntegerFor(result));
}


/*	arguments: name(type, stack offset)
	username(String, 3)
	password(String, 2)
	hostname(String, 1)
	channelHandle(ByteArray, 0) */

EXPORT(sqInt)
primitiveCreatePhoneUser(void) {
    void*channelHandle;
    unsigned handle;
    char*hostname;
    char*password;
    char*username;

	if (!(validateArgCount(4))) {
		return null;
	}
	channelHandle = stackPointerPointer(0);
	;
	if (interpreterProxy->failed()) {
		return null;
	}
	username = stackStringValue(3);
	password = stackStringValue(2);
	hostname = stackStringValue(1);
	if (interpreterProxy->failed()) {
		if (username != null) {
			free(username);
		}
		if (password != null) {
			free(password);
		}
		return null;
	}

	/* Free the C-strings */
#if !EXCLUDE_IAX
	handle = qCreatePhoneUser(username, password, hostname, channelHandle);
#endif
	free(username);
	free(password);
	free(hostname);
	if (handle == 0) {
		return interpreterProxy->primitiveFail();
	}
	return interpreterProxy->popthenPush(4, interpreterProxy->positive32BitIntegerFor(handle));
}

EXPORT(sqInt)
primitiveCreateSinkBufferedResampler(void) {
    unsigned handle;

	if (!(validateArgCount(0))) {
		return null;
	}
	handle = qCreateSinkBufferedResampler();
	if (handle == 0) {
		return interpreterProxy->primitiveFail();
	}
	return interpreterProxy->popthenPush(1, interpreterProxy->positive32BitIntegerFor(handle));
}


/*	arguments: name(type, stack offset)
	channelHandle(ByteArray, 0) */

EXPORT(sqInt)
primitiveCreateSinkForDebugFeedback(void) {
    void*channelHandle;
    unsigned handle;

	if (!(validateArgCount(1))) {
		return null;
	}
	channelHandle = stackPointerPointer(0);
	;
	if (interpreterProxy->failed()) {
		return null;
	}
	handle = qCreateSinkForDebugFeedback(channelHandle);
	if (handle == 0) {
		return interpreterProxy->primitiveFail();
	}
	return interpreterProxy->popthenPush(2, interpreterProxy->positive32BitIntegerFor(handle));
}

EXPORT(sqInt)
primitiveCreateSinkMixer(void) {
    unsigned handle;

	if (!(validateArgCount(0))) {
		return null;
	}
	handle = qCreateSinkMixer();
	if (handle == 0) {
		return interpreterProxy->primitiveFail();
	}
	return interpreterProxy->popthenPush(1, interpreterProxy->positive32BitIntegerFor(handle));
}

EXPORT(sqInt)
primitiveCreateSinkOpenAL(void) {
    unsigned handle;

	if (!(validateArgCount(0))) {
		return null;
	}
	handle = qCreateSinkOpenAL();
	if (handle == 0) {
		return interpreterProxy->primitiveFail();
	}
	return interpreterProxy->popthenPush(1, interpreterProxy->positive32BitIntegerFor(handle));
}

EXPORT(sqInt)
primitiveCreateSinkPOTS(void) {
    unsigned handle;

	if (!(validateArgCount(0))) {
		return null;
	}
	handle = qCreateSinkPOTS();
	if (handle == 0) {
		return interpreterProxy->primitiveFail();
	}
	return interpreterProxy->popthenPush(1, interpreterProxy->positive32BitIntegerFor(handle));
}

EXPORT(sqInt)
primitiveCreateSinkPortAudio(void) {
    unsigned handle;

	if (!(validateArgCount(0))) {
		return null;
	}
	handle = qCreateSinkPortAudio();
	if (handle == 0) {
		return interpreterProxy->primitiveFail();
	}
	return interpreterProxy->popthenPush(1, interpreterProxy->positive32BitIntegerFor(handle));
}

EXPORT(sqInt)
primitiveCreateSinkSpeex(void) {
    unsigned handle;

	if (!(validateArgCount(0))) {
		return null;
	}
	handle = qCreateSinkSpeex();
	if (handle == 0) {
		return interpreterProxy->primitiveFail();
	}
	return interpreterProxy->popthenPush(1, interpreterProxy->positive32BitIntegerFor(handle));
}


/*	arguments: name(type, stack offset)
	handle	:	uint32			0 */

EXPORT(sqInt)
primitiveDestroyAudioDecoder(void) {
    unsigned int handle;

	if (!(validateArgCount(1))) {
		return null;
	}
	handle = interpreterProxy->positive32BitValueOf(interpreterProxy->stackValue(0));
	if (interpreterProxy->failed()) {
		qLogFromC("primitiveDestroyAudioDecoder() ERROR: bad handle\n");;
		return null;
	}
	qDestroyAudioDecoder(handle);;
	interpreterProxy->pop(1);
	return null;
}


/*	arguments: name(type, stack offset)
	handle	:	uint32			0 */

EXPORT(sqInt)
primitiveDestroyAudioEncoder(void) {
    unsigned int handle;

	if (!(validateArgCount(1))) {
		return null;
	}
	handle = interpreterProxy->positive32BitValueOf(interpreterProxy->stackValue(0));
	if (interpreterProxy->failed()) {
		qLogFromC("primitiveDestroyAudioEncoder() ERROR: bad handle\n");;
		return null;
	}
	qDestroyAudioEncoder(handle);;
	interpreterProxy->pop(1);
	return null;
}


/*	Destroy a C++ FeedbackChannel object. */
/*	arguments: name(type, stack offset)
	address(ExternalAddress, 0) */

EXPORT(sqInt)
primitiveDestroyFeedbackChannel(void) {
    void* addressPtr;

	if (!((interpreterProxy->methodArgumentCount()) == 1)) {
		return interpreterProxy->primitiveFail();
	}
	addressPtr = stackPointerPointer(0);
	;
	if (interpreterProxy->failed()) {
		return null;
	}
	qDestroyFeedbackChannel(addressPtr);
	return interpreterProxy->pop(1);
}


/*	arguments: name(type, stack offset)
	handle(Integer, 0) */

EXPORT(sqInt)
primitiveDestroyPhoneInterfaceIAX(void) {
    unsigned handle;

	if (!(validateArgCount(1))) {
		return null;
	}
	handle = interpreterProxy->positive32BitValueOf(interpreterProxy->stackValue(0));

	/* reuse handle for result */
#if !EXCLUDE_IAX
	handle = qDestroyPhoneInterfaceIAX(handle);
#endif
	if (!(handle == 0)) {
		return interpreterProxy->primitiveFail();
	}
	return interpreterProxy->pop(1);
}

EXPORT(sqInt)
primitiveDestroySink(void) {
    unsigned handle;

	if (!(validateArgCount(1))) {
		return null;
	}
	handle = interpreterProxy->positive32BitValueOf(interpreterProxy->stackValue(0));
	;
	if (interpreterProxy->failed()) {
		return null;
	}
	qDestroySink(handle);
	return interpreterProxy->pop(1);
}


/*	Pop the frontmost event from the channel identified by 'externalAddress'. */
/*	arguments: name(type, stack offset)
	address(ExternalAddress, 0) */

EXPORT(sqInt)
primitiveFeedbackChannelPopEvent(void) {
    void* addressPtr;

	if (!((interpreterProxy->methodArgumentCount()) == 1)) {
		return interpreterProxy->primitiveFail();
	}
	addressPtr = stackPointerPointer(0);
	;
	if (interpreterProxy->failed()) {
		return null;
	}
	qFeedbackChannelPopEvent(addressPtr);
	return interpreterProxy->pop(1);
}


/*	Answer a newly-instantiated ByteArray describing the channel's next event,
	or nil if there is no next event (and also if the address is invalid).
	Note that the event stays in the channel until it is released via
	#primitiveFeedbackChannelPopEvent:. 
 */
/*	arguments: name(type, stack offset)
	address(ExternalAddress, 0) */

EXPORT(sqInt)
primitiveFeedbackChannelReadEvent(void) {
    void* addressPtr;
    sqInt resultOop;

	if (!((interpreterProxy->methodArgumentCount()) == 1)) {
		return interpreterProxy->primitiveFail();
	}
	addressPtr = stackPointerPointer(0);
	;
	if (interpreterProxy->failed()) {
		return null;
	}
	resultOop = qFeedbackChannelReadEvent(addressPtr);
	return interpreterProxy->popthenPush(2, resultOop);
}


/*	Pop the frontmost event from the channel identified by 'externalAddress'. */
/*	arguments: name(type, stack offset)
	address(ExternalAddress, 1)
	address(Boolean, 0) */

EXPORT(sqInt)
primitiveFeedbackChannelSetLogging(void) {
    void* addressPtr;
    sqInt trueOrFalse;

	if (!((interpreterProxy->methodArgumentCount()) == 2)) {
		return interpreterProxy->primitiveFail();
	}
	addressPtr = stackPointerPointer(1);
	;
	if (interpreterProxy->failed()) {
		return null;
	}
	trueOrFalse = interpreterProxy->booleanValueOf(interpreterProxy->stackValue(0));
	;
	if (interpreterProxy->failed()) {
		return null;
	}
	qFeedbackChannelSetLogging(addressPtr, trueOrFalse);
	return interpreterProxy->pop(1);
}


/*	Generate a series of phone events and enqueue them on the specified
	feedback channel. See the Squeak class QPhoneTestFeedbackChannel. */
/*	arguments: name(type, stack offset)
	address(ExternalAddress, 0) */

EXPORT(sqInt)
primitiveGenerateTestPhoneEvents(void) {
    void* addressPtr;

	if (!((interpreterProxy->methodArgumentCount()) == 1)) {
		return interpreterProxy->primitiveFail();
	}
	addressPtr = stackPointerPointer(0);
	;
	if (interpreterProxy->failed()) {
		return null;
	}
#if !EXCLUDE_IAX
	qGenerateTestPhoneEvents(addressPtr);
#endif
	return interpreterProxy->pop(1);
}


/*	Get the current logging verbosity level. 0 is the lowest/default
	verbosity; higher numbers are more verbose. */

EXPORT(sqInt)
primitiveGetLogVerbosity(void) {
    sqInt result;

	if (!(validateArgCount(0))) {
		return null;
	}
	result = interpreterProxy->signed32BitIntegerFor(qGetLogVerbosity());
	return interpreterProxy->popthenPush(1, result);
}


/*	BLECH! Push straight into our Digium-hacked iaxclient. No mixing of
	multiple streams. */
/*	arguments: name(type, stack offset)
	byteArray(ByteArray, 0) */

EXPORT(sqInt)
primitiveHackPushGSM(void) {
    sqInt byteArray;
    void*bytePtr;
    sqInt byteSize;
    sqInt result;

	if (!(validateArgCount(1))) {
		return null;
	}
	byteArray = interpreterProxy->stackObjectValue(0);
	interpreterProxy->success(interpreterProxy->isBytes(byteArray));
	if (interpreterProxy->failed()) {
		return null;
	}
	bytePtr = interpreterProxy->firstIndexableField(byteArray);
	byteSize = interpreterProxy->slotSizeOf(byteArray);
	if (interpreterProxy->failed()) {
		return null;
	}
	;
	;
	;
#if !EXCLUDE_IAX
	result = iaxc_write_output_buffer(0, bytePtr, byteSize);
#endif
	result = interpreterProxy->signed32BitIntegerFor(result);
	return interpreterProxy->popthenPush(2, result);
}


/*	arguments: name(type, stack offset)
	callNo(Integer, 0) */

EXPORT(sqInt)
primitiveIaxcAnswerCall(void) {
    sqInt callNo;

	if (!(validateArgCount(1))) {
		return null;
	}
	callNo = interpreterProxy->positive32BitValueOf(interpreterProxy->stackValue(0));
	;
	if (interpreterProxy->failed()) {
		return null;
	}
#if !EXCLUDE_IAX
	iaxc_answer_call(callNo);
#endif
	return interpreterProxy->pop(1);
}


/*	arguments: name(type, stack offset)
	dialString(String, 0) */

EXPORT(sqInt)
primitiveIaxcCall(void) {
    char*dialString;
    sqInt result;

	if (!(validateArgCount(1))) {
		return null;
	}
	dialString = stackStringValue(0);
	if (interpreterProxy->failed()) {
		free(dialString);
		return null;
	}
#if !EXCLUDE_IAX
	result = iaxc_call(dialString);
#endif
	result = interpreterProxy->signed32BitIntegerFor(result);
	free(dialString);
	return interpreterProxy->popthenPush(2, result);
}


/*	arguments: name(type, stack offset)
	callNo(Integer, 0) */

EXPORT(sqInt)
primitiveIaxcHangupCall(void) {
    sqInt callNo;
    sqInt current;
    sqInt result;

	if (!(validateArgCount(1))) {
		return null;
	}
	callNo = interpreterProxy->positive32BitValueOf(interpreterProxy->stackValue(0));
	if (interpreterProxy->failed()) {
		return null;
	}
#if !EXCLUDE_IAX
	current = iaxc_selected_call();
	result = iaxc_select_call(callNo);
	if (!(result == 0)) {
		iaxc_select_call(current);
		return interpreterProxy->primitiveFail();
	}
	iaxc_dump_call();
	if (!(current == callNo)) {
		iaxc_select_call(current);
	}
#endif
	return interpreterProxy->pop(1);
}

EXPORT(sqInt)
primitiveIaxcInit(void) {
    sqInt result;

	if (!(validateArgCount(0))) {
		return null;
	}
#if !EXCLUDE_IAX
	result = qIaxInit();
#endif
	if (result < 0) {
		interpreterProxy->primitiveFail();
	}
	return null;
}


/*	'moh' stands for music-on-hold. If zero, don't play music-on-hold.
	Otherwise, do. */
/*	arguments: name(type, stack offset)
	callNo(Integer, 0)
	moh(Integer,1) */

EXPORT(sqInt)
primitiveIaxcQuelchCall(void) {
    sqInt callNo;
    sqInt moh;
    sqInt result;

	if (!(validateArgCount(2))) {
		return null;
	}
	callNo = interpreterProxy->positive32BitValueOf(interpreterProxy->stackValue(1));
	moh = interpreterProxy->positive32BitValueOf(interpreterProxy->stackValue(0));
	;
	;
	if (interpreterProxy->failed()) {
		return null;
	}
#if !EXCLUDE_IAX
	result = iaxc_quelch(callNo, moh);
#endif
	result = interpreterProxy->signed32BitIntegerFor(result);
	return interpreterProxy->popthenPush(3, result);
}


/*	arguments: name(type, stack offset)
	callNo(Integer, 0) */

EXPORT(sqInt)
primitiveIaxcRejectCall(void) {
    sqInt callNo;

	if (!(validateArgCount(1))) {
		return null;
	}
	callNo = interpreterProxy->positive32BitValueOf(interpreterProxy->stackValue(0));
	;
	if (interpreterProxy->failed()) {
		return null;
	}
#if !EXCLUDE_IAX
	iaxc_reject_call_number(callNo);
#endif
	return interpreterProxy->pop(1);
}


/*	arguments: name(type, stack offset)
	callNo(Integer, 0) */

EXPORT(sqInt)
primitiveIaxcSelectCall(void) {
    sqInt callNo;
    sqInt result;

	if (!(validateArgCount(1))) {
		return null;
	}
	callNo = interpreterProxy->positive32BitValueOf(interpreterProxy->stackValue(0));
	;
	if (interpreterProxy->failed()) {
		return null;
	}
#if !EXCLUDE_IAX
	result = iaxc_select_call(callNo);
#endif
	result = interpreterProxy->signed32BitIntegerFor(result);
	return interpreterProxy->popthenPush(2, result);
}


/*	arguments: name(type, stack offset)
	callNo(Integer, 0) */

EXPORT(sqInt)
primitiveIaxcSendBusyForCall(void) {
    sqInt callNo;

	if (!(validateArgCount(1))) {
		return null;
	}
	callNo = interpreterProxy->positive32BitValueOf(interpreterProxy->stackValue(0));
	;
	if (interpreterProxy->failed()) {
		return null;
	}
#if !EXCLUDE_IAX
	iaxc_send_busy_on_incoming_call(callNo);
#endif
	return interpreterProxy->pop(1);
}

EXPORT(sqInt)
primitiveIaxcShutdown(void) {
	if (!(validateArgCount(0))) {
		return null;
	}
#if !EXCLUDE_IAX
	qIaxShutdown();
#endif
	return null;
}


/*	arguments: name(type, stack offset)
	callNo(Integer, 0) */

EXPORT(sqInt)
primitiveIaxcUnquelchCall(void) {
    sqInt callNo;
    sqInt result;

	if (!(validateArgCount(1))) {
		return null;
	}
	callNo = interpreterProxy->positive32BitValueOf(interpreterProxy->stackValue(0));
	;
	if (interpreterProxy->failed()) {
		return null;
	}
#if !EXCLUDE_IAX
	result = iaxc_unquelch(callNo);
#endif
	result = interpreterProxy->signed32BitIntegerFor(result);
	return interpreterProxy->popthenPush(2, result);
}


/*	Allows us to log to the current plugin log-file (typically
	QAudioPlugin.log). 
 */

EXPORT(sqInt)
primitiveLogMsg(void) {
    char*logString;

	if (!(validateArgCount(1))) {
		return null;
	}
	logString = stackStringValue(0);
	if (interpreterProxy->failed()) {
		free(logString);
		return null;
	}
	qLogFromC(logString);
	free(logString);
	return interpreterProxy->pop(1);
}

EXPORT(sqInt)
primitiveOalCreateContext(void) {
    sqInt handle;

	if (!((interpreterProxy->methodArgumentCount()) == 0)) {
		return interpreterProxy->primitiveFail();
	}

	/* If the handle couldn't be created, fail.  Another primitive (#primitiveOalGetPluginError) can be used to check what went wrong. */

	handle = (sqInt) qOalCreateContext();
	if (handle == 0) {
		return interpreterProxy->primitiveFail();
	}
	return interpreterProxy->popthenPush(1, interpreterProxy->positive32BitIntegerFor(handle));
}

EXPORT(sqInt)
primitiveOalDestroyContext(void) {
    sqInt handle;
    sqInt result;

	if (!((interpreterProxy->methodArgumentCount()) == 1)) {
		return interpreterProxy->primitiveFail();
	}
	handle = interpreterProxy->positive32BitValueOf(interpreterProxy->stackValue(0));
	if (interpreterProxy->failed()) {
		return null;
	}
	if (!(handle == 0)) {
		result = (sqInt) qOalDestroyContext((void*)handle);
	}
	if (!(result == 0)) {
		return interpreterProxy->primitiveFail();
	}
	return interpreterProxy->pop(1);
}

EXPORT(sqInt)
primitiveOalGetPluginError(void) {
    sqInt handle;

	if (!((interpreterProxy->methodArgumentCount()) == 0)) {
		return interpreterProxy->primitiveFail();
	}
	handle = (sqInt) qOalGetPluginError();
	return interpreterProxy->popthenPush(1, interpreterProxy->positive32BitIntegerFor(handle));
}


/*	Specify the device-name that OpenAL should use to create a new context
	(use nil to get the default device.
 */

EXPORT(sqInt)
primitiveOalSetAudioDevice(void) {
    char*deviceName;
    sqInt maybeNil;

	if (!(validateArgCount(1))) {
		return null;
	}
	maybeNil = interpreterProxy->stackValue(0);
	if (interpreterProxy->failed()) {
		return null;
	}
	if (maybeNil == (interpreterProxy->nilObject())) {
		qOalSetAudioDevice(NULL);
		interpreterProxy->pop(1);
		return null;
	}
	deviceName = stackStringValue(0);
	if (interpreterProxy->failed()) {
		if (deviceName == null) {
			null;
		}
		else {
			free(deviceName);
		}
		return null;
	}
	qOalSetAudioDevice(deviceName);
	return interpreterProxy->pop(1);
}


/*	Log info about PortAudio devices. */

EXPORT(sqInt)
primitivePortAudioPrintDeviceInfo(void) {
	if (!(validateArgCount(0))) {
		return null;
	}
	qPortAudioPrintDeviceInfo();
	return null;
}


/*	Log info about PortAudio devices. */

EXPORT(sqInt)
primitivePortAudioResetDevice(void) {
	if (!(validateArgCount(0))) {
		return null;
	}
	qPortAudioResetDevice();
	return null;
}

EXPORT(sqInt)
primitiveSetLogFile(void) {
    char*filePath;

	if (!(validateArgCount(1))) {
		return null;
	}
	filePath = stackStringValue(0);
	if (interpreterProxy->failed()) {
		free(filePath);
		return null;
	}
	qLogToFile(filePath);
	free(filePath);
	return interpreterProxy->pop(1);
}


/*	Set the verbosity level of the logging. 0 is the lowest/default verbosity;
	higher numbers are more verbose. */

EXPORT(sqInt)
primitiveSetLogVerbosity(void) {
    sqInt newVerbosity;

	if (!(validateArgCount(1))) {
		return null;
	}
	newVerbosity = interpreterProxy->stackIntegerValue(0);
	if (interpreterProxy->failed()) {
		return null;
	}
	qSetLogVerbosity(newVerbosity);
	return interpreterProxy->pop(1);
}


/*	arguments: name(type, stack offset)
	sinkHandle(integer, 1)
	sourceHandle(integer,0) */

EXPORT(sqInt)
primitiveSinkAddSource(void) {
    sqInt result;
    unsigned sinkHandle;
    unsigned sourceHandle;

	if (!(validateArgCount(2))) {
		return null;
	}
	sinkHandle = interpreterProxy->positive32BitValueOf(interpreterProxy->stackValue(1));
	sourceHandle = interpreterProxy->positive32BitValueOf(interpreterProxy->stackValue(0));
	;
	;
	if (interpreterProxy->failed()) {
		return interpreterProxy->primitiveFailFor(3);
	}
	result = qSinkAddSource(sinkHandle, sourceHandle);
	if (!(result == 0)) {
		return interpreterProxy->primitiveFailFor(result);
	}
	return interpreterProxy->pop(2);
}


/*	Make it easier to add new ways to control sinks without writing new Slang
	for each one.
 */
/*	arguments: name(type, stack offset)
	handle(integer, 2)
	ctlType(integer, 1)
	ctlValue(integer, 0)
	 */

EXPORT(sqInt)
primitiveSinkControl(void) {
    sqInt ctlType;
    sqInt ctlValue;
    unsigned handle;
    sqInt result;

	if (!(validateArgCount(3))) {
		return null;
	}
	handle = interpreterProxy->positive32BitValueOf(interpreterProxy->stackValue(2));
	ctlType = interpreterProxy->stackIntegerValue(1);
	ctlValue = interpreterProxy->stackIntegerValue(0);
	;
	;
	;
	if (interpreterProxy->failed()) {
		return null;
	}
	result = qSinkControl(handle, ctlType, ctlValue);
	interpreterProxy->pop(4);
	return interpreterProxy->pushInteger(result);
}


/*	Obtain the timing-info for events that have been pushed into QAudioPlugin.
	Takes a single arg: the sink's handle, and allocates a new ByteArray to
	hold the info.
	The answered data has the following format:
	32 byte header:
	int32 version number
	int32 for the number of entries (see below)
	int32 for the number of discarded entries
	5 int32 reserved values
	12 byte entries (the number of entries is specified in the header):
	int32 network-timestamp
	uint64 UTC time that the corresponding event happened in the plugin */

EXPORT(sqInt)
primitiveSinkGetEventTimings(void) {
    unsigned handle;
    sqInt oop;

	if (!(validateArgCount(1))) {
		return null;
	}
	handle = interpreterProxy->positive32BitValueOf(interpreterProxy->stackValue(0));
	if (interpreterProxy->failed()) {
		return null;
	}
	;
	oop = qSinkGetEventTimings(handle);
	return interpreterProxy->popthenPush(2, oop);
}


/*	Squeak provides a structure to fill in with stats.. */
/*	arguments: name(type, stack offset)
	handle(integer, 1)
	structure(ByteArray, 0)
	 */

EXPORT(sqInt)
primitiveSinkGetJitterbufferStats(void) {
    sqInt err;
    unsigned handle;
    int minSize;
    void *structPtr;
    int structSize;
    sqInt structure;

	if (!(validateArgCount(2))) {
		return null;
	}
	handle = interpreterProxy->positive32BitValueOf(interpreterProxy->stackValue(1));
	;
	structure = interpreterProxy->stackObjectValue(0);
	interpreterProxy->success(interpreterProxy->isBytes(structure));
	if (interpreterProxy->failed()) {
		return null;
	}
	structPtr = interpreterProxy->firstIndexableField(structure);
	structSize = interpreterProxy->slotSizeOf(structure);
	if (interpreterProxy->failed()) {
		return null;
	}
	;

	/* XXXXX: don't compare struct size... we'll rely on the caller to provide a structure of the appropriate size for the stats-version you're requesting. */
	/* 	structSize < minSize ifTrue: [^interpreterProxy primitiveFail]. */

	minSize = sizeof(QJitterbufferStats);
	err = qSinkSpeexGetJitterbufferStats(handle, (QJitterbufferStats*)structPtr);
	if (err != 0) {
		return interpreterProxy->primitiveFail();
	}
	return interpreterProxy->pop(2);
}


/*	arguments: name(type, stack offset)
	handle(integer, 0) */

EXPORT(sqInt)
primitiveSinkIsSpeexDebugRecording(void) {
    unsigned handle;
    sqInt result;

	if (!(validateArgCount(1))) {
		return null;
	}
	handle = interpreterProxy->positive32BitValueOf(interpreterProxy->stackValue(0));
	if (interpreterProxy->failed()) {
		return null;
	}
	;
	result = qSinkSpeexIsDebugRecording(handle);
	if (result != 0) {
		result = interpreterProxy->trueObject();
	}
	else {
		result = interpreterProxy->falseObject();
	}
	return interpreterProxy->popthenPush(2, result);
}


/*	Direct access to Speex jitter_buffer_ctl() function. Also answers an
	integer for the 'getter' commands. */
/*	arguments: name(type, stack offset)
	handle(integer, 2)
	ctlType(integer, 1)
	ctlValue(integer, 0)
	 */

EXPORT(sqInt)
primitiveSinkJitterbufferCtlSpeex(void) {
    sqInt ctlType;
    sqInt ctlValue;
    unsigned handle;
    sqInt result;

	if (!(validateArgCount(3))) {
		return null;
	}
	handle = interpreterProxy->positive32BitValueOf(interpreterProxy->stackValue(2));
	ctlType = interpreterProxy->stackIntegerValue(1);
	ctlValue = interpreterProxy->stackIntegerValue(0);
	;
	;
	;
	if (interpreterProxy->failed()) {
		return null;
	}
	result = qSinkJitterbufferCtlSpeex(handle, ctlType, ctlValue);
	interpreterProxy->pop(4);
	return interpreterProxy->pushInteger(result);
}


/*	arguments: name(type, stack offset)
	handle(integer, 1)
	soundBuffer(SoundBuffer, 0) */

EXPORT(sqInt)
primitiveSinkPlayDebugAudioDirectlyViaOpenAL(void) {
    int byteSize;
    void *bytes;
    unsigned handle;
    sqInt result;
    sqInt soundBuffer;

	if (!(validateArgCount(2))) {
		return null;
	}

	/* Get the size of the soundBuffer, and a pointer to it's data. */

	handle = interpreterProxy->positive32BitValueOf(interpreterProxy->stackValue(1));
	soundBuffer = interpreterProxy->stackObjectValue(0);
	interpreterProxy->success(interpreterProxy->isWords(soundBuffer));
	if (interpreterProxy->failed()) {
		return interpreterProxy->primitiveFailFor(3);
	}
	bytes = interpreterProxy->firstIndexableField(soundBuffer);
	byteSize = interpreterProxy->slotSizeOf(soundBuffer);
	byteSize = byteSize * 2;
	if (interpreterProxy->failed()) {
		return null;
	}
	;
	;
	result = qSinkPlayDebugAudioDirectlyViaOpenAL(handle, bytes, byteSize);
	if (!(result == 0)) {
		return interpreterProxy->primitiveFailFor(result);
	}
	return interpreterProxy->pop(2);
}


/*	arguments: name(type, stack offset)
	handle(integer, 1)
	encodedBytes(ByteArray, 0) */

EXPORT(sqInt)
primitiveSinkPushEncodedSpeex(void) {
    void *bytePtr;
    int byteSize;
    sqInt bytes;
    unsigned handle;

	if (!(validateArgCount(2))) {
		return null;
	}

	/* Get the size of the encoded bytes, and a pointer to it's data. */

	handle = interpreterProxy->positive32BitValueOf(interpreterProxy->stackValue(1));
	bytes = interpreterProxy->stackObjectValue(0);
	interpreterProxy->success(interpreterProxy->isBytes(bytes));
	if (interpreterProxy->failed()) {
		return null;
	}
	bytePtr = interpreterProxy->firstIndexableField(bytes);
	byteSize = interpreterProxy->slotSizeOf(bytes);
	if (interpreterProxy->failed()) {
		return null;
	}
	;
	;
	;
	qSinkPushEncodedSpeex(handle, bytePtr, byteSize, -1);
	return interpreterProxy->pop(2);
}


/*	arguments: name(type, stack offset)
	handle(integer, 2)
	encodedBytes(ByteArray, 1)
	timestamp(integer, 0) */

EXPORT(sqInt)
primitiveSinkPushEncodedSpeexWithTimestamp(void) {
    void *bytePtr;
    int byteSize;
    sqInt bytes;
    unsigned handle;
    int timestamp;

	if (!(validateArgCount(3))) {
		return null;
	}

	/* Get the size of the encoded bytes, and a pointer to it's data. */

	handle = interpreterProxy->positive32BitValueOf(interpreterProxy->stackValue(2));
	bytes = interpreterProxy->stackObjectValue(1);
	interpreterProxy->success(interpreterProxy->isBytes(bytes));
	if (interpreterProxy->failed()) {
		return null;
	}
	bytePtr = interpreterProxy->firstIndexableField(bytes);

	/* Get the timestamp. */

	byteSize = interpreterProxy->slotSizeOf(bytes);
	timestamp = interpreterProxy->stackIntegerValue(0);
	if (interpreterProxy->failed()) {
		return null;
	}
	;
	;
	;
	;
	qSinkPushEncodedSpeex(handle, bytePtr, byteSize, timestamp);
	return interpreterProxy->pop(3);
}

EXPORT(sqInt)
primitiveSinkPushRawAudio(void) {
    sqInt bufferOop;
    void*bufferPtr;
    unsigned handle;
    sqInt result;
    sqInt sampleCount;

	if (!(validateArgCount(2))) {
		return null;
	}
	handle = interpreterProxy->positive32BitValueOf(interpreterProxy->stackValue(1));
	bufferOop = interpreterProxy->stackObjectValue(0);
	interpreterProxy->success(interpreterProxy->isWords(bufferOop));
	if (interpreterProxy->failed()) {
		return null;
	}
	bufferPtr = interpreterProxy->firstIndexableField(bufferOop);

	/* number of 16-bit samples */

	sampleCount = ((sqInt) (interpreterProxy->byteSizeOf(bufferOop)) >> 1);
	if (interpreterProxy->failed()) {
		return interpreterProxy->primitiveFailFor(3);
	}
	;
	;
	;
	result = qSinkPushRawAudio(handle, (short*)bufferPtr, sampleCount);
	if (!(result == 0)) {
		return interpreterProxy->primitiveFailFor(result);
	}
	interpreterProxy->pop(2);
	return null;
}


/*	arguments: name(type, stack offset)
	sinkHandle(integer, 1)
	sourceHandle(integer,0) */

EXPORT(sqInt)
primitiveSinkRemoveSource(void) {
    sqInt result;
    unsigned sinkHandle;
    unsigned sourceHandle;

	if (!(validateArgCount(2))) {
		return null;
	}
	sinkHandle = interpreterProxy->positive32BitValueOf(interpreterProxy->stackValue(1));
	sourceHandle = interpreterProxy->positive32BitValueOf(interpreterProxy->stackValue(0));
	;
	;
	if (interpreterProxy->failed()) {
		return interpreterProxy->primitiveFailFor(3);
	}
	result = qSinkRemoveSource(sinkHandle, sourceHandle);
	if (!(result == 0)) {
		return interpreterProxy->primitiveFailFor(result);
	}
	return interpreterProxy->pop(2);
}


/*	arguments: name(type, stack offset)
	handle(integer, 0) */

EXPORT(sqInt)
primitiveSinkResetJitterbufferTimestamps(void) {
    unsigned handle;

	if (!(validateArgCount(1))) {
		return null;
	}
	handle = interpreterProxy->positive32BitValueOf(interpreterProxy->stackValue(0));
	if (interpreterProxy->failed()) {
		return null;
	}
	;
	qSinkResetJitterbufferTimestamps(handle);
	return interpreterProxy->pop(1);
}

EXPORT(sqInt)
primitiveSinkSetBufferedFrameCount(void) {
    unsigned frameCount;
    unsigned handle;
    sqInt result;

	if (!(validateArgCount(2))) {
		return null;
	}
	handle = interpreterProxy->positive32BitValueOf(interpreterProxy->stackValue(1));
	frameCount = interpreterProxy->positive32BitValueOf(interpreterProxy->stackValue(0));
	if (interpreterProxy->failed()) {
		return interpreterProxy->primitiveFailFor(3);
	}
	;
	;
	result = qSinkSetBufferedFrameCount(handle, frameCount);
	if (!(result == 0)) {
		return interpreterProxy->primitiveFailFor(result);
	}
	interpreterProxy->pop(2);
	return null;
}


/*	arguments: name(type, stack offset)
	handle(integer, 1)
	gain(double, 0) */

EXPORT(sqInt)
primitiveSinkSetGainOpenAL(void) {
    double gain;
    unsigned handle;
    sqInt result;

	if (!(validateArgCount(2))) {
		return null;
	}
	handle = interpreterProxy->positive32BitValueOf(interpreterProxy->stackValue(1));
	gain = interpreterProxy->floatValueOf(interpreterProxy->stackValue(0));
	;
	;
	if (interpreterProxy->failed()) {
		return interpreterProxy->primitiveFailFor(3);
	}
	result = qSinkSetGainOpenAL(handle, gain);
	if (!(result == 0)) {
		return interpreterProxy->primitiveFailFor(result);
	}
	return interpreterProxy->pop(2);
}


/*	Rather than provide separate primitives for reference distance, maximum
	distance, rolloff factor, cone inner/outer angles and cone outer gain, I
	put them all in this one primitive. Why? Lazy. */
/*	arguments: name(type, stack offset)
	handle(integer, 6)
	refDist(double, 5)
	maxDist(double, 4)
	rolloff(double, 3)
	innerAngle(double, 2)
	outerAngle(double, 1)
	outerGain(double, 0) */

EXPORT(sqInt)
primitiveSinkSetInitialPropertiesOpenAL(void) {
    unsigned handle;
    double innerAngle;
    double maxDist;
    double outerAngle;
    double outerGain;
    double refDist;
    sqInt result;
    double rolloff;

	if (!(validateArgCount(7))) {
		return null;
	}
	handle = interpreterProxy->positive32BitValueOf(interpreterProxy->stackValue(6));
	refDist = interpreterProxy->floatValueOf(interpreterProxy->stackValue(5));
	maxDist = interpreterProxy->floatValueOf(interpreterProxy->stackValue(4));
	rolloff = interpreterProxy->floatValueOf(interpreterProxy->stackValue(3));
	innerAngle = interpreterProxy->floatValueOf(interpreterProxy->stackValue(2));
	outerAngle = interpreterProxy->floatValueOf(interpreterProxy->stackValue(1));
	outerGain = interpreterProxy->floatValueOf(interpreterProxy->stackValue(0));
	;
	;
	;
	;
	;
	;
	;
	if (interpreterProxy->failed()) {
		return interpreterProxy->primitiveFailFor(3);
	}
	result = qSinkSetInitialPropertiesOpenAL(handle, refDist, maxDist, rolloff, innerAngle, outerAngle, outerGain);
	if (!(result == 0)) {
		return interpreterProxy->primitiveFailFor(result);
	}
	return interpreterProxy->pop(7);
}

EXPORT(sqInt)
primitiveSinkSetInputSamplingRate(void) {
    unsigned handle;
    unsigned rate;
    sqInt result;

	if (!(validateArgCount(2))) {
		return null;
	}
	handle = interpreterProxy->positive32BitValueOf(interpreterProxy->stackValue(1));
	rate = interpreterProxy->positive32BitValueOf(interpreterProxy->stackValue(0));
	if (interpreterProxy->failed()) {
		return interpreterProxy->primitiveFailFor(3);
	}
	;
	;
	result = qSinkSetInputSamplingRate(handle, rate);
	if (!(result == 0)) {
		return interpreterProxy->primitiveFailFor(result);
	}
	interpreterProxy->pop(2);
	return null;
}

EXPORT(sqInt)
primitiveSinkSetOutputSamplingRate(void) {
    unsigned handle;
    unsigned rate;
    sqInt result;

	if (!(validateArgCount(2))) {
		return null;
	}
	handle = interpreterProxy->positive32BitValueOf(interpreterProxy->stackValue(1));
	rate = interpreterProxy->positive32BitValueOf(interpreterProxy->stackValue(0));
	if (interpreterProxy->failed()) {
		return interpreterProxy->primitiveFailFor(3);
	}
	;
	;
	result = qSinkSetOutputSamplingRate(handle, rate);
	if (!(result == 0)) {
		return interpreterProxy->primitiveFailFor(result);
	}
	interpreterProxy->pop(2);
	return null;
}


/*	arguments: name(type, stack offset)
	handle(integer, 6)
	posX(double, 5)
	posY(double, 4)
	posZ(double, 3)
	dirX(double, 2)
	dirY(double, 1)
	dirZ(double, 0) */

EXPORT(sqInt)
primitiveSinkSetTransformOpenAL(void) {
    double dirX;
    double dirY;
    double dirZ;
    unsigned handle;
    double posX;
    double posY;
    double posZ;
    sqInt result;

	if (!(validateArgCount(7))) {
		return null;
	}
	handle = interpreterProxy->positive32BitValueOf(interpreterProxy->stackValue(6));
	posX = interpreterProxy->floatValueOf(interpreterProxy->stackValue(5));
	posY = interpreterProxy->floatValueOf(interpreterProxy->stackValue(4));
	posZ = interpreterProxy->floatValueOf(interpreterProxy->stackValue(3));
	dirX = interpreterProxy->floatValueOf(interpreterProxy->stackValue(2));
	dirY = interpreterProxy->floatValueOf(interpreterProxy->stackValue(1));
	dirZ = interpreterProxy->floatValueOf(interpreterProxy->stackValue(0));
	;
	;
	;
	;
	;
	;
	;
	if (interpreterProxy->failed()) {
		return interpreterProxy->primitiveFailFor(3);
	}
	result = qSinkSetTransformOpenAL(handle, posX, posY, posZ, dirX, dirY, dirZ);
	if (!(result == 0)) {
		return interpreterProxy->primitiveFailFor(result);
	}
	return interpreterProxy->pop(7);
}


/*	arguments: name(type, stack offset)
	handle(integer, 1)
	filePath(String, 0) */

EXPORT(sqInt)
primitiveSinkStartSpeexDebugRecording(void) {
    char*filePath;
    unsigned handle;

	if (!(validateArgCount(2))) {
		return null;
	}
	handle = interpreterProxy->positive32BitValueOf(interpreterProxy->stackValue(1));
	if (interpreterProxy->failed()) {
		return null;
	}
	;
	filePath = stackStringValue(0);
	if (interpreterProxy->failed()) {
		free(filePath);
		return null;
	}
	qSinkSpeexStartDebugRecording(handle, filePath);
	free(filePath);
	return interpreterProxy->pop(2);
}


/*	arguments: name(type, stack offset)
	handle(integer, 0) */

EXPORT(sqInt)
primitiveSinkStopSpeexDebugRecording(void) {
    unsigned handle;

	if (!(validateArgCount(1))) {
		return null;
	}
	handle = interpreterProxy->positive32BitValueOf(interpreterProxy->stackValue(0));
	if (interpreterProxy->failed()) {
		return null;
	}
	;
	qSinkSpeexStopDebugRecording(handle);
	return interpreterProxy->pop(1);
}

EXPORT(sqInt)
primitiveSpeexCreateHandle(void) {
    sqInt handle;

	if (!((interpreterProxy->methodArgumentCount()) == 0)) {
		return interpreterProxy->primitiveFail();
	}
	handle = (sqInt) qSpeexCreateHandle();
	return interpreterProxy->popthenPush(1, interpreterProxy->positive32BitIntegerFor(handle));
}


/*	arguments: name(type, stack offset)
	handle(integer, 2)
	input(ByteArray, 1)
	output(SoundBuffer, 0) */

EXPORT(sqInt)
primitiveSpeexDecode(void) {
    sqInt buffer;
    void* bufferPtr;
    sqInt bufferSize;
    sqInt handle;
    sqInt input;
    void* inputPtr;
    sqInt inputSize;
    sqInt result;

	if (!((interpreterProxy->methodArgumentCount()) == 3)) {
		return interpreterProxy->primitiveFail();
	}
	handle = interpreterProxy->positive32BitValueOf(interpreterProxy->stackValue(2));
	if (interpreterProxy->failed()) {
		return null;
	}
	buffer = interpreterProxy->stackObjectValue(0);
	interpreterProxy->success(interpreterProxy->isWords(buffer));
	if (interpreterProxy->failed()) {
		return null;
	}
	bufferPtr = interpreterProxy->firstIndexableField(buffer);
	bufferSize = interpreterProxy->slotSizeOf(buffer);

	/* contains 16-bit samples */
	/* Get a pointer to the encoded sound data. */

	bufferSize = bufferSize * 2;
	input = interpreterProxy->stackObjectValue(1);
	if (input == (interpreterProxy->nilObject())) {
		inputPtr = 0;
		inputSize = 0;
	}
	else {
		interpreterProxy->success(interpreterProxy->isBytes(input));
		if (interpreterProxy->failed()) {
			return null;
		}
		inputPtr = interpreterProxy->firstIndexableField(input);
		inputSize = interpreterProxy->slotSizeOf(input);
	}
	;
	;
	;
	;
	result = qSpeexDecode((QSpeexCodecPtr)handle, inputPtr, inputSize, bufferPtr, bufferSize);
	return interpreterProxy->popthenPush(4, interpreterProxy->positive32BitIntegerFor(result));
}


/*	arguments: name(type, stack offset)
	handle(integer, 2)
	input(ByteArray, 1)
	output(SoundBuffer, 0) */

EXPORT(sqInt)
primitiveSpeexDecodeToTestJB(void) {
    sqInt buffer;
    void* bufferPtr;
    sqInt bufferSize;
    sqInt handle;
    sqInt input;
    void* inputPtr;
    sqInt inputSize;
    sqInt result;

	if (!((interpreterProxy->methodArgumentCount()) == 3)) {
		return interpreterProxy->primitiveFail();
	}
	handle = interpreterProxy->positive32BitValueOf(interpreterProxy->stackValue(2));
	if (interpreterProxy->failed()) {
		return null;
	}
	buffer = interpreterProxy->stackObjectValue(0);
	interpreterProxy->success(interpreterProxy->isWords(buffer));
	if (interpreterProxy->failed()) {
		return null;
	}
	bufferPtr = interpreterProxy->firstIndexableField(buffer);
	bufferSize = interpreterProxy->slotSizeOf(buffer);

	/* contains 16-bit samples */
	/* Get a pointer to the encoded sound data. */

	bufferSize = bufferSize * 2;
	input = interpreterProxy->stackObjectValue(1);
	interpreterProxy->success(interpreterProxy->isBytes(input));
	if (interpreterProxy->failed()) {
		return null;
	}
	inputPtr = interpreterProxy->firstIndexableField(input);

	/* Make the compiler happy. */

	inputSize = interpreterProxy->slotSizeOf(input);
	;
	;
	;
	;
	result = qSpeexDecodeToTestJB((QSpeexCodecPtr)handle, inputPtr, inputSize, bufferPtr, bufferSize);
	return interpreterProxy->popthenPush(4, interpreterProxy->positive32BitIntegerFor(result));
}

EXPORT(sqInt)
primitiveSpeexDestroyHandle(void) {
    sqInt handle;

	if (!((interpreterProxy->methodArgumentCount()) == 1)) {
		return interpreterProxy->primitiveFail();
	}
	handle = interpreterProxy->positive32BitValueOf(interpreterProxy->stackValue(0));
	if (interpreterProxy->failed()) {
		return null;
	}
	;
	qSpeexDestroyHandle((QSpeexCodecPtr)handle);
	return interpreterProxy->pop(1);
}


/*	arguments: name(type, stack offset)
	handle(integer, 1)
	buffer(SoundBuffer, 0) */

EXPORT(sqInt)
primitiveSpeexEncode(void) {
    sqInt buffer;
    void* bufferPtr;
    sqInt bufferSize;
    void* bytePtr;
    sqInt byteSize;
    sqInt bytes;
    sqInt handle;

	if (!((interpreterProxy->methodArgumentCount()) == 2)) {
		return interpreterProxy->primitiveFail();
	}
	handle = interpreterProxy->positive32BitValueOf(interpreterProxy->stackValue(1));
	if (interpreterProxy->failed()) {
		return null;
	}
	buffer = interpreterProxy->stackObjectValue(0);
	interpreterProxy->success(interpreterProxy->isWords(buffer));
	if (interpreterProxy->failed()) {
		return null;
	}
	bufferPtr = interpreterProxy->firstIndexableField(buffer);
	bufferSize = interpreterProxy->slotSizeOf(buffer);

	/* contains 16-bit samples */
	/* Encode the buffer, but don't yet read it into our memory.  Instead, figure out how much space is required for the result (using speex_bits_nbytes())... we'll use this to allocate a ByteArray of the appropriate size.  After this, we're done with the buffer, so we don't care if it's relocated while allocating the ByteArray. */

	bufferSize = bufferSize * 2;
	byteSize = qSpeexEncode((QSpeexCodecPtr)handle, bufferPtr, bufferSize);
	bytes = interpreterProxy->instantiateClassindexableSize(interpreterProxy->classByteArray(), byteSize);
	bytePtr = interpreterProxy->firstIndexableField(bytes);
	if (interpreterProxy->failed()) {
		return null;
	}
	qSpeexEncodeRead((QSpeexCodecPtr)handle, bytePtr, byteSize);
	;
	;
	;
	return interpreterProxy->popthenPush(3, bytes);
}

EXPORT(sqInt)
primitiveTestBufferSize(void) {
    sqInt buffer;
    sqInt bufferSize;

	if (!((interpreterProxy->methodArgumentCount()) == 1)) {
		return interpreterProxy->primitiveFail();
	}
	buffer = interpreterProxy->stackObjectValue(0);
	interpreterProxy->success(interpreterProxy->isWords(buffer));
	if (interpreterProxy->failed()) {
		return null;
	}
	bufferSize = interpreterProxy->slotSizeOf(buffer);
	return interpreterProxy->popthenPush(2, interpreterProxy->positive32BitIntegerFor(bufferSize));
}

EXPORT(sqInt)
primitiveTickerSetInterval(void) {
    sqInt interval;

	if (!((interpreterProxy->methodArgumentCount()) == 1)) {
		return interpreterProxy->primitiveFail();
	}
	interval = interpreterProxy->positive32BitValueOf(interpreterProxy->stackValue(0));
	;
	if (interpreterProxy->failed()) {
		return null;
	}
	qTickerSetInterval((unsigned)interval);
	return interpreterProxy->pop(1);
}


/*	Setting verbosity to 0 turns off all messages, setting it to 9 turns them
	all on. Setting it somewhere in between does something in between :-). */

EXPORT(sqInt)
primitiveTickerSetVerbosity(void) {
    sqInt verbosity;

	if (!((interpreterProxy->methodArgumentCount()) == 1)) {
		return interpreterProxy->primitiveFail();
	}
	verbosity = interpreterProxy->positive32BitValueOf(interpreterProxy->stackValue(0));
	;
	if (interpreterProxy->failed()) {
		return null;
	}
	qTickerSetVerbosity((unsigned)verbosity);
	return interpreterProxy->pop(1);
}

EXPORT(sqInt)
primitiveTickerStart(void) {
	if (!((interpreterProxy->methodArgumentCount()) == 0)) {
		return interpreterProxy->primitiveFail();
	}
	qTickerStart();
	return 0;
}

EXPORT(sqInt)
primitiveTickerStop(void) {
	if (!((interpreterProxy->methodArgumentCount()) == 0)) {
		return interpreterProxy->primitiveFail();
	}
	qTickerStop();
	return 0;
}

EXPORT(sqInt)
primitiveTickerTickNow(void) {
	if (!((interpreterProxy->methodArgumentCount()) == 0)) {
		return interpreterProxy->primitiveFail();
	}
	qTickerTickNow();
	return 0;
}


/*	Note: This is coded so that is can be run from Squeak. */

EXPORT(sqInt)
setInterpreter(struct VirtualMachine*anInterpreter) {
    sqInt ok;

	interpreterProxy = anInterpreter;
	ok = interpreterProxy->majorVersion() == VM_PROXY_MAJOR;
	if (ok == 0) {
		return 0;
	}
	ok = interpreterProxy->minorVersion() >= VM_PROXY_MINOR;
	return ok;
}

EXPORT(sqInt)
shutdownModule(void) {
	return qShutdownModule();
}

static sqInt
stackBooleanValue(sqInt index) {
	return interpreterProxy->booleanValueOf(interpreterProxy->stackValue(index));
}


/*	The stack object at 'index' should be an ExternalAddress; this function
	answers a pointer to the actual address (skip the object header).
 */

static void*
stackPointerPointer(sqInt index) {
    sqInt obj;
    void* ptr;

	obj = interpreterProxy->stackObjectValue(index);
	interpreterProxy->success(interpreterProxy->isBytes(obj));
	ptr = interpreterProxy->firstIndexableField(obj);
	interpreterProxy->success(interpreterProxy->slotSizeOf(obj) == sizeof(char*));
	if (interpreterProxy->failed()) {
		return null;
	}
	else {
		return ptr;
	}
}

static void *
stackStringValue(sqInt index) {
    char*dstPtr;
    sqInt i;
    sqInt obj;
    char*srcPtr;
    sqInt sz;

	obj = interpreterProxy->stackValue(index);
	if (!(interpreterProxy->isBytes(obj))) {
		interpreterProxy->primitiveFail();
		return null;
	}
	sz = interpreterProxy->byteSizeOf(obj);
	dstPtr = malloc(sz + 1);
	srcPtr = interpreterProxy->firstIndexableField(obj);
	for (i = 0; i <= (sz - 1); i += 1) {
		dstPtr[i] = (srcPtr[i]);
	}
	dstPtr[sz] = 0;
	return dstPtr;
}

static sqInt
validateArgCount(sqInt expectedArgCount) {
    sqInt ok;

	ok = (interpreterProxy->methodArgumentCount()) == expectedArgCount;
	if (!(ok)) {
		interpreterProxy->primitiveFailFor(2);
	}
	return ok;
}


#ifdef SQUEAK_BUILTIN_PLUGIN

void* QAudioPlugin_exports[][3] = {
	{"QAudioPlugin", "getModuleName", (void*)getModuleName},
	{"QAudioPlugin", "initialiseModule", (void*)initialiseModule},
	{"QAudioPlugin", "primitiveAudioAsyncEncode", (void*)primitiveAudioAsyncEncode},
	{"QAudioPlugin", "primitiveAudioDecode", (void*)primitiveAudioDecode},
	{"QAudioPlugin", "primitiveCreateAudioDecoder", (void*)primitiveCreateAudioDecoder},
	{"QAudioPlugin", "primitiveCreateAudioEncoder", (void*)primitiveCreateAudioEncoder},
	{"QAudioPlugin", "primitiveCreateFeedbackChannel", (void*)primitiveCreateFeedbackChannel},
	{"QAudioPlugin", "primitiveCreatePhoneUser", (void*)primitiveCreatePhoneUser},
	{"QAudioPlugin", "primitiveCreateSinkBufferedResampler", (void*)primitiveCreateSinkBufferedResampler},
	{"QAudioPlugin", "primitiveCreateSinkForDebugFeedback", (void*)primitiveCreateSinkForDebugFeedback},
	{"QAudioPlugin", "primitiveCreateSinkMixer", (void*)primitiveCreateSinkMixer},
	{"QAudioPlugin", "primitiveCreateSinkOpenAL", (void*)primitiveCreateSinkOpenAL},
	{"QAudioPlugin", "primitiveCreateSinkPOTS", (void*)primitiveCreateSinkPOTS},
	{"QAudioPlugin", "primitiveCreateSinkPortAudio", (void*)primitiveCreateSinkPortAudio},
	{"QAudioPlugin", "primitiveCreateSinkSpeex", (void*)primitiveCreateSinkSpeex},
	{"QAudioPlugin", "primitiveDestroyAudioDecoder", (void*)primitiveDestroyAudioDecoder},
	{"QAudioPlugin", "primitiveDestroyAudioEncoder", (void*)primitiveDestroyAudioEncoder},
	{"QAudioPlugin", "primitiveDestroyFeedbackChannel", (void*)primitiveDestroyFeedbackChannel},
	{"QAudioPlugin", "primitiveDestroyPhoneInterfaceIAX", (void*)primitiveDestroyPhoneInterfaceIAX},
	{"QAudioPlugin", "primitiveDestroySink", (void*)primitiveDestroySink},
	{"QAudioPlugin", "primitiveFeedbackChannelPopEvent", (void*)primitiveFeedbackChannelPopEvent},
	{"QAudioPlugin", "primitiveFeedbackChannelReadEvent", (void*)primitiveFeedbackChannelReadEvent},
	{"QAudioPlugin", "primitiveFeedbackChannelSetLogging", (void*)primitiveFeedbackChannelSetLogging},
	{"QAudioPlugin", "primitiveGenerateTestPhoneEvents", (void*)primitiveGenerateTestPhoneEvents},
	{"QAudioPlugin", "primitiveGetLogVerbosity", (void*)primitiveGetLogVerbosity},
	{"QAudioPlugin", "primitiveHackPushGSM", (void*)primitiveHackPushGSM},
	{"QAudioPlugin", "primitiveIaxcAnswerCall", (void*)primitiveIaxcAnswerCall},
	{"QAudioPlugin", "primitiveIaxcCall", (void*)primitiveIaxcCall},
	{"QAudioPlugin", "primitiveIaxcHangupCall", (void*)primitiveIaxcHangupCall},
	{"QAudioPlugin", "primitiveIaxcInit", (void*)primitiveIaxcInit},
	{"QAudioPlugin", "primitiveIaxcQuelchCall", (void*)primitiveIaxcQuelchCall},
	{"QAudioPlugin", "primitiveIaxcRejectCall", (void*)primitiveIaxcRejectCall},
	{"QAudioPlugin", "primitiveIaxcSelectCall", (void*)primitiveIaxcSelectCall},
	{"QAudioPlugin", "primitiveIaxcSendBusyForCall", (void*)primitiveIaxcSendBusyForCall},
	{"QAudioPlugin", "primitiveIaxcShutdown", (void*)primitiveIaxcShutdown},
	{"QAudioPlugin", "primitiveIaxcUnquelchCall", (void*)primitiveIaxcUnquelchCall},
	{"QAudioPlugin", "primitiveLogMsg", (void*)primitiveLogMsg},
	{"QAudioPlugin", "primitiveOalCreateContext", (void*)primitiveOalCreateContext},
	{"QAudioPlugin", "primitiveOalDestroyContext", (void*)primitiveOalDestroyContext},
	{"QAudioPlugin", "primitiveOalGetPluginError", (void*)primitiveOalGetPluginError},
	{"QAudioPlugin", "primitiveOalSetAudioDevice", (void*)primitiveOalSetAudioDevice},
	{"QAudioPlugin", "primitivePortAudioPrintDeviceInfo", (void*)primitivePortAudioPrintDeviceInfo},
	{"QAudioPlugin", "primitivePortAudioResetDevice", (void*)primitivePortAudioResetDevice},
	{"QAudioPlugin", "primitiveSetLogFile", (void*)primitiveSetLogFile},
	{"QAudioPlugin", "primitiveSetLogVerbosity", (void*)primitiveSetLogVerbosity},
	{"QAudioPlugin", "primitiveSinkAddSource", (void*)primitiveSinkAddSource},
	{"QAudioPlugin", "primitiveSinkControl", (void*)primitiveSinkControl},
	{"QAudioPlugin", "primitiveSinkGetEventTimings", (void*)primitiveSinkGetEventTimings},
	{"QAudioPlugin", "primitiveSinkGetJitterbufferStats", (void*)primitiveSinkGetJitterbufferStats},
	{"QAudioPlugin", "primitiveSinkIsSpeexDebugRecording", (void*)primitiveSinkIsSpeexDebugRecording},
	{"QAudioPlugin", "primitiveSinkJitterbufferCtlSpeex", (void*)primitiveSinkJitterbufferCtlSpeex},
	{"QAudioPlugin", "primitiveSinkPlayDebugAudioDirectlyViaOpenAL", (void*)primitiveSinkPlayDebugAudioDirectlyViaOpenAL},
	{"QAudioPlugin", "primitiveSinkPushEncodedSpeex", (void*)primitiveSinkPushEncodedSpeex},
	{"QAudioPlugin", "primitiveSinkPushEncodedSpeexWithTimestamp", (void*)primitiveSinkPushEncodedSpeexWithTimestamp},
	{"QAudioPlugin", "primitiveSinkPushRawAudio", (void*)primitiveSinkPushRawAudio},
	{"QAudioPlugin", "primitiveSinkRemoveSource", (void*)primitiveSinkRemoveSource},
	{"QAudioPlugin", "primitiveSinkResetJitterbufferTimestamps", (void*)primitiveSinkResetJitterbufferTimestamps},
	{"QAudioPlugin", "primitiveSinkSetBufferedFrameCount", (void*)primitiveSinkSetBufferedFrameCount},
	{"QAudioPlugin", "primitiveSinkSetGainOpenAL", (void*)primitiveSinkSetGainOpenAL},
	{"QAudioPlugin", "primitiveSinkSetInitialPropertiesOpenAL", (void*)primitiveSinkSetInitialPropertiesOpenAL},
	{"QAudioPlugin", "primitiveSinkSetInputSamplingRate", (void*)primitiveSinkSetInputSamplingRate},
	{"QAudioPlugin", "primitiveSinkSetOutputSamplingRate", (void*)primitiveSinkSetOutputSamplingRate},
	{"QAudioPlugin", "primitiveSinkSetTransformOpenAL", (void*)primitiveSinkSetTransformOpenAL},
	{"QAudioPlugin", "primitiveSinkStartSpeexDebugRecording", (void*)primitiveSinkStartSpeexDebugRecording},
	{"QAudioPlugin", "primitiveSinkStopSpeexDebugRecording", (void*)primitiveSinkStopSpeexDebugRecording},
	{"QAudioPlugin", "primitiveSpeexCreateHandle", (void*)primitiveSpeexCreateHandle},
	{"QAudioPlugin", "primitiveSpeexDecode", (void*)primitiveSpeexDecode},
	{"QAudioPlugin", "primitiveSpeexDecodeToTestJB", (void*)primitiveSpeexDecodeToTestJB},
	{"QAudioPlugin", "primitiveSpeexDestroyHandle", (void*)primitiveSpeexDestroyHandle},
	{"QAudioPlugin", "primitiveSpeexEncode", (void*)primitiveSpeexEncode},
	{"QAudioPlugin", "primitiveTestBufferSize", (void*)primitiveTestBufferSize},
	{"QAudioPlugin", "primitiveTickerSetInterval", (void*)primitiveTickerSetInterval},
	{"QAudioPlugin", "primitiveTickerSetVerbosity", (void*)primitiveTickerSetVerbosity},
	{"QAudioPlugin", "primitiveTickerStart", (void*)primitiveTickerStart},
	{"QAudioPlugin", "primitiveTickerStop", (void*)primitiveTickerStop},
	{"QAudioPlugin", "primitiveTickerTickNow", (void*)primitiveTickerTickNow},
	{"QAudioPlugin", "setInterpreter", (void*)setInterpreter},
	{"QAudioPlugin", "shutdownModule", (void*)shutdownModule},
	{NULL, NULL, NULL}
};

#endif /* ifdef SQ_BUILTIN_PLUGIN */
