/* Automatically generated by
	VMPluginCodeGenerator VMMaker-eem.715 uuid: 707ba1f8-c822-4204-82b6-1c7e7af64117
   from
	IA32ABIPlugin VMMaker-eem.715 uuid: 707ba1f8-c822-4204-82b6-1c7e7af64117
 */
static char __buildInfo[] = "IA32ABIPlugin VMMaker-eem.715 uuid: 707ba1f8-c822-4204-82b6-1c7e7af64117 " __DATE__ ;



#include <math.h>
#include <stdio.h>
#include <stdlib.h>
#include <string.h>
#include <time.h>
#include <setjmp.h>

/* Default EXPORT macro that does nothing (see comment in sq.h): */
#define EXPORT(returnType) returnType

/* Do not include the entire sq.h file but just those parts needed. */
/*  The virtual machine proxy definition */
#include "sqVirtualMachine.h"
/* Configuration options */
#include "sqConfig.h"
/* Platform specific definitions */
#include "sqPlatformSpecific.h"

#define true 1
#define false 0
#define null 0  /* using 'null' because nil is predefined in Think C */
#ifdef SQUEAK_BUILTIN_PLUGIN
#undef EXPORT
// was #undef EXPORT(returnType) but screws NorCroft cc
#define EXPORT(returnType) static returnType
#endif

#include "vmCallback.h"
#include "ia32abi.h"
#include "sqMemoryAccess.h"

typedef struct {
	int	type;
	int	pad;
	union {
							long valword;
							struct { int low, high; } valleint64;
							struct { int high, low; } valbeint64;
							double valflt64;
							struct { void *addr; long size; } valstruct;
						}	crvrvs;
 } VMCallbackReturnValue;



/*** Constants ***/
#define BaseHeaderSize 4
#define BytesPerOop 4
#define PrimErrBadArgument 3
#define PrimErrBadIndex 4
#define PrimErrBadReceiver 2
#define PrimErrInappropriate 6
#define PrimErrNoCMemory 10
#define PrimErrNoMemory 9
#define PrimErrNotFound 11
#define PrimErrUnsupported 7


/*** Function Prototypes ***/
static VirtualMachine * getInterpreter(void);
EXPORT(const char*) getModuleName(void);
static sqInt halt(void);
static sqInt indexlengthinRange(sqInt byteIndex, sqInt length, sqInt rcvr);
EXPORT(sqInt) isAlien(sqInt anOop);
static sqInt msg(char *s);
EXPORT(sqInt) primAddressField(void);
EXPORT(sqInt) primAddressFieldPut(void);
EXPORT(sqInt) primAlienReplace(void);
EXPORT(sqInt) primAllocateExecutablePage(void);
EXPORT(sqInt) primBoxedFree(void);
EXPORT(sqInt) primCallOutDoubleReturn(void);
EXPORT(sqInt) primCallOutFloatReturn(void);
EXPORT(sqInt) primCallOutIntegralReturn(void);
EXPORT(sqInt) primCalloc(void);
EXPORT(sqInt) primDoubleAt(void);
EXPORT(sqInt) primDoubleAtPut(void);
EXPORT(sqInt) primFloatAt(void);
EXPORT(sqInt) primFloatAtPut(void);
EXPORT(sqInt) primFree(void);
EXPORT(sqInt) primInIOProcessEventsFlagAddress(void);
EXPORT(sqInt) primInLibraryFindSymbol(void);
EXPORT(sqInt) primLoadLibrary(void);
EXPORT(sqInt) primMalloc(void);
EXPORT(sqInt) primReturnAsFromContextThrough(void);
EXPORT(sqInt) primReturnFromContextThrough(void);
EXPORT(sqInt) primSignedByteAt(void);
EXPORT(sqInt) primSignedByteAtPut(void);
EXPORT(sqInt) primSignedLongAt(void);
EXPORT(sqInt) primSignedLongAtPut(void);
EXPORT(sqInt) primSignedLongLongAt(void);
EXPORT(sqInt) primSignedLongLongAtPut(void);
EXPORT(sqInt) primSignedShortAt(void);
EXPORT(sqInt) primSignedShortAtPut(void);
EXPORT(sqInt) primSizeField(void);
EXPORT(sqInt) primSizeFieldPut(void);
EXPORT(sqInt) primStrlenFromStartIndex(void);
EXPORT(sqInt) primStrlenThroughPointerAtIndex(void);
EXPORT(sqInt) primThunkEntryAddress(void);
EXPORT(sqInt) primUnsignedByteAt(void);
EXPORT(sqInt) primUnsignedByteAtPut(void);
EXPORT(sqInt) primUnsignedLongAt(void);
EXPORT(sqInt) primUnsignedLongAtPut(void);
EXPORT(sqInt) primUnsignedLongLongAt(void);
EXPORT(sqInt) primUnsignedLongLongAtPut(void);
EXPORT(sqInt) primUnsignedShortAt(void);
EXPORT(sqInt) primUnsignedShortAtPut(void);
EXPORT(sqInt) primVarArgsCallOutDoubleReturn(void);
EXPORT(sqInt) primVarArgsCallOutFloatReturn(void);
EXPORT(sqInt) primVarArgsCallOutIntegralReturn(void);
EXPORT(sqInt) setInterpreter(struct VirtualMachine*anInterpreter);
static sqInt sizeField(sqInt rcvr);
static sqInt startOfByteData(sqInt rcvr);
static sqInt startOfData(sqInt rcvr);
static sqInt startOfDatawithSize(sqInt rcvr, sqInt sizeField);


/*** Variables ***/

#ifdef SQUEAK_BUILTIN_PLUGIN
extern
#endif
struct VirtualMachine* interpreterProxy;
static const char *moduleName =
#ifdef SQUEAK_BUILTIN_PLUGIN
	"IA32ABI VMMaker-eem.715 (i)"
#else
	"IA32ABI VMMaker-eem.715 (e)"
#endif
;



/*	Note: This is coded so that plugins can be run from Squeak. */

static VirtualMachine *
getInterpreter(void)
{
	return interpreterProxy;
}


/*	Note: This is hardcoded so it can be run from Squeak.
	The module name is used for validating a module *after*
	it is loaded to check if it does really contain the module
	we're thinking it contains. This is important! */

EXPORT(const char*)
getModuleName(void)
{
	return moduleName;
}

static sqInt
halt(void)
{
	;
	return 0;
}


/*	Answer if the indices byteIndex to byteIndex + length - 1 are valid
	zero-relative indices into the rcvr.
	N.B. This code only works when translated because asUnisgnedInteger only
	works for non-negative
	values. Hence the override in IA32ABIPluginSimulator. */

static sqInt
indexlengthinRange(sqInt byteIndex, sqInt length, sqInt rcvr)
{
    sqInt dataSize;

	return (((dataSize = longAt(rcvr + BaseHeaderSize))) == 0)
	 || (((((usqInt)byteIndex)) + length) <= (abs(dataSize)));
}

EXPORT(sqInt)
isAlien(sqInt anOop)
{
	return interpreterProxy->includesBehaviorThatOf(interpreterProxy->fetchClassOf(anOop), interpreterProxy->classAlien());
}

static sqInt
msg(char *s)
{
	fprintf(stderr, "\n%s: %s", moduleName, s);
	return 0;
}


/*	Answer the unsigned 32-bit integer comprising the address field (the
	second 32-bit field).
 */
/*	<Alien> primAddressField ^<Integer>
	<primitive: 'primAddressField' error: errorCode module: 'IA32ABI'> */

EXPORT(sqInt)
primAddressField(void)
{
    sqInt rcvr;
    sqInt value;
    sqInt valueOop;

	rcvr = interpreterProxy->stackValue(0);
	value = longAt((rcvr + BaseHeaderSize) + BytesPerOop);
	valueOop = interpreterProxy->positive32BitIntegerFor(value);
	return interpreterProxy->popthenPush(1, valueOop);
}


/*	Store an unsigned integer into the size field (the second 32 bit field;
	little endian).
 */
/*	<Alien> addressFieldPut: value <Integer> ^<Integer>
	<primitive: 'primAddressFieldPut' error: errorCode module: 'IA32ABI'> */

EXPORT(sqInt)
primAddressFieldPut(void)
{
    sqInt rcvr;
    sqInt value;
    sqInt valueOop;

	valueOop = interpreterProxy->stackValue(0);
	rcvr = interpreterProxy->stackValue(1);
	value = interpreterProxy->positive32BitValueOf(valueOop);
	if (interpreterProxy->failed()) {
		return interpreterProxy->primitiveFailFor(PrimErrBadArgument);
	}
	longAtput((rcvr + BaseHeaderSize) + BytesPerOop, value);
	return interpreterProxy->popthenPush(2, valueOop);
}


/*	Copy some number of bytes from some source object starting at the index
	into the receiver destination object from startIndex to stopIndex . The
	source and destination may be Aliens or byte-indexable objects. The
	primitive wll have either
	of the following signatures:
	<Alien | indexableByteSubclass | indexableWordSubclass>
	primReplaceFrom: start <Integer>
	to: stop <Integer>
	with: replacement <Alien | indexableByteSubclass | indexableWordSubclass |
	Integer> startingAt: repStart <Integer> ^<self>
	<primitive: 'primitiveAlienReplace' error: errorCode module: 'IA32ABI'>
	<Anywhere>
	primReplaceIn: dest <Alien | indexableByteSubclass |
	indexableWordSubclass> from: start <Integer>
	to: stop <Integer>
	with: replacement <Alien | indexableByteSubclass | indexableWordSubclass |
	Integer> startingAt: repStart <Integer> ^<self>
	<primitive: 'primitiveAlienReplace' error: errorCode module: 'IA32ABI'>
	 */

EXPORT(sqInt)
primAlienReplace(void)
{
    sqInt array;
    sqInt count;
    sqInt dest;
    sqInt repl;
    sqInt replStart;
    sqInt src;
    sqInt start;
    sqInt stop;
    sqInt totalLength;

	array = interpreterProxy->stackValue(4);
	start = interpreterProxy->stackIntegerValue(3);
	stop = interpreterProxy->stackIntegerValue(2);
	repl = interpreterProxy->stackValue(1);
	replStart = interpreterProxy->stackIntegerValue(0);
	if ((interpreterProxy->failed())
	 || (!(interpreterProxy->isWordsOrBytes(array)))) {
		return interpreterProxy->primitiveFailFor(PrimErrBadArgument);
	}
	if (interpreterProxy->includesBehaviorThatOf(interpreterProxy->fetchClassOf(array), interpreterProxy->classAlien())) {
		totalLength = longAt(array + BaseHeaderSize);
		dest = (((totalLength > 0
	? (array + BaseHeaderSize) + BytesPerOop
	: longAt((array + BaseHeaderSize) + BytesPerOop))) + start) - 1;
		if (totalLength == 0) {

			/* no bounds checks for zero-sized (pointer) Aliens */

			totalLength = stop;
		}
		else {
			totalLength = abs(totalLength);
		}
	}
	else {
		totalLength = interpreterProxy->byteSizeOf(array);
		dest = ((array + BaseHeaderSize) + start) - 1;
	}
	if (!((start >= 1)
		 && (((start - 1) <= stop)
 && (stop <= totalLength)))) {
		return interpreterProxy->primitiveFailFor(PrimErrBadIndex);
	}
	if ((repl & 1)) {
		if (((repl >> 1)) <= 0) {
			return interpreterProxy->primitiveFailFor(PrimErrBadArgument);
		}
		src = (((repl >> 1)) + replStart) - 1;
	}
	else {
		if ((interpreterProxy->fetchClassOf(repl)) == (interpreterProxy->classLargePositiveInteger())) {
			src = ((interpreterProxy->positive32BitValueOf(repl)) + replStart) - 1;
			if (interpreterProxy->failed()) {
				return interpreterProxy->primitiveFailFor(PrimErrBadArgument);
			}
		}
		else {
			if (interpreterProxy->includesBehaviorThatOf(interpreterProxy->fetchClassOf(repl), interpreterProxy->classAlien())) {
				totalLength = longAt(repl + BaseHeaderSize);
				src = (((totalLength > 0
	? (repl + BaseHeaderSize) + BytesPerOop
	: longAt((repl + BaseHeaderSize) + BytesPerOop))) + replStart) - 1;
				if (totalLength == 0) {

					/* no bounds checks for zero-sized (pointer) Aliens */

					totalLength = (stop - start) + replStart;
				}
				else {
					totalLength = abs(totalLength);
				}
			}
			else {
				if (!(interpreterProxy->isWordsOrBytes(repl))) {
					return interpreterProxy->primitiveFailFor(PrimErrBadArgument);
				}
				totalLength = interpreterProxy->byteSizeOf(repl);
				src = ((repl + BaseHeaderSize) + replStart) - 1;
			}
			if (!((replStart >= 1)
				 && (((stop - start) + replStart) <= totalLength))) {
				return interpreterProxy->primitiveFailFor(PrimErrBadIndex);
			}
		}
	}
	count = (stop - start) + 1;
	memcpy((void *)dest,(void *)src,count);
	interpreterProxy->pop(interpreterProxy->methodArgumentCount());
}


/*	Answer an Alien for an executable page; for thunks */
/*	primAllocateExecutablePage ^<Alien>
	<primitive: 'primAllocateExecutablePage' error: errorCode module:
	'IA32ABI'> 
 */

EXPORT(sqInt)
primAllocateExecutablePage(void)
{
    sqInt alien;
    long byteSize;
    void *mem;
    long *ptr;

	mem = allocateExecutablePage(&byteSize);
	if (mem == 0) {
		return interpreterProxy->primitiveFailFor(PrimErrNoCMemory);
	}
	alien = interpreterProxy->instantiateClassindexableSize(interpreterProxy->classAlien(), 8);
	if (interpreterProxy->failed()) {
		return interpreterProxy->primitiveFailFor(PrimErrNoMemory);
	}
	ptr = interpreterProxy->firstIndexableField(alien);
	ptr[0] = (0 - byteSize);
	ptr[1] = (((long) mem));
	interpreterProxy->popthenPush(1, alien);
}


/*	Free the memory referenced by the receiver, an Alien. */
/*	proxy <Alien> primFree ^<Alien>
	<primitive: 'primBoxedFree' error: errorCode module: 'IA32ABI'> */

EXPORT(sqInt)
primBoxedFree(void)
{
    sqInt addr;
    sqInt *ptr;
    sqInt rcvr;
    long sizeField;

	rcvr = interpreterProxy->stackObjectValue(0);
	if (!(((interpreterProxy->byteSizeOf(rcvr)) >= 2) * BytesPerOop)) {
		return interpreterProxy->primitiveFailFor(PrimErrBadReceiver);
	}
	ptr = interpreterProxy->firstIndexableField(rcvr);
	sizeField = ptr[0];

	/* Don't you dare to free Squeak's memory! */

	addr = ptr[1];
	if ((sizeField >= 0)
	 || ((addr == 0)
 || (interpreterProxy->isInMemory(addr)))) {
		return interpreterProxy->primitiveFailFor(PrimErrInappropriate);
	}
	free((void *)addr);
	ptr[0] = 0;
	ptr[1] = 0;
}


/*	Call a foreign function that answers a double-precision floating-point
	result in %f0
	according to IA32-ish ABI rules. The primitive will have a signature of
	the form
	functionAddress <Alien> primFFICallResult: result <Alien|Object> with:
	firstArg <Alien | Integer> ... with: lastArg <Alien | Integer> ^<Alien>
	<primitive: 'primCallOutDoubleReturn' error: errorCode module: 'IA32ABI'>.
	Answer result. If result is an Alien the value answered by the call will
	be assigned to result.
 */

EXPORT(sqInt)
primCallOutDoubleReturn(void)
{
    sqInt errCode;
    sqInt mac;
    sqInt result;

	mac = interpreterProxy->methodArgumentCount();
	errCode = callIA32DoubleReturn(interpreterProxy->getStackPointer() - mac + 2, /* arg vec */
													mac - 1	/* nargs */,
													mac	/* funcOffset*/,
													mac - 1	/* resultOffset */);
	if (errCode != 0) {
		return interpreterProxy->primitiveFailFor(errCode);
	}
	result = interpreterProxy->stackValue(mac - 1);
	interpreterProxy->popthenPush(mac + 1, result);
}


/*	Call a foreign function that answers a single-precision floating-point
	result in %f0
	according to IA32-ish ABI rules. The primitive will have a signature of
	the form
	functionAddress <Alien> primFFICallResult: result <Alien|Object> with:
	firstArg <Alien | Integer> ... with: lastArg <Alien | Integer> ^<Alien>
	<primitive: 'primCallOutFloatReturn' error: errorCode module: 'IA32ABI'>.
	Answer result. If result is an Alien the value answered by the call will
	be assigned to result.
 */

EXPORT(sqInt)
primCallOutFloatReturn(void)
{
    sqInt errCode;
    sqInt mac;
    sqInt result;

	mac = interpreterProxy->methodArgumentCount();
	errCode = callIA32FloatReturn(interpreterProxy->getStackPointer() - mac + 2, /* arg vec */
												mac - 1	/* nargs */,
												mac	/* funcOffset*/,
												mac - 1	/* resultOffset */);
	if (errCode != 0) {
		return interpreterProxy->primitiveFailFor(errCode);
	}
	result = interpreterProxy->stackValue(mac - 1);
	interpreterProxy->popthenPush(mac + 1, result);
}


/*	Call a foreign function that answers an integral result in %eax (and
	possibly %edx)
	according to IA32-ish ABI rules. The primitive will have a signature of
	the form
	functionAddress <Alien> primFFICallResult: result <Alien|Object> with:
	firstArg <Alien | Integer> ... with: lastArg <Alien | Integer> ^<Alien>
	<primitive: 'primCallOutIntegralReturn' error: errorCode module:
	'IA32ABI'>. Answer result. If result is an Alien the value answered by the
	call will be assigned to result.
 */

EXPORT(sqInt)
primCallOutIntegralReturn(void)
{
    sqInt errCode;
    sqInt mac;
    sqInt result;

	mac = interpreterProxy->methodArgumentCount();
	errCode = callIA32IntegralReturn(interpreterProxy->getStackPointer() - mac + 2, /* arg vec */
													mac - 1	/* nargs */,
													mac	/* funcOffset*/,
													mac - 1	/* resultOffset */);
	if (errCode != 0) {
		return interpreterProxy->primitiveFailFor(errCode);
	}
	result = interpreterProxy->stackValue(mac - 1);
	interpreterProxy->popthenPush(mac + 1, result);
}


/*	calloc (malloc + zero-fill) arg bytes. */
/*	primCalloc: byteSize <Integer> ^<Integer>
	<primitive: 'primCalloc' error: errorCode module: 'IA32ABI'> */

EXPORT(sqInt)
primCalloc(void)
{
    sqInt addr;
    long byteSize;

	byteSize = interpreterProxy->stackIntegerValue(0);
	if ((interpreterProxy->failed())
	 || (byteSize <= 0)) {
		return interpreterProxy->primitiveFailFor(PrimErrBadArgument);
	}
	addr = (sqInt)calloc(1,byteSize);
	if (addr == 0) {
		return interpreterProxy->primitiveFailFor(PrimErrNoCMemory);
	}
	interpreterProxy->popthenPush(2, interpreterProxy->positive32BitIntegerFor(addr));
}


/*	Answer the 64-bit double starting at the given byte offset (little
	endian). 
 */
/*	<Alien> doubleAt: index <Integer> ^<Float>
	<primitive: 'primDoubleAt' error: errorCode module: 'IA32ABI'> */

EXPORT(sqInt)
primDoubleAt(void)
{
    sqInt addr;
    sqInt byteOffset;
    sqInt dataSize;
    double  floatValue;
    sqInt rcvr;

	byteOffset = (interpreterProxy->stackPositiveMachineIntegerValue(0)) - 1;
	rcvr = interpreterProxy->stackObjectValue(1);
	if (interpreterProxy->failed()) {
		return interpreterProxy->primitiveFailFor(PrimErrBadArgument);
	}
	if (!((((dataSize = longAt(rcvr + BaseHeaderSize))) == 0)
		 || (((((usqInt)byteOffset)) + 8) <= (abs(dataSize))))) {
		return interpreterProxy->primitiveFailFor(PrimErrBadIndex);
	}
	addr = (((longAt(rcvr + BaseHeaderSize)) > 0
	? (rcvr + BaseHeaderSize) + BytesPerOop
	: longAt((rcvr + BaseHeaderSize) + BytesPerOop))) + byteOffset;
	((long *)(&floatValue))[0] = ((long *)addr)[0]; ((long *)(&floatValue))[1] = ((long *)addr)[1];
	interpreterProxy->pop(2);
	return interpreterProxy->pushFloat(floatValue);
}


/*	Store a double into 64 bits starting at the given byte offset (little
	endian). 
 */
/*	<Alien> doubleAt: index <Integer> put: value <Float | Integer> ^<Float |
	Integer> <primitive: 'primDoubleAtPut' error: errorCode module: 'IA32ABI'> */

EXPORT(sqInt)
primDoubleAtPut(void)
{
    sqInt addr;
    sqInt byteOffset;
    sqInt dataSize;
    double  floatValue;
    sqInt rcvr;
    sqInt valueOop;

	valueOop = interpreterProxy->stackValue(0);
	if ((valueOop & 1)) {
		floatValue = ((double) ((valueOop >> 1)));
	}
	else {
		floatValue = ((double) (interpreterProxy->floatValueOf(valueOop)));
	}
	byteOffset = (interpreterProxy->stackPositiveMachineIntegerValue(1)) - 1;
	rcvr = interpreterProxy->stackObjectValue(2);
	if (interpreterProxy->failed()) {
		return interpreterProxy->primitiveFailFor(PrimErrBadArgument);
	}
	if (!((((dataSize = longAt(rcvr + BaseHeaderSize))) == 0)
		 || (((((usqInt)byteOffset)) + 8) <= (abs(dataSize))))) {
		return interpreterProxy->primitiveFailFor(PrimErrBadIndex);
	}
	addr = (((longAt(rcvr + BaseHeaderSize)) > 0
	? (rcvr + BaseHeaderSize) + BytesPerOop
	: longAt((rcvr + BaseHeaderSize) + BytesPerOop))) + byteOffset;
	((int*)addr)[0] = ((int*)(&floatValue))[0];
	((int*)addr)[1] = ((int*)(&floatValue))[1];
	interpreterProxy->popthenPush(3, valueOop);
}


/*	Answer the 32-bit float starting at the given byte offset (little endian). */
/*	<Alien> floatAt: index <Integer> ^<Float>
	<primitive: 'primFloatAt' error: errorCode module: 'IA32ABI'> */

EXPORT(sqInt)
primFloatAt(void)
{
    sqInt addr;
    sqInt byteOffset;
    sqInt dataSize;
    float  floatValue;
    sqInt rcvr;

	byteOffset = (interpreterProxy->stackPositiveMachineIntegerValue(0)) - 1;
	rcvr = interpreterProxy->stackObjectValue(1);
	if (interpreterProxy->failed()) {
		return interpreterProxy->primitiveFailFor(PrimErrBadArgument);
	}
	if (!((((dataSize = longAt(rcvr + BaseHeaderSize))) == 0)
		 || (((((usqInt)byteOffset)) + 4) <= (abs(dataSize))))) {
		return interpreterProxy->primitiveFailFor(PrimErrBadIndex);
	}
	addr = (((longAt(rcvr + BaseHeaderSize)) > 0
	? (rcvr + BaseHeaderSize) + BytesPerOop
	: longAt((rcvr + BaseHeaderSize) + BytesPerOop))) + byteOffset;
	((long *)(&floatValue))[0] = ((long *)addr)[0];
	interpreterProxy->pop(2);
	return interpreterProxy->pushFloat(floatValue);
}


/*	Store a float into 32 bits starting at the given byte offset (little
	endian). 
 */
/*	<Alien> floatAt: index <Integer> put: value <Float | Integer> ^<Float |
	Integer> <primitive: 'primFloatAtPut' error: errorCode module: 'IA32ABI'> */

EXPORT(sqInt)
primFloatAtPut(void)
{
    sqInt addr;
    sqInt byteOffset;
    sqInt dataSize;
    float  floatValue;
    sqInt rcvr;
    sqInt valueOop;

	valueOop = interpreterProxy->stackValue(0);
	if ((valueOop & 1)) {
		floatValue = ((double) ((valueOop >> 1)));
	}
	else {
		floatValue = ((double) (interpreterProxy->floatValueOf(valueOop)));
	}
	byteOffset = (interpreterProxy->stackPositiveMachineIntegerValue(1)) - 1;
	rcvr = interpreterProxy->stackObjectValue(2);
	if (interpreterProxy->failed()) {
		return interpreterProxy->primitiveFailFor(PrimErrBadArgument);
	}
	if (!((((dataSize = longAt(rcvr + BaseHeaderSize))) == 0)
		 || (((((usqInt)byteOffset)) + 4) <= (abs(dataSize))))) {
		return interpreterProxy->primitiveFailFor(PrimErrBadIndex);
	}
	addr = (((longAt(rcvr + BaseHeaderSize)) > 0
	? (rcvr + BaseHeaderSize) + BytesPerOop
	: longAt((rcvr + BaseHeaderSize) + BytesPerOop))) + byteOffset;
	((long *)addr)[0] = ((long *)(&floatValue))[0];
	interpreterProxy->popthenPush(3, valueOop);
}


/*	Free the memory referenced by the argument, an integer. */
/*	<Anywhere> primFree: address <Integer>
	<primitive: 'primFree' error: errorCode module: 'IA32ABI'> */

EXPORT(sqInt)
primFree(void)
{
    sqInt addr;

	addr = interpreterProxy->positive32BitValueOf(interpreterProxy->stackValue(0));
	if (interpreterProxy->failed()) {
		return interpreterProxy->primitiveFailFor(PrimErrBadArgument);
	}
	if ((addr == 0)
	 || (interpreterProxy->isInMemory(addr))) {
		return interpreterProxy->primitiveFailFor(PrimErrInappropriate);
	}
	free((void *)addr);
	interpreterProxy->pop(1);
}


/*	Answer the address of the int inIOProcessEvents flag. This can be used to
	disable invocation of ioProcessEvents and is for backward-compatibility.
	Please use the core VM primitiveEventProcessingControl in new code. */

EXPORT(sqInt)
primInIOProcessEventsFlagAddress(void)
{
    sqInt address;

	{ extern int inIOProcessEvents; address = (sqInt)&inIOProcessEvents; }
	interpreterProxy->popthenPush(1, interpreterProxy->positive32BitIntegerFor(address));
}


/*	Attempt to find the address of a symbol in a loaded library.
	The primitive can have a signature either of the form:
	<Anywhere> primInLibrary: libraryHandle <Alien> findSymbol: symbolName
	<String> ^<Integer>
	<primitive: 'primInLibraryFindSymbol' error: errorCode module: 'IA32ABI'>
	or:
	libraryHandle <Alien> primFindSymbol: symbolName <String> ^<Integer>
	<primitive: 'primInLibraryFindSymbol' error: errorCode module: 'IA32ABI'> */

EXPORT(sqInt)
primInLibraryFindSymbol(void)
{
    sqInt address;
    sqInt functionName;
    sqInt libraryProxy;

	functionName = interpreterProxy->stackValue(0);
	libraryProxy = interpreterProxy->stackValue(1);
	if (!((interpreterProxy->includesBehaviorThatOf(interpreterProxy->fetchClassOf(libraryProxy), interpreterProxy->classAlien()))
		 && ((((interpreterProxy->byteSizeOf(libraryProxy)) >= 2) * BytesPerOop)
 && (interpreterProxy->isBytes(functionName))))) {
		return interpreterProxy->primitiveFailFor(PrimErrBadArgument);
	}
	address = interpreterProxy->ioLoadSymbolOfLengthFromModule(((sqInt) (interpreterProxy->firstIndexableField(functionName))), interpreterProxy->byteSizeOf(functionName), longAt((libraryProxy + BaseHeaderSize) + BytesPerOop));
	if ((interpreterProxy->failed())
	 || (address == 0)) {
		return interpreterProxy->primitiveFailFor(PrimErrNotFound);
	}
	interpreterProxy->popthenPush((interpreterProxy->methodArgumentCount()) + 1, interpreterProxy->positive32BitIntegerFor(address));
}


/*	Attempt to load a library of the given name. The primitive will have a
	signature of the form:
	<Anywhere> primLoadLibrary: libraryName <String> ^<Integer>
	<primitive: 'primLoadLibrary' error: errorCode module: 'IA32ABI'> */

EXPORT(sqInt)
primLoadLibrary(void)
{
    sqInt libraryHandle;
    sqInt libraryName;

	libraryName = interpreterProxy->stackValue(0);
	if (!(interpreterProxy->isBytes(libraryName))) {
		return interpreterProxy->primitiveFailFor(PrimErrBadArgument);
	}
	libraryHandle = interpreterProxy->ioLoadModuleOfLength(((sqInt) (interpreterProxy->firstIndexableField(libraryName))), interpreterProxy->byteSizeOf(libraryName));
	if (libraryHandle == 0) {
		return interpreterProxy->primitiveFailFor(PrimErrNotFound);
	}
	interpreterProxy->popthenPush(2, interpreterProxy->positive32BitIntegerFor(libraryHandle));
}


/*	Malloc arg bytes. */
/*	primMalloc: byteSize <Integer> <^Integer>
	<primitive: 'primMalloc' error: errorCode module: 'IA32ABI'> */

EXPORT(sqInt)
primMalloc(void)
{
    sqInt addr;
    long byteSize;

	byteSize = interpreterProxy->stackIntegerValue(0);
	if ((interpreterProxy->failed())
	 || (byteSize <= 0)) {
		return interpreterProxy->primitiveFailFor(PrimErrBadArgument);
	}
	addr = (sqInt)malloc(byteSize);
	if (addr == 0) {
		return interpreterProxy->primitiveFailFor(PrimErrNoCMemory);
	}
	interpreterProxy->popthenPush(2, interpreterProxy->positive32BitIntegerFor(addr));
}


/*	Return a result from a callback to the callback's callee. The primitive
	has a signature of the form:
	result <VMCallbackContext32/64>
	primReturnAs: returnTypeCode <Integer>
	FromContext: callbackContext <Context>
	<primitive: 'primReturnAsFromContextThrough' error: errorCode module:
	'IA32ABI'>  */

EXPORT(sqInt)
primReturnAsFromContextThrough(void)
{
	if (!(interpreterProxy->returnAsThroughCallbackContext(interpreterProxy->stackValue(1), ((VMCallbackContext *) (startOfData(interpreterProxy->stackValue(2)))), interpreterProxy->stackValue(0)))) {
		return interpreterProxy->primitiveFailFor(PrimErrBadArgument);
	}
}


/*	Return a result from a callback to the callback's callee. The primitive
	has a signature of the form:
	result <FFICallbackResult> primReturnFromContext: callbackContext
	<Context> through: jmpBuf <Integer>
	<primitive: 'primReturnFromContextThrough' error: errorCode module:
	'IA32ABI'>  */

EXPORT(sqInt)
primReturnFromContextThrough(void)
{
    VMCallbackContext *vmCallbackContext;
    VMCallbackReturnValue *vmCallbackReturnValue;

	vmCallbackReturnValue = ((VMCallbackReturnValue *) (startOfData(interpreterProxy->stackValue(2))));
	vmCallbackContext = ((VMCallbackContext *) (interpreterProxy->positive32BitValueOf(interpreterProxy->stackValue(0))));
	if ((interpreterProxy->failed())
	 || (vmCallbackContext == 0)) {
		return interpreterProxy->primitiveFailFor(PrimErrBadArgument);
	}
	if (!(interpreterProxy->reestablishContextPriorToCallback(interpreterProxy->stackValue(1)))) {
		return interpreterProxy->primitiveFailFor(PrimErrBadArgument);
	}
	memcpy((&((vmCallbackContext->rvs))), (&((vmCallbackReturnValue->crvrvs))), sizeof((vmCallbackContext->rvs)));
	longjmp((vmCallbackContext->trampoline), ((vmCallbackReturnValue->type)) + 1);
}


/*	Answer the signed 8-bit integer starting at the given byte offset (little
	endian). 
 */
/*	<Alien> unsignedByteAt: index <Integer> ^<Integer>
	<primitive: 'primSignedByteAt' error: errorCode module: 'IA32ABI'> */

EXPORT(sqInt)
primSignedByteAt(void)
{
    sqInt addr;
    sqInt byteOffset;
    sqInt dataSize;
    sqInt rcvr;
    signed char  value;
    sqInt valueOop;

	byteOffset = (interpreterProxy->stackPositiveMachineIntegerValue(0)) - 1;
	rcvr = interpreterProxy->stackObjectValue(1);
	if (interpreterProxy->failed()) {
		return interpreterProxy->primitiveFailFor(PrimErrBadArgument);
	}
	if (!((((dataSize = longAt(rcvr + BaseHeaderSize))) == 0)
		 || (((((usqInt)byteOffset)) + 1) <= (abs(dataSize))))) {
		return interpreterProxy->primitiveFailFor(PrimErrBadIndex);
	}
	addr = (((longAt(rcvr + BaseHeaderSize)) > 0
	? (rcvr + BaseHeaderSize) + BytesPerOop
	: longAt((rcvr + BaseHeaderSize) + BytesPerOop))) + byteOffset;
	value = byteAt(addr);
	valueOop = interpreterProxy->signed32BitIntegerFor(value);
	return interpreterProxy->popthenPush(2, valueOop);
}


/*	Store a signed integer into 8 bits starting at the given byte offset
	(little endian).
 */
/*	<Alien> signedByteAt: index <Integer> put: value <Integer> ^<Integer>
	<primitive: 'primSignedByteAtPut' error: errorCode module: 'IA32ABI'> */

EXPORT(sqInt)
primSignedByteAtPut(void)
{
    sqInt addr;
    sqInt byteOffset;
    sqInt dataSize;
    sqInt rcvr;
    sqInt value;
    sqInt valueOop;

	valueOop = interpreterProxy->stackValue(0);
	byteOffset = (interpreterProxy->stackPositiveMachineIntegerValue(1)) - 1;
	rcvr = interpreterProxy->stackObjectValue(2);
	value = interpreterProxy->signed32BitValueOf(valueOop);
	if ((interpreterProxy->failed())
	 || ((value < -128)
 || (value > 127))) {
		return interpreterProxy->primitiveFailFor(PrimErrBadArgument);
	}
	if (!((((dataSize = longAt(rcvr + BaseHeaderSize))) == 0)
		 || (((((usqInt)byteOffset)) + 1) <= (abs(dataSize))))) {
		return interpreterProxy->primitiveFailFor(PrimErrBadIndex);
	}
	addr = (((longAt(rcvr + BaseHeaderSize)) > 0
	? (rcvr + BaseHeaderSize) + BytesPerOop
	: longAt((rcvr + BaseHeaderSize) + BytesPerOop))) + byteOffset;
	byteAtput(addr, value);
	return interpreterProxy->popthenPush(3, valueOop);
}


/*	Answer the signed 32-bit integer starting at the given byte offset (little
	endian). 
 */
/*	<Alien> signedLongAt: index <Integer> ^<Integer>
	<primitive: 'primSignedLongAt' error: errorCode module: 'IA32ABI'> */

EXPORT(sqInt)
primSignedLongAt(void)
{
    sqInt addr;
    sqInt byteOffset;
    sqInt dataSize;
    sqInt rcvr;
    sqInt value;
    sqInt valueOop;

	byteOffset = (interpreterProxy->stackPositiveMachineIntegerValue(0)) - 1;
	rcvr = interpreterProxy->stackObjectValue(1);
	if (interpreterProxy->failed()) {
		return interpreterProxy->primitiveFailFor(PrimErrBadArgument);
	}
	if (!((((dataSize = longAt(rcvr + BaseHeaderSize))) == 0)
		 || (((((usqInt)byteOffset)) + 4) <= (abs(dataSize))))) {
		return interpreterProxy->primitiveFailFor(PrimErrBadIndex);
	}
	addr = (((longAt(rcvr + BaseHeaderSize)) > 0
	? (rcvr + BaseHeaderSize) + BytesPerOop
	: longAt((rcvr + BaseHeaderSize) + BytesPerOop))) + byteOffset;
	value = longAt(addr);
	valueOop = interpreterProxy->signed32BitIntegerFor(value);
	return interpreterProxy->popthenPush(2, valueOop);
}


/*	Store a signed integer into 32 bits starting at the given byte offset
	(little endian).
 */
/*	<Alien> signedLongAt: index <Integer> put: value <Integer> ^<Integer>
	<primitive: 'primSignedLongAtPut' error: errorCode module: 'IA32ABI'> */

EXPORT(sqInt)
primSignedLongAtPut(void)
{
    sqInt addr;
    sqInt byteOffset;
    sqInt dataSize;
    sqInt rcvr;
    sqInt value;
    sqInt valueOop;

	valueOop = interpreterProxy->stackValue(0);
	byteOffset = (interpreterProxy->stackPositiveMachineIntegerValue(1)) - 1;
	rcvr = interpreterProxy->stackObjectValue(2);
	value = interpreterProxy->signed32BitValueOf(valueOop);
	if (interpreterProxy->failed()) {
		return interpreterProxy->primitiveFailFor(PrimErrBadArgument);
	}
	if (!((((dataSize = longAt(rcvr + BaseHeaderSize))) == 0)
		 || (((((usqInt)byteOffset)) + 4) <= (abs(dataSize))))) {
		return interpreterProxy->primitiveFailFor(PrimErrBadIndex);
	}
	addr = (((longAt(rcvr + BaseHeaderSize)) > 0
	? (rcvr + BaseHeaderSize) + BytesPerOop
	: longAt((rcvr + BaseHeaderSize) + BytesPerOop))) + byteOffset;
	longAtput(addr, value);
	return interpreterProxy->popthenPush(3, valueOop);
}


/*	Answer the signed 64-bit integer starting at the given byte offset (little
	endian). 
 */
/*	<Alien> signedLongLongAt: index <Integer> ^<Integer>
	<primitive: 'primSignedLongLongAt' error: errorCode module: 'IA32ABI'> */

EXPORT(sqInt)
primSignedLongLongAt(void)
{
    sqInt addr;
    sqInt byteOffset;
    sqInt dataSize;
    sqInt rcvr;
    long long signedlonglongvalue;
    long long *signedlonglongvaluePtr;
    sqInt valueOop;

	signedlonglongvaluePtr = 0;
	;
	byteOffset = (interpreterProxy->stackPositiveMachineIntegerValue(0)) - 1;
	rcvr = interpreterProxy->stackObjectValue(1);
	if (interpreterProxy->failed()) {
		return interpreterProxy->primitiveFailFor(PrimErrBadArgument);
	}
	if (!((((dataSize = longAt(rcvr + BaseHeaderSize))) == 0)
		 || (((((usqInt)byteOffset)) + 8) <= (abs(dataSize))))) {
		return interpreterProxy->primitiveFailFor(PrimErrBadIndex);
	}
	addr = (((longAt(rcvr + BaseHeaderSize)) > 0
	? (rcvr + BaseHeaderSize) + BytesPerOop
	: longAt((rcvr + BaseHeaderSize) + BytesPerOop))) + byteOffset;
	signedlonglongvaluePtr = ((long long*) addr);
	signedlonglongvalue = *signedlonglongvaluePtr;
	valueOop = interpreterProxy->signed64BitIntegerFor(signedlonglongvalue);
	return interpreterProxy->popthenPush(2, valueOop);
}


/*	Store a signed integer into 64 bits starting at the given byte offset
	(little endian).
 */
/*	<Alien> signedLongLongAt: index <Integer> put: value <Integer> ^<Integer>
	<primitive: 'primSignedLongLongAtPut' error: errorCode module: 'IA32ABI'> */

EXPORT(sqInt)
primSignedLongLongAtPut(void)
{
    sqInt addr;
    sqInt byteOffset;
    sqInt dataSize;
    sqInt rcvr;
    long long signedlonglongvalue;
    long long *signedlonglongvaluePtr;
    sqInt valueOop;

	signedlonglongvaluePtr = 0;
	;
	valueOop = interpreterProxy->stackValue(0);
	byteOffset = (interpreterProxy->stackPositiveMachineIntegerValue(1)) - 1;
	rcvr = interpreterProxy->stackObjectValue(2);
	signedlonglongvalue = interpreterProxy->signed64BitValueOf(valueOop);
	;
	if (interpreterProxy->failed()) {
		return interpreterProxy->primitiveFailFor(PrimErrBadArgument);
	}
	if (!((((dataSize = longAt(rcvr + BaseHeaderSize))) == 0)
		 || (((((usqInt)byteOffset)) + 8) <= (abs(dataSize))))) {
		return interpreterProxy->primitiveFailFor(PrimErrBadIndex);
	}
	addr = (((longAt(rcvr + BaseHeaderSize)) > 0
	? (rcvr + BaseHeaderSize) + BytesPerOop
	: longAt((rcvr + BaseHeaderSize) + BytesPerOop))) + byteOffset;
	signedlonglongvaluePtr = ((long long*) addr);
	*signedlonglongvaluePtr = signedlonglongvalue;
	return interpreterProxy->popthenPush(3, valueOop);
}


/*	Answer the signed 32-bit integer starting at the given byte offset (little
	endian). 
 */
/*	<Alien> signedShortAt: index <Integer> ^<Integer>
	<primitive: 'primSignedShortAt' error: errorCode module: 'IA32ABI'> */

EXPORT(sqInt)
primSignedShortAt(void)
{
    sqInt addr;
    sqInt byteOffset;
    sqInt dataSize;
    sqInt rcvr;
    short  value;
    sqInt valueOop;

	byteOffset = (interpreterProxy->stackPositiveMachineIntegerValue(0)) - 1;
	rcvr = interpreterProxy->stackObjectValue(1);
	if (interpreterProxy->failed()) {
		return interpreterProxy->primitiveFailFor(PrimErrBadArgument);
	}
	if (!((((dataSize = longAt(rcvr + BaseHeaderSize))) == 0)
		 || (((((usqInt)byteOffset)) + 2) <= (abs(dataSize))))) {
		return interpreterProxy->primitiveFailFor(PrimErrBadIndex);
	}
	addr = (((longAt(rcvr + BaseHeaderSize)) > 0
	? (rcvr + BaseHeaderSize) + BytesPerOop
	: longAt((rcvr + BaseHeaderSize) + BytesPerOop))) + byteOffset;
	value = shortAt(addr);
	valueOop = interpreterProxy->signed32BitIntegerFor(value);
	return interpreterProxy->popthenPush(2, valueOop);
}


/*	Store a signed integer into 16 bits starting at the given byte offset
	(little endian).
 */
/*	<Alien> signedShortAt: index <Integer> put: value <Integer> ^<Integer>
	<primitive: 'primSignedShortAtPut' error: errorCode module: 'IA32ABI'> */

EXPORT(sqInt)
primSignedShortAtPut(void)
{
    sqInt addr;
    sqInt byteOffset;
    sqInt dataSize;
    sqInt rcvr;
    sqInt value;
    sqInt valueOop;

	valueOop = interpreterProxy->stackValue(0);
	byteOffset = (interpreterProxy->stackPositiveMachineIntegerValue(1)) - 1;
	rcvr = interpreterProxy->stackObjectValue(2);
	value = interpreterProxy->signed32BitValueOf(valueOop);
	if ((interpreterProxy->failed())
	 || ((value < -32768)
 || (value > 32767))) {
		return interpreterProxy->primitiveFailFor(PrimErrBadArgument);
	}
	if (!((((dataSize = longAt(rcvr + BaseHeaderSize))) == 0)
		 || (((((usqInt)byteOffset)) + 2) <= (abs(dataSize))))) {
		return interpreterProxy->primitiveFailFor(PrimErrBadIndex);
	}
	addr = (((longAt(rcvr + BaseHeaderSize)) > 0
	? (rcvr + BaseHeaderSize) + BytesPerOop
	: longAt((rcvr + BaseHeaderSize) + BytesPerOop))) + byteOffset;
	shortAtput(addr, value);
	return interpreterProxy->popthenPush(3, valueOop);
}


/*	Answer the signed 32-bit integer comprising the size field (the first
	32-bit field).
 */
/*	<Alien> primSizeField ^<Integer>
	<primitive: 'primSizeField' error: errorCode module: 'IA32ABI'> */

EXPORT(sqInt)
primSizeField(void)
{
    sqInt rcvr;
    sqInt value;
    sqInt valueOop;

	rcvr = interpreterProxy->stackValue(0);
	value = longAt(rcvr + BaseHeaderSize);
	valueOop = interpreterProxy->signed32BitIntegerFor(value);
	return interpreterProxy->popthenPush(1, valueOop);
}


/*	Store a signed integer into the size field (the first 32 bit field; little
	endian). 
 */
/*	<Alien> sizeFieldPut: value <Integer> ^<Integer>
	<primitive: 'primSizeFieldPut' error: errorCode module: 'IA32ABI'> */

EXPORT(sqInt)
primSizeFieldPut(void)
{
    sqInt rcvr;
    sqInt value;
    sqInt valueOop;

	valueOop = interpreterProxy->stackValue(0);
	rcvr = interpreterProxy->stackValue(1);
	value = interpreterProxy->signed32BitValueOf(valueOop);
	if (interpreterProxy->failed()) {
		return interpreterProxy->primitiveFailFor(PrimErrBadArgument);
	}
	longAtput(rcvr + BaseHeaderSize, value);
	return interpreterProxy->popthenPush(2, valueOop);
}


/*	Answer the number of non-null bytes starting at index. If
	there isn't a null byte before the end of the object then the
	result will be the number of bytes from index to the end of
	the object, i.e. the result will be within the bounds of the object. */
/*	<Alien> primStrlenFrom: index <Integer> ^<Integer>
	<primitive: 'primStrlenFromStartIndex' error: errorCode module: 'IA32ABI'> */

EXPORT(sqInt)
primStrlenFromStartIndex(void)
{
    sqInt byteOffset;
    sqInt dataSize;
    sqInt index;
    sqInt limit;
    char *ptr;
    sqInt rcvr;

	byteOffset = (interpreterProxy->stackPositiveMachineIntegerValue(0)) - 1;
	rcvr = interpreterProxy->stackObjectValue(1);
	if (interpreterProxy->failed()) {
		return interpreterProxy->primitiveFailFor(PrimErrBadArgument);
	}
	if (!((((dataSize = longAt(rcvr + BaseHeaderSize))) == 0)
		 || (((((usqInt)byteOffset)) + 1) <= (abs(dataSize))))) {
		return interpreterProxy->primitiveFailFor(PrimErrBadIndex);
	}
	limit = longAt(rcvr + BaseHeaderSize);
	ptr = ((char *) (((limit > 0
	? (rcvr + BaseHeaderSize) + BytesPerOop
	: longAt((rcvr + BaseHeaderSize) + BytesPerOop))) + byteOffset));
	if (limit == 0) {
		index = strlen(ptr);
	}
	else {
		limit = abs(limit);
		index = 0;
		while ((index < limit)
 && ((ptr[index]) != 0)) {
			index += 1;
		}
	}
	return interpreterProxy->popthenPush(2, interpreterProxy->positive32BitIntegerFor(index));
}


/*	Answer the number of non-null bytes starting at the byte addressed by
	the 4-byte pointer at index. */
/*	<Alien> strlenThroughPointerAt: index <Integer> ^<Integer>
	<primitive: 'primStrlenThroughPointerAtIndex' error: errorCode module:
	'IA32ABI'> 
 */

EXPORT(sqInt)
primStrlenThroughPointerAtIndex(void)
{
    sqInt addr;
    sqInt byteOffset;
    sqInt dataSize;
    char *ptr;
    sqInt rcvr;

	byteOffset = (interpreterProxy->stackPositiveMachineIntegerValue(0)) - 1;
	rcvr = interpreterProxy->stackObjectValue(1);
	if (interpreterProxy->failed()) {
		return interpreterProxy->primitiveFailFor(PrimErrBadArgument);
	}
	if (!((((dataSize = longAt(rcvr + BaseHeaderSize))) == 0)
		 || (((((usqInt)byteOffset)) + 4) <= (abs(dataSize))))) {
		return interpreterProxy->primitiveFailFor(PrimErrBadIndex);
	}
	addr = (((longAt(rcvr + BaseHeaderSize)) > 0
	? (rcvr + BaseHeaderSize) + BytesPerOop
	: longAt((rcvr + BaseHeaderSize) + BytesPerOop))) + byteOffset;
	ptr = ((char *) (longAt(addr)));
	return interpreterProxy->popthenPush(2, interpreterProxy->positive32BitIntegerFor(strlen(ptr)));
}


/*	Answer the address of the entry-point for thunk callbacks:
	long thunkEntry(void *thunkp, long *stackp);
	This could be derived via loadModule: findSymbol: etc but that would
	preclude making the plugin internal. */

EXPORT(sqInt)
primThunkEntryAddress(void)
{
    sqInt address;

	address = (sqInt)thunkEntry;
	interpreterProxy->popthenPush(1, interpreterProxy->positive32BitIntegerFor(address));
}


/*	Answer the unsigned 8-bit integer starting at the given byte offset
	(little endian).
 */
/*	<Alien> unsignedByteAt: index <Integer> ^<Integer>
	<primitive: 'primUnsignedByteAt' error: errorCode module: 'IA32ABI'> */

EXPORT(sqInt)
primUnsignedByteAt(void)
{
    sqInt addr;
    sqInt byteOffset;
    sqInt dataSize;
    sqInt rcvr;
    unsigned char  value;
    sqInt valueOop;

	byteOffset = (interpreterProxy->stackPositiveMachineIntegerValue(0)) - 1;
	rcvr = interpreterProxy->stackObjectValue(1);
	if (interpreterProxy->failed()) {
		return interpreterProxy->primitiveFailFor(PrimErrBadArgument);
	}
	if (!((((dataSize = longAt(rcvr + BaseHeaderSize))) == 0)
		 || (((((usqInt)byteOffset)) + 1) <= (abs(dataSize))))) {
		return interpreterProxy->primitiveFailFor(PrimErrBadIndex);
	}
	addr = (((longAt(rcvr + BaseHeaderSize)) > 0
	? (rcvr + BaseHeaderSize) + BytesPerOop
	: longAt((rcvr + BaseHeaderSize) + BytesPerOop))) + byteOffset;
	value = byteAt(addr);
	valueOop = interpreterProxy->positive32BitIntegerFor(value);
	return interpreterProxy->popthenPush(2, valueOop);
}


/*	Store an unsigned integer into 8 bits starting at the given byte offset
	(little endian).
 */
/*	<Alien> unsignedByteAt: index <Integer> put: value <Integer> ^<Integer>
	<primitive: 'primUnsignedByteAtPut' error: errorCode module: 'IA32ABI'> */

EXPORT(sqInt)
primUnsignedByteAtPut(void)
{
    sqInt addr;
    sqInt byteOffset;
    sqInt dataSize;
    sqInt rcvr;
    sqInt value;
    sqInt valueOop;

	valueOop = interpreterProxy->stackValue(0);
	byteOffset = (interpreterProxy->stackPositiveMachineIntegerValue(1)) - 1;
	rcvr = interpreterProxy->stackObjectValue(2);
	value = interpreterProxy->positive32BitValueOf(valueOop);
	if ((interpreterProxy->failed())
	 || (value > 255)) {
		return interpreterProxy->primitiveFailFor(PrimErrBadArgument);
	}
	if (!((((dataSize = longAt(rcvr + BaseHeaderSize))) == 0)
		 || (((((usqInt)byteOffset)) + 1) <= (abs(dataSize))))) {
		return interpreterProxy->primitiveFailFor(PrimErrBadIndex);
	}
	addr = (((longAt(rcvr + BaseHeaderSize)) > 0
	? (rcvr + BaseHeaderSize) + BytesPerOop
	: longAt((rcvr + BaseHeaderSize) + BytesPerOop))) + byteOffset;
	byteAtput(addr, value);
	return interpreterProxy->popthenPush(3, valueOop);
}


/*	Answer the unsigned 32-bit integer starting at the given byte offset
	(little endian).
 */
/*	<Alien> unsignedLongAt: index <Integer> ^<Integer>
	<primitive: 'primUnsignedLongAt' error: errorCode module: 'IA32ABI'> */

EXPORT(sqInt)
primUnsignedLongAt(void)
{
    sqInt addr;
    sqInt byteOffset;
    sqInt dataSize;
    sqInt rcvr;
    sqInt value;
    sqInt valueOop;

	byteOffset = (interpreterProxy->stackPositiveMachineIntegerValue(0)) - 1;
	rcvr = interpreterProxy->stackObjectValue(1);
	if (interpreterProxy->failed()) {
		return interpreterProxy->primitiveFailFor(PrimErrBadArgument);
	}
	if (!((((dataSize = longAt(rcvr + BaseHeaderSize))) == 0)
		 || (((((usqInt)byteOffset)) + 4) <= (abs(dataSize))))) {
		return interpreterProxy->primitiveFailFor(PrimErrBadIndex);
	}
	addr = (((longAt(rcvr + BaseHeaderSize)) > 0
	? (rcvr + BaseHeaderSize) + BytesPerOop
	: longAt((rcvr + BaseHeaderSize) + BytesPerOop))) + byteOffset;
	value = longAt(addr);
	valueOop = interpreterProxy->positive32BitIntegerFor(value);
	return interpreterProxy->popthenPush(2, valueOop);
}


/*	Store an unsigned integer into 32 bits starting at the given byte offset
	(little endian).
 */
/*	<Alien> unsignedLongAt: index <Integer> put: value <Integer> ^<Integer>
	<primitive: 'primUnsignedLongAtPut' error: errorCode module: 'IA32ABI'> */

EXPORT(sqInt)
primUnsignedLongAtPut(void)
{
    sqInt addr;
    sqInt byteOffset;
    sqInt dataSize;
    sqInt rcvr;
    sqInt value;
    sqInt valueOop;

	valueOop = interpreterProxy->stackValue(0);
	byteOffset = (interpreterProxy->stackPositiveMachineIntegerValue(1)) - 1;
	rcvr = interpreterProxy->stackObjectValue(2);
	value = interpreterProxy->positive32BitValueOf(valueOop);
	if (interpreterProxy->failed()) {
		return interpreterProxy->primitiveFailFor(PrimErrBadArgument);
	}
	if (!((((dataSize = longAt(rcvr + BaseHeaderSize))) == 0)
		 || (((((usqInt)byteOffset)) + 4) <= (abs(dataSize))))) {
		return interpreterProxy->primitiveFailFor(PrimErrBadIndex);
	}
	addr = (((longAt(rcvr + BaseHeaderSize)) > 0
	? (rcvr + BaseHeaderSize) + BytesPerOop
	: longAt((rcvr + BaseHeaderSize) + BytesPerOop))) + byteOffset;
	longAtput(addr, value);
	return interpreterProxy->popthenPush(3, valueOop);
}


/*	Answer the unsigned 64-bit integer starting at the given byte offset
	(little endian).
 */
/*	<Alien>unsignedLongLongAt: index <Integer> ^<Integer>
	<primitive: 'primUnsignedLongLongAt' error: errorCode module: 'IA32ABI'> */

EXPORT(sqInt)
primUnsignedLongLongAt(void)
{
    sqInt addr;
    sqInt byteOffset;
    sqInt dataSize;
    sqInt rcvr;
    unsigned long long unsignedlonglongvalue;
    unsigned long long *unsignedlonglongvaluePtr;
    sqInt valueOop;

	unsignedlonglongvaluePtr = 0;
	;
	byteOffset = (interpreterProxy->stackPositiveMachineIntegerValue(0)) - 1;
	rcvr = interpreterProxy->stackObjectValue(1);
	if (interpreterProxy->failed()) {
		return interpreterProxy->primitiveFailFor(PrimErrBadArgument);
	}
	if (!((((dataSize = longAt(rcvr + BaseHeaderSize))) == 0)
		 || (((((usqInt)byteOffset)) + 8) <= (abs(dataSize))))) {
		return interpreterProxy->primitiveFailFor(PrimErrBadIndex);
	}
	addr = (((longAt(rcvr + BaseHeaderSize)) > 0
	? (rcvr + BaseHeaderSize) + BytesPerOop
	: longAt((rcvr + BaseHeaderSize) + BytesPerOop))) + byteOffset;
	unsignedlonglongvaluePtr = ((unsigned long long*) addr);
	unsignedlonglongvalue = *unsignedlonglongvaluePtr;
	valueOop = interpreterProxy->positive64BitIntegerFor(unsignedlonglongvalue);
	return interpreterProxy->popthenPush(2, valueOop);
}


/*	Store a signed integer into 64 bits starting at the given byte offset
	(little endian).
 */
/*	<Alien> unsignedLongLongAt: index <Integer> put: value <Integer>
	^<Integer> <primitive: 'primUnSignedLongLongAtPut' error: errorCode
	module: 'IA32ABI'> */

EXPORT(sqInt)
primUnsignedLongLongAtPut(void)
{
    sqInt addr;
    sqInt byteOffset;
    sqInt dataSize;
    sqInt rcvr;
    unsigned long long unsignedlonglongvalue;
    unsigned long long *unsignedlonglongvaluePtr;
    sqInt valueOop;

	unsignedlonglongvaluePtr = 0;
	;
	valueOop = interpreterProxy->stackValue(0);
	byteOffset = (interpreterProxy->stackPositiveMachineIntegerValue(1)) - 1;
	rcvr = interpreterProxy->stackObjectValue(2);
	unsignedlonglongvalue = interpreterProxy->positive64BitValueOf(valueOop);
	;
	if (interpreterProxy->failed()) {
		return interpreterProxy->primitiveFailFor(PrimErrBadArgument);
	}
	if (!((((dataSize = longAt(rcvr + BaseHeaderSize))) == 0)
		 || (((((usqInt)byteOffset)) + 8) <= (abs(dataSize))))) {
		return interpreterProxy->primitiveFailFor(PrimErrBadIndex);
	}
	addr = (((longAt(rcvr + BaseHeaderSize)) > 0
	? (rcvr + BaseHeaderSize) + BytesPerOop
	: longAt((rcvr + BaseHeaderSize) + BytesPerOop))) + byteOffset;
	unsignedlonglongvaluePtr = ((unsigned long long*) addr);
	*unsignedlonglongvaluePtr = unsignedlonglongvalue;
	return interpreterProxy->popthenPush(3, valueOop);
}


/*	Answer the unsigned 16-bit integer starting at the given byte offset
	(little endian).
 */
/*	<Alien> unsignedShortAt: index <Integer> ^<Integer>
	<primitive: 'primUnsignedShortAt' error: errorCode module: 'IA32ABI'> */

EXPORT(sqInt)
primUnsignedShortAt(void)
{
    sqInt addr;
    sqInt byteOffset;
    sqInt dataSize;
    sqInt rcvr;
    unsigned short value;
    sqInt valueOop;

	byteOffset = (interpreterProxy->stackPositiveMachineIntegerValue(0)) - 1;
	rcvr = interpreterProxy->stackObjectValue(1);
	if (interpreterProxy->failed()) {
		return interpreterProxy->primitiveFailFor(PrimErrBadArgument);
	}
	if (!((((dataSize = longAt(rcvr + BaseHeaderSize))) == 0)
		 || (((((usqInt)byteOffset)) + 2) <= (abs(dataSize))))) {
		return interpreterProxy->primitiveFailFor(PrimErrBadIndex);
	}
	addr = (((longAt(rcvr + BaseHeaderSize)) > 0
	? (rcvr + BaseHeaderSize) + BytesPerOop
	: longAt((rcvr + BaseHeaderSize) + BytesPerOop))) + byteOffset;
	value = shortAt(addr);
	valueOop = interpreterProxy->positive32BitIntegerFor(value);
	return interpreterProxy->popthenPush(2, valueOop);
}


/*	Store an unsigned integer into 16 bits starting at the given byte offset
	(little endian).
 */
/*	<Alien> unsignedShortAt: index <Integer> put: value <Integer> ^<Integer>
	<primitive: 'primUnsignedShortAtPut' error: errorCode module: 'IA32ABI'> */

EXPORT(sqInt)
primUnsignedShortAtPut(void)
{
    sqInt addr;
    sqInt byteOffset;
    sqInt dataSize;
    sqInt rcvr;
    sqInt value;
    sqInt valueOop;

	valueOop = interpreterProxy->stackValue(0);
	byteOffset = (interpreterProxy->stackPositiveMachineIntegerValue(1)) - 1;
	rcvr = interpreterProxy->stackObjectValue(2);
	value = interpreterProxy->positive32BitValueOf(valueOop);
	if ((interpreterProxy->failed())
	 || (value > 65535)) {
		return interpreterProxy->primitiveFailFor(PrimErrBadArgument);
	}
	if (!((((dataSize = longAt(rcvr + BaseHeaderSize))) == 0)
		 || (((((usqInt)byteOffset)) + 2) <= (abs(dataSize))))) {
		return interpreterProxy->primitiveFailFor(PrimErrBadIndex);
	}
	addr = (((longAt(rcvr + BaseHeaderSize)) > 0
	? (rcvr + BaseHeaderSize) + BytesPerOop
	: longAt((rcvr + BaseHeaderSize) + BytesPerOop))) + byteOffset;
	shortAtput(addr, value);
	return interpreterProxy->popthenPush(3, valueOop);
}


/*	Call a foreign function that answers a double-precision floating-point
	result in %f0
	according to IA32-ish ABI rules. The primitive will have a signature of
	the form
	functionAddress <Alien> primFFICallResult: result <Alien|Object>
	withArguments: args <Array of: Alien | Integer> ^<Alien>
	<primitive: 'primVarArgsCallOutDoubleReturn' error: errorCode module:
	'IA32ABI'>. Answer result. If result is an Alien the value answered by the
	call will be assigned to result.
 */

EXPORT(sqInt)
primVarArgsCallOutDoubleReturn(void)
{
    sqInt array;
    sqInt errCode;
    sqInt result;

	array = interpreterProxy->stackValue(0);
	if (!(interpreterProxy->isArray(array))) {
		return interpreterProxy->primitiveFailFor(PrimErrBadArgument);
	}
	errCode = callIA32DoubleReturn(interpreterProxy->firstIndexableField(array),	/* arg vec */
													interpreterProxy->stSizeOf(array)			/* nargs */,
													2											/* funcOffset*/,
													1											/* resultOffset */);
	if (errCode != 0) {
		return interpreterProxy->primitiveFailFor(errCode);
	}
	result = interpreterProxy->stackValue(1);
	interpreterProxy->popthenPush(3, result);
}


/*	Call a foreign function that answers a single-precision floating-point
	result in %f0
	according to IA32-ish ABI rules. The primitive will have a signature of
	the form
	functionAddress <Alien> primFFICallResult: result <Alien|Object>
	withArguments: args <Array of: Alien | Integer> ^<Alien>
	<primitive: 'primVarArgsCallOutFloatReturn' error: errorCode module:
	'IA32ABI'>. Answer result. If result is an Alien the value answered by the
	call will be assigned to result.
 */

EXPORT(sqInt)
primVarArgsCallOutFloatReturn(void)
{
    sqInt array;
    sqInt errCode;
    sqInt result;

	array = interpreterProxy->stackValue(0);
	if (!(interpreterProxy->isArray(array))) {
		return interpreterProxy->primitiveFailFor(PrimErrBadArgument);
	}
	errCode = callIA32FloatReturn(interpreterProxy->firstIndexableField(array),	/* arg vec */
												interpreterProxy->stSizeOf(array)				/* nargs */,
												2												/* funcOffset*/,
												1												/* resultOffset */);
	if (errCode != 0) {
		return interpreterProxy->primitiveFailFor(errCode);
	}
	result = interpreterProxy->stackValue(1);
	interpreterProxy->popthenPush(3, result);
}


/*	Call a foreign function that answers an integral result in %eax (and
	possibly %edx)
	according to IA32-ish ABI rules. The primitive will have a signature of
	the form
	functionAddress <Alien> primFFICallResult: result <Alien|Object>
	withArguments: args <Array of: Alien | Integer> ^<Alien>
	<primitive: 'primVarArgsCallOutIntegralReturn' error: errorCode module:
	'IA32ABI'>. Answer result. If result is an Alien the value answered by the
	call will be assigned to result.
 */

EXPORT(sqInt)
primVarArgsCallOutIntegralReturn(void)
{
    sqInt array;
    sqInt errCode;
    sqInt result;

	array = interpreterProxy->stackValue(0);
	if (!(interpreterProxy->isArray(array))) {
		return interpreterProxy->primitiveFailFor(PrimErrBadArgument);
	}
	errCode = callIA32IntegralReturn(interpreterProxy->firstIndexableField(array),	/* arg vec */
													interpreterProxy->stSizeOf(array)			/* nargs */,
													2											/* funcOffset*/,
													1											/* resultOffset */);
	if (errCode != 0) {
		return interpreterProxy->primitiveFailFor(errCode);
	}
	result = interpreterProxy->stackValue(1);
	interpreterProxy->popthenPush(3, result);
}


/*	Note: This is coded so that is can be run from Squeak. */

EXPORT(sqInt)
setInterpreter(struct VirtualMachine*anInterpreter)
{
    sqInt ok;

	interpreterProxy = anInterpreter;
	ok = interpreterProxy->majorVersion() == VM_PROXY_MAJOR;
	if (ok == 0) {
		return 0;
	}
	ok = interpreterProxy->minorVersion() >= VM_PROXY_MINOR;
	return ok;
}


/*	Answer the first field of rcvr which is assumed to be an Alien of at least
	8 bytes
 */

static sqInt
sizeField(sqInt rcvr)
{
	return longAt(rcvr + BaseHeaderSize);
}


/*	<byte indexable oop> ^<Integer> */
/*	Answer the start of rcvr's data, given that it is not an alien. */

static sqInt
startOfByteData(sqInt rcvr)
{
	return rcvr + BaseHeaderSize;
}


/*	<Alien oop> ^<Integer> */
/*	Answer the start of rcvr's data. For direct aliens this is the address of
	the second field. For indirect and pointer aliens it is what the second
	field points to. */

static sqInt
startOfData(sqInt rcvr)
{
	return ((longAt(rcvr + BaseHeaderSize)) > 0
		? (rcvr + BaseHeaderSize) + BytesPerOop
		: longAt((rcvr + BaseHeaderSize) + BytesPerOop));
}


/*	<Alien oop> */
/*	<Integer> ^<Integer> */
/*	Answer the start of rcvr's data. For direct aliens this is the address of
	the second field. For indirect and pointer aliens it is what the second
	field points to. */

static sqInt
startOfDatawithSize(sqInt rcvr, sqInt sizeField)
{
	return (sizeField > 0
		? (rcvr + BaseHeaderSize) + BytesPerOop
		: longAt((rcvr + BaseHeaderSize) + BytesPerOop));
}


#ifdef SQUEAK_BUILTIN_PLUGIN

void* IA32ABI_exports[][3] = {
	{"IA32ABI", "getModuleName", (void*)getModuleName},
	{"IA32ABI", "isAlien", (void*)isAlien},
	{"IA32ABI", "primAddressField", (void*)primAddressField},
	{"IA32ABI", "primAddressFieldPut", (void*)primAddressFieldPut},
	{"IA32ABI", "primAlienReplace", (void*)primAlienReplace},
	{"IA32ABI", "primAllocateExecutablePage", (void*)primAllocateExecutablePage},
	{"IA32ABI", "primBoxedFree", (void*)primBoxedFree},
	{"IA32ABI", "primCallOutDoubleReturn", (void*)primCallOutDoubleReturn},
	{"IA32ABI", "primCallOutFloatReturn", (void*)primCallOutFloatReturn},
	{"IA32ABI", "primCallOutIntegralReturn", (void*)primCallOutIntegralReturn},
	{"IA32ABI", "primCalloc", (void*)primCalloc},
	{"IA32ABI", "primDoubleAt", (void*)primDoubleAt},
	{"IA32ABI", "primDoubleAtPut", (void*)primDoubleAtPut},
	{"IA32ABI", "primFloatAt", (void*)primFloatAt},
	{"IA32ABI", "primFloatAtPut", (void*)primFloatAtPut},
	{"IA32ABI", "primFree", (void*)primFree},
	{"IA32ABI", "primInIOProcessEventsFlagAddress", (void*)primInIOProcessEventsFlagAddress},
	{"IA32ABI", "primInLibraryFindSymbol", (void*)primInLibraryFindSymbol},
	{"IA32ABI", "primLoadLibrary", (void*)primLoadLibrary},
	{"IA32ABI", "primMalloc", (void*)primMalloc},
	{"IA32ABI", "primReturnAsFromContextThrough", (void*)primReturnAsFromContextThrough},
	{"IA32ABI", "primReturnFromContextThrough", (void*)primReturnFromContextThrough},
	{"IA32ABI", "primSignedByteAt", (void*)primSignedByteAt},
	{"IA32ABI", "primSignedByteAtPut", (void*)primSignedByteAtPut},
	{"IA32ABI", "primSignedLongAt", (void*)primSignedLongAt},
	{"IA32ABI", "primSignedLongAtPut", (void*)primSignedLongAtPut},
	{"IA32ABI", "primSignedLongLongAt", (void*)primSignedLongLongAt},
	{"IA32ABI", "primSignedLongLongAtPut", (void*)primSignedLongLongAtPut},
	{"IA32ABI", "primSignedShortAt", (void*)primSignedShortAt},
	{"IA32ABI", "primSignedShortAtPut", (void*)primSignedShortAtPut},
	{"IA32ABI", "primSizeField", (void*)primSizeField},
	{"IA32ABI", "primSizeFieldPut", (void*)primSizeFieldPut},
	{"IA32ABI", "primStrlenFromStartIndex", (void*)primStrlenFromStartIndex},
	{"IA32ABI", "primStrlenThroughPointerAtIndex", (void*)primStrlenThroughPointerAtIndex},
	{"IA32ABI", "primThunkEntryAddress", (void*)primThunkEntryAddress},
	{"IA32ABI", "primUnsignedByteAt", (void*)primUnsignedByteAt},
	{"IA32ABI", "primUnsignedByteAtPut", (void*)primUnsignedByteAtPut},
	{"IA32ABI", "primUnsignedLongAt", (void*)primUnsignedLongAt},
	{"IA32ABI", "primUnsignedLongAtPut", (void*)primUnsignedLongAtPut},
	{"IA32ABI", "primUnsignedLongLongAt", (void*)primUnsignedLongLongAt},
	{"IA32ABI", "primUnsignedLongLongAtPut", (void*)primUnsignedLongLongAtPut},
	{"IA32ABI", "primUnsignedShortAt", (void*)primUnsignedShortAt},
	{"IA32ABI", "primUnsignedShortAtPut", (void*)primUnsignedShortAtPut},
	{"IA32ABI", "primVarArgsCallOutDoubleReturn", (void*)primVarArgsCallOutDoubleReturn},
	{"IA32ABI", "primVarArgsCallOutFloatReturn", (void*)primVarArgsCallOutFloatReturn},
	{"IA32ABI", "primVarArgsCallOutIntegralReturn", (void*)primVarArgsCallOutIntegralReturn},
	{"IA32ABI", "setInterpreter", (void*)setInterpreter},
	{NULL, NULL, NULL}
};

#endif /* ifdef SQ_BUILTIN_PLUGIN */
