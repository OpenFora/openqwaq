/* Automatically generated by
	SmartSyntaxPluginCodeGenerator VMMaker-eem.666 uuid: 4edd7d00-3db5-48ef-b579-5d95fae49120
   from
	QWebcamPlugin Qwaq-Plugins-jcg.108 uuid: be07d71f-9c53-4c06-8e16-66431a11bfe4
 */
static char __buildInfo[] = "QWebcamPlugin Qwaq-Plugins-jcg.108 uuid: be07d71f-9c53-4c06-8e16-66431a11bfe4 " __DATE__ ;




#include <math.h>
#include <stdio.h>
#include <stdlib.h>
#include <string.h>
#include <time.h>

/* Default EXPORT macro that does nothing (see comment in sq.h): */
#define EXPORT(returnType) returnType

/* Do not include the entire sq.h file but just those parts needed. */
/*  The virtual machine proxy definition */
#include "sqVirtualMachine.h"
/* Configuration options */
#include "sqConfig.h"
/* Platform specific definitions */
#include "sqPlatformSpecific.h"

#define true 1
#define false 0
#define null 0  /* using 'null' because nil is predefined in Think C */
#ifdef SQUEAK_BUILTIN_PLUGIN
#undef EXPORT
// was #undef EXPORT(returnType) but screws NorCroft cc
#define EXPORT(returnType) static returnType
#endif
#include "QWebcamPlugin.h"

#include "sqMemoryAccess.h"


/*** Constants ***/


/*** Function Prototypes ***/
static VirtualMachine * getInterpreter(void);
EXPORT(const char*) getModuleName(void);
static sqInt halt(void);
EXPORT(sqInt) initialiseModule(void);
static sqInt msg(char *s);
static sqInt oopFromString(char*cString);
EXPORT(sqInt) primitiveCameraAdjust(void);
EXPORT(sqInt) primitiveCameraGetParams(void);
EXPORT(sqInt) primitiveCameraIsValid(void);
EXPORT(sqInt) primitiveCameraName(void);
EXPORT(sqInt) primitiveCameraPause(void);
EXPORT(sqInt) primitiveCameraRun(void);
EXPORT(sqInt) primitiveCameraStop(void);
EXPORT(sqInt) primitiveCameraUID(void);
EXPORT(sqInt) primitiveCreateCamera(void);
EXPORT(sqInt) primitiveCreateCameraByUID(void);
EXPORT(sqInt) primitiveCreateFeedbackChannel(void);
EXPORT(sqInt) primitiveDestroyCamera(void);
EXPORT(sqInt) primitiveDestroyFeedbackChannel(void);
EXPORT(sqInt) primitiveFeedbackChannelPopEvent(void);
EXPORT(sqInt) primitiveFeedbackChannelReadEvent(void);
EXPORT(sqInt) primitiveFeedbackChannelSetLogging(void);
EXPORT(sqInt) primitiveGetCamDeviceIsBusy(void);
EXPORT(sqInt) primitiveGetCamDeviceName(void);
EXPORT(sqInt) primitiveGetCamDeviceUID(void);
EXPORT(sqInt) primitiveGetNumCamDevices(void);
EXPORT(sqInt) primitiveUtilReadIntoBitmap(void);
EXPORT(sqInt) setInterpreter(struct VirtualMachine*anInterpreter);
EXPORT(sqInt) shutdownModule(void);
static void sqAssert(sqInt aBool);
static void* stringFromOop(sqInt strOop);


/*** Variables ***/

#ifdef SQUEAK_BUILTIN_PLUGIN
extern
#endif
struct VirtualMachine* interpreterProxy;
static const char *moduleName =
#ifdef SQUEAK_BUILTIN_PLUGIN
	"QWebcamPlugin Qwaq-Plugins-jcg.108 (i)"
#else
	"QWebcamPlugin Qwaq-Plugins-jcg.108 (e)"
#endif
;



/*	Note: This is coded so that plugins can be run from Squeak. */

static VirtualMachine *
getInterpreter(void) {
	return interpreterProxy;
}


/*	Note: This is hardcoded so it can be run from Squeak.
	The module name is used for validating a module *after*
	it is loaded to check if it does really contain the module
	we're thinking it contains. This is important! */

EXPORT(const char*)
getModuleName(void) {
	return moduleName;
}

static sqInt
halt(void) {
	;
	return 0;
}

EXPORT(sqInt)
initialiseModule(void) {
	qInitModule();
	return 1;
}

static sqInt
msg(char *s) {
	fprintf(stderr, "\n%s: %s", moduleName, s);
	return 0;
}

static sqInt
oopFromString(char*cString) {
	sqInt result;
	char*dstPtr;
	sqInt i;
	sqInt sz;

	if (cString == null) {
		return interpreterProxy->nilObject();
	}
	sz = strlen(cString);
	result = interpreterProxy->instantiateClassindexableSize(interpreterProxy->classString(), sz);
	dstPtr = interpreterProxy->firstIndexableField(result);
	for (i = 0; i <= (sz - 1); i += 1) {
		dstPtr[i] = (cString[i]);
	}
	return result;
}


/*	Adjust the camera (frame rate, extent, etc.) */

EXPORT(sqInt)
primitiveCameraAdjust(void) {
	sqInt cameraIndex;
	char *cameraArgs;
	sqInt argsSize;

	cameraIndex = interpreterProxy->stackIntegerValue(2);
	interpreterProxy->success(interpreterProxy->isBytes(interpreterProxy->stackValue(1)));
	cameraArgs = ((char *) (interpreterProxy->firstIndexableField(interpreterProxy->stackValue(1))));
	argsSize = interpreterProxy->stackIntegerValue(0);
	if (interpreterProxy->failed()) {
		return null;
	}
	qCameraAdjust(cameraIndex, cameraArgs, argsSize);
	if (interpreterProxy->failed()) {
		return null;
	}
	interpreterProxy->pop(3);
	return null;
}


/*	Store a pointer to the camera's parameters into 'externalAddress' (or NULL
	if the camera is invalid). A return value of 0 means success; non-zero is
	an error code.
 */

EXPORT(sqInt)
primitiveCameraGetParams(void) {
	sqInt result;
	sqInt cameraIndex;
	char *externalAddress;
	sqInt _return_value;

	cameraIndex = interpreterProxy->stackIntegerValue(1);
	interpreterProxy->success(interpreterProxy->isBytes(interpreterProxy->stackValue(0)));
	externalAddress = ((char *) (interpreterProxy->firstIndexableField(interpreterProxy->stackValue(0))));
	if (interpreterProxy->failed()) {
		return null;
	}
	result = qCameraGetParams(cameraIndex, externalAddress);
	_return_value = interpreterProxy->integerObjectOf(result);
	if (interpreterProxy->failed()) {
		return null;
	}
	interpreterProxy->popthenPush(3, _return_value);
	return null;
}


/*	Answer true if the camera handle is valid, and false otherwise. */

EXPORT(sqInt)
primitiveCameraIsValid(void) {
	sqInt result;
	sqInt cameraIndex;
	sqInt _return_value;

	cameraIndex = interpreterProxy->stackIntegerValue(0);
	if (interpreterProxy->failed()) {
		return null;
	}
	result = qCameraIsValid(cameraIndex);
	if (result) {
		_return_value = interpreterProxy->trueObject();
		if (interpreterProxy->failed()) {
			return null;
		}
		interpreterProxy->popthenPush(2, _return_value);
		return null;
	}
	else {
		_return_value = interpreterProxy->falseObject();
		if (interpreterProxy->failed()) {
			return null;
		}
		interpreterProxy->popthenPush(2, _return_value);
		return null;
	}
}


/*	Answer the UTF-8 string identifying this camera to the user.
	The cameraIndex is the identifier for an open camera instance. */

EXPORT(sqInt)
primitiveCameraName(void) {
	sqInt result;
	sqInt cameraIndex;
	sqInt _return_value;

	cameraIndex = interpreterProxy->stackIntegerValue(0);
	if (interpreterProxy->failed()) {
		return null;
	}
	result = qCameraName(cameraIndex);
	_return_value = oopFromString(result);
	if (interpreterProxy->failed()) {
		return null;
	}
	interpreterProxy->popthenPush(2, _return_value);
	return null;
}


/*	Answer 0 for success and a negative value for error. */

EXPORT(sqInt)
primitiveCameraPause(void) {
	sqInt result;
	sqInt cameraIndex;
	sqInt _return_value;

	cameraIndex = interpreterProxy->stackIntegerValue(0);
	if (interpreterProxy->failed()) {
		return null;
	}
	result = qCameraPause(cameraIndex);
	_return_value = interpreterProxy->integerObjectOf(result);
	if (interpreterProxy->failed()) {
		return null;
	}
	interpreterProxy->popthenPush(2, _return_value);
	return null;
}


/*	Answer 0 for success and a negative value for error. */

EXPORT(sqInt)
primitiveCameraRun(void) {
	sqInt result;
	sqInt cameraIndex;
	sqInt _return_value;

	cameraIndex = interpreterProxy->stackIntegerValue(0);
	if (interpreterProxy->failed()) {
		return null;
	}
	result = qCameraRun(cameraIndex);
	_return_value = interpreterProxy->integerObjectOf(result);
	if (interpreterProxy->failed()) {
		return null;
	}
	interpreterProxy->popthenPush(2, _return_value);
	return null;
}


/*	Answer 0 for success and a negative value for error. */

EXPORT(sqInt)
primitiveCameraStop(void) {
	sqInt result;
	sqInt cameraIndex;
	sqInt _return_value;

	cameraIndex = interpreterProxy->stackIntegerValue(0);
	if (interpreterProxy->failed()) {
		return null;
	}
	result = qCameraStop(cameraIndex);
	_return_value = interpreterProxy->integerObjectOf(result);
	if (interpreterProxy->failed()) {
		return null;
	}
	interpreterProxy->popthenPush(2, _return_value);
	return null;
}


/*	Answer the string identifying this camera to the system,
	a string which persistently matches the value of the device-enumeration
	camDeviceUID. The cameraIndex is the identifier for an open camera
	instance.  */

EXPORT(sqInt)
primitiveCameraUID(void) {
	sqInt result;
	sqInt cameraIndex;
	sqInt _return_value;

	cameraIndex = interpreterProxy->stackIntegerValue(0);
	if (interpreterProxy->failed()) {
		return null;
	}
	result = qCameraUID(cameraIndex);
	_return_value = oopFromString(result);
	if (interpreterProxy->failed()) {
		return null;
	}
	interpreterProxy->popthenPush(2, _return_value);
	return null;
}


/*	Answers an integer that represents
	- the index of the newly created camera (if >= 0)
	- an error condition (if < 0) */

EXPORT(sqInt)
primitiveCreateCamera(void) {
	sqInt result;
	char *cameraArgs;
	sqInt argsSize;
	char *channelHandle;
	sqInt _return_value;

	interpreterProxy->success(interpreterProxy->isBytes(interpreterProxy->stackValue(2)));
	cameraArgs = ((char *) (interpreterProxy->firstIndexableField(interpreterProxy->stackValue(2))));
	argsSize = interpreterProxy->stackIntegerValue(1);
	interpreterProxy->success(interpreterProxy->isBytes(interpreterProxy->stackValue(0)));
	channelHandle = ((char *) (interpreterProxy->firstIndexableField(interpreterProxy->stackValue(0))));
	if (interpreterProxy->failed()) {
		return null;
	}
	result = qCreateCamera(cameraArgs, argsSize, channelHandle);
	_return_value = interpreterProxy->integerObjectOf(result);
	if (interpreterProxy->failed()) {
		return null;
	}
	interpreterProxy->popthenPush(4, _return_value);
	return null;
}


/*	Answers an integer that represents
	- the index of the newly created camera (if >= 0)
	- an error condition (if < 0) */

EXPORT(sqInt)
primitiveCreateCameraByUID(void) {
	char*suid;
	sqInt result;
	sqInt uidStringOrNil;
	char *cameraArgs;
	sqInt argsSize;
	char *channelHandle;
	sqInt _return_value;

	uidStringOrNil = interpreterProxy->stackValue(3);
	interpreterProxy->success(interpreterProxy->isBytes(interpreterProxy->stackValue(2)));
	cameraArgs = ((char *) (interpreterProxy->firstIndexableField(interpreterProxy->stackValue(2))));
	argsSize = interpreterProxy->stackIntegerValue(1);
	interpreterProxy->success(interpreterProxy->isBytes(interpreterProxy->stackValue(0)));
	channelHandle = ((char *) (interpreterProxy->firstIndexableField(interpreterProxy->stackValue(0))));
	if (interpreterProxy->failed()) {
		return null;
	}
	suid = stringFromOop(uidStringOrNil);
	result = qCreateCameraByUID(suid, cameraArgs, argsSize, channelHandle);
	_return_value = interpreterProxy->integerObjectOf(result);
	if (interpreterProxy->failed()) {
		return null;
	}
	interpreterProxy->popthenPush(5, _return_value);
	return null;
}


/*	Create a C++ FeedbackChannel object; stash a pointer to it in
	'externalAddress'. Answer 0 for success and a negative value for errors.
	If unsuccessful, the contents of 'externalAddress' will be unchanged. */

EXPORT(sqInt)
primitiveCreateFeedbackChannel(void) {
	sqInt result;
	char *externalAddress;
	sqInt semaphoreIndex;
	sqInt _return_value;

	interpreterProxy->success(interpreterProxy->isBytes(interpreterProxy->stackValue(1)));
	externalAddress = ((char *) (interpreterProxy->firstIndexableField(interpreterProxy->stackValue(1))));
	semaphoreIndex = interpreterProxy->stackIntegerValue(0);
	if (interpreterProxy->failed()) {
		return null;
	}
	result = qCreateFeedbackChannel(externalAddress, semaphoreIndex);
	_return_value = interpreterProxy->integerObjectOf(result);
	if (interpreterProxy->failed()) {
		return null;
	}
	interpreterProxy->popthenPush(3, _return_value);
	return null;
}

EXPORT(sqInt)
primitiveDestroyCamera(void) {
	sqInt result;
	sqInt cameraIndex;
	sqInt _return_value;

	cameraIndex = interpreterProxy->stackIntegerValue(0);
	if (interpreterProxy->failed()) {
		return null;
	}
	result = qDestroyCamera(cameraIndex);
	_return_value = interpreterProxy->integerObjectOf(result);
	if (interpreterProxy->failed()) {
		return null;
	}
	interpreterProxy->popthenPush(2, _return_value);
	return null;
}


/*	Destroy a C++ FeedbackChannel object. */

EXPORT(sqInt)
primitiveDestroyFeedbackChannel(void) {
	char *externalAddress;

	interpreterProxy->success(interpreterProxy->isBytes(interpreterProxy->stackValue(0)));
	externalAddress = ((char *) (interpreterProxy->firstIndexableField(interpreterProxy->stackValue(0))));
	if (interpreterProxy->failed()) {
		return null;
	}
	qDestroyFeedbackChannel(externalAddress);
	if (interpreterProxy->failed()) {
		return null;
	}
	interpreterProxy->pop(1);
	return null;
}


/*	Pop the frontmost event from the channel identified by 'externalAddress'. */

EXPORT(sqInt)
primitiveFeedbackChannelPopEvent(void) {
	char *externalAddress;

	interpreterProxy->success(interpreterProxy->isBytes(interpreterProxy->stackValue(0)));
	externalAddress = ((char *) (interpreterProxy->firstIndexableField(interpreterProxy->stackValue(0))));
	if (interpreterProxy->failed()) {
		return null;
	}
	qFeedbackChannelPopEvent(externalAddress);
	if (interpreterProxy->failed()) {
		return null;
	}
	interpreterProxy->pop(1);
	return null;
}


/*	Answer a newly-instantiated ByteArray describing the channel's next event,
	or nil if there is no next event (and also if the address is invalid).
	Note that the event stays in the channel until it is released via
	#primitiveFeedbackChannelPopEvent:. 
 */

EXPORT(sqInt)
primitiveFeedbackChannelReadEvent(void) {
	sqInt resultOop;
	char *externalAddress;

	interpreterProxy->success(interpreterProxy->isBytes(interpreterProxy->stackValue(0)));
	externalAddress = ((char *) (interpreterProxy->firstIndexableField(interpreterProxy->stackValue(0))));
	if (interpreterProxy->failed()) {
		return null;
	}
	resultOop = qFeedbackChannelReadEvent(externalAddress);
	if (interpreterProxy->failed()) {
		return null;
	}
	interpreterProxy->popthenPush(2, resultOop);
	return null;
}


/*	Turn logging on or off for the specified channel. */

EXPORT(sqInt)
primitiveFeedbackChannelSetLogging(void) {
	char *externalAddress;
	sqInt trueOrFalse;

	interpreterProxy->success(interpreterProxy->isBytes(interpreterProxy->stackValue(1)));
	externalAddress = ((char *) (interpreterProxy->firstIndexableField(interpreterProxy->stackValue(1))));
	trueOrFalse = interpreterProxy->booleanValueOf(interpreterProxy->stackValue(0));
	if (interpreterProxy->failed()) {
		return null;
	}
	qFeedbackChannelSetLogging(externalAddress, trueOrFalse);
	if (interpreterProxy->failed()) {
		return null;
	}
	interpreterProxy->pop(2);
	return null;
}


/*	Boolean, true if the given camera is in use by another application (if
	known). This will be used to disable the option of choosing the camera for
	web cam input.
	The devIndex is 0-based, allowable values 0..(primtiveGetNumCameras-1),
	where the most recent call to primitiveGetNumCameras prevails (and,
	c-side, caches the dev-info). */

EXPORT(sqInt)
primitiveGetCamDeviceIsBusy(void) {
	sqInt result;
	sqInt devIndex;
	sqInt _return_value;

	devIndex = interpreterProxy->stackIntegerValue(0);
	if (interpreterProxy->failed()) {
		return null;
	}
	result = qGetCamDeviceIsBusy(devIndex);
	if (result) {
		_return_value = interpreterProxy->trueObject();
		if (interpreterProxy->failed()) {
			return null;
		}
		interpreterProxy->popthenPush(2, _return_value);
		return null;
	}
	else {
		_return_value = interpreterProxy->falseObject();
		if (interpreterProxy->failed()) {
			return null;
		}
		interpreterProxy->popthenPush(2, _return_value);
		return null;
	}
}


/*	Answer the UTF-8 string identifying this device to the user,
	or nil if the camera is no longer known or usable.
	The devIndex is 0-based, allowable values 0..(primitiveGetNumCameras-1),
	where the most recent call to primitiveGetNumCameras prevails (and,
	c-side, caches the dev-info). */

EXPORT(sqInt)
primitiveGetCamDeviceName(void) {
	sqInt result;
	sqInt devIndex;
	sqInt _return_value;

	devIndex = interpreterProxy->stackIntegerValue(0);
	if (interpreterProxy->failed()) {
		return null;
	}

	/* BGF - not confident I don't need a further success-check before this, but it works at least. */

	result = qGetCamDeviceName(devIndex);
	_return_value = oopFromString(result);
	if (interpreterProxy->failed()) {
		return null;
	}
	interpreterProxy->popthenPush(2, _return_value);
	return null;
}


/*	Answer the string to use to identify this camera for use across
	application sessions;
	this string should be stable for the same device across distinct
	enumerations of cameras,
	and ideally be stable across application and computer restarts for use in
	preferences. The devIndex is 0-based, allowable values
	0..(primtiveGetNumCameras-1), where the most recent call to
	primitiveGetNumCameras prevails (and, c-side, caches the dev-info). */

EXPORT(sqInt)
primitiveGetCamDeviceUID(void) {
	sqInt result;
	sqInt devIndex;
	sqInt _return_value;

	devIndex = interpreterProxy->stackIntegerValue(0);
	if (interpreterProxy->failed()) {
		return null;
	}

	/* BGF - not confident I don't need a further success-check before this, but it works at least. */

	result = qGetCamDeviceUID(devIndex);
	_return_value = oopFromString(result);
	if (interpreterProxy->failed()) {
		return null;
	}
	interpreterProxy->popthenPush(2, _return_value);
	return null;
}


/*	Answer the number of web cam input devices known to the system, or
	negative on error.
	The plugin should cache a stable table of such devices at each call to
	this method.
 */

EXPORT(sqInt)
primitiveGetNumCamDevices(void) {
	sqInt result;
	sqInt _return_value;

	result = qGetNumCamDevices ();
	_return_value = interpreterProxy->integerObjectOf(result);
	if (interpreterProxy->failed()) {
		return null;
	}
	interpreterProxy->popthenPush(1, _return_value);
	return null;
}


/*	Read from the specified address into the bitmap.
	Defer to the glue code for the cipy as this allows a platform to indirect.
	e.g. the linux v4l-based code translates direct from the camera's mmap'ed
	buffers.  */

EXPORT(sqInt)
primitiveUtilReadIntoBitmap(void) {
	sqInt destPtr;
	char *bufferAddress;
	sqInt bitmap;
	sqInt bufferSize;

	interpreterProxy->success(interpreterProxy->isBytes(interpreterProxy->stackValue(2)));
	bufferAddress = ((char *) (interpreterProxy->firstIndexableField(interpreterProxy->stackValue(2))));
	interpreterProxy->success(interpreterProxy->isKindOf(interpreterProxy->stackValue(1), "Bitmap"));
	bitmap = interpreterProxy->stackValue(1);
	bufferSize = interpreterProxy->stackIntegerValue(0);
	if (interpreterProxy->failed()) {
		return null;
	}
	destPtr = ((char*) (interpreterProxy->firstIndexableField(bitmap)));
	qCopyBufferToBitmap(destPtr, bufferAddress, bufferSize);
	if (interpreterProxy->failed()) {
		return null;
	}
	interpreterProxy->pop(3);
	return null;
}


/*	Note: This is coded so that is can be run from Squeak. */

EXPORT(sqInt)
setInterpreter(struct VirtualMachine*anInterpreter) {
	sqInt ok;

	interpreterProxy = anInterpreter;
	ok = interpreterProxy->majorVersion() == VM_PROXY_MAJOR;
	if (ok == 0) {
		return 0;
	}
	ok = interpreterProxy->minorVersion() >= VM_PROXY_MINOR;
	return ok;
}

EXPORT(sqInt)
shutdownModule(void) {
	qShutdownModule();
	return 1;
}

static void
sqAssert(sqInt aBool) {
	/* missing DebugCode */;
}


/*	Make a terminated c-string from the given (String or nil) oop - return
	NULL if not bytes.
	Once per primitive! - Uses a static buffer. */

static void*
stringFromOop(sqInt strOop) {
	static char strBuf[1024];
	sqInt i;
	char*srcPtr;
	sqInt sz;

	;
	if (!(interpreterProxy->isBytes(strOop))) {
		return null;
	}
	sz = interpreterProxy->byteSizeOf(strOop);
	if (!(sz < 1024)) {
		return null;
	}
	srcPtr = interpreterProxy->firstIndexableField(strOop);
	for (i = 0; i <= (sz - 1); i += 1) {
		strBuf[i] = (srcPtr[i]);
	}
	strBuf[sz] = 0;
	return strBuf;
}


#ifdef SQUEAK_BUILTIN_PLUGIN

void* QWebcamPlugin_exports[][3] = {
	{"QWebcamPlugin", "getModuleName", (void*)getModuleName},
	{"QWebcamPlugin", "initialiseModule", (void*)initialiseModule},
	{"QWebcamPlugin", "primitiveCameraAdjust", (void*)primitiveCameraAdjust},
	{"QWebcamPlugin", "primitiveCameraGetParams", (void*)primitiveCameraGetParams},
	{"QWebcamPlugin", "primitiveCameraIsValid", (void*)primitiveCameraIsValid},
	{"QWebcamPlugin", "primitiveCameraName", (void*)primitiveCameraName},
	{"QWebcamPlugin", "primitiveCameraPause", (void*)primitiveCameraPause},
	{"QWebcamPlugin", "primitiveCameraRun", (void*)primitiveCameraRun},
	{"QWebcamPlugin", "primitiveCameraStop", (void*)primitiveCameraStop},
	{"QWebcamPlugin", "primitiveCameraUID", (void*)primitiveCameraUID},
	{"QWebcamPlugin", "primitiveCreateCamera", (void*)primitiveCreateCamera},
	{"QWebcamPlugin", "primitiveCreateCameraByUID", (void*)primitiveCreateCameraByUID},
	{"QWebcamPlugin", "primitiveCreateFeedbackChannel", (void*)primitiveCreateFeedbackChannel},
	{"QWebcamPlugin", "primitiveDestroyCamera", (void*)primitiveDestroyCamera},
	{"QWebcamPlugin", "primitiveDestroyFeedbackChannel", (void*)primitiveDestroyFeedbackChannel},
	{"QWebcamPlugin", "primitiveFeedbackChannelPopEvent", (void*)primitiveFeedbackChannelPopEvent},
	{"QWebcamPlugin", "primitiveFeedbackChannelReadEvent", (void*)primitiveFeedbackChannelReadEvent},
	{"QWebcamPlugin", "primitiveFeedbackChannelSetLogging", (void*)primitiveFeedbackChannelSetLogging},
	{"QWebcamPlugin", "primitiveGetCamDeviceIsBusy", (void*)primitiveGetCamDeviceIsBusy},
	{"QWebcamPlugin", "primitiveGetCamDeviceName", (void*)primitiveGetCamDeviceName},
	{"QWebcamPlugin", "primitiveGetCamDeviceUID", (void*)primitiveGetCamDeviceUID},
	{"QWebcamPlugin", "primitiveGetNumCamDevices", (void*)primitiveGetNumCamDevices},
	{"QWebcamPlugin", "primitiveUtilReadIntoBitmap", (void*)primitiveUtilReadIntoBitmap},
	{"QWebcamPlugin", "setInterpreter", (void*)setInterpreter},
	{"QWebcamPlugin", "shutdownModule", (void*)shutdownModule},
	{NULL, NULL, NULL}
};

#endif /* ifdef SQ_BUILTIN_PLUGIN */
