/* Automatically generated by
	VMPluginCodeGenerator VMMaker-eem.673 uuid: d1addb33-5fc7-47e9-a2f6-40dc2215fc4a
   from
	ThreadedIA32FFIPlugin VMMaker-eem.673 uuid: d1addb33-5fc7-47e9-a2f6-40dc2215fc4a
 */
static char __buildInfo[] = "ThreadedIA32FFIPlugin VMMaker-eem.673 uuid: d1addb33-5fc7-47e9-a2f6-40dc2215fc4a " __DATE__ ;



#include <math.h>
#include <stdio.h>
#include <stdlib.h>
#include <string.h>
#include <time.h>

/* Default EXPORT macro that does nothing (see comment in sq.h): */
#define EXPORT(returnType) returnType

/* Do not include the entire sq.h file but just those parts needed. */
/*  The virtual machine proxy definition */
#include "sqVirtualMachine.h"
/* Configuration options */
#include "sqConfig.h"
/* Platform specific definitions */
#include "sqPlatformSpecific.h"

#define true 1
#define false 0
#define null 0  /* using 'null' because nil is predefined in Think C */
#ifdef SQUEAK_BUILTIN_PLUGIN
#undef EXPORT
// was #undef EXPORT(returnType) but screws NorCroft cc
#define EXPORT(returnType) static returnType
#endif

#include "sqMemoryAccess.h"


#include "sqAssert.h" /* for assert */
#undef halt /* sqAssert.h provides a halt used in the interpreter */

#ifdef _MSC_VER
# define alloca _alloca
#endif
#if defined(__GNUC__) && (defined(_X86_) || defined(i386) || defined(__i386) || defined(__i386__))
# define setsp(sp) asm volatile ("movl %0,%%esp" : : "m"(sp))
# define getsp() ({ void *esp; asm volatile ("movl %%esp,%0" : "=r"(esp) : ); esp;})
#endif
#if !defined(getsp)
# define getsp() 0
#endif 
#if !defined(setsp)
# define setsp(ignored) 0
#endif 

#if !defined(STACK_ALIGN_BYTES)
# if __APPLE__ && __MACH__ && __i386__
#  define STACK_ALIGN_BYTES 16
# elif __linux__ && __i386__
#  define STACK_ALIGN_BYTES 16
# elif defined(__amd64__) || defined(__x86_64__) ||  defined(__amd64) || defined(__x86_64)
#  define STACK_ALIGN_BYTES 16
# elif defined(powerpc) || defined(__powerpc__) || defined(_POWER) || defined(__POWERPC__) || defined(__PPC__)
#  define STACK_ALIGN_BYTES 16
# elif defined(__sparc64__) || defined(__sparcv9__) || defined(__sparc_v9__) /* must preceed 32-bit sparc defs */
#  define STACK_ALIGN_BYTES 16
# elif defined(sparc) || defined(__sparc__) || defined(__sparclite__)
#  define STACK_ALIGN_BYTES 8
# else
#  define STACK_ALIGN_BYTES 0
# endif
#endif /* !defined(STACK_ALIGN_BYTES) */

#if !defined(STACK_OFFSET_BYTES)
# define STACK_OFFSET_BYTES 0
#endif

#if defined(_X86_) || defined(i386) || defined(__i386) || defined(__i386__)
/* Both Mac OS X x86 and Win32 x86 return structs of a power of two in size
 * less than or equal to eight bytes in length in registers. Linux never does so.
 */
# if __linux__
#	define WIN32_X86_STRUCT_RETURN 0
# else
#	define WIN32_X86_STRUCT_RETURN 1
# endif
# if WIN32
#	define PLATFORM_API_USES_CALLEE_POPS_CONVENTION 1
# else
#	define PLATFORM_API_USES_CALLEE_POPS_CONVENTION 0
# endif
# if defined(__MINGW32__) && (__GNUC__ >= 3)
    /*
     * cygwin -mno-cygwin (MinGW) gcc 3.4.x's alloca is a library routine that answers
     * %esp + 4, so the outgoing stack is offset by one word if uncorrected.
     * Grab the actual stack pointer to correct.
     */
#	define ALLOCA_LIES_SO_USE_GETSP 1
# endif
#endif /* defined(_X86_) || defined(i386) || defined(__i386) || defined(__i386__) */

#if !defined(ALLOCA_LIES_SO_USE_GETSP)
# define ALLOCA_LIES_SO_USE_GETSP 0
#endif

/* The dispatchOn:in:with:with: generates an unwanted call on error.  Just squash it. */
#define error(foo) 0

/* but print assert failures. */
void
warning(char *s) { /* Print an error message but don't exit. */
	printf("\n%s\n", s);
}

typedef struct {
	char *argVector;
	char *currentArg;
	char *limit;
	sqInt	structReturnSize;
	sqInt	callFlags;
	void *ffiArgSpec;
	sqInt	ffiArgSpecSize;
	sqInt	ffiArgHeader;
	sqInt	ffiRetHeader;
	sqInt	stringArgIndex;
	char *stringArgs[15];
 } CalloutState;

#define ThreadedFFICalloutState CalloutState



/*** Constants ***/
#define BaseHeaderSize 4
#define BytesPerOop 4
#define DefaultMaxStackSize 16384
#define ExternalFunctionArgTypesIndex 2
#define ExternalFunctionFlagsIndex 1
#define ExternalFunctionStackSizeIndex 3
#define FFIAtomicTypeMask 0xF000000
#define FFIAtomicTypeShift 24
#define FFICallFlagThreaded 0x100
#define FFICallTypeApi 1
#define FFIErrorAddressNotFound 13
#define FFIErrorAttemptToPassVoid 14
#define FFIErrorBadAddress 11
#define FFIErrorBadArg 3
#define FFIErrorBadArgs 2
#define FFIErrorBadAtomicType 5
#define FFIErrorBadExternalFunction 17
#define FFIErrorBadExternalLibrary 16
#define FFIErrorBadReturn 10
#define FFIErrorCallFrameTooBig 19
#define FFIErrorCallType 9
#define FFIErrorCoercionFailed 6
#define FFIErrorIntAsPointer 4
#define FFIErrorInvalidPointer 18
#define FFIErrorModuleNotFound 15
#define FFIErrorNoModule 12
#define FFIErrorNotFunction 1
#define FFIErrorStructSize 8
#define FFIErrorWrongType 7
#define FFIFlagAtomic 0x40000
#define FFIFlagPointer 0x20000
#define FFIFlagStructure 0x10000
#define FFINoCalloutAvailable -1
#define FFIStructSizeMask 0xFFFF
#define FFITypeBool 1
#define FFITypeDoubleFloat 13
#define FFITypeSignedByte 3
#define FFITypeSignedChar 11
#define FFITypeSignedInt 7
#define FFITypeSignedLongLong 9
#define FFITypeSignedShort 5
#define FFITypeSingleFloat 12
#define FFITypeUnsignedByte 2
#define FFITypeVoid 0
#define MaxNumArgs 15
#define PrimErrBadArgument 3
#define PrimErrBadMethod 12
#define PrimErrBadNumArgs 5
#define PrimErrBadReceiver 2
#define PrimErrNoCMemory 10
#define PrimErrObjectMayMove 14


/*** Function Prototypes ***/
static sqInt atomicTypeOf(sqInt typeSpec);
static void cleanupCalloutState(CalloutState *calloutState);
static sqInt externalFunctionHasStackSizeSlot(void);
static sqInt ffiAddressOfstartingAtsize(sqInt rcvr, sqInt byteOffset, sqInt byteSize);
static sqInt ffiArgByValuein(sqInt oop, CalloutState *calloutState);
static sqInt ffiArgumentSpecClassin(sqInt oop, sqInt argSpec, sqInt argClass, CalloutState *calloutState);
static sqInt ffiAtomicArgByReferenceClassin(sqInt oop, sqInt oopClass, CalloutState *calloutState);
static sqInt ffiAtomicStructByReferenceClassin(sqInt oop, sqInt oopClass, CalloutState *calloutState);
static sqInt ffiCalloutToSpecOnStackin(void *procAddr, sqInt specOnStack, CalloutState *calloutState);
static sqInt ffiCallArgArrayOrNilNumArgs(sqInt externalFunction, sqInt argArrayOrNil, sqInt nArgs);
static sqInt ffiCheckReturnWithin(sqInt retSpec, sqInt retClass, CalloutState *calloutState);
static sqInt ffiContentsOfHandleerrCode(sqInt oop, sqInt errCode);
static sqInt ffiCreateIntegralResultOopofAtomicTypein(usqLong retVal, sqInt atomicType, CalloutState *calloutState);
static sqInt ffiFail(sqInt reason);
static double ffiFloatValueOf(sqInt oop);
static sqInt ffiIntegerValueOf(sqInt oop);
static sqInt ffiLoadCalloutAddressFrom(sqInt oop);
static sqInt ffiLoadCalloutAddress(sqInt lit);
static sqInt ffiLoadCalloutModule(sqInt module);
static void ffiLogCallout(sqInt lit);
EXPORT(sqInt) ffiLogCallsTo(char*fileName);
static sqInt ffiPushDoubleFloatin(double value, CalloutState *calloutState);
static sqInt ffiPushPointerContentsOfin(sqInt oop, CalloutState *calloutState);
static sqInt ffiPushPointerin(void *pointer, CalloutState *calloutState);
static sqInt ffiPushSignedBytein(sqInt value, CalloutState *calloutState);
static sqInt ffiPushSignedCharin(sqInt value, CalloutState *calloutState);
static sqInt ffiPushSignedIntin(sqInt value, CalloutState *calloutState);
static sqInt ffiPushSignedLongLongOopin(sqInt oop, CalloutState *calloutState);
static sqInt ffiPushSignedLongLongin(usqLong value, CalloutState *calloutState);
static sqInt ffiPushSignedShortin(sqInt value, CalloutState *calloutState);
static sqInt ffiPushSingleFloatin(float value, CalloutState *calloutState);
static sqInt ffiPushStringOfLengthin(char *pointer, sqInt length, CalloutState *calloutState);
static sqInt ffiPushStructureContentsOfin(sqInt oop, CalloutState *calloutState);
static sqInt ffiPushStructureofSizetypeSpecofLengthin(void *pointer, sqInt structSize, sqInt *argSpec, sqInt argSpecSize, CalloutState *calloutState);
static sqInt ffiPushUnsignedBytein(sqInt value, CalloutState *calloutState);
static sqInt ffiPushUnsignedCharin(sqInt value, CalloutState *calloutState);
static sqInt ffiPushUnsignedIntin(sqInt value, CalloutState *calloutState);
static sqInt ffiPushUnsignedLongLongOopin(sqInt oop, CalloutState *calloutState);
static sqInt ffiPushUnsignedLongLongin(usqLong value, CalloutState *calloutState);
static sqInt ffiPushUnsignedShortin(sqInt value, CalloutState *calloutState);
static sqInt ffiPushVoidin(sqInt ignored, CalloutState *calloutState);
static sqInt ffiReturnCStringFrom(sqInt cPointer);
static sqInt ffiReturnPointerofTypein(usqLong retVal, sqInt retType, CalloutState *calloutState);
static sqInt ffiReturnStructofTypein(usqLong longLongRet, sqInt ffiRetType, CalloutState *calloutState);
static sqInt ffiReturnType(sqInt specOnStack);
static sqInt ffiSupportsCallingConvention(sqInt aCallingConvention);
static sqInt ffiValidateExternalDataAtomicType(sqInt oop, sqInt atomicType);
static VirtualMachine * getInterpreter(void);
EXPORT(const char*) getModuleName(void);
static sqInt halt(void);
EXPORT(sqInt) initialiseModule(void);
static sqInt isAlien(sqInt anOop);
static sqInt isAtomicType(sqInt typeSpec);
static sqInt isDirectAlien(sqInt oop);
static sqInt msg(char *s);
static sqInt nonRegisterStructReturnIsViaImplicitFirstArgument(void);
EXPORT(void) primitiveCallout(void);
EXPORT(void) primitiveCalloutWithArgs(void);
EXPORT(sqInt) primitiveCreateManualSurface(void);
EXPORT(sqInt) primitiveDestroyManualSurface(void);
EXPORT(sqInt) primitiveFFIAllocate(void);
EXPORT(sqInt) primitiveFFIDoubleAt(void);
EXPORT(sqInt) primitiveFFIDoubleAtPut(void);
EXPORT(sqInt) primitiveFFIFloatAt(void);
EXPORT(sqInt) primitiveFFIFloatAtPut(void);
EXPORT(sqInt) primitiveFFIFree(void);
EXPORT(sqInt) primitiveFFIGetLastError(void);
EXPORT(sqInt) primitiveFFIIntegerAt(void);
EXPORT(sqInt) primitiveFFIIntegerAtPut(void);
EXPORT(sqInt) primitiveForceLoad(void);
EXPORT(sqInt) primitiveLogCallsTo(void);
EXPORT(sqInt) primitiveSetManualSurfacePointer(void);
static sqInt registerArgsSlop(void);
EXPORT(sqInt) setInterpreter(struct VirtualMachine*anInterpreter);
static sqInt sizeField(sqInt oop);
static sqInt startOfData(sqInt oop);


/*** Variables ***/
static sqInt externalFunctionInstSize;
static sqInt ffiLastError;
static sqInt ffiLogEnabled;

#ifdef SQUEAK_BUILTIN_PLUGIN
extern
#endif
struct VirtualMachine* interpreterProxy;
static const char *moduleName =
#ifdef SQUEAK_BUILTIN_PLUGIN
	"SqueakFFIPrims VMMaker-eem.673 (i)"
#else
	"SqueakFFIPrims VMMaker-eem.673 (e)"
#endif
;


/*** Macros ***/
#define allocaLiesSoUseGetsp() ALLOCA_LIES_SO_USE_GETSP
#define cStackAlignment() STACK_ALIGN_BYTES
#define dispatchFunctionPointer(aFunctionPointer) (aFunctionPointer)()
#define ffiAlloc(bytes) (usqInt)malloc(bytes)
#define ffiFree(pointer) free((void *)(pointer))
#define isCalleePopsConvention(callType) (PLATFORM_API_USES_CALLEE_POPS_CONVENTION && (callType) == FFICallTypeApi)
#define returnStructInRegisters(sz) (WIN32_X86_STRUCT_RETURN && (sz) <= 8 && !((sz)&((sz)-1)))


static sqInt
atomicTypeOf(sqInt typeSpec) {
	return ((usqInt) (typeSpec & FFIAtomicTypeMask)) >> FFIAtomicTypeShift;
}


/*	Free any temporary arg strings. */

static void
cleanupCalloutState(CalloutState *calloutState) {
	while (((calloutState->stringArgIndex)) > 0) {
		free(((calloutState->stringArgs))[(calloutState->stringArgIndex = ((calloutState->stringArgIndex)) - 1)]);
	}
}

static sqInt
externalFunctionHasStackSizeSlot(void) {
	return externalFunctionInstSize > ExternalFunctionStackSizeIndex;
}


/*	return an int of the address of the byteSize slot (byte, short, int,
	whatever) at byteOffset in rcvr. Nominally intended for use with
	ExternalAddress objects, this code will work (for obscure historical
	reasons) with plain Byte or Word Arrays as well.
 */

static sqInt
ffiAddressOfstartingAtsize(sqInt rcvr, sqInt byteOffset, sqInt byteSize) {
    sqInt addr;
    sqInt rcvrClass;
    sqInt rcvrSize;

	if (!(interpreterProxy->isBytes(rcvr))) {
		return interpreterProxy->primitiveFail();
	}
	if (!(byteOffset > 0)) {
		return interpreterProxy->primitiveFail();
	}
	rcvrClass = interpreterProxy->fetchClassOf(rcvr);
	rcvrSize = interpreterProxy->byteSizeOf(rcvr);
	if (rcvrClass == (interpreterProxy->classExternalAddress())) {
		if (!(rcvrSize == 4)) {
			return interpreterProxy->primitiveFail();
		}

		/* don't you dare to read from object memory! */

		addr = interpreterProxy->fetchPointerofObject(0, rcvr);
		if ((addr == 0)
		 || (interpreterProxy->isInMemory(addr))) {
			return interpreterProxy->primitiveFail();
		}
	}
	else {
		if (!(((byteOffset + byteSize) - 1) <= rcvrSize)) {
			return interpreterProxy->primitiveFail();
		}
		addr = ((int) (interpreterProxy->firstIndexableField(rcvr)));
	}
	addr = (addr + byteOffset) - 1;
	return addr;
}


/*	Support for generic callout. Prepare an argument by value for a callout. */

static sqInt
ffiArgByValuein(sqInt oop, CalloutState *calloutState) {
    sqInt atomicType;
    double floatValue;
    sqInt intValue;
    sqInt oopClass;
    sqInt oopClass1;
    sqInt typeSpec;

	/* begin atomicTypeOf: */
	typeSpec = (calloutState->ffiArgHeader);
	atomicType = ((usqInt) (typeSpec & FFIAtomicTypeMask)) >> FFIAtomicTypeShift;
	if ((atomicType < 0)
	 || (atomicType > FFITypeDoubleFloat)) {
		return FFIErrorBadAtomicType;
	}
	if (atomicType < FFITypeSingleFloat) {
		if ((((usqInt) atomicType) >> 1) == (((usqInt) FFITypeSignedLongLong) >> 1)) {

			/* integer types */
			/* ffi support code must coerce longlong */

			intValue = oop;
		}
		else {
			/* begin ffiIntegerValueOf: */
			if ((oop & 1)) {
				intValue = (oop >> 1);
				goto l1;
			}
			if (oop == (interpreterProxy->nilObject())) {
				intValue = 0;
				goto l1;
			}
			if (oop == (interpreterProxy->falseObject())) {
				intValue = 0;
				goto l1;
			}
			if (oop == (interpreterProxy->trueObject())) {
				intValue = 1;
				goto l1;
			}
			oopClass = interpreterProxy->fetchClassOf(oop);
			if (oopClass == (interpreterProxy->classFloat())) {
				intValue = ((sqInt)(interpreterProxy->floatValueOf(oop)));
				goto l1;
			}
			if (oopClass == (interpreterProxy->classCharacter())) {
				intValue = interpreterProxy->fetchIntegerofObject(0, oop);
				goto l1;
			}
			if (oopClass == (interpreterProxy->classLargePositiveInteger())) {
				intValue = interpreterProxy->positive32BitValueOf(oop);
				goto l1;
			}
			intValue = interpreterProxy->signed32BitValueOf(oop);
		l1:	/* end ffiIntegerValueOf: */;
		}
		if (interpreterProxy->failed()) {
			return FFIErrorCoercionFailed;
		}
		
		switch (atomicType) {
		case 0:
			return FFIErrorAttemptToPassVoid;
		case 1:
			return ffiPushUnsignedIntin(intValue, calloutState);
		case 2:
			return ffiPushUnsignedBytein(intValue, calloutState);
		case 3:
			return ffiPushSignedBytein(intValue, calloutState);
		case 4:
			return ffiPushUnsignedShortin(intValue, calloutState);
		case 5:
			return ffiPushSignedShortin(intValue, calloutState);
		case 6:
			return ffiPushUnsignedIntin(intValue, calloutState);
		case 7:
			return ffiPushSignedIntin(intValue, calloutState);
		case 8:
			return ffiPushUnsignedLongLongOopin(intValue, calloutState);
		case 9:
			return ffiPushSignedLongLongOopin(intValue, calloutState);
		case 10:
			return ffiPushUnsignedCharin(intValue, calloutState);
		case 11:
			return ffiPushSignedCharin(intValue, calloutState);

		default:
			error("Case not found");
			return -1;
		}
	}
	/* begin ffiFloatValueOf: */
	oopClass1 = interpreterProxy->fetchClassOf(oop);
	if (oopClass1 == (interpreterProxy->classFloat())) {
		floatValue = interpreterProxy->floatValueOf(oop);
		goto l2;
	}
	floatValue = ((double) (ffiIntegerValueOf(oop)) );
l2:	/* end ffiFloatValueOf: */;
	if (interpreterProxy->failed()) {
		return FFIErrorCoercionFailed;
	}
	if (atomicType == FFITypeSingleFloat) {
		/* begin ffiPushSingleFloat:in: */
		if ((((calloutState->currentArg)) + 4) > ((calloutState->limit))) {
			return FFIErrorCallFrameTooBig;
		}
		storeSingleFloatAtPointerfrom((calloutState->currentArg), floatValue);
		(calloutState->currentArg = ((calloutState->currentArg)) + 4);
		return 0;
	}
	else {
		/* begin ffiPushDoubleFloat:in: */
		if ((((calloutState->currentArg)) + 8) > ((calloutState->limit))) {
			return FFIErrorCallFrameTooBig;
		}
		storeFloatAtPointerfrom((calloutState->currentArg), floatValue);
		(calloutState->currentArg = ((calloutState->currentArg)) + 8);
		return 0;
	}
}


/*	Callout support. Prepare the given oop as argument.
	argSpec defines the compiled spec for the argument.
	argClass (if non-nil) defines the required (super)class for the argument. */

static sqInt
ffiArgumentSpecClassin(sqInt oop, sqInt argSpec, sqInt argClass, CalloutState *calloutState) {
    sqInt *argSpec1;
    sqInt *argSpec2;
    sqInt argSpecSize;
    sqInt argSpecSize1;
    sqInt atomicType;
    sqInt atomicType1;
    sqInt atomicType2;
    char *copy;
    sqInt err;
    double floatValue;
    sqInt intValue;
    sqInt isAlien;
    sqInt isString;
    sqInt isStruct;
    sqInt length;
    sqInt nilOop;
    sqInt oopClass;
    sqInt oopClass1;
    sqInt oopClass2;
    char *pointer;
    void *pointer1;
    void *pointer2;
    void *pointer3;
    sqInt ptrAddress;
    sqInt ptrClass;
    sqInt ptrType;
    sqInt roundedSize;
    sqInt roundedSize1;
    sqInt spec;
    sqInt specOop;
    sqInt specType;
    sqInt structSize;
    sqInt structSize1;
    sqInt typeSpec;
    sqInt typeSpec1;
    sqInt typeSpec2;
    sqInt valueOop;
    sqInt valueOop1;


	/* Prefetch class (we'll need it) */

	oopClass = interpreterProxy->fetchClassOf(oop);

	/* Do the necessary type checks */

	nilOop = interpreterProxy->nilObject();
	if (!(argClass == nilOop)) {
		if (!(interpreterProxy->includesBehaviorThatOf(argClass, interpreterProxy->classExternalStructure()))) {
			return FFIErrorWrongType;
		}
		if (!((nilOop == oop)
			 || (interpreterProxy->includesBehaviorThatOf(oopClass, argClass)))) {
			return FFIErrorCoercionFailed;
		}
	}
	isStruct = 0;
	if (!(((oop & 1))
		 || (oop == nilOop))) {
		if (interpreterProxy->isPointers(oop)) {

			/* #isPointers: will fail if oop is SmallInteger so don't even attempt to use it */

			isStruct = interpreterProxy->includesBehaviorThatOf(oopClass, interpreterProxy->classExternalStructure());
			if (!((argClass == nilOop)
				 || (isStruct))) {
				return FFIErrorCoercionFailed;
			}
		}
	}
	if (isStruct) {
		valueOop = interpreterProxy->fetchPointerofObject(0, oop);
	}
	else {
		valueOop = oop;
	}
	if ((argSpec & 1)) {
		return FFIErrorWrongType;
	}
	if (!(interpreterProxy->isWords(argSpec))) {
		return FFIErrorWrongType;
	}
	(calloutState->ffiArgSpecSize = interpreterProxy->slotSizeOf(argSpec));
	if (((calloutState->ffiArgSpecSize)) == 0) {
		return FFIErrorWrongType;
	}
	(calloutState->ffiArgSpec = interpreterProxy->firstIndexableField(argSpec));
	(calloutState->ffiArgHeader = longAt((calloutState->ffiArgSpec)));
	if (((calloutState->ffiArgHeader)) & FFIFlagStructure) {
		if (!(isStruct)) {
			return FFIErrorCoercionFailed;
		}
		if (((calloutState->ffiArgHeader)) & FFIFlagAtomic) {
			return FFIErrorWrongType;
		}
		/* begin ffiPushStructureContentsOf:in: */
		ptrClass = interpreterProxy->fetchClassOf(valueOop);
		if (ptrClass == (interpreterProxy->classExternalAddress())) {

			/* ExternalAddress is bytes */
			/* There is no way we can make sure the structure is valid.
		But we can at least check for attempts to pass pointers to ST memory. */

			ptrAddress = interpreterProxy->fetchPointerofObject(0, valueOop);
			if (interpreterProxy->isInMemory(ptrAddress)) {
				return FFIErrorInvalidPointer;
			}
			/* begin ffiPushStructure:ofSize:typeSpec:ofLength:in: */
			structSize = ((calloutState->ffiArgHeader)) & FFIStructSizeMask;
			argSpec2 = (calloutState->ffiArgSpec);
			argSpecSize = (calloutState->ffiArgSpecSize);
			roundedSize = (structSize + 3) & (~3);
			if ((((calloutState->currentArg)) + roundedSize) > ((calloutState->limit))) {
				return FFIErrorCallFrameTooBig;
			}
			memcpy((calloutState->currentArg), ((void *) ptrAddress), structSize);
			(calloutState->currentArg = ((calloutState->currentArg)) + roundedSize);
			return 0;
		}
		if (ptrClass == (interpreterProxy->classByteArray())) {
			if (!((interpreterProxy->byteSizeOf(valueOop)) == (((calloutState->ffiArgHeader)) & FFIStructSizeMask))) {
				return FFIErrorStructSize;
			}
			ptrAddress = ((int) (interpreterProxy->firstIndexableField(valueOop)));
			if (!(((calloutState->ffiArgHeader)) & FFIFlagPointer)) {
				if ((((calloutState->callFlags)) & FFICallFlagThreaded)
				 && (interpreterProxy->isYoung(valueOop))) {
					return -PrimErrObjectMayMove;
				}
				/* begin ffiPushStructure:ofSize:typeSpec:ofLength:in: */
				structSize1 = ((calloutState->ffiArgHeader)) & FFIStructSizeMask;
				argSpec1 = (calloutState->ffiArgSpec);
				argSpecSize1 = (calloutState->ffiArgSpecSize);
				roundedSize1 = (structSize1 + 3) & (~3);
				if ((((calloutState->currentArg)) + roundedSize1) > ((calloutState->limit))) {
					return FFIErrorCallFrameTooBig;
				}
				memcpy((calloutState->currentArg), ((void *) ptrAddress), structSize1);
				(calloutState->currentArg = ((calloutState->currentArg)) + roundedSize1);
				return 0;
			}
			if (!((((calloutState->ffiArgHeader)) & FFIStructSizeMask) == 4)) {
				return FFIErrorStructSize;
			}
			ptrAddress = interpreterProxy->fetchPointerofObject(0, valueOop);
			if (interpreterProxy->isInMemory(ptrAddress)) {
				return FFIErrorInvalidPointer;
			}
			/* begin ffiPushPointer:in: */
			if ((((calloutState->currentArg)) + 4) > ((calloutState->limit))) {
				return FFIErrorCallFrameTooBig;
			}
			longAtput((calloutState->currentArg), ptrAddress);
			(calloutState->currentArg = ((calloutState->currentArg)) + 4);
			return 0;
		}
		return FFIErrorBadArg;
	}
	if (((calloutState->ffiArgHeader)) & FFIFlagPointer) {
		if ((oop & 1)) {
			return FFIErrorIntAsPointer;
		}
		if (oop == (interpreterProxy->nilObject())) {
			/* begin ffiPushPointer:in: */
			if ((((calloutState->currentArg)) + 4) > ((calloutState->limit))) {
				return FFIErrorCallFrameTooBig;
			}
			longAtput((calloutState->currentArg), null);
			(calloutState->currentArg = ((calloutState->currentArg)) + 4);
			return 0;
		}
		if (((calloutState->ffiArgHeader)) & FFIFlagAtomic) {
			if (isStruct) {
				/* begin ffiAtomicStructByReference:Class:in: */
				if (!(oopClass == (interpreterProxy->classExternalData()))) {
					return FFIErrorCoercionFailed;
				}
				/* begin atomicTypeOf: */
				typeSpec = (calloutState->ffiArgHeader);
				atomicType = ((usqInt) (typeSpec & FFIAtomicTypeMask)) >> FFIAtomicTypeShift;
				if (atomicType != FFITypeVoid) {
					/* begin ffiValidateExternalData:AtomicType: */
					ptrType = interpreterProxy->fetchPointerofObject(1, oop);
					if ((ptrType & 1)) {
						err = FFIErrorWrongType;
						goto l3;
					}
					if (!(interpreterProxy->isPointers(ptrType))) {
						err = FFIErrorWrongType;
						goto l3;
					}
					if ((interpreterProxy->slotSizeOf(ptrType)) < 2) {
						err = FFIErrorWrongType;
						goto l3;
					}
					specOop = interpreterProxy->fetchPointerofObject(0, ptrType);
					if ((specOop & 1)) {
						err = FFIErrorWrongType;
						goto l3;
					}
					if (!(interpreterProxy->isWords(specOop))) {
						err = FFIErrorWrongType;
						goto l3;
					}
					if ((interpreterProxy->slotSizeOf(specOop)) == 0) {
						err = FFIErrorWrongType;
						goto l3;
					}
					spec = interpreterProxy->fetchPointerofObject(0, specOop);
					if (!(spec & FFIFlagAtomic)) {
						err = FFIErrorWrongType;
						goto l3;
					}
					specType = ((usqInt) (spec & FFIAtomicTypeMask)) >> FFIAtomicTypeShift;
					if (specType != atomicType) {
						if (!((atomicType > FFITypeBool)
							 && (atomicType < FFITypeSingleFloat))) {
							err = FFIErrorCoercionFailed;
							goto l3;
						}
						if (!((((usqInt) atomicType) >> 1) == (((usqInt) specType) >> 1))) {
							err = FFIErrorCoercionFailed;
							goto l3;
						}
					}
					err = 0;
				l3:	/* end ffiValidateExternalData:AtomicType: */;
					if (err != 0) {
						return err;
					}
				}
				valueOop1 = interpreterProxy->fetchPointerofObject(0, oop);
				return ffiPushPointerContentsOfin(valueOop1, calloutState);
			}
			else {
				/* begin ffiAtomicArgByReference:Class:in: */
				/* begin atomicTypeOf: */
				typeSpec2 = (calloutState->ffiArgHeader);
				atomicType2 = ((usqInt) (typeSpec2 & FFIAtomicTypeMask)) >> FFIAtomicTypeShift;
				if (atomicType2 == FFITypeBool) {
					return FFIErrorCoercionFailed;
				}
				isAlien = ((isString = interpreterProxy->includesBehaviorThatOf(oopClass, interpreterProxy->classString()))
					? 0
					: interpreterProxy->includesBehaviorThatOf(oopClass, interpreterProxy->classAlien()));
				if ((((usqInt) atomicType2) >> 1) == (((usqInt) FFITypeSignedChar) >> 1)) {
					if (isString) {
						/* begin ffiPushString:OfLength:in: */
						pointer = interpreterProxy->firstIndexableField(oop);
						length = interpreterProxy->byteSizeOf(oop);
						if (((calloutState->stringArgIndex)) >= MaxNumArgs) {
							return -PrimErrBadNumArgs;
						}
						copy = malloc(length + 1);
						if (copy == null) {
							return -PrimErrNoCMemory;
						}
						memcpy(copy, pointer, length);
						copy[length] = 0;
						((calloutState->stringArgs))[(calloutState->stringArgIndex)] = copy;
						(calloutState->stringArgIndex = ((calloutState->stringArgIndex)) + 1);
						/* begin ffiPushPointer:in: */
						if ((((calloutState->currentArg)) + 4) > ((calloutState->limit))) {
							return FFIErrorCallFrameTooBig;
						}
						longAtput((calloutState->currentArg), copy);
						(calloutState->currentArg = ((calloutState->currentArg)) + 4);
						return 0;
					}
					atomicType2 = FFITypeUnsignedByte;
				}
				if ((((calloutState->callFlags)) & FFICallFlagThreaded)
				 && (((!isAlien)
 || (isDirectAlien(oop)))
 && (interpreterProxy->isYoung(oop)))) {
					return -PrimErrObjectMayMove;
				}
				if ((atomicType2 == FFITypeVoid)
				 || ((((usqInt) atomicType2) >> 1) == (((usqInt) FFITypeSignedByte) >> 1))) {
					if (isString
					 || (oopClass == (interpreterProxy->classByteArray()))) {
						/* begin ffiPushPointer:in: */
						pointer1 = interpreterProxy->firstIndexableField(oop);
						if ((((calloutState->currentArg)) + 4) > ((calloutState->limit))) {
							return FFIErrorCallFrameTooBig;
						}
						longAtput((calloutState->currentArg), pointer1);
						(calloutState->currentArg = ((calloutState->currentArg)) + 4);
						return 0;
					}
					if (isAlien) {
						/* begin ffiPushPointer:in: */
						pointer2 = pointerForOop(((longAt(oop + BaseHeaderSize)) > 0
							? (oop + BaseHeaderSize) + BytesPerOop
							: longAt((oop + BaseHeaderSize) + BytesPerOop)));
						if ((((calloutState->currentArg)) + 4) > ((calloutState->limit))) {
							return FFIErrorCallFrameTooBig;
						}
						longAtput((calloutState->currentArg), pointer2);
						(calloutState->currentArg = ((calloutState->currentArg)) + 4);
						return 0;
					}
					if (!(atomicType2 == FFITypeVoid)) {
						return FFIErrorCoercionFailed;
					}
				}
				if ((atomicType2 <= FFITypeSignedInt)
				 || (atomicType2 == FFITypeSingleFloat)) {
					if (interpreterProxy->isWords(oop)) {
						/* begin ffiPushPointer:in: */
						pointer3 = interpreterProxy->firstIndexableField(oop);
						if ((((calloutState->currentArg)) + 4) > ((calloutState->limit))) {
							return FFIErrorCallFrameTooBig;
						}
						longAtput((calloutState->currentArg), pointer3);
						(calloutState->currentArg = ((calloutState->currentArg)) + 4);
						return 0;
					}
				}
				return FFIErrorCoercionFailed;
			}
		}
		if (!(isStruct)) {
			return FFIErrorCoercionFailed;
		}
		return ffiPushPointerContentsOfin(valueOop, calloutState);
	}
	if (((calloutState->ffiArgHeader)) & FFIFlagAtomic) {
		/* begin ffiArgByValue:in: */
		/* begin atomicTypeOf: */
		typeSpec1 = (calloutState->ffiArgHeader);
		atomicType1 = ((usqInt) (typeSpec1 & FFIAtomicTypeMask)) >> FFIAtomicTypeShift;
		if ((atomicType1 < 0)
		 || (atomicType1 > FFITypeDoubleFloat)) {
			return FFIErrorBadAtomicType;
		}
		if (atomicType1 < FFITypeSingleFloat) {
			if ((((usqInt) atomicType1) >> 1) == (((usqInt) FFITypeSignedLongLong) >> 1)) {

				/* integer types */
				/* ffi support code must coerce longlong */

				intValue = valueOop;
			}
			else {
				/* begin ffiIntegerValueOf: */
				if ((valueOop & 1)) {
					intValue = (valueOop >> 1);
					goto l1;
				}
				if (valueOop == (interpreterProxy->nilObject())) {
					intValue = 0;
					goto l1;
				}
				if (valueOop == (interpreterProxy->falseObject())) {
					intValue = 0;
					goto l1;
				}
				if (valueOop == (interpreterProxy->trueObject())) {
					intValue = 1;
					goto l1;
				}
				oopClass2 = interpreterProxy->fetchClassOf(valueOop);
				if (oopClass2 == (interpreterProxy->classFloat())) {
					intValue = ((sqInt)(interpreterProxy->floatValueOf(valueOop)));
					goto l1;
				}
				if (oopClass2 == (interpreterProxy->classCharacter())) {
					intValue = interpreterProxy->fetchIntegerofObject(0, valueOop);
					goto l1;
				}
				if (oopClass2 == (interpreterProxy->classLargePositiveInteger())) {
					intValue = interpreterProxy->positive32BitValueOf(valueOop);
					goto l1;
				}
				intValue = interpreterProxy->signed32BitValueOf(valueOop);
			l1:	/* end ffiIntegerValueOf: */;
			}
			if (interpreterProxy->failed()) {
				return FFIErrorCoercionFailed;
			}
			
			switch (atomicType1) {
			case 0:
				return FFIErrorAttemptToPassVoid;
			case 1:
				return ffiPushUnsignedIntin(intValue, calloutState);
			case 2:
				return ffiPushUnsignedBytein(intValue, calloutState);
			case 3:
				return ffiPushSignedBytein(intValue, calloutState);
			case 4:
				return ffiPushUnsignedShortin(intValue, calloutState);
			case 5:
				return ffiPushSignedShortin(intValue, calloutState);
			case 6:
				return ffiPushUnsignedIntin(intValue, calloutState);
			case 7:
				return ffiPushSignedIntin(intValue, calloutState);
			case 8:
				return ffiPushUnsignedLongLongOopin(intValue, calloutState);
			case 9:
				return ffiPushSignedLongLongOopin(intValue, calloutState);
			case 10:
				return ffiPushUnsignedCharin(intValue, calloutState);
			case 11:
				return ffiPushSignedCharin(intValue, calloutState);

			default:
				error("Case not found");
				return -1;
			}
		}
		/* begin ffiFloatValueOf: */
		oopClass1 = interpreterProxy->fetchClassOf(valueOop);
		if (oopClass1 == (interpreterProxy->classFloat())) {
			floatValue = interpreterProxy->floatValueOf(valueOop);
			goto l2;
		}
		floatValue = ((double) (ffiIntegerValueOf(valueOop)) );
	l2:	/* end ffiFloatValueOf: */;
		if (interpreterProxy->failed()) {
			return FFIErrorCoercionFailed;
		}
		if (atomicType1 == FFITypeSingleFloat) {
			/* begin ffiPushSingleFloat:in: */
			if ((((calloutState->currentArg)) + 4) > ((calloutState->limit))) {
				return FFIErrorCallFrameTooBig;
			}
			storeSingleFloatAtPointerfrom((calloutState->currentArg), floatValue);
			(calloutState->currentArg = ((calloutState->currentArg)) + 4);
			return 0;
		}
		else {
			/* begin ffiPushDoubleFloat:in: */
			if ((((calloutState->currentArg)) + 8) > ((calloutState->limit))) {
				return FFIErrorCallFrameTooBig;
			}
			storeFloatAtPointerfrom((calloutState->currentArg), floatValue);
			(calloutState->currentArg = ((calloutState->currentArg)) + 8);
			return 0;
		}
	}
	return FFIErrorWrongType;
}


/*	Support for generic callout. Prepare a pointer reference to an atomic type
	for callout.
	Note: for type 'void*' we allow ByteArray/String/Symbol,
	wordVariableSubclass or Alien.
 */

static sqInt
ffiAtomicArgByReferenceClassin(sqInt oop, sqInt oopClass, CalloutState *calloutState) {
    sqInt atomicType;
    char *copy;
    sqInt isAlien;
    sqInt isString;
    sqInt length;
    char *pointer;
    void *pointer1;
    void *pointer2;
    void *pointer3;
    sqInt typeSpec;

	/* begin atomicTypeOf: */
	typeSpec = (calloutState->ffiArgHeader);
	atomicType = ((usqInt) (typeSpec & FFIAtomicTypeMask)) >> FFIAtomicTypeShift;
	if (atomicType == FFITypeBool) {
		return FFIErrorCoercionFailed;
	}
	isAlien = ((isString = interpreterProxy->includesBehaviorThatOf(oopClass, interpreterProxy->classString()))
		? 0
		: interpreterProxy->includesBehaviorThatOf(oopClass, interpreterProxy->classAlien()));
	if ((((usqInt) atomicType) >> 1) == (((usqInt) FFITypeSignedChar) >> 1)) {
		if (isString) {
			/* begin ffiPushString:OfLength:in: */
			pointer = interpreterProxy->firstIndexableField(oop);
			length = interpreterProxy->byteSizeOf(oop);
			if (((calloutState->stringArgIndex)) >= MaxNumArgs) {
				return -PrimErrBadNumArgs;
			}
			copy = malloc(length + 1);
			if (copy == null) {
				return -PrimErrNoCMemory;
			}
			memcpy(copy, pointer, length);
			copy[length] = 0;
			((calloutState->stringArgs))[(calloutState->stringArgIndex)] = copy;
			(calloutState->stringArgIndex = ((calloutState->stringArgIndex)) + 1);
			/* begin ffiPushPointer:in: */
			if ((((calloutState->currentArg)) + 4) > ((calloutState->limit))) {
				return FFIErrorCallFrameTooBig;
			}
			longAtput((calloutState->currentArg), copy);
			(calloutState->currentArg = ((calloutState->currentArg)) + 4);
			return 0;
		}
		atomicType = FFITypeUnsignedByte;
	}
	if ((((calloutState->callFlags)) & FFICallFlagThreaded)
	 && (((!isAlien)
 || (isDirectAlien(oop)))
 && (interpreterProxy->isYoung(oop)))) {
		return -PrimErrObjectMayMove;
	}
	if ((atomicType == FFITypeVoid)
	 || ((((usqInt) atomicType) >> 1) == (((usqInt) FFITypeSignedByte) >> 1))) {
		if (isString
		 || (oopClass == (interpreterProxy->classByteArray()))) {
			/* begin ffiPushPointer:in: */
			pointer1 = interpreterProxy->firstIndexableField(oop);
			if ((((calloutState->currentArg)) + 4) > ((calloutState->limit))) {
				return FFIErrorCallFrameTooBig;
			}
			longAtput((calloutState->currentArg), pointer1);
			(calloutState->currentArg = ((calloutState->currentArg)) + 4);
			return 0;
		}
		if (isAlien) {
			/* begin ffiPushPointer:in: */
			pointer2 = pointerForOop(((longAt(oop + BaseHeaderSize)) > 0
				? (oop + BaseHeaderSize) + BytesPerOop
				: longAt((oop + BaseHeaderSize) + BytesPerOop)));
			if ((((calloutState->currentArg)) + 4) > ((calloutState->limit))) {
				return FFIErrorCallFrameTooBig;
			}
			longAtput((calloutState->currentArg), pointer2);
			(calloutState->currentArg = ((calloutState->currentArg)) + 4);
			return 0;
		}
		if (!(atomicType == FFITypeVoid)) {
			return FFIErrorCoercionFailed;
		}
	}
	if ((atomicType <= FFITypeSignedInt)
	 || (atomicType == FFITypeSingleFloat)) {
		if (interpreterProxy->isWords(oop)) {
			/* begin ffiPushPointer:in: */
			pointer3 = interpreterProxy->firstIndexableField(oop);
			if ((((calloutState->currentArg)) + 4) > ((calloutState->limit))) {
				return FFIErrorCallFrameTooBig;
			}
			longAtput((calloutState->currentArg), pointer3);
			(calloutState->currentArg = ((calloutState->currentArg)) + 4);
			return 0;
		}
	}
	return FFIErrorCoercionFailed;
}


/*	Support for generic callout. Prepare an external pointer reference to an
	atomic type for callout.
 */

static sqInt
ffiAtomicStructByReferenceClassin(sqInt oop, sqInt oopClass, CalloutState *calloutState) {
    sqInt atomicType;
    sqInt err;
    sqInt ptrType;
    sqInt spec;
    sqInt specOop;
    sqInt specType;
    sqInt typeSpec;
    sqInt valueOop;

	if (!(oopClass == (interpreterProxy->classExternalData()))) {
		return FFIErrorCoercionFailed;
	}
	/* begin atomicTypeOf: */
	typeSpec = (calloutState->ffiArgHeader);
	atomicType = ((usqInt) (typeSpec & FFIAtomicTypeMask)) >> FFIAtomicTypeShift;
	if (atomicType != FFITypeVoid) {
		/* begin ffiValidateExternalData:AtomicType: */
		ptrType = interpreterProxy->fetchPointerofObject(1, oop);
		if ((ptrType & 1)) {
			err = FFIErrorWrongType;
			goto l1;
		}
		if (!(interpreterProxy->isPointers(ptrType))) {
			err = FFIErrorWrongType;
			goto l1;
		}
		if ((interpreterProxy->slotSizeOf(ptrType)) < 2) {
			err = FFIErrorWrongType;
			goto l1;
		}
		specOop = interpreterProxy->fetchPointerofObject(0, ptrType);
		if ((specOop & 1)) {
			err = FFIErrorWrongType;
			goto l1;
		}
		if (!(interpreterProxy->isWords(specOop))) {
			err = FFIErrorWrongType;
			goto l1;
		}
		if ((interpreterProxy->slotSizeOf(specOop)) == 0) {
			err = FFIErrorWrongType;
			goto l1;
		}
		spec = interpreterProxy->fetchPointerofObject(0, specOop);
		if (!(spec & FFIFlagAtomic)) {
			err = FFIErrorWrongType;
			goto l1;
		}
		specType = ((usqInt) (spec & FFIAtomicTypeMask)) >> FFIAtomicTypeShift;
		if (specType != atomicType) {
			if (!((atomicType > FFITypeBool)
				 && (atomicType < FFITypeSingleFloat))) {
				err = FFIErrorCoercionFailed;
				goto l1;
			}
			if (!((((usqInt) atomicType) >> 1) == (((usqInt) specType) >> 1))) {
				err = FFIErrorCoercionFailed;
				goto l1;
			}
		}
		err = 0;
	l1:	/* end ffiValidateExternalData:AtomicType: */;
		if (err != 0) {
			return err;
		}
	}
	valueOop = interpreterProxy->fetchPointerofObject(0, oop);
	return ffiPushPointerContentsOfin(valueOop, calloutState);
}


/*	Go out, call this guy and create the return value. This *must* be inlined
	because of
	the alloca of the outgoing stack frame in
	ffiCall:WithFlags:NumArgs:Args:AndTypes: 
 */

static sqInt
ffiCalloutToSpecOnStackin(void *procAddr, sqInt specOnStack, CalloutState *calloutState) {
    sqInt argTypes;
    sqInt argTypes1;
    sqInt atomicType;
    sqInt atomicType1;
    sqInt classOop;
    char *cString;
    sqInt ffiRetType;
    double floatRet;
    sqInt i;
    usqLong intRet;
    sqInt myThreadIndex;
    sqInt oop;
    sqInt oop1;
    sqInt *ptr;
    sqInt retClass;
    sqInt retClass1;
    sqInt retOop;
    sqInt retOop1;
    sqInt retType;
    sqInt specLiteral;
    sqInt specLiteral1;
    sqInt strLen;
    sqInt strOop;
    char *strPtr;
    sqInt typeSpec;
    sqInt typeSpec1;

	if (((calloutState->callFlags)) & FFICallFlagThreaded) {
		myThreadIndex = interpreterProxy->disownVM(0);
	}
	if ((0 + (cStackAlignment())) > 0) {
		setsp((calloutState->argVector));
	}
	/* begin atomicTypeOf: */
	typeSpec = (calloutState->ffiRetHeader);
	atomicType = ((usqInt) (typeSpec & FFIAtomicTypeMask)) >> FFIAtomicTypeShift;
	if ((atomicType == FFITypeSingleFloat)
	 || (atomicType == FFITypeDoubleFloat)) {
		floatRet = dispatchFunctionPointer(((double (*)()) procAddr));
	}
	else {
		intRet = dispatchFunctionPointer(((usqLong (*)()) procAddr));
	}
	if (isCalleePopsConvention((calloutState->callFlags))) {
		setsp((calloutState->argVector));
	}
	if (((calloutState->callFlags)) & FFICallFlagThreaded) {
		interpreterProxy->ownVM(myThreadIndex);
	}
	if (((calloutState->ffiRetHeader)) & FFIFlagPointer) {
		/* begin ffiReturnPointer:ofType:in: */
		/* begin ffiReturnType: */
		specLiteral1 = (specOnStack
			? interpreterProxy->stackValue(1)
			: interpreterProxy->literalofMethod(0, interpreterProxy->primitiveMethod()));
		argTypes1 = interpreterProxy->fetchPointerofObject(ExternalFunctionArgTypesIndex, specLiteral1);
		retType = interpreterProxy->fetchPointerofObject(0, argTypes1);
		retClass1 = interpreterProxy->fetchPointerofObject(1, retType);
		if (retClass1 == (interpreterProxy->nilObject())) {
			/* begin atomicTypeOf: */
			typeSpec1 = (calloutState->ffiRetHeader);
			atomicType1 = ((usqInt) (typeSpec1 & FFIAtomicTypeMask)) >> FFIAtomicTypeShift;
			if ((((usqInt) atomicType1) >> 1) == (((usqInt) FFITypeSignedChar) >> 1)) {
				/* begin ffiReturnCStringFrom: */
				if ((((usqInt) intRet)) == null) {
					return interpreterProxy->methodReturnValue(interpreterProxy->nilObject());
				}
				cString = ((char *) (((usqInt) intRet)));
				strLen = 0;
				while (!((cString[strLen]) == 0)) {
					strLen += 1;
				}
				strOop = interpreterProxy->instantiateClassindexableSize(interpreterProxy->classString(), strLen);
				strPtr = interpreterProxy->firstIndexableField(strOop);
				for (i = 0; i <= (strLen - 1); i += 1) {
					strPtr[i] = (cString[i]);
				}
				return interpreterProxy->methodReturnValue(strOop);
			}
			interpreterProxy->pushRemappableOop(retType);
			oop1 = interpreterProxy->instantiateClassindexableSize(interpreterProxy->classExternalAddress(), 4);
			ptr = interpreterProxy->firstIndexableField(oop1);
			ptr[0] = (((sqInt) intRet));
			interpreterProxy->pushRemappableOop(oop1);
			retOop1 = interpreterProxy->instantiateClassindexableSize(interpreterProxy->classExternalData(), 0);

			/* external address */

			oop1 = interpreterProxy->popRemappableOop();
			interpreterProxy->storePointerofObjectwithValue(0, retOop1, oop1);

			/* return type */

			oop1 = interpreterProxy->popRemappableOop();
			interpreterProxy->storePointerofObjectwithValue(1, retOop1, oop1);
			return interpreterProxy->methodReturnValue(retOop1);
		}
		interpreterProxy->pushRemappableOop(retClass1);
		if (((calloutState->ffiRetHeader)) & FFIFlagStructure) {
			classOop = interpreterProxy->classByteArray();
		}
		else {
			classOop = interpreterProxy->classExternalAddress();
		}
		oop1 = interpreterProxy->instantiateClassindexableSize(classOop, 4);
		ptr = interpreterProxy->firstIndexableField(oop1);
		ptr[0] = (((sqInt) intRet));

		/* return class */

		retClass1 = interpreterProxy->popRemappableOop();
		interpreterProxy->pushRemappableOop(oop1);
		retOop1 = interpreterProxy->instantiateClassindexableSize(retClass1, 0);

		/* external address */

		oop1 = interpreterProxy->popRemappableOop();
		interpreterProxy->storePointerofObjectwithValue(0, retOop1, oop1);
		return interpreterProxy->methodReturnValue(retOop1);
	}
	if (((calloutState->ffiRetHeader)) & FFIFlagStructure) {
		/* begin ffiReturnStruct:ofType:in: */
		/* begin ffiReturnType: */
		specLiteral = (specOnStack
			? interpreterProxy->stackValue(1)
			: interpreterProxy->literalofMethod(0, interpreterProxy->primitiveMethod()));
		argTypes = interpreterProxy->fetchPointerofObject(ExternalFunctionArgTypesIndex, specLiteral);
		ffiRetType = interpreterProxy->fetchPointerofObject(0, argTypes);
		retClass = interpreterProxy->fetchPointerofObject(1, ffiRetType);
		retOop = interpreterProxy->instantiateClassindexableSize(retClass, 0);
		interpreterProxy->pushRemappableOop(retOop);
		oop = interpreterProxy->instantiateClassindexableSize(interpreterProxy->classByteArray(), (calloutState->structReturnSize));
		if (returnStructInRegisters((calloutState->structReturnSize))) {
			memcpy(interpreterProxy->firstIndexableField(oop), (&intRet), (calloutState->structReturnSize));
		}
		else {
			memcpy(interpreterProxy->firstIndexableField(oop), (calloutState->limit), (calloutState->structReturnSize));
		}
		retOop = interpreterProxy->popRemappableOop();
		interpreterProxy->storePointerofObjectwithValue(0, retOop, oop);
		return interpreterProxy->methodReturnValue(retOop);
	}
	if ((atomicType == FFITypeSingleFloat)
	 || (atomicType == FFITypeDoubleFloat)) {
		return interpreterProxy->methodReturnValue(interpreterProxy->floatObjectOf(floatRet));
	}
	return interpreterProxy->methodReturnValue(ffiCreateIntegralResultOopofAtomicTypein(intRet, atomicType, calloutState));
}


/*	Generic callout. Does the actual work. If argArrayOrNil is nil it takes
	args from the stack
	and the spec from the method. If argArrayOrNil is not nil takes args from
	argArrayOrNil and the spec from the receiver. */

static sqInt
ffiCallArgArrayOrNilNumArgs(sqInt externalFunction, sqInt argArrayOrNil, sqInt nArgs) {
    sqInt address;
    sqInt address1;
    sqInt addressPtr;
    char *allocation;
    sqInt argClass;
    sqInt argSpec;
    sqInt argType;
    sqInt argTypeArray;
    sqInt argTypes;
    sqInt argTypes1;
    sqInt atomicType;
    sqInt atomicType1;
    CalloutState *calloutState;
    sqInt classOop;
    char *cString;
    sqInt err;
    sqInt ffiRetType;
    sqInt flags;
    double floatRet;
    sqInt functionName;
    sqInt i;
    sqInt i1;
    usqLong intRet;
    sqInt myThreadIndex;
    sqInt oop;
    sqInt oop1;
    sqInt oop2;
    void *pointer;
    int *ptr;
    sqInt *ptr1;
    sqInt requiredStackSize;
    sqInt result;
    sqInt retClass;
    sqInt retClass1;
    sqInt retOop;
    sqInt retOop1;
    sqInt retType;
    sqInt specLiteral;
    sqInt specLiteral1;
    sqInt stackSize;
    sqInt strLen;
    sqInt strOop;
    char *strPtr;
    CalloutState theCalloutState;
    sqInt typeSpec;
    sqInt typeSpec1;

	if (!(interpreterProxy->isKindOfClass(externalFunction, interpreterProxy->classExternalFunction()))) {
		return ffiFail(FFIErrorNotFunction);
	}
	flags = interpreterProxy->fetchIntegerofObject(ExternalFunctionFlagsIndex, externalFunction);
	if (interpreterProxy->failed()) {
		return ffiFail(FFIErrorBadArgs);
	}

	/* must be array of arg types */

	argTypeArray = interpreterProxy->fetchPointerofObject(ExternalFunctionArgTypesIndex, externalFunction);
	if (!((interpreterProxy->isArray(argTypeArray))
		 && ((interpreterProxy->slotSizeOf(argTypeArray)) == (nArgs + 1)))) {
		return ffiFail(FFIErrorBadArgs);
	}
	if (!(1)) {
		return ffiFail(FFIErrorCallType);
	}
	/* begin ffiLoadCalloutAddress: */

	/* Lookup the address */
	/* Make sure it's an external handle */

	addressPtr = interpreterProxy->fetchPointerofObject(0, externalFunction);
	/* begin ffiContentsOfHandle:errCode: */
	if ((addressPtr & 1)) {
		address1 = ffiFail(FFIErrorBadAddress);
		goto l3;
	}
	if (!(interpreterProxy->isBytes(addressPtr))) {
		address1 = ffiFail(FFIErrorBadAddress);
		goto l3;
	}
	if (!((interpreterProxy->byteSizeOf(addressPtr)) == 4)) {
		address1 = ffiFail(FFIErrorBadAddress);
		goto l3;
	}
	address1 = interpreterProxy->fetchPointerofObject(0, addressPtr);
l3:	/* end ffiContentsOfHandle:errCode: */;
	if (interpreterProxy->failed()) {
		address = 0;
		goto l4;
	}
	if (address1 == 0) {
		if (externalFunctionInstSize > ExternalFunctionStackSizeIndex) {
			interpreterProxy->storePointerofObjectwithValue(ExternalFunctionStackSizeIndex, externalFunction, ((-1 << 1) | 1));
		}
		if ((interpreterProxy->slotSizeOf(externalFunction)) < 5) {
			address = ffiFail(FFIErrorNoModule);
			goto l4;
		}
		address1 = ffiLoadCalloutAddressFrom(externalFunction);
		if (interpreterProxy->failed()) {
			address = 0;
			goto l4;
		}
		ptr = interpreterProxy->firstIndexableField(addressPtr);
		ptr[0] = address1;
	}
	address = address1;
l4:	/* end ffiLoadCalloutAddress: */;
	if (interpreterProxy->failed()) {
		return 0;
	}
	requiredStackSize = (externalFunctionInstSize > ExternalFunctionStackSizeIndex
		? interpreterProxy->fetchIntegerofObject(ExternalFunctionStackSizeIndex, externalFunction)
		: -1);
	if (interpreterProxy->failed()) {
		return interpreterProxy->primitiveFailFor((argArrayOrNil == null
			? PrimErrBadMethod
			: PrimErrBadReceiver));
	}
	stackSize = (requiredStackSize < 0
		? DefaultMaxStackSize
		: requiredStackSize);
	null;
	calloutState = (&theCalloutState);
		memset(calloutState, 0, sizeof(CalloutState));
;
	(calloutState->callFlags = flags);
	argType = interpreterProxy->fetchPointerofObject(0, argTypeArray);
	argSpec = interpreterProxy->fetchPointerofObject(0, argType);
	argClass = interpreterProxy->fetchPointerofObject(1, argType);
	if (((err = ffiCheckReturnWithin(argSpec, argClass, calloutState))) != 0) {
		return ffiFail(err);
	}
	allocation = alloca(((stackSize + ((calloutState->structReturnSize))) + 0) + (cStackAlignment()));
	if (allocaLiesSoUseGetsp()) {
		allocation = getsp();
	}
	if ((cStackAlignment()) != 0) {
		allocation = ((char *) ((((usqInt)allocation)) & (~((cStackAlignment()) - 1))));
	}
	(calloutState->argVector = allocation);
	(calloutState->currentArg = allocation + 0);
	(calloutState->limit = (allocation + stackSize) + 0);
	if ((((calloutState->structReturnSize)) > 0)
	 && (1
 && (!(returnStructInRegisters((calloutState->structReturnSize)))))) {
		/* begin ffiPushPointer:in: */
		pointer = (calloutState->limit);
		if ((((calloutState->currentArg)) + 4) > ((calloutState->limit))) {
			goto l1;
		}
		longAtput((calloutState->currentArg), pointer);
		(calloutState->currentArg = ((calloutState->currentArg)) + 4);
	l1:	/* end ffiPushPointer:in: */;
	}
	for (i = 1; i <= nArgs; i += 1) {
		argType = interpreterProxy->fetchPointerofObject(i, argTypeArray);
		argSpec = interpreterProxy->fetchPointerofObject(0, argType);
		argClass = interpreterProxy->fetchPointerofObject(1, argType);
		oop = (argArrayOrNil == null
			? interpreterProxy->stackValue(nArgs - i)
			: interpreterProxy->fetchPointerofObject(i - 1, argArrayOrNil));
		err = ffiArgumentSpecClassin(oop, argSpec, argClass, calloutState);
		if (err != 0) {
			/* begin cleanupCalloutState: */
			while (((calloutState->stringArgIndex)) > 0) {
				free(((calloutState->stringArgs))[(calloutState->stringArgIndex = ((calloutState->stringArgIndex)) - 1)]);
			}
			if (err == (-PrimErrObjectMayMove)) {
				return PrimErrObjectMayMove;
			}
			return ffiFail(err);
		}
	}
	assert(!(interpreterProxy->failed()));
	/* begin ffiLogCallout: */
	if (ffiLogEnabled) {
		functionName = interpreterProxy->fetchPointerofObject(externalFunctionInstSize, externalFunction);
		if (!(interpreterProxy->isBytes(functionName))) {
			goto l2;
		}
		ffiLogCallOfLength(interpreterProxy->firstIndexableField(functionName), interpreterProxy->byteSizeOf(functionName));
	}
l2:	/* end ffiLogCallout: */;
	if ((requiredStackSize < 0)
	 && (externalFunctionInstSize > ExternalFunctionStackSizeIndex)) {
		stackSize = ((calloutState->currentArg)) - ((calloutState->argVector));
		interpreterProxy->storeIntegerofObjectwithValue(ExternalFunctionStackSizeIndex, externalFunction, stackSize);
	}
	/* begin ffiCalloutTo:SpecOnStack:in: */
	if (((calloutState->callFlags)) & FFICallFlagThreaded) {
		myThreadIndex = interpreterProxy->disownVM(0);
	}
	if ((0 + (cStackAlignment())) > 0) {
		setsp((calloutState->argVector));
	}
	/* begin atomicTypeOf: */
	typeSpec = (calloutState->ffiRetHeader);
	atomicType = ((usqInt) (typeSpec & FFIAtomicTypeMask)) >> FFIAtomicTypeShift;
	if ((atomicType == FFITypeSingleFloat)
	 || (atomicType == FFITypeDoubleFloat)) {
		floatRet = dispatchFunctionPointer(((double (*)()) address));
	}
	else {
		intRet = dispatchFunctionPointer(((usqLong (*)()) address));
	}
	if (isCalleePopsConvention((calloutState->callFlags))) {
		setsp((calloutState->argVector));
	}
	if (((calloutState->callFlags)) & FFICallFlagThreaded) {
		interpreterProxy->ownVM(myThreadIndex);
	}
	if (((calloutState->ffiRetHeader)) & FFIFlagPointer) {
		/* begin ffiReturnPointer:ofType:in: */
		/* begin ffiReturnType: */
		specLiteral1 = (argArrayOrNil != null
			? interpreterProxy->stackValue(1)
			: interpreterProxy->literalofMethod(0, interpreterProxy->primitiveMethod()));
		argTypes1 = interpreterProxy->fetchPointerofObject(ExternalFunctionArgTypesIndex, specLiteral1);
		retType = interpreterProxy->fetchPointerofObject(0, argTypes1);
		retClass1 = interpreterProxy->fetchPointerofObject(1, retType);
		if (retClass1 == (interpreterProxy->nilObject())) {
			/* begin atomicTypeOf: */
			typeSpec1 = (calloutState->ffiRetHeader);
			atomicType1 = ((usqInt) (typeSpec1 & FFIAtomicTypeMask)) >> FFIAtomicTypeShift;
			if ((((usqInt) atomicType1) >> 1) == (((usqInt) FFITypeSignedChar) >> 1)) {
				/* begin ffiReturnCStringFrom: */
				if ((((usqInt) intRet)) == null) {
					result = interpreterProxy->methodReturnValue(interpreterProxy->nilObject());
					goto l5;
				}
				cString = ((char *) (((usqInt) intRet)));
				strLen = 0;
				while (!((cString[strLen]) == 0)) {
					strLen += 1;
				}
				strOop = interpreterProxy->instantiateClassindexableSize(interpreterProxy->classString(), strLen);
				strPtr = interpreterProxy->firstIndexableField(strOop);
				for (i1 = 0; i1 <= (strLen - 1); i1 += 1) {
					strPtr[i1] = (cString[i1]);
				}
				result = interpreterProxy->methodReturnValue(strOop);
				goto l5;
			}
			interpreterProxy->pushRemappableOop(retType);
			oop1 = interpreterProxy->instantiateClassindexableSize(interpreterProxy->classExternalAddress(), 4);
			ptr1 = interpreterProxy->firstIndexableField(oop1);
			ptr1[0] = (((sqInt) intRet));
			interpreterProxy->pushRemappableOop(oop1);
			retOop1 = interpreterProxy->instantiateClassindexableSize(interpreterProxy->classExternalData(), 0);

			/* external address */

			oop1 = interpreterProxy->popRemappableOop();
			interpreterProxy->storePointerofObjectwithValue(0, retOop1, oop1);

			/* return type */

			oop1 = interpreterProxy->popRemappableOop();
			interpreterProxy->storePointerofObjectwithValue(1, retOop1, oop1);
			result = interpreterProxy->methodReturnValue(retOop1);
			goto l5;
		}
		interpreterProxy->pushRemappableOop(retClass1);
		if (((calloutState->ffiRetHeader)) & FFIFlagStructure) {
			classOop = interpreterProxy->classByteArray();
		}
		else {
			classOop = interpreterProxy->classExternalAddress();
		}
		oop1 = interpreterProxy->instantiateClassindexableSize(classOop, 4);
		ptr1 = interpreterProxy->firstIndexableField(oop1);
		ptr1[0] = (((sqInt) intRet));

		/* return class */

		retClass1 = interpreterProxy->popRemappableOop();
		interpreterProxy->pushRemappableOop(oop1);
		retOop1 = interpreterProxy->instantiateClassindexableSize(retClass1, 0);

		/* external address */

		oop1 = interpreterProxy->popRemappableOop();
		interpreterProxy->storePointerofObjectwithValue(0, retOop1, oop1);
		result = interpreterProxy->methodReturnValue(retOop1);
		goto l5;
	}
	if (((calloutState->ffiRetHeader)) & FFIFlagStructure) {
		/* begin ffiReturnStruct:ofType:in: */
		/* begin ffiReturnType: */
		specLiteral = (argArrayOrNil != null
			? interpreterProxy->stackValue(1)
			: interpreterProxy->literalofMethod(0, interpreterProxy->primitiveMethod()));
		argTypes = interpreterProxy->fetchPointerofObject(ExternalFunctionArgTypesIndex, specLiteral);
		ffiRetType = interpreterProxy->fetchPointerofObject(0, argTypes);
		retClass = interpreterProxy->fetchPointerofObject(1, ffiRetType);
		retOop = interpreterProxy->instantiateClassindexableSize(retClass, 0);
		interpreterProxy->pushRemappableOop(retOop);
		oop2 = interpreterProxy->instantiateClassindexableSize(interpreterProxy->classByteArray(), (calloutState->structReturnSize));
		if (returnStructInRegisters((calloutState->structReturnSize))) {
			memcpy(interpreterProxy->firstIndexableField(oop2), (&intRet), (calloutState->structReturnSize));
		}
		else {
			memcpy(interpreterProxy->firstIndexableField(oop2), (calloutState->limit), (calloutState->structReturnSize));
		}
		retOop = interpreterProxy->popRemappableOop();
		interpreterProxy->storePointerofObjectwithValue(0, retOop, oop2);
		result = interpreterProxy->methodReturnValue(retOop);
		goto l5;
	}
	if ((atomicType == FFITypeSingleFloat)
	 || (atomicType == FFITypeDoubleFloat)) {
		result = interpreterProxy->methodReturnValue(interpreterProxy->floatObjectOf(floatRet));
		goto l5;
	}
	result = interpreterProxy->methodReturnValue(ffiCreateIntegralResultOopofAtomicTypein(intRet, atomicType, calloutState));
l5:	/* end ffiCalloutTo:SpecOnStack:in: */;
	/* begin cleanupCalloutState: */
	while (((calloutState->stringArgIndex)) > 0) {
		free(((calloutState->stringArgs))[(calloutState->stringArgIndex = ((calloutState->stringArgIndex)) - 1)]);
	}
	return result;
}


/*	Make sure we can return an object of the given type */

static sqInt
ffiCheckReturnWithin(sqInt retSpec, sqInt retClass, CalloutState *calloutState) {
    sqInt ffiRetSpec;

	if (!(retClass == (interpreterProxy->nilObject()))) {
		if (!(interpreterProxy->includesBehaviorThatOf(retClass, interpreterProxy->classExternalStructure()))) {
			return FFIErrorBadReturn;
		}
	}
	if (!(interpreterProxy->isWords(retSpec))) {
		return FFIErrorWrongType;
	}
	if ((interpreterProxy->slotSizeOf(retSpec)) == 0) {
		return FFIErrorWrongType;
	}
	ffiRetSpec = ((int) (interpreterProxy->firstIndexableField(retSpec)));
	(calloutState->ffiRetHeader = longAt(ffiRetSpec));
	if (!(isAtomicType((calloutState->ffiRetHeader)))) {
		if (retClass == (interpreterProxy->nilObject())) {
			return FFIErrorBadReturn;
		}
	}
	if ((((calloutState->ffiRetHeader)) & (FFIFlagPointer | FFIFlagStructure)) == FFIFlagStructure) {
		(calloutState->structReturnSize = ((calloutState->ffiRetHeader)) & FFIStructSizeMask);
	}
	return 0;
}


/*	Make sure that the given oop is a valid external handle */

static sqInt
ffiContentsOfHandleerrCode(sqInt oop, sqInt errCode) {
	if ((oop & 1)) {
		return ffiFail(errCode);
	}
	if (!(interpreterProxy->isBytes(oop))) {
		return ffiFail(errCode);
	}
	if (!((interpreterProxy->byteSizeOf(oop)) == 4)) {
		return ffiFail(errCode);
	}
	return interpreterProxy->fetchPointerofObject(0, oop);
}


/*	Callout support. Return the appropriate oop for the given atomic type */

static sqInt
ffiCreateIntegralResultOopofAtomicTypein(usqLong retVal, sqInt atomicType, CalloutState *calloutState) {
    sqInt byteSize;
    sqInt mask;
    sqInt shift;
    sqInt value;

	assert(atomicType < FFITypeSingleFloat);
	if (atomicType == FFITypeBool) {

		/* Make sure bool honors the byte size requested */

		byteSize = ((calloutState->ffiRetHeader)) & FFIStructSizeMask;
		value = (byteSize == 4
			? retVal
			: retVal & ((1 << (byteSize * 8)) - 1));
		return (value == 0
			? interpreterProxy->falseObject()
			: interpreterProxy->trueObject());
	}
	if (atomicType <= FFITypeSignedInt) {
		if (atomicType <= FFITypeSignedShort) {

			/* these are all generall integer returns */
			/* byte/short. first extract partial word, then sign extend */
			/* # of significant bits */

			shift = (((usqInt) atomicType) >> 1) * 8;
			value = retVal & ((1 << shift) - 1);
			if (atomicType & 1) {

				/* make the guy signed */

				mask = 1 << (shift - 1);
				value = (value & (mask - 1)) - (value & mask);
			}
			return ((value << 1) | 1);
		}
		return (atomicType & 1
			? interpreterProxy->signed32BitIntegerFor(retVal)
			: interpreterProxy->positive32BitIntegerFor(retVal));
	}
	if ((((usqInt) atomicType) >> 1) == (((usqInt) FFITypeSignedLongLong) >> 1)) {
		return (atomicType & 1
			? interpreterProxy->signed64BitIntegerFor(retVal)
			: interpreterProxy->positive64BitIntegerFor(retVal));
	}
	else {
		return interpreterProxy->fetchPointerofObject(retVal & 255, interpreterProxy->characterTable());
	}
}


/*	Map the FFI error code into a primitive error code. If reason is negative
	it encodes one of the
	standard PrimErr... codes, negated to distinguish it from the FFIError
	codes. If it is an FFIError...
	code then add the size of the primitive error table + 2 to disambiguate it
	from the PrimErr... codes.
	For historic reasons the FFIError codes range from -1 on up hence adding
	size + 2 maps them to
	size of table + 1 on up. This OFFSET IS undone by ExternalFunction
	class>>externalCallFailedWith:. Thus we can communicate back both
	PrimErr.. and FFIError codes. Complex but necessary. */

static sqInt
ffiFail(sqInt reason) {
	ffiLastError = reason;
	return interpreterProxy->primitiveFailFor((reason >= FFINoCalloutAvailable
		? (reason + 2) + (interpreterProxy->slotSizeOf(interpreterProxy->primitiveErrorTable()))
		: -reason));
}


/*	Support for generic callout. Return a float value that is coerced as C
	would do.
 */

static double
ffiFloatValueOf(sqInt oop) {
    sqInt oopClass;

	oopClass = interpreterProxy->fetchClassOf(oop);
	if (oopClass == (interpreterProxy->classFloat())) {
		return interpreterProxy->floatValueOf(oop);
	}
	return ((double) (ffiIntegerValueOf(oop)) );
}


/*	Support for generic callout. Return an integer value that is coerced as C
	would do.
 */

static sqInt
ffiIntegerValueOf(sqInt oop) {
    sqInt oopClass;

	if ((oop & 1)) {
		return (oop >> 1);
	}
	if (oop == (interpreterProxy->nilObject())) {
		return 0;
	}
	if (oop == (interpreterProxy->falseObject())) {
		return 0;
	}
	if (oop == (interpreterProxy->trueObject())) {
		return 1;
	}
	oopClass = interpreterProxy->fetchClassOf(oop);
	if (oopClass == (interpreterProxy->classFloat())) {
		return ((sqInt)(interpreterProxy->floatValueOf(oop)));
	}
	if (oopClass == (interpreterProxy->classCharacter())) {
		return interpreterProxy->fetchIntegerofObject(0, oop);
	}
	if (oopClass == (interpreterProxy->classLargePositiveInteger())) {
		return interpreterProxy->positive32BitValueOf(oop);
	}
	return interpreterProxy->signed32BitValueOf(oop);
}


/*	Load the function address for a call out to an external function */

static sqInt
ffiLoadCalloutAddressFrom(sqInt oop) {
    sqInt address;
    sqInt ffiModuleName;
    sqInt functionLength;
    sqInt functionName;
    sqInt module;
    sqInt moduleHandle;
    sqInt moduleHandle1;
    sqInt moduleHandlePtr;
    sqInt moduleLength;
    int *ptr;
    sqInt rcvr;


	/* First find and load the module */

	module = interpreterProxy->fetchPointerofObject(externalFunctionInstSize + 1, oop);
	/* begin ffiLoadCalloutModule: */
	if (interpreterProxy->isBytes(module)) {

		/* plain module name */

		ffiModuleName = module;
		moduleLength = interpreterProxy->byteSizeOf(ffiModuleName);
		moduleHandle1 = interpreterProxy->ioLoadModuleOfLength(((int) (interpreterProxy->firstIndexableField(ffiModuleName))), moduleLength);
		if ((interpreterProxy->failed())
		 || (moduleHandle1 == 0)) {
			moduleHandle = ffiFail(FFIErrorModuleNotFound);
			goto l2;
		}
		moduleHandle = moduleHandle1;
		goto l2;
	}
	rcvr = interpreterProxy->stackValue(interpreterProxy->methodArgumentCount());
	if (!(interpreterProxy->isKindOfClass(rcvr, interpreterProxy->classExternalLibrary()))) {
		moduleHandle = ffiFail(FFIErrorNoModule);
		goto l2;
	}
	moduleHandlePtr = interpreterProxy->fetchPointerofObject(0, rcvr);
	/* begin ffiContentsOfHandle:errCode: */
	if ((moduleHandlePtr & 1)) {
		moduleHandle1 = ffiFail(FFIErrorBadExternalLibrary);
		goto l1;
	}
	if (!(interpreterProxy->isBytes(moduleHandlePtr))) {
		moduleHandle1 = ffiFail(FFIErrorBadExternalLibrary);
		goto l1;
	}
	if (!((interpreterProxy->byteSizeOf(moduleHandlePtr)) == 4)) {
		moduleHandle1 = ffiFail(FFIErrorBadExternalLibrary);
		goto l1;
	}
	moduleHandle1 = interpreterProxy->fetchPointerofObject(0, moduleHandlePtr);
l1:	/* end ffiContentsOfHandle:errCode: */;
	if (interpreterProxy->failed()) {
		moduleHandle = 0;
		goto l2;
	}
	if (moduleHandle1 == 0) {

		/* need to reload module */

		ffiModuleName = interpreterProxy->fetchPointerofObject(1, rcvr);
		if (!(interpreterProxy->isBytes(ffiModuleName))) {
			moduleHandle = ffiFail(FFIErrorBadExternalLibrary);
			goto l2;
		}
		moduleLength = interpreterProxy->byteSizeOf(ffiModuleName);
		moduleHandle1 = interpreterProxy->ioLoadModuleOfLength(((int) (interpreterProxy->firstIndexableField(ffiModuleName))), moduleLength);
		if ((interpreterProxy->failed())
		 || (moduleHandle1 == 0)) {
			moduleHandle = ffiFail(FFIErrorModuleNotFound);
			goto l2;
		}
		ptr = interpreterProxy->firstIndexableField(moduleHandlePtr);
		ptr[0] = moduleHandle1;
	}
	moduleHandle = moduleHandle1;
l2:	/* end ffiLoadCalloutModule: */;
	if (interpreterProxy->failed()) {
		return 0;
	}
	functionName = interpreterProxy->fetchPointerofObject(externalFunctionInstSize, oop);
	if (!(interpreterProxy->isBytes(functionName))) {
		return ffiFail(FFIErrorBadExternalFunction);
	}
	functionLength = interpreterProxy->byteSizeOf(functionName);
	address = interpreterProxy->ioLoadSymbolOfLengthFromModule(((int) (interpreterProxy->firstIndexableField(functionName))), functionLength, moduleHandle);
	if ((interpreterProxy->failed())
	 || (address == 0)) {
		return ffiFail(FFIErrorAddressNotFound);
	}
	return address;
}


/*	Load the address of the foreign function from the given object */

static sqInt
ffiLoadCalloutAddress(sqInt lit) {
    sqInt address;
    sqInt addressPtr;
    int *ptr;


	/* Lookup the address */
	/* Make sure it's an external handle */

	addressPtr = interpreterProxy->fetchPointerofObject(0, lit);
	/* begin ffiContentsOfHandle:errCode: */
	if ((addressPtr & 1)) {
		address = ffiFail(FFIErrorBadAddress);
		goto l1;
	}
	if (!(interpreterProxy->isBytes(addressPtr))) {
		address = ffiFail(FFIErrorBadAddress);
		goto l1;
	}
	if (!((interpreterProxy->byteSizeOf(addressPtr)) == 4)) {
		address = ffiFail(FFIErrorBadAddress);
		goto l1;
	}
	address = interpreterProxy->fetchPointerofObject(0, addressPtr);
l1:	/* end ffiContentsOfHandle:errCode: */;
	if (interpreterProxy->failed()) {
		return 0;
	}
	if (address == 0) {
		if (externalFunctionInstSize > ExternalFunctionStackSizeIndex) {
			interpreterProxy->storePointerofObjectwithValue(ExternalFunctionStackSizeIndex, lit, ((-1 << 1) | 1));
		}
		if ((interpreterProxy->slotSizeOf(lit)) < 5) {
			return ffiFail(FFIErrorNoModule);
		}
		address = ffiLoadCalloutAddressFrom(lit);
		if (interpreterProxy->failed()) {
			return 0;
		}
		ptr = interpreterProxy->firstIndexableField(addressPtr);
		ptr[0] = address;
	}
	return address;
}


/*	Load the given module and return its handle */

static sqInt
ffiLoadCalloutModule(sqInt module) {
    sqInt ffiModuleName;
    sqInt moduleHandle;
    sqInt moduleHandlePtr;
    sqInt moduleLength;
    int *ptr;
    sqInt rcvr;

	if (interpreterProxy->isBytes(module)) {

		/* plain module name */

		ffiModuleName = module;
		moduleLength = interpreterProxy->byteSizeOf(ffiModuleName);
		moduleHandle = interpreterProxy->ioLoadModuleOfLength(((int) (interpreterProxy->firstIndexableField(ffiModuleName))), moduleLength);
		if ((interpreterProxy->failed())
		 || (moduleHandle == 0)) {
			return ffiFail(FFIErrorModuleNotFound);
		}
		return moduleHandle;
	}
	rcvr = interpreterProxy->stackValue(interpreterProxy->methodArgumentCount());
	if (!(interpreterProxy->isKindOfClass(rcvr, interpreterProxy->classExternalLibrary()))) {
		return ffiFail(FFIErrorNoModule);
	}
	moduleHandlePtr = interpreterProxy->fetchPointerofObject(0, rcvr);
	/* begin ffiContentsOfHandle:errCode: */
	if ((moduleHandlePtr & 1)) {
		moduleHandle = ffiFail(FFIErrorBadExternalLibrary);
		goto l1;
	}
	if (!(interpreterProxy->isBytes(moduleHandlePtr))) {
		moduleHandle = ffiFail(FFIErrorBadExternalLibrary);
		goto l1;
	}
	if (!((interpreterProxy->byteSizeOf(moduleHandlePtr)) == 4)) {
		moduleHandle = ffiFail(FFIErrorBadExternalLibrary);
		goto l1;
	}
	moduleHandle = interpreterProxy->fetchPointerofObject(0, moduleHandlePtr);
l1:	/* end ffiContentsOfHandle:errCode: */;
	if (interpreterProxy->failed()) {
		return 0;
	}
	if (moduleHandle == 0) {

		/* need to reload module */

		ffiModuleName = interpreterProxy->fetchPointerofObject(1, rcvr);
		if (!(interpreterProxy->isBytes(ffiModuleName))) {
			return ffiFail(FFIErrorBadExternalLibrary);
		}
		moduleLength = interpreterProxy->byteSizeOf(ffiModuleName);
		moduleHandle = interpreterProxy->ioLoadModuleOfLength(((int) (interpreterProxy->firstIndexableField(ffiModuleName))), moduleLength);
		if ((interpreterProxy->failed())
		 || (moduleHandle == 0)) {
			return ffiFail(FFIErrorModuleNotFound);
		}
		ptr = interpreterProxy->firstIndexableField(moduleHandlePtr);
		ptr[0] = moduleHandle;
	}
	return moduleHandle;
}


/*	fetch the function name */

static void
ffiLogCallout(sqInt lit) {
    sqInt functionName;

	if (ffiLogEnabled) {
		functionName = interpreterProxy->fetchPointerofObject(externalFunctionInstSize, lit);
		if (!(interpreterProxy->isBytes(functionName))) {
			return;
		}
		ffiLogCallOfLength(interpreterProxy->firstIndexableField(functionName), interpreterProxy->byteSizeOf(functionName));
	}
}


/*	This is a special entry point exposed such that client code can 
	enable and disable logging of FFI calls. */

EXPORT(sqInt)
ffiLogCallsTo(char*fileName) {
    sqInt ok;

	if (fileName == null) {

		/* disable logging */

		ok = ffiLogFileNameOfLength(null, 0);
		if (!(ok)) {
			return 0;
		}
		ffiLogEnabled = 0;
	}
	else {

		/* enable logging */

		ok = ffiLogFileNameOfLength(fileName, strlen(fileName));
		if (!(ok)) {
			return 0;
		}
		ffiLogEnabled = 1;
	}
	return 1;
}

static sqInt
ffiPushDoubleFloatin(double value, CalloutState *calloutState) {
	if ((((calloutState->currentArg)) + 8) > ((calloutState->limit))) {
		return FFIErrorCallFrameTooBig;
	}
	storeFloatAtPointerfrom((calloutState->currentArg), value);
	(calloutState->currentArg = ((calloutState->currentArg)) + 8);
	return 0;
}


/*	Push the contents of the given external structure */

static sqInt
ffiPushPointerContentsOfin(sqInt oop, CalloutState *calloutState) {
    sqInt ptrAddress;
    sqInt ptrClass;

	ptrClass = interpreterProxy->fetchClassOf(oop);
	if (ptrClass == (interpreterProxy->classExternalAddress())) {

		/* Don't you dare to pass pointers into object memory */

		ptrAddress = interpreterProxy->fetchPointerofObject(0, oop);
		if (interpreterProxy->isInMemory(ptrAddress)) {
			return FFIErrorInvalidPointer;
		}
		/* begin ffiPushPointer:in: */
		if ((((calloutState->currentArg)) + 4) > ((calloutState->limit))) {
			return FFIErrorCallFrameTooBig;
		}
		longAtput((calloutState->currentArg), ptrAddress);
		(calloutState->currentArg = ((calloutState->currentArg)) + 4);
		return 0;
	}
	if (ptrClass == (interpreterProxy->classByteArray())) {
		if ((((calloutState->callFlags)) & FFICallFlagThreaded)
		 && (interpreterProxy->isYoung(oop))) {
			return -PrimErrObjectMayMove;
		}
		ptrAddress = ((int) (interpreterProxy->firstIndexableField(oop)));
		/* begin ffiPushPointer:in: */
		if ((((calloutState->currentArg)) + 4) > ((calloutState->limit))) {
			return FFIErrorCallFrameTooBig;
		}
		longAtput((calloutState->currentArg), ptrAddress);
		(calloutState->currentArg = ((calloutState->currentArg)) + 4);
		return 0;
	}
	if (interpreterProxy->includesBehaviorThatOf(ptrClass, interpreterProxy->classAlien())) {
		if ((((calloutState->callFlags)) & FFICallFlagThreaded)
		 && ((isDirectAlien(oop))
 && (interpreterProxy->isYoung(oop)))) {
			return -PrimErrObjectMayMove;
		}
		ptrAddress = ((longAt(oop + BaseHeaderSize)) > 0
			? (oop + BaseHeaderSize) + BytesPerOop
			: longAt((oop + BaseHeaderSize) + BytesPerOop));
		/* begin ffiPushPointer:in: */
		if ((((calloutState->currentArg)) + 4) > ((calloutState->limit))) {
			return FFIErrorCallFrameTooBig;
		}
		longAtput((calloutState->currentArg), ptrAddress);
		(calloutState->currentArg = ((calloutState->currentArg)) + 4);
		return 0;
	}
	return FFIErrorBadArg;
}

static sqInt
ffiPushPointerin(void *pointer, CalloutState *calloutState) {
	if ((((calloutState->currentArg)) + 4) > ((calloutState->limit))) {
		return FFIErrorCallFrameTooBig;
	}
	longAtput((calloutState->currentArg), pointer);
	(calloutState->currentArg = ((calloutState->currentArg)) + 4);
	return 0;
}

static sqInt
ffiPushSignedBytein(sqInt value, CalloutState *calloutState) {
	if ((((calloutState->currentArg)) + 4) > ((calloutState->limit))) {
		return FFIErrorCallFrameTooBig;
	}
	longAtput((calloutState->currentArg), ((signed char) value));
	(calloutState->currentArg = ((calloutState->currentArg)) + 4);
	return 0;
}

static sqInt
ffiPushSignedCharin(sqInt value, CalloutState *calloutState) {
	if ((((calloutState->currentArg)) + 4) > ((calloutState->limit))) {
		return FFIErrorCallFrameTooBig;
	}
	longAtput((calloutState->currentArg), ((signed char) value));
	(calloutState->currentArg = ((calloutState->currentArg)) + 4);
	return 0;
}

static sqInt
ffiPushSignedIntin(sqInt value, CalloutState *calloutState) {
	if ((((calloutState->currentArg)) + 4) > ((calloutState->limit))) {
		return FFIErrorCallFrameTooBig;
	}
	longAtput((calloutState->currentArg), value);
	(calloutState->currentArg = ((calloutState->currentArg)) + 4);
	return 0;
}


/*	Push a longlong type (e.g., a 64bit integer).
	Note: Coercions from float are *not* supported. */

static sqInt
ffiPushSignedLongLongOopin(sqInt oop, CalloutState *calloutState) {
    sqLong value;

	if ((oop == (interpreterProxy->nilObject()))
	 || (oop == (interpreterProxy->falseObject()))) {
		value = 0;
	}
	else {
		if (oop == (interpreterProxy->trueObject())) {
			value = 1;
		}
		else {
			value = interpreterProxy->signed64BitValueOf(oop);
			if (interpreterProxy->failed()) {
				return FFIErrorCoercionFailed;
			}
		}
	}
	/* begin ffiPushSignedLongLong:in: */
	if ((((calloutState->currentArg)) + 8) > ((calloutState->limit))) {
		return FFIErrorCallFrameTooBig;
	}
	longAtput((calloutState->currentArg), ((usqInt) value));
	longAtput(((calloutState->currentArg)) + 4, ((usqInt) (((unsigned sqLong )value) >> 32)));
	(calloutState->currentArg = ((calloutState->currentArg)) + 8);
	return 0;
}

static sqInt
ffiPushSignedLongLongin(usqLong value, CalloutState *calloutState) {
	if ((((calloutState->currentArg)) + 8) > ((calloutState->limit))) {
		return FFIErrorCallFrameTooBig;
	}
	longAtput((calloutState->currentArg), ((usqInt) value));
	longAtput(((calloutState->currentArg)) + 4, ((usqInt) (value >> 32)));
	(calloutState->currentArg = ((calloutState->currentArg)) + 8);
	return 0;
}

static sqInt
ffiPushSignedShortin(sqInt value, CalloutState *calloutState) {
	if ((((calloutState->currentArg)) + 4) > ((calloutState->limit))) {
		return FFIErrorCallFrameTooBig;
	}
	longAtput((calloutState->currentArg), ((signed short) value));
	(calloutState->currentArg = ((calloutState->currentArg)) + 4);
	return 0;
}

static sqInt
ffiPushSingleFloatin(float value, CalloutState *calloutState) {
	if ((((calloutState->currentArg)) + 4) > ((calloutState->limit))) {
		return FFIErrorCallFrameTooBig;
	}
	storeSingleFloatAtPointerfrom((calloutState->currentArg), value);
	(calloutState->currentArg = ((calloutState->currentArg)) + 4);
	return 0;
}

static sqInt
ffiPushStringOfLengthin(char *pointer, sqInt length, CalloutState *calloutState) {
    char *copy;

	if (((calloutState->stringArgIndex)) >= MaxNumArgs) {
		return -PrimErrBadNumArgs;
	}
	copy = malloc(length + 1);
	if (copy == null) {
		return -PrimErrNoCMemory;
	}
	memcpy(copy, pointer, length);
	copy[length] = 0;
	((calloutState->stringArgs))[(calloutState->stringArgIndex)] = copy;
	(calloutState->stringArgIndex = ((calloutState->stringArgIndex)) + 1);
	/* begin ffiPushPointer:in: */
	if ((((calloutState->currentArg)) + 4) > ((calloutState->limit))) {
		return FFIErrorCallFrameTooBig;
	}
	longAtput((calloutState->currentArg), copy);
	(calloutState->currentArg = ((calloutState->currentArg)) + 4);
	return 0;
}


/*	Push the contents of the given external structure */

static sqInt
ffiPushStructureContentsOfin(sqInt oop, CalloutState *calloutState) {
    sqInt *argSpec;
    sqInt *argSpec1;
    sqInt argSpecSize;
    sqInt argSpecSize1;
    sqInt ptrAddress;
    sqInt ptrClass;
    sqInt roundedSize;
    sqInt roundedSize1;
    sqInt structSize;
    sqInt structSize1;

	ptrClass = interpreterProxy->fetchClassOf(oop);
	if (ptrClass == (interpreterProxy->classExternalAddress())) {

		/* ExternalAddress is bytes */
		/* There is no way we can make sure the structure is valid.
		But we can at least check for attempts to pass pointers to ST memory. */

		ptrAddress = interpreterProxy->fetchPointerofObject(0, oop);
		if (interpreterProxy->isInMemory(ptrAddress)) {
			return FFIErrorInvalidPointer;
		}
		/* begin ffiPushStructure:ofSize:typeSpec:ofLength:in: */
		structSize = ((calloutState->ffiArgHeader)) & FFIStructSizeMask;
		argSpec = (calloutState->ffiArgSpec);
		argSpecSize = (calloutState->ffiArgSpecSize);
		roundedSize = (structSize + 3) & (~3);
		if ((((calloutState->currentArg)) + roundedSize) > ((calloutState->limit))) {
			return FFIErrorCallFrameTooBig;
		}
		memcpy((calloutState->currentArg), ((void *) ptrAddress), structSize);
		(calloutState->currentArg = ((calloutState->currentArg)) + roundedSize);
		return 0;
	}
	if (ptrClass == (interpreterProxy->classByteArray())) {
		if (!((interpreterProxy->byteSizeOf(oop)) == (((calloutState->ffiArgHeader)) & FFIStructSizeMask))) {
			return FFIErrorStructSize;
		}
		ptrAddress = ((int) (interpreterProxy->firstIndexableField(oop)));
		if (!(((calloutState->ffiArgHeader)) & FFIFlagPointer)) {
			if ((((calloutState->callFlags)) & FFICallFlagThreaded)
			 && (interpreterProxy->isYoung(oop))) {
				return -PrimErrObjectMayMove;
			}
			/* begin ffiPushStructure:ofSize:typeSpec:ofLength:in: */
			structSize1 = ((calloutState->ffiArgHeader)) & FFIStructSizeMask;
			argSpec1 = (calloutState->ffiArgSpec);
			argSpecSize1 = (calloutState->ffiArgSpecSize);
			roundedSize1 = (structSize1 + 3) & (~3);
			if ((((calloutState->currentArg)) + roundedSize1) > ((calloutState->limit))) {
				return FFIErrorCallFrameTooBig;
			}
			memcpy((calloutState->currentArg), ((void *) ptrAddress), structSize1);
			(calloutState->currentArg = ((calloutState->currentArg)) + roundedSize1);
			return 0;
		}
		if (!((((calloutState->ffiArgHeader)) & FFIStructSizeMask) == 4)) {
			return FFIErrorStructSize;
		}
		ptrAddress = interpreterProxy->fetchPointerofObject(0, oop);
		if (interpreterProxy->isInMemory(ptrAddress)) {
			return FFIErrorInvalidPointer;
		}
		/* begin ffiPushPointer:in: */
		if ((((calloutState->currentArg)) + 4) > ((calloutState->limit))) {
			return FFIErrorCallFrameTooBig;
		}
		longAtput((calloutState->currentArg), ptrAddress);
		(calloutState->currentArg = ((calloutState->currentArg)) + 4);
		return 0;
	}
	return FFIErrorBadArg;
}

static sqInt
ffiPushStructureofSizetypeSpecofLengthin(void *pointer, sqInt structSize, sqInt *argSpec, sqInt argSpecSize, CalloutState *calloutState) {
    sqInt roundedSize;

	roundedSize = (structSize + 3) & (~3);
	if ((((calloutState->currentArg)) + roundedSize) > ((calloutState->limit))) {
		return FFIErrorCallFrameTooBig;
	}
	memcpy((calloutState->currentArg), pointer, structSize);
	(calloutState->currentArg = ((calloutState->currentArg)) + roundedSize);
	return 0;
}

static sqInt
ffiPushUnsignedBytein(sqInt value, CalloutState *calloutState) {
	if ((((calloutState->currentArg)) + 4) > ((calloutState->limit))) {
		return FFIErrorCallFrameTooBig;
	}
	longAtput((calloutState->currentArg), ((unsigned char) value));
	(calloutState->currentArg = ((calloutState->currentArg)) + 4);
	return 0;
}

static sqInt
ffiPushUnsignedCharin(sqInt value, CalloutState *calloutState) {
	if ((((calloutState->currentArg)) + 4) > ((calloutState->limit))) {
		return FFIErrorCallFrameTooBig;
	}
	longAtput((calloutState->currentArg), ((unsigned char) value));
	(calloutState->currentArg = ((calloutState->currentArg)) + 4);
	return 0;
}

static sqInt
ffiPushUnsignedIntin(sqInt value, CalloutState *calloutState) {
	if ((((calloutState->currentArg)) + 4) > ((calloutState->limit))) {
		return FFIErrorCallFrameTooBig;
	}
	longAtput((calloutState->currentArg), value);
	(calloutState->currentArg = ((calloutState->currentArg)) + 4);
	return 0;
}


/*	Push an unsigned longlong type (e.g., a 64bit integer).
	Note: Coercions from float are *not* supported. */

static sqInt
ffiPushUnsignedLongLongOopin(sqInt oop, CalloutState *calloutState) {
    usqLong value;

	if ((oop == (interpreterProxy->nilObject()))
	 || (oop == (interpreterProxy->falseObject()))) {
		value = 0;
	}
	else {
		if (oop == (interpreterProxy->trueObject())) {
			value = 1;
		}
		else {
			value = interpreterProxy->positive64BitValueOf(oop);
			if (interpreterProxy->failed()) {
				return FFIErrorCoercionFailed;
			}
		}
	}
	/* begin ffiPushUnsignedLongLong:in: */
	if ((((calloutState->currentArg)) + 8) > ((calloutState->limit))) {
		return FFIErrorCallFrameTooBig;
	}
	longAtput((calloutState->currentArg), ((usqInt) value));
	longAtput(((calloutState->currentArg)) + 4, ((usqInt) (value >> 32)));
	(calloutState->currentArg = ((calloutState->currentArg)) + 8);
	return 0;
}

static sqInt
ffiPushUnsignedLongLongin(usqLong value, CalloutState *calloutState) {
	if ((((calloutState->currentArg)) + 8) > ((calloutState->limit))) {
		return FFIErrorCallFrameTooBig;
	}
	longAtput((calloutState->currentArg), ((usqInt) value));
	longAtput(((calloutState->currentArg)) + 4, ((usqInt) (value >> 32)));
	(calloutState->currentArg = ((calloutState->currentArg)) + 8);
	return 0;
}

static sqInt
ffiPushUnsignedShortin(sqInt value, CalloutState *calloutState) {
	if ((((calloutState->currentArg)) + 4) > ((calloutState->limit))) {
		return FFIErrorCallFrameTooBig;
	}
	longAtput((calloutState->currentArg), ((unsigned short) value));
	(calloutState->currentArg = ((calloutState->currentArg)) + 4);
	return 0;
}


/*	This is a fallback in case somebody tries to pass a 'void' value.
	We could simply ignore the argument but I think it's better to let
	the caller know what he did */

static sqInt
ffiPushVoidin(sqInt ignored, CalloutState *calloutState) {
	return FFIErrorAttemptToPassVoid;
}


/*	Create a Smalltalk string from a zero terminated C string */

static sqInt
ffiReturnCStringFrom(sqInt cPointer) {
    char *cString;
    sqInt i;
    sqInt strLen;
    sqInt strOop;
    char *strPtr;

	if (cPointer == null) {
		return interpreterProxy->methodReturnValue(interpreterProxy->nilObject());
	}
	cString = ((char *) cPointer);
	strLen = 0;
	while (!((cString[strLen]) == 0)) {
		strLen += 1;
	}
	strOop = interpreterProxy->instantiateClassindexableSize(interpreterProxy->classString(), strLen);
	strPtr = interpreterProxy->firstIndexableField(strOop);
	for (i = 0; i <= (strLen - 1); i += 1) {
		strPtr[i] = (cString[i]);
	}
	return interpreterProxy->methodReturnValue(strOop);
}


/*	Generic callout support. Create a pointer return value from an external
	function call
 */

static sqInt
ffiReturnPointerofTypein(usqLong retVal, sqInt retType, CalloutState *calloutState) {
    sqInt atomicType;
    sqInt classOop;
    char *cString;
    sqInt i;
    sqInt oop;
    sqInt *ptr;
    sqInt retClass;
    sqInt retOop;
    sqInt strLen;
    sqInt strOop;
    char *strPtr;
    sqInt typeSpec;

	retClass = interpreterProxy->fetchPointerofObject(1, retType);
	if (retClass == (interpreterProxy->nilObject())) {
		/* begin atomicTypeOf: */
		typeSpec = (calloutState->ffiRetHeader);
		atomicType = ((usqInt) (typeSpec & FFIAtomicTypeMask)) >> FFIAtomicTypeShift;
		if ((((usqInt) atomicType) >> 1) == (((usqInt) FFITypeSignedChar) >> 1)) {
			/* begin ffiReturnCStringFrom: */
			if ((((usqInt) retVal)) == null) {
				return interpreterProxy->methodReturnValue(interpreterProxy->nilObject());
			}
			cString = ((char *) (((usqInt) retVal)));
			strLen = 0;
			while (!((cString[strLen]) == 0)) {
				strLen += 1;
			}
			strOop = interpreterProxy->instantiateClassindexableSize(interpreterProxy->classString(), strLen);
			strPtr = interpreterProxy->firstIndexableField(strOop);
			for (i = 0; i <= (strLen - 1); i += 1) {
				strPtr[i] = (cString[i]);
			}
			return interpreterProxy->methodReturnValue(strOop);
		}
		interpreterProxy->pushRemappableOop(retType);
		oop = interpreterProxy->instantiateClassindexableSize(interpreterProxy->classExternalAddress(), 4);
		ptr = interpreterProxy->firstIndexableField(oop);
		ptr[0] = (((sqInt) retVal));
		interpreterProxy->pushRemappableOop(oop);
		retOop = interpreterProxy->instantiateClassindexableSize(interpreterProxy->classExternalData(), 0);

		/* external address */

		oop = interpreterProxy->popRemappableOop();
		interpreterProxy->storePointerofObjectwithValue(0, retOop, oop);

		/* return type */

		oop = interpreterProxy->popRemappableOop();
		interpreterProxy->storePointerofObjectwithValue(1, retOop, oop);
		return interpreterProxy->methodReturnValue(retOop);
	}
	interpreterProxy->pushRemappableOop(retClass);
	if (((calloutState->ffiRetHeader)) & FFIFlagStructure) {
		classOop = interpreterProxy->classByteArray();
	}
	else {
		classOop = interpreterProxy->classExternalAddress();
	}
	oop = interpreterProxy->instantiateClassindexableSize(classOop, 4);
	ptr = interpreterProxy->firstIndexableField(oop);
	ptr[0] = (((sqInt) retVal));

	/* return class */

	retClass = interpreterProxy->popRemappableOop();
	interpreterProxy->pushRemappableOop(oop);
	retOop = interpreterProxy->instantiateClassindexableSize(retClass, 0);

	/* external address */

	oop = interpreterProxy->popRemappableOop();
	interpreterProxy->storePointerofObjectwithValue(0, retOop, oop);
	return interpreterProxy->methodReturnValue(retOop);
}


/*	Create a structure return value from an external function call. The value
	as been stored in
	alloca'ed space pointed to by the calloutState. */

static sqInt
ffiReturnStructofTypein(usqLong longLongRet, sqInt ffiRetType, CalloutState *calloutState) {
    sqInt oop;
    sqInt retClass;
    sqInt retOop;

	retClass = interpreterProxy->fetchPointerofObject(1, ffiRetType);
	retOop = interpreterProxy->instantiateClassindexableSize(retClass, 0);
	interpreterProxy->pushRemappableOop(retOop);
	oop = interpreterProxy->instantiateClassindexableSize(interpreterProxy->classByteArray(), (calloutState->structReturnSize));
	if (returnStructInRegisters((calloutState->structReturnSize))) {
		memcpy(interpreterProxy->firstIndexableField(oop), (&longLongRet), (calloutState->structReturnSize));
	}
	else {
		memcpy(interpreterProxy->firstIndexableField(oop), (calloutState->limit), (calloutState->structReturnSize));
	}
	retOop = interpreterProxy->popRemappableOop();
	interpreterProxy->storePointerofObjectwithValue(0, retOop, oop);
	return interpreterProxy->methodReturnValue(retOop);
}


/*	Answer the return type object for the current invocation */

static sqInt
ffiReturnType(sqInt specOnStack) {
    sqInt argTypes;
    sqInt specLiteral;

	specLiteral = (specOnStack
		? interpreterProxy->stackValue(1)
		: interpreterProxy->literalofMethod(0, interpreterProxy->primitiveMethod()));
	argTypes = interpreterProxy->fetchPointerofObject(ExternalFunctionArgTypesIndex, specLiteral);
	return interpreterProxy->fetchPointerofObject(0, argTypes);
}


/*	Currently all target platforms (Mac OS X ppc or x86, linux x86, Win32)
	answer true
	for the two calling conventions, FFICallTypeCDecl FFICallTypeApi, so let's
	not waste
	time by testing for these. The only issue is whether the FFICallTypeApi is
	callee pops
	or not (which itself is of little importance to an alloca-based
	implementation, but does
	save a few instructions if not). Subclasses can still override if
	necessary.  */

static sqInt
ffiSupportsCallingConvention(sqInt aCallingConvention) {
	return 1;
}


/*	Validate if the given oop (an instance of ExternalData) can be passed as a
	pointer to the given atomic type.
 */

static sqInt
ffiValidateExternalDataAtomicType(sqInt oop, sqInt atomicType) {
    sqInt ptrType;
    sqInt spec;
    sqInt specOop;
    sqInt specType;

	ptrType = interpreterProxy->fetchPointerofObject(1, oop);
	if ((ptrType & 1)) {
		return FFIErrorWrongType;
	}
	if (!(interpreterProxy->isPointers(ptrType))) {
		return FFIErrorWrongType;
	}
	if ((interpreterProxy->slotSizeOf(ptrType)) < 2) {
		return FFIErrorWrongType;
	}
	specOop = interpreterProxy->fetchPointerofObject(0, ptrType);
	if ((specOop & 1)) {
		return FFIErrorWrongType;
	}
	if (!(interpreterProxy->isWords(specOop))) {
		return FFIErrorWrongType;
	}
	if ((interpreterProxy->slotSizeOf(specOop)) == 0) {
		return FFIErrorWrongType;
	}
	spec = interpreterProxy->fetchPointerofObject(0, specOop);
	if (!(spec & FFIFlagAtomic)) {
		return FFIErrorWrongType;
	}
	specType = ((usqInt) (spec & FFIAtomicTypeMask)) >> FFIAtomicTypeShift;
	if (specType != atomicType) {
		if (!((atomicType > FFITypeBool)
			 && (atomicType < FFITypeSingleFloat))) {
			return FFIErrorCoercionFailed;
		}
		if (!((((usqInt) atomicType) >> 1) == (((usqInt) specType) >> 1))) {
			return FFIErrorCoercionFailed;
		}
	}
	return 0;
}


/*	Note: This is coded so that plugins can be run from Squeak. */

static VirtualMachine *
getInterpreter(void) {
	return interpreterProxy;
}


/*	Note: This is hardcoded so it can be run from Squeak.
	The module name is used for validating a module *after*
	it is loaded to check if it does really contain the module
	we're thinking it contains. This is important! */

EXPORT(const char*)
getModuleName(void) {
	return moduleName;
}

static sqInt
halt(void) {
	;
	return 0;
}


/*	By default, disable logging */

EXPORT(sqInt)
initialiseModule(void) {

	/* Get the instSize of ExternalFunction to know whether it contains a cache of the stackSize,
	 and what the offset of ExternalLibraryFunction's functionName and moduleName slots are. */

	ffiLogEnabled = 0;
	externalFunctionInstSize = interpreterProxy->instanceSizeOf(interpreterProxy->classExternalFunction());
	initSurfacePluginFunctionPointers();
	return 1;
}

static sqInt
isAlien(sqInt anOop) {
	return interpreterProxy->includesBehaviorThatOf(interpreterProxy->fetchClassOf(anOop), interpreterProxy->classAlien());
}

static sqInt
isAtomicType(sqInt typeSpec) {
	return typeSpec & FFIFlagAtomic;
}

static sqInt
isDirectAlien(sqInt oop) {
	assert(isAlien(oop));
	return (longAt(oop + BaseHeaderSize)) > 0;
}

static sqInt
msg(char *s) {
	fprintf(stderr, "\n%s: %s", moduleName, s);
	return 0;
}


/*	Answer if a struct returned in memory is returned to the
	referent of a pointer passed as an implciit first argument.
	It almost always is. Subclasses can override if not. */

static sqInt
nonRegisterStructReturnIsViaImplicitFirstArgument(void) {
	return 1;
}


/*	IMPORTANT: IF YOU CHANGE THE NAME OF THIS METHOD YOU MUST CHANGE
	Interpreter>>primitiveCalloutToFFI
	TO REFLECT THE CHANGE. */
/*	Perform a function call to a foreign function.
	Only invoked from method containing explicit external call spec. */

EXPORT(void)
primitiveCallout(void) {
    sqInt externalFunction;
    sqInt meth;
    sqInt nArgs;
    sqInt retryCount;

	meth = interpreterProxy->primitiveMethod();
	if (!((interpreterProxy->literalCountOf(meth)) > 0)) {
		interpreterProxy->primitiveFailFor(PrimErrBadMethod); return;
	}
	externalFunction = interpreterProxy->literalofMethod(0, meth);
	nArgs = interpreterProxy->methodArgumentCount();
	retryCount = 0;
	while (((ffiCallArgArrayOrNilNumArgs(externalFunction, null, nArgs)) == PrimErrObjectMayMove)
 && (((retryCount += 1)) <= nArgs)) {
		interpreterProxy->tenuringIncrementalGC();
	}
	return;
}


/*	Perform a function call to a foreign function.
	Only invoked from ExternalFunction>>invokeWithArguments: */

EXPORT(void)
primitiveCalloutWithArgs(void) {
    sqInt argArray;
    sqInt externalFunction;
    sqInt nArgs;
    sqInt retryCount;

	if (!((interpreterProxy->methodArgumentCount()) == 1)) {
		interpreterProxy->primitiveFailFor(PrimErrBadNumArgs); return;
	}
	retryCount = 0;
	while (1) {
		externalFunction = interpreterProxy->stackValue(1);
		argArray = interpreterProxy->stackValue(0);
		if (!(interpreterProxy->isArray(argArray))) {
			interpreterProxy->primitiveFailFor(PrimErrBadArgument); return;
		}
		nArgs = interpreterProxy->slotSizeOf(argArray);
		if (!(((ffiCallArgArrayOrNilNumArgs(externalFunction, argArray, nArgs)) == PrimErrObjectMayMove)
 && (((retryCount += 1)) <= nArgs))) break;
		interpreterProxy->tenuringIncrementalGC();
	}
	return;
}


/*	arguments: name(type, stack offset)
	width(Integer, 4)
	height(Integer, 3)
	rowPitch(Integer, 2)
	depth(Integer, 1)
	isMSB(Boolean, 0) */

EXPORT(sqInt)
primitiveCreateManualSurface(void) {
    sqInt depth;
    sqInt height;
    sqInt isMSB;
    sqInt result;
    sqInt rowPitch;
    sqInt width;

	if (!((interpreterProxy->methodArgumentCount()) == 5)) {
		return interpreterProxy->primitiveFail();
	}
	width = interpreterProxy->stackIntegerValue(4);
	height = interpreterProxy->stackIntegerValue(3);
	rowPitch = interpreterProxy->stackIntegerValue(2);
	depth = interpreterProxy->stackIntegerValue(1);
	isMSB = interpreterProxy->stackObjectValue(0);
	isMSB = interpreterProxy->booleanValueOf(isMSB);
	if (interpreterProxy->failed()) {
		return null;
	}
	;
	;
	;
	;
	;
	result = createManualSurface(width, height, rowPitch, depth, isMSB);
	if (result < 0) {
		return interpreterProxy->primitiveFail();
	}
	result = interpreterProxy->signed32BitIntegerFor(result);
	return interpreterProxy->popthenPush(6, result);
}


/*	arguments: name(type, stack offset)
	surfaceID(Integer, 0) */

EXPORT(sqInt)
primitiveDestroyManualSurface(void) {
    sqInt result;
    sqInt surfaceID;

	if (!((interpreterProxy->methodArgumentCount()) == 1)) {
		return interpreterProxy->primitiveFail();
	}
	surfaceID = interpreterProxy->stackIntegerValue(0);
	if (interpreterProxy->failed()) {
		return null;
	}
	result = destroyManualSurface(surfaceID);
	if (result == 0) {
		return interpreterProxy->primitiveFail();
	}
	return interpreterProxy->pop(1);
}


/*	Primitive. Allocate an object on the external heap. */

EXPORT(sqInt)
primitiveFFIAllocate(void) {
    sqInt addr;
    sqInt byteSize;
    sqInt oop;
    int *ptr;

	byteSize = interpreterProxy->stackIntegerValue(0);
	if (interpreterProxy->failed()) {
		return null;
	}
	addr = ffiAlloc(byteSize);
	if (addr == 0) {
		return interpreterProxy->primitiveFail();
	}
	oop = interpreterProxy->instantiateClassindexableSize(interpreterProxy->classExternalAddress(), 4);
	ptr = interpreterProxy->firstIndexableField(oop);
	ptr[0] = addr;
	interpreterProxy->popthenPush(2, oop);
}


/*	Return a (signed or unsigned) n byte integer from the given byte offset. */

EXPORT(sqInt)
primitiveFFIDoubleAt(void) {
    sqInt addr;
    sqInt byteOffset;
    double  floatValue;
    sqInt rcvr;

	byteOffset = interpreterProxy->stackIntegerValue(0);
	rcvr = interpreterProxy->stackObjectValue(1);
	if (interpreterProxy->failed()) {
		return 0;
	}
	addr = ffiAddressOfstartingAtsize(rcvr, byteOffset, 8);
	if (interpreterProxy->failed()) {
		return 0;
	}
	((int*)(&floatValue))[0] = ((int*)addr)[0];
	((int*)(&floatValue))[1] = ((int*)addr)[1];
	interpreterProxy->pop(2);
	return interpreterProxy->pushFloat(floatValue);
}


/*	Return a (signed or unsigned) n byte integer from the given byte offset. */

EXPORT(sqInt)
primitiveFFIDoubleAtPut(void) {
    sqInt addr;
    sqInt byteOffset;
    sqInt floatOop;
    double  floatValue;
    sqInt rcvr;

	floatOop = interpreterProxy->stackValue(0);
	if ((floatOop & 1)) {
		floatValue = ((double) ((floatOop >> 1)));
	}
	else {
		floatValue = ((double) (interpreterProxy->floatValueOf(floatOop)));
	}
	byteOffset = interpreterProxy->stackIntegerValue(1);
	rcvr = interpreterProxy->stackObjectValue(2);
	if (interpreterProxy->failed()) {
		return 0;
	}
	addr = ffiAddressOfstartingAtsize(rcvr, byteOffset, 8);
	if (interpreterProxy->failed()) {
		return 0;
	}
	((int*)addr)[0] = ((int*)(&floatValue))[0];
	((int*)addr)[1] = ((int*)(&floatValue))[1];
	interpreterProxy->popthenPush(3, floatOop);
}


/*	Return a (signed or unsigned) n byte integer from the given byte offset. */

EXPORT(sqInt)
primitiveFFIFloatAt(void) {
    sqInt addr;
    sqInt byteOffset;
    float  floatValue;
    sqInt rcvr;

	byteOffset = interpreterProxy->stackIntegerValue(0);
	rcvr = interpreterProxy->stackObjectValue(1);
	if (interpreterProxy->failed()) {
		return 0;
	}
	addr = ffiAddressOfstartingAtsize(rcvr, byteOffset, 4);
	if (interpreterProxy->failed()) {
		return 0;
	}
	((int*)(&floatValue))[0] = ((int*)addr)[0];
	interpreterProxy->pop(2);
	return interpreterProxy->pushFloat(floatValue);
}


/*	Return a (signed or unsigned) n byte integer from the given byte offset. */

EXPORT(sqInt)
primitiveFFIFloatAtPut(void) {
    sqInt addr;
    sqInt byteOffset;
    sqInt floatOop;
    float  floatValue;
    sqInt rcvr;

	floatOop = interpreterProxy->stackValue(0);
	if ((floatOop & 1)) {
		floatValue = ((float) ((floatOop >> 1)));
	}
	else {
		floatValue = ((float) (interpreterProxy->floatValueOf(floatOop)));
	}
	byteOffset = interpreterProxy->stackIntegerValue(1);
	rcvr = interpreterProxy->stackObjectValue(2);
	if (interpreterProxy->failed()) {
		return 0;
	}
	addr = ffiAddressOfstartingAtsize(rcvr, byteOffset, 4);
	if (interpreterProxy->failed()) {
		return 0;
	}
	((int*)addr)[0] = ((int*)(&floatValue))[0];
	interpreterProxy->popthenPush(3, floatOop);
}


/*	Primitive. Free the object pointed to on the external heap. */

EXPORT(sqInt)
primitiveFFIFree(void) {
    sqInt addr;
    sqInt oop;
    int *ptr;

	oop = interpreterProxy->stackObjectValue(0);
	if (interpreterProxy->failed()) {
		return null;
	}
	if (!((interpreterProxy->fetchClassOf(oop)) == (interpreterProxy->classExternalAddress()))) {
		return interpreterProxy->primitiveFail();
	}
	if (!((interpreterProxy->byteSizeOf(oop)) == 4)) {
		return interpreterProxy->primitiveFail();
	}
	ptr = interpreterProxy->firstIndexableField(oop);

	/* Don't you dare to free Squeak's memory! */

	addr = ptr[0];
	if ((addr == 0)
	 || (interpreterProxy->isInMemory(addr))) {
		return interpreterProxy->primitiveFail();
	}
	ffiFree(addr);
	return ptr[0] = 0;
}


/*	Primitive. Return the error code from a failed call to the foreign
	function interface.
	This is for backwards-compatibility. Thread-safe access to the error code
	is via the
	primitive error code. */

EXPORT(sqInt)
primitiveFFIGetLastError(void) {
	interpreterProxy->pop(1);
	return interpreterProxy->pushInteger(ffiLastError);
}


/*	Return a (signed or unsigned) n byte integer from the given byte offset. */

EXPORT(sqInt)
primitiveFFIIntegerAt(void) {
    sqInt addr;
    sqInt byteOffset;
    sqInt byteSize;
    sqInt isSigned;
    sqInt mask;
    sqInt rcvr;
    sqInt value;

	isSigned = interpreterProxy->booleanValueOf(interpreterProxy->stackValue(0));
	byteSize = interpreterProxy->stackIntegerValue(1);
	byteOffset = interpreterProxy->stackIntegerValue(2);
	rcvr = interpreterProxy->stackObjectValue(3);
	if (interpreterProxy->failed()) {
		return 0;
	}
	if (!((byteOffset > 0)
		 && ((byteSize == 1)
 || ((byteSize == 2)
 || (byteSize == 4))))) {
		return interpreterProxy->primitiveFail();
	}
	addr = ffiAddressOfstartingAtsize(rcvr, byteOffset, byteSize);
	if (interpreterProxy->failed()) {
		return 0;
	}
	if (byteSize < 4) {
		if (byteSize == 1) {

			/* short/byte */

			value = byteAt(addr);
		}
		else {
			value = *((short int *) addr);
		}
		if (isSigned) {

			/* sign extend value */

			mask = 1 << ((byteSize * 8) - 1);
			value = (value & (mask - 1)) - (value & mask);
		}
		value = ((value << 1) | 1);
	}
	else {

		/* general 32 bit integer */

		value = longAt(addr);
		value = (isSigned
			? interpreterProxy->signed32BitIntegerFor(value)
			: interpreterProxy->positive32BitIntegerFor(value));
	}
	interpreterProxy->popthenPush(4, value);
}


/*	Store a (signed or unsigned) n byte integer at the given byte offset. */

EXPORT(sqInt)
primitiveFFIIntegerAtPut(void) {
    sqInt addr;
    sqInt byteOffset;
    sqInt byteSize;
    sqInt isSigned;
    sqInt max;
    sqInt rcvr;
    sqInt value;
    sqInt valueOop;

	isSigned = interpreterProxy->booleanValueOf(interpreterProxy->stackValue(0));
	byteSize = interpreterProxy->stackIntegerValue(1);
	valueOop = interpreterProxy->stackValue(2);
	byteOffset = interpreterProxy->stackIntegerValue(3);
	rcvr = interpreterProxy->stackObjectValue(4);
	if (interpreterProxy->failed()) {
		return 0;
	}
	if (!((byteOffset > 0)
		 && ((byteSize == 1)
 || ((byteSize == 2)
 || (byteSize == 4))))) {
		return interpreterProxy->primitiveFail();
	}
	addr = ffiAddressOfstartingAtsize(rcvr, byteOffset, byteSize);
	if (interpreterProxy->failed()) {
		return 0;
	}
	if (isSigned) {
		value = interpreterProxy->signed32BitValueOf(valueOop);
	}
	else {
		value = interpreterProxy->positive32BitValueOf(valueOop);
	}
	if (interpreterProxy->failed()) {
		return 0;
	}
	if (byteSize < 4) {
		if (isSigned) {
			max = 1 << ((8 * byteSize) - 1);
			if (value >= max) {
				return interpreterProxy->primitiveFail();
			}
			if (value < (0 - max)) {
				return interpreterProxy->primitiveFail();
			}
		}
		else {
			if (value >= (1 << (8 * byteSize))) {
				return interpreterProxy->primitiveFail();
			}
		}
		if (byteSize == 1) {
			byteAtput(addr, value);
		}
		else {
			*((short int *) addr) = value;
		}
	}
	else {
		longAtput(addr, value);
	}
	interpreterProxy->popthenPush(5, valueOop);
}


/*	Primitive. Force loading the receiver (an instance of ExternalLibrary). */

EXPORT(sqInt)
primitiveForceLoad(void) {
    sqInt ffiModuleName;
    sqInt moduleHandle;
    sqInt moduleHandlePtr;
    int *ptr;
    sqInt rcvr;

	if (!((interpreterProxy->methodArgumentCount()) == 0)) {
		return interpreterProxy->primitiveFail();
	}
	rcvr = interpreterProxy->stackValue(0);
	if (!(interpreterProxy->isKindOfClass(rcvr, interpreterProxy->classExternalLibrary()))) {
		return ffiFail(FFIErrorBadExternalLibrary);
	}
	moduleHandlePtr = interpreterProxy->fetchPointerofObject(0, rcvr);
	/* begin ffiContentsOfHandle:errCode: */
	if ((moduleHandlePtr & 1)) {
		moduleHandle = ffiFail(FFIErrorBadExternalLibrary);
		goto l1;
	}
	if (!(interpreterProxy->isBytes(moduleHandlePtr))) {
		moduleHandle = ffiFail(FFIErrorBadExternalLibrary);
		goto l1;
	}
	if (!((interpreterProxy->byteSizeOf(moduleHandlePtr)) == 4)) {
		moduleHandle = ffiFail(FFIErrorBadExternalLibrary);
		goto l1;
	}
	moduleHandle = interpreterProxy->fetchPointerofObject(0, moduleHandlePtr);
l1:	/* end ffiContentsOfHandle:errCode: */;
	if (interpreterProxy->failed()) {
		return 0;
	}
	ffiModuleName = interpreterProxy->fetchPointerofObject(1, rcvr);
	if (!(interpreterProxy->isBytes(ffiModuleName))) {
		return ffiFail(FFIErrorBadExternalLibrary);
	}
	moduleHandle = interpreterProxy->ioLoadModuleOfLength(((int) (interpreterProxy->firstIndexableField(ffiModuleName))), interpreterProxy->byteSizeOf(ffiModuleName));
	if (interpreterProxy->failed()) {
		return ffiFail(FFIErrorModuleNotFound);
	}
	ptr = interpreterProxy->firstIndexableField(moduleHandlePtr);
	ptr[0] = moduleHandle;
	return 0;
}


/*	Enable logging of FFI calls by providing it with a log file name. */

EXPORT(sqInt)
primitiveLogCallsTo(void) {
    sqInt logFile;
    sqInt ok;

	if (!((interpreterProxy->methodArgumentCount()) == 1)) {
		return interpreterProxy->primitiveFail();
	}
	logFile = interpreterProxy->stackObjectValue(0);
	if (logFile == (interpreterProxy->nilObject())) {

		/* disable logging */

		ok = ffiLogFileNameOfLength(null, 0);
		if (!(ok)) {
			return interpreterProxy->primitiveFail();
		}
		ffiLogEnabled = 0;
	}
	else {
		if (!(interpreterProxy->isBytes(logFile))) {
			return interpreterProxy->primitiveFail();
		}
		ok = ffiLogFileNameOfLength(interpreterProxy->firstIndexableField(logFile), interpreterProxy->byteSizeOf(logFile));
		if (!(ok)) {
			return interpreterProxy->primitiveFail();
		}
		ffiLogEnabled = 1;
	}
	return interpreterProxy->pop(1);
}


/*	Create a 'manual surface' data-structure. See the ExternalForm class in
	the FFI package for example usage. */
/*	arguments: name(type, stack offset)
	surfaceID(Integer, 1)
	ptr(uint32, 0) */

EXPORT(sqInt)
primitiveSetManualSurfacePointer(void) {
    unsigned int ptr;
    sqInt result;
    sqInt surfaceID;

	if (!((interpreterProxy->methodArgumentCount()) == 2)) {
		return interpreterProxy->primitiveFail();
	}
	surfaceID = interpreterProxy->stackIntegerValue(1);
	ptr = interpreterProxy->positive32BitValueOf(interpreterProxy->stackValue(0));
	if (interpreterProxy->failed()) {
		return null;
	}
	;
	;
	result = setManualSurfacePointer(surfaceID, (void*)ptr);
	if (result == 0) {
		return interpreterProxy->primitiveFail();
	}
	return interpreterProxy->pop(2);
}


/*	Answer any space needed to prevent the alloca'ed outgoing arguments
	marshalling area from
	being overwritten by any register arguments during calls during
	marshalling. On x86 this is 0 */

static sqInt
registerArgsSlop(void) {
	return 0;
}


/*	Note: This is coded so that is can be run from Squeak. */

EXPORT(sqInt)
setInterpreter(struct VirtualMachine*anInterpreter) {
    sqInt ok;

	interpreterProxy = anInterpreter;
	ok = interpreterProxy->majorVersion() == VM_PROXY_MAJOR;
	if (ok == 0) {
		return 0;
	}
	ok = interpreterProxy->minorVersion() >= VM_PROXY_MINOR;
	return ok;
}


/*	Answer the first field of oop which is assumed to be an Alien of at least
	8 bytes
 */

static sqInt
sizeField(sqInt oop) {
	return longAt(oop + BaseHeaderSize);
}


/*	<Alien oop> ^<Integer> */
/*	Answer the start of oop's data. For direct aliens this is the address of
	the second field. For indirect and pointer aliens it is what the second
	field points to. */

static sqInt
startOfData(sqInt oop) {
	return ((longAt(oop + BaseHeaderSize)) > 0
		? (oop + BaseHeaderSize) + BytesPerOop
		: longAt((oop + BaseHeaderSize) + BytesPerOop));
}


#ifdef SQUEAK_BUILTIN_PLUGIN

void* SqueakFFIPrims_exports[][3] = {
	{"SqueakFFIPrims", "ffiLogCallsTo", (void*)ffiLogCallsTo},
	{"SqueakFFIPrims", "getModuleName", (void*)getModuleName},
	{"SqueakFFIPrims", "initialiseModule", (void*)initialiseModule},
	{"SqueakFFIPrims", "primitiveCallout", (void*)primitiveCallout},
	{"SqueakFFIPrims", "primitiveCalloutWithArgs", (void*)primitiveCalloutWithArgs},
	{"SqueakFFIPrims", "primitiveCreateManualSurface", (void*)primitiveCreateManualSurface},
	{"SqueakFFIPrims", "primitiveDestroyManualSurface", (void*)primitiveDestroyManualSurface},
	{"SqueakFFIPrims", "primitiveFFIAllocate", (void*)primitiveFFIAllocate},
	{"SqueakFFIPrims", "primitiveFFIDoubleAt", (void*)primitiveFFIDoubleAt},
	{"SqueakFFIPrims", "primitiveFFIDoubleAtPut", (void*)primitiveFFIDoubleAtPut},
	{"SqueakFFIPrims", "primitiveFFIFloatAt", (void*)primitiveFFIFloatAt},
	{"SqueakFFIPrims", "primitiveFFIFloatAtPut", (void*)primitiveFFIFloatAtPut},
	{"SqueakFFIPrims", "primitiveFFIFree", (void*)primitiveFFIFree},
	{"SqueakFFIPrims", "primitiveFFIGetLastError", (void*)primitiveFFIGetLastError},
	{"SqueakFFIPrims", "primitiveFFIIntegerAt", (void*)primitiveFFIIntegerAt},
	{"SqueakFFIPrims", "primitiveFFIIntegerAtPut", (void*)primitiveFFIIntegerAtPut},
	{"SqueakFFIPrims", "primitiveForceLoad", (void*)primitiveForceLoad},
	{"SqueakFFIPrims", "primitiveLogCallsTo", (void*)primitiveLogCallsTo},
	{"SqueakFFIPrims", "primitiveSetManualSurfacePointer", (void*)primitiveSetManualSurfacePointer},
	{"SqueakFFIPrims", "setInterpreter", (void*)setInterpreter},
	{NULL, NULL, NULL}
};

#endif /* ifdef SQ_BUILTIN_PLUGIN */
