'From Croquet1.0beta of 11 April 2006 [latest update: #1] on 6 January 2010 at 5:51:31 pm'!!QDisplayPanel methodsFor: 'menu' stamp: 'bgf 1/5/2010 14:48'!titleClick: event	"A click on my title (or background) - bring the avatar hither"	event avatar ifNotNilDo: [ : av |			av doWarpMoves ifTrue: [			gotoButton bringToDestination: event		]]! !!QGate methodsFor: 'events' stamp: 'bgf 1/5/2010 14:48'!titleClick: event	"A click on my title (or background) - bring the avatar hither"	event avatar ifNotNilDo: [ : av |			av doWarpMoves ifTrue: [			gotoButton bringToDestination: event		]]! !!QSessionCapturePaneBaseUI methodsFor: 'recording' stamp: 'jcg 1/6/2010 17:46'!startRecording	"Start recording the session"	| resp supportsRecording |	showWarning := true. "warn once per recording"	self isRecording ifTrue:[^self].	"Used in various places below."	startTimeAndDate := DateAndTime now asFileNameString.	"XXXXX: IIRC, we won't run 3.0 clients against older servers... if so, remove this test."	resp := owner serviceMgr netvidPing: owner session hubID.	resp name == #ok ifFalse:[ ^owner inform: 'The server does not support recording'].	"If current audio-interface doesn't support recording, pop up a dialog and give up."	[supportsRecording := owner audioSession audioInterface supportsRecording]		on: Error do: [:err |			QLogger logError: err.			^owner inform: 				'Failed to start audio-capture due to error in audio sub-system'		].	supportsRecording ifFalse: [		| yesNo |		yesNo := CDialog 					confirm: 						'Session-recording and webcast require OpenAL to be enabled.',						String cr, String cr,						'Open the Sound Settings pane to make this change?'					yes: 'Yes'					no: 'No'					label: 'OpenAL is disabled'.		yesNo ifTrue: [owner controlBar adjustSound].		^self.	].	"Some final things may need to be done before starting recording..."	self doFinalRecordingPreparations.	"Now that everything is set up, we can actually start recording."	super startRecording.	"Update the UI to reflect that we're recording."	self isRecording ifTrue: [		placeChoice disable.		qualityChoice disable.	]! !!QwaqAudioSession methodsFor: 'initialize' stamp: 'jcg 1/6/2010 17:47'!initializeFromPreferences: prefs "a QUserPreferences"	| device |	[		SoundPlayer defaultPlayer isEmptyOrNil ifTrue: [			"Important on windows where sys default might be different than our preference.			Set it now before things get started."			device := prefs audioPlayer.			SoundPlayer defaultPlayer: device.			self openALDevice: device.			 ].		self useOpenAL: prefs useOpenAL.		self startScript: #useOpenAL: when: {prefs. #useOpenALChanged}.	] on: Error do: [  : ex |		QLogger logWarning: 'failed to initialize audio-session (there will be no sound)'.		QLogger logError: ex.	]! !!TFrame methodsFor: 'render' stamp: 'bgf 1/12/2010 13:34'!renderSelection: ogl color: color	"Render selection-boxing indicators that this object is selected.	 Returns the bounding-box that has been outlined."	| box descale m lineWid alphaAdjust |	descale := 1.0 / self nominalScale.	box := self boundingBox.	box := (box clone scale: descale) atLeast: (0.01).	box min:	  (box origin - (box middleDimension * 0.005))		max: (box corner + (box middleDimension * 0.005)).	"Line thickness and opacity are reduced when distance exceeds thresholds	 based on the size of the object... so they don't overpower at long distance."	lineWid := 3.0.	alphaAdjust := 1.0.	ogl objectDistanceSquared ifNotNilDo: [ :ds |		ds > ((box middleDimension * 4) squared)  ifTrue: [ lineWid := 2.0 ].		ds > 2500 ifTrue: [ alphaAdjust := 0.75 ].	].	ogl glDisable: GLFog.	"Show the hidden boundaries in a stippled thin outline."	(OpenGL maxRendererFlags anyMask: 8  "B3D-Antialiasing " ) ifTrue: [		"If we're not antialiasing, don't do stipples either; they cause trouble with very-lame cards."		ogl glDisable: GLDepthTest.		ogl glLineStipple: 1 with: 4r03030303.		ogl glEnable: GLLineStipple.		box outline: ogl			color: (color clone alpha: (color alpha * alphaAdjust  * 0.6))			thickness: 1.		ogl glEnable: GLDepthTest.		ogl glDisable: GLLineStipple.	].	box		outline: ogl 		color: (color clone alpha: (color alpha * alphaAdjust))		thickness: (lineWid).	ogl glEnable: GLFog.	false ifTrue: [		"Inside-out matte box.  		 Omitted for now as it encourages one to think that	 	 that the bounding box of the selection should be menu-able."		m := self class selectionMatteMaterial.		m enable: ogl.		self render: ogl 			cube: box			location: box center			scale: 1.0.		m disable: ogl.	].	^ box! !!TOutlineGroup methodsFor: 'render' stamp: 'bgf 1/12/2010 13:35'!render: ogl alpha: bAlpha	"The outline group's appearance is the bounding box outline."	| doLine doBox box descale |	doLine := (lineColor alpha < 1) = bAlpha.	doBox := matte notNil and: [ matte hasAlpha  = bAlpha ].	(doBox | doLine) ifFalse: [ ^ self ].	descale := 1.0 / (self nominalScale).	box := self boundingBox.	box := (box clone scale: descale) atLeast: (0.1).	box min:	  (box origin - (box middleDimension * 0.0125))		max: (box corner + (box middleDimension * 0.0125)).	doLine ifTrue: [		hiddenLineWidth > 0 ifTrue: [			(OpenGL maxRendererFlags anyMask: 8  "B3D-Antialiasing " ) ifTrue: [				"If not antialiasing, don't do stipples either; they cause trouble with very-lame cards."				ogl glDisable: GLDepthTest.				ogl glLineStipple: 1 with: 4r03030303; glEnable: GLLineStipple.				box outline: ogl color: hiddenLineColor thickness: hiddenLineWidth.				ogl glDisable: GLLineStipple.				ogl glEnable: GLDepthTest.			]].		lineWidth > 0 ifTrue: [			box outline: ogl  color: lineColor thickness: lineWidth.		].	].	doBox ifTrue: [		matte enable: ogl.		box render: ogl.		matte disable: ogl.	].! !!QEditBox methodsFor: 'persist' stamp: 'bgf 1/11/2010 12:43'!constructFrom: pStream	"Persist the receiver"	| trans scl |	super constructFrom: pStream.	trans := self localTransform.	self edit: (pStream readObject: 'contents' default: self contents).	"fix up for new, improved scale management"	scl := (pStream readNumber: 'scale' default: self scale).	scaleFrame nominalScale: scaleFrame nominalScale*scl.	contents ifNotNil: [		contents nominalScale: 1.0.	].	self extent: (pStream readVector3: 'extent' default: self extent).	self localTransform: trans.! !!QEditBox methodsFor: 'initialize' stamp: 'bgf 1/11/2010 12:45'!edit: conts	(conts isKindOf: QEditBox) ifTrue: [ ^ self ].	contents = conts ifTrue:[^ self ].	contents ifNotNil:[ self stopScript: #contentsDeleted. self outOfBox.].	undoMessage := OrderedCollection new. "reset the undo array"	contents := conts.	self runScript: #contentsDeleted when: {contents. #destroyed.}.	contents ifNotNil: [			self intoBox.	].! !!QControlBar methodsFor: 'events' stamp: 'bgf 12/30/2009 14:42'!onSessionChanged	"The owner sets the mainView after harness setup;	 we catch the changes here and keep my 'view' up to date."	<on: sessionChanged in: owner>	self stopScript: #updateAppCount.	owner session ifNotNil: [		self startScript: #updateAppCount when: {owner session . #embeddedAppsUpdated }.		].	self isSeatNearby: false.	self stopScript: #postureChangedFrom:to:.	self stopScript: #isSeatNearby:.	owner avatar ifNotNil: [		self startScript: #postureChangedFrom:to: 			when: { owner avatar . #postureChangedFrom:to: }.		self startScript: #isSeatNearby: 			when: { owner avatar . #isNearASeat }.	].! !!TRay methodsFor: 'picking' stamp: 'bgf 12/24/2009 10:18'!pickBoundSphere: bnds	"This method only answers yes/no."	| position dp d distance gp |	"Test the ray against a TBoundSphere or TBoundSphereUnion"	bnds ifNil:[^ false ]. "nothing to pick"	gp := bnds globalPosition.	gp ifNil:[ ^false ].	position := gp - self globalPosition.	distance :=  ((position length - bnds globalRadius) * frameScale).	self selectedDistance ifNotNilDo: [ : sd |		sd > distance ifFalse:[ ^ false].		"Already found something closer."	].	(self maxDistance * frameScale) > distance ifFalse: [ ^ false ].		"Out of range"	dp := position - ((lookAt dot: position)*lookAt).	d := dp dot: dp.	d < bnds globalRadiusSquared ifFalse:[ ^ false ].	self sphereDistSquared: d.	^ true.! !!QInspector methodsFor: 'events' stamp: 'bgf 1/12/2010 13:39'!onSelectionChanged	|   selFrame |	<on: cursorChanged in: objectsTree>	DropAllButLastEvent signal.	selectionPath ifNotNil: [ ^ self ].		"Distinguishes intermediate states during trree-refresh."	self selectedItem ifNotNilDo: [ : item | | klass |		klass :=  item actualValue get: #class.		((klass includesBehavior: TFrame) and: [ (klass includesBehavior: TSpace) not ]) 		ifTrue: [			selFrame := item actualValue.		]. 		objectsTree menu: (item treeMenu: self).		objectsTree scrollToShow: (item bounds expandBy: (0@24)).	].	owner avatar ifNil: [ ^ self ].	owner avatar replica isValidFarRef ifTrue: [		(selFrame isValidFarRef and: [ selFrame island = owner avatar replica island ])		ifTrue: [ 			owner avatar replica future selectFrame: selFrame		] ifFalse: [			owner avatar replica future clearFrameSelection		]]! !