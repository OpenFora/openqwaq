'From Croquet1.0beta of 11 April 2006 [latest update: #1] on 23 December 2009 at 9:37:33 am'!!QAvatarReplica methodsFor: 'goto' stamp: 'bgf 12/23/2009 09:15'!currentPlace: aQPlace stance: stance andFollow: bFollow	"Make the given place my current place, and go there.	 If bFollow is true, arrange keep going to the place if it moves,	 until further notice (until my current place is changed again.)	 Signals #placeChanged at any change, 	 including when the place is cleared to nil."	currentPlace ~= aQPlace ifTrue: [		self stopScript: #doFollowPlace:.		followPlaceTime := nil.		currentPlace := aQPlace.		currentPlaceStance := stance.		self signal: #placeChanged with: currentPlace.		(bFollow and: [currentPlace notNil]) ifTrue: [			"A little magic - if I go to a moving destination, I follow it..."			self startFollowingPlace: currentPlace.		]	] ifFalse: [		(currentPlaceStance = stance) ifFalse: [			currentPlaceStance := stance.			self signal: #placeChanged with: currentPlace		].	].	currentPlaceVia := nil.	currentPlace ifNotNil: [ lastMovedTime := nil ].	self updateFocalTransform.	besideMePlace ifNotNil: [		besideMePlace 			suggestedPOV: (self currentPlacePOV)	].	self refreshLeaderPlace.	"Bring the crew, if I'm leading."	"The cleaner setup does a stopscript that might stop -me- so it needs to be async."	self future setCurrentPlaceCleanup: (self destinationFrame).	^ currentPlace ! !!QAvatarReplica methodsFor: 'private' stamp: 'bgf 12/23/2009 09:15'!setCurrentPlaceCleanup: placeFrame	"Don't remain logically attached to places that get removed.	 This is called out into a separate future-sent method because 	 the methods that call it sometimes arise from clearCurrentPlace,  	 which is stopped here."	self stopScript: #clearCurrentPlace.	(placeFrame notNil and: [ placeFrame = self destinationFrame ] ) 	 ifTrue: [		self startScript: #clearCurrentPlace when: {placeFrame . #deleted}.		self startScript: #clearCurrentPlace when: {placeFrame . #destroyed}.	].! !!QAutoActionJob class methodsFor: 'job handling' stamp: 'bgf 12/28/2009 11:26'!startJob: job forClient: aParticipantUI	"Handle the autosave request, unless someone else got there first."	| resultRef |	job isValidRef ifFalse: [ ^ self ].	(resultRef  := job future confirmSaveBegin) whenResolved: [ : yesNo |		(yesNo == true) ifTrue: [			"Note we don't check readyForEvents here, 	 		 since auto-saves need to fire around logouts, etc."			aParticipantUI exitTripped ifFalse: [				aParticipantUI signal: self jobActionTrigger with: (job get:#requester).			]		].		resultRef discardRef.	].! !!QAutoImportJob class methodsFor: 'job handling' stamp: 'bgf 12/28/2009 11:28'!startJob: job forClient: aParticipantUI	"Handle the processing request, unless someone else got there first."	| avatar resultRef |	"Not if exiting, or reconnecting, or anything suspect.. only volunteer when happy."	aParticipantUI readyForEvents ifFalse: [ ^ self ].	aParticipantUI avatar isDelayed ifTrue: [ ^ self ].	avatar := aParticipantUI avatar replica.	(avatar isValidRef and: [avatar island = job island]) ifFalse: [ "eg., teleporting" ^self ].	aParticipantUI readyForEvents ifFalse: [ ^ self ].	(resultRef  := (job future confirmSaveBegin: avatar)) whenResolved: [ : yesNo |		(yesNo == true) ifTrue: [			aParticipantUI readyForEvents ifTrue: [ 				aParticipantUI avatar isDelayed ifFalse: [					aParticipantUI signal: self jobActionTrigger with: (job get:#requester).				].			].		].		resultRef discardRef	].! !