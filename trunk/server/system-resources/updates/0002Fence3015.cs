'From Croquet1.0beta of 11 April 2006 [latest update: #1] on 29 September 2009 at 11:29:50 pm'!

!ClassDescription methodsFor: 'compiling' stamp: 'bgf 9/27/2009 12:29'!acceptsLoggingOfCompilation	^ false! !
SharedPool subclass: #GLExtConstants	instanceVariableNames: ''	classVariableNames: 'GLArrayBufferARB GLArrayBufferBindingARB GLArrayElementLockCountEXT GLArrayElementLockFirstEXT GLBoolARB GLBoolVec2ARB GLBoolVec3ARB GLBoolVec4ARB GLBufferAccessARB GLBufferMappedARB GLBufferSizeARB GLBufferUsageARB GLColorArrayBufferBindingARB GLColorAttachment0EXT GLColorAttachment10EXT GLColorAttachment11EXT GLColorAttachment12EXT GLColorAttachment13EXT GLColorAttachment14EXT GLColorAttachment15EXT GLColorAttachment1EXT GLColorAttachment2EXT GLColorAttachment3EXT GLColorAttachment4EXT GLColorAttachment5EXT GLColorAttachment6EXT GLColorAttachment7EXT GLColorAttachment8EXT GLColorAttachment9EXT GLColorSumARB GLCompressedAlphaARB GLCompressedIntensityARB GLCompressedLuminanceAlphaARB GLCompressedLuminanceARB GLCompressedRgbARB GLCompressedRgbaARB GLCompressedRgbaS3tcDxt1EXT GLCompressedRgbaS3tcDxt3EXT GLCompressedRgbaS3tcDxt5EXT GLCompressedRgbS3tcDxt1EXT GLCompressedTextureFormatsARB GLCurrentMatrixARB GLCurrentMatrixStackDepthARB GLCurrentVertexAttribARB GLDepthAttachmentEXT GLDynamicCopyARB GLDynamicDrawARB GLDynamicReadARB GLEdgeFlagArrayBufferBindingARB GLElementArrayBufferARB GLElementArrayBufferBindingARB GLFLOAT GLFloatMat2ARB GLFloatMat3ARB GLFloatMat4ARB GLFloatVec2ARB GLFloatVec3ARB GLFloatVec4ARB GLFogCoordinateArrayBufferBindingARB GLFragmentShaderARB GLFragmentShaderDerivativeHintARB GLFramebufferAttachmentObjectNameEXT GLFramebufferAttachmentObjectTypeEXT GLFramebufferAttachmentTexture3dZoffsetEXT GLFramebufferAttachmentTextureCubeMapFaceEXT GLFramebufferAttachmentTextureLevelEXT GLFramebufferBindingEXT GLFramebufferCompleteEXT GLFramebufferEXT GLFramebufferIncompleteAttachmentEXT GLFramebufferIncompleteDimensionsEXT GLFramebufferIncompleteDrawBufferEXT GLFramebufferIncompleteFormatsEXT GLFramebufferIncompleteMissingAttachmentEXT GLFramebufferIncompleteReadBufferEXT GLFramebufferUnsupportedEXT GLGenerateMipmapHintSGIS GLGenerateMipmapSGIS GLINT GLIndexArrayBufferBindingARB GLIntVec2ARB GLIntVec3ARB GLIntVec4ARB GLInvalidFramebufferOperationEXT GLMatrix0ARB GLMatrix10ARB GLMatrix11ARB GLMatrix12ARB GLMatrix13ARB GLMatrix14ARB GLMatrix15ARB GLMatrix16ARB GLMatrix17ARB GLMatrix18ARB GLMatrix19ARB GLMatrix1ARB GLMatrix20ARB GLMatrix21ARB GLMatrix22ARB GLMatrix23ARB GLMatrix24ARB GLMatrix25ARB GLMatrix26ARB GLMatrix27ARB GLMatrix28ARB GLMatrix29ARB GLMatrix2ARB GLMatrix30ARB GLMatrix31ARB GLMatrix3ARB GLMatrix4ARB GLMatrix5ARB GLMatrix6ARB GLMatrix7ARB GLMatrix8ARB GLMatrix9ARB GLMaxColorAttachmentsEXT GLMaxCombinedTextureImageUnitsARB GLMaxFragmentUniformComponentsARB GLMaxProgramAddressRegistersARB GLMaxProgramAttribsARB GLMaxProgramEnvParametersARB GLMaxProgramInstructionsARB GLMaxProgramLocalParametersARB GLMaxProgramMatricesARB GLMaxProgramMatrixStackDepthARB GLMaxProgramNativeAddressRegistersARB GLMaxProgramNativeAttribsARB GLMaxProgramNativeInstructionsARB GLMaxProgramNativeParametersARB GLMaxProgramNativeTemporariesARB GLMaxProgramParametersARB GLMaxProgramTemporariesARB GLMaxRectangleTextureSizeARB GLMaxRenderbufferSizeEXT GLMaxTextureCoordsARB GLMaxTextureImageUnitsARB GLMaxVaryingFloatsARB GLMaxVertexAttribsARB GLMaxVertexTextureImageUnitsARB GLMaxVertexUniformComponentsARB GLMultisampleARB GLMultisampleFilterHintNV GLNormalArrayBufferBindingARB GLNumCompressedTextureFormatsARB GLObjectActiveAttributeMaxLengthARB GLObjectActiveAttributesARB GLObjectActiveUniformMaxLengthARB GLObjectActiveUniformsARB GLObjectAttachedObjectsARB GLObjectCompileStatusARB GLObjectDeleteStatusARB GLObjectInfoLogLengthARB GLObjectLinkStatusARB GLObjectShaderSourceLengthARB GLObjectSubtypeARB GLObjectTypeARB GLObjectValidateStatusARB GLProgramAddressRegistersARB GLProgramAttribsARB GLProgramBindingARB GLProgramErrorPositionARB GLProgramErrorStringARB GLProgramFormatARB GLProgramFormatAsciiARB GLProgramInstructionsARB GLProgramLengthARB GLProgramNativeAddressRegistersARB GLProgramNativeAttribsARB GLProgramNativeInstructionsARB GLProgramNativeParametersARB GLProgramNativeTemporariesARB GLProgramObjectARB GLProgramParametersARB GLProgramStringARB GLProgramTemporariesARB GLProgramUnderNativeLimitsARB GLProxyTextureRectangleARB GLReadOnlyARB GLReadWriteARB GLRenderbufferAlphaSizeEXT GLRenderbufferBindingEXT GLRenderbufferBlueSizeEXT GLRenderbufferDepthSizeEXT GLRenderbufferEXT GLRenderbufferGreenSizeEXT GLRenderbufferHeightEXT GLRenderbufferInternalFormatEXT GLRenderbufferRedSizeEXT GLRenderbufferStencilSizeEXT GLRenderbufferWidthEXT GLSampler1dARB GLSampler1dShadowARB GLSampler2dARB GLSampler2dRectARB GLSampler2dRectShadowARB GLSampler2dShadowARB GLSampler3dARB GLSamplerCubeARB GLSecondaryColorArrayBufferBindingARB GLShaderObjectARB GLStaticCopyARB GLStaticDrawARB GLStaticReadARB GLStencilAttachmentEXT GLStencilIndex16EXT GLStencilIndex1EXT GLStencilIndex4EXT GLStencilIndex8EXT GLStreamCopyARB GLStreamDrawARB GLStreamReadARB GLTextureBindingRectangleARB GLTextureCompressedARB GLTextureCompressedImageSizeARB GLTextureCompressionHintARB GLTextureCoordArrayBufferBindingARB GLTextureRectangleARB GLTransposeCurrentMatrixARB GLVertexArrayBufferBindingARB GLVertexAttribArrayBufferBindingARB GLVertexAttribArrayEnabledARB GLVertexAttribArrayNormalizedARB GLVertexAttribArrayPointerARB GLVertexAttribArraySizeARB GLVertexAttribArrayStrideARB GLVertexAttribArrayTypeARB GLVertexProgramARB GLVertexProgramPointSizeARB GLVertexProgramTwoSideARB GLVertexShaderARB GLWeightArrayBufferBindingARB GLWriteOnlyARB GLFenceAPPLE GLFenceStatusNV GLAllCompletedNV GLFenceConditionNV GLDrawPixelsAPPLE'	poolDictionaries: ''	category: 'OpenGL-Pools'!Object subclass: #OpenGL	instanceVariableNames: 'platform handle farReference bufRect glExt extensions frontFace maxPortalDepth changeTexture test contentManager textureManager fontManager shaderManager isMirror inPortal3D camera forceWire inGLBlock eventPointer forcePick forceHilite suppressPortals noSwap fogOn transparency portalDepth view vertexBufferDictionary polyCount hasVBO blendFuncStack colorMask meshCache currentMesh renderState gpuProfile nativeIsland resetIdle usingVBO changeMaterial lastMaterial scaleStack clientVertex clientNormal clientTexture clientColor textureEnabled textureMode lastTexture errorCount normalize countTextures timeStamp offsetShift haveDrawRangeElements textureScale isMiniScene isSnapshot vampireMode hasFence fence'	classVariableNames: 'DefaultRendererFlags DisablePartialTextureUploads InstalledOpenGLLibrary MaxRendererFlags MinRendererFlags MinVBO PartialTextureUploads ResetMaterial'	poolDictionaries: 'OpenGLConstants GLExtConstants'	category: 'OpenGL-OpenGL'!!OGLExtManager class methodsFor: 'GL_APPLE_fence' stamp:'bgf 9/27/2009 12:29'!glDeleteFencesAPPLE: t1 with: t2 	<apicall: void 'glDeleteFencesAPPLE' (long ulong*)>	^ self externalCallFailed! !!OGLExtManager class methodsFor: 'GL_APPLE_fence' stamp:'bgf 9/27/2009 12:29'!glGenFencesAPPLE: t1 with: t2 	<apicall: void 'glGenFencesAPPLE' (long ulong*)>	^ self externalCallFailed! !!OGLExtManager class methodsFor: 'GL_APPLE_fence' stamp:'bgf 9/27/2009 12:29'!glSetFenceAPPLE: t1 	<apicall: void 'glSetFenceAPPLE' (ulong)>	^ self externalCallFailed! !!OGLExtManager class methodsFor: 'GL_APPLE_fence' stamp:'bgf 9/27/2009 12:29'!glTestFenceAPPLE: t1 	<apicall: long 'glTestFenceAPPLE' (ulong)>	^ self externalCallFailed! !!OGLExtManager class methodsFor: 'GL_APPLE_fence' stamp:'bgf 9/27/2009 12:29'!initializeAppleFence	self install: 'AppleFence' withEXTConstants: #('DRAW_PIXELS_APPLE		0x8A0A' 'FENCE_APPLE				0x8A0B' )! !!OGLExtManager class methodsFor: 'GL_NV_fence' stamp:'bgf 9/27/2009 12:29'!glDeleteFencesNV: t1 with: t2 	<apicall: void 'glDeleteFencesNV' (long ulong*)>	^ self externalCallFailed! !!OGLExtManager class methodsFor: 'GL_NV_fence' stamp:'bgf 9/27/2009 12:29'!glGenFencesNV: t1 with: t2 	<apicall: void 'glGenFencesNV' (long ulong*)>	^ self externalCallFailed! !!OGLExtManager class methodsFor: 'GL_NV_fence' stamp:'bgf 9/27/2009 12:29'!glSetFenceNV: t1 with: t2 	<apicall: void 'glSetFenceNV' (ulong long)>	^ self externalCallFailed! !!OGLExtManager class methodsFor: 'GL_NV_fence' stamp:'bgf 9/27/2009 12:29'!glTestFenceNV: t1 	<apicall: long 'glTestFenceNV' (ulong)>	^ self externalCallFailed! !!OGLExtManager class methodsFor: 'GL_NV_fence' stamp:'bgf 9/27/2009 12:29'!initializeNvFence	self install: 'NvFence' withEXTConstants: #('ALL_COMPLETED_NV		0x84F2' 'FENCE_STATUS_NV		0x84F3' 'FENCE_CONDITION_NV	0x84F4' )! !!OpenGL methodsFor: 'accessing' stamp:'bgf 9/27/2009 12:29'!hasFence	^ hasFence! !!OpenGL methodsFor: 'fence' stamp:'bgf 9/27/2009 12:29'!beginFence	| t1 |	hasFence		ifFalse: [^ self].	fence		ifNotNil: [QLogger logWarning: 'Pre-existing fence' every: 5000.			self discardFence].	t1 := WordArray new: 1.	CMacOSPlatform isActivePlatform		ifTrue: [self glGenFencesAPPLE: 1 with: t1.			fence := t1 at: 1.			self glSetFenceAPPLE: fence]		ifFalse: [self glGenFencesNV: 1 with: t1.			fence := t1 at: 1.			self glSetFenceNV: fence with: GLAllCompletedNV]! !!OpenGL methodsFor: 'fence' stamp:'bgf 9/27/2009 12:29'!discardFence	| t1 |	hasFence		ifFalse: [^ nil].	fence		ifNil: [^ nil].	t1 := WordArray with: fence.	CMacOSPlatform isActivePlatform		ifTrue: [self glDeleteFencesAPPLE: 1 with: t1]		ifFalse: [self glDeleteFencesNV: 1 with: t1].	fence := nil! !!OpenGL methodsFor: 'fence' stamp:'bgf 9/27/2009 12:29'!endFence	| t1 t2 t3 |	hasFence		ifFalse: [^ self glFinish].	fence		ifNil: [QLogger logWarning: 'No fence.' every: 5000.			^ self glFinish].	t2 := WordArray with: fence.	t1 := Delay forMilliseconds: 5.	t3 := 0.	CMacOSPlatform isActivePlatform		ifTrue: [[t3 > 100				or: [(self glTestFenceAPPLE: fence)						= GLTrue]]				whileFalse: [t3 := t3 + 1.					t1 wait].			self glDeleteFencesAPPLE: 1 with: t2]		ifFalse: [[t3 > 100				or: [(self glTestFenceNV: fence)						= GLTrue]]				whileFalse: [t3 := t3 + 1.					t1 wait].			self glDeleteFencesNV: 1 with: t2].	t3 > 100		ifTrue: [QLogger logWarning: 'Disabling GL Fence (Timed Out)'.			hasFence := false].	fence := nil! !!GLExtConstants class methodsFor: 'pool initialization' stamp: 'bgf 9/29/2009 23:27'!initializeAppleFence	GLDrawPixelsAPPLE := 35338.	GLFenceAPPLE := 35339.! !!GLExtConstants class methodsFor: 'pool initialization' stamp: 'bgf 9/29/2009 23:27'!initializeNvFence	GLAllCompletedNV := 34034.	GLFenceStatusNV := 34035.	GLFenceConditionNV := 34036.! !!OGLExtManager class methodsFor: 'class initialization' stamp:'bgf 9/27/2009 12:29'!initialize	self class		selectorsAndMethodsDo: [:t1 :t2 | 			(t1 ~= #initialize					and: [t1 beginsWith: 'initialize'])				ifTrue: [self perform: t1].			((t1 beginsWith: 'gl')					and: [t2 numLiterals > 0							and: [(t2 literalAt: 1)									isKindOf: ExternalLibraryFunction]])				ifTrue: [self forwardExtMethod: t1]].	GLExtConstants initialize! !!OpenGL methodsFor: 'initialize' stamp:'bgf 9/27/2009 12:29'!initializeIn: t1 	| t2 |	t2 := MaxRendererFlags.	[handle := self				primCreateRenderer: t2				x: t1 left				y: t1 top				w: t1 width				h: t1 height.	handle		ifNil: [t2 ~= MinRendererFlags]		ifNotNil: [false]]		whileTrue: [t2 := self dropFlagsFrom: t2].	handle		ifNil: [^ self error: 'Could not create OpenGL renderer'].	bufRect := t1.	glExt := OGLExtManager new ogl: self.	hasVBO := self hasExtension: #'GL_ARB_vertex_buffer_object'.	hasFence := CMacOSPlatform isActivePlatform				ifTrue: [self hasExtension: #'GL_APPLE_fence']				ifFalse: [self hasExtension: #'GL_NV_fence'].	QLogger logInfo: 'Testing for OpenGL Fence extension: '			, (hasFence					ifTrue: ['present']					ifFalse: ['unavailable']).	self preloadExtensions.	(Smalltalk platformName = 'Mac OS'			and: [Smalltalk osVersion = '1055'])		ifTrue: [(self vendorString beginsWith: 'nvidia' caseSensitive: false)				ifTrue: [self class disablePartialTextureUploads: true]].	(self vendorString beginsWith: 'Parallels' caseSensitive: false)		ifTrue: [(self vendorString includesSubstring: 'nvidia' caseSensitive: false)				ifTrue: [self class disablePartialTextureUploads: true]].	TLogger logInfo: 'VBO available: ' , hasVBO.	TLogger logInfo: 'Partial textures enabled: ' , self class disablePartialTextureUploads not! !!OpenGL methodsFor: 'initialize' stamp:'bgf 9/27/2009 12:29'!swapBuffers	noSwap		ifTrue: [noSwap := false.			^ self].	^ (self primSwapBuffers: handle) notNil! !!OpenGL methodsFor: 'GL_ARB_transpose_matrix' stamp: 'bgf 9/29/2009 23:27'!glLoadTransposeMatrixfARB: m	"This method was automatically generated"	^glExt glLoadTransposeMatrixfARB: m! !!OpenGL methodsFor: 'GL_ARB_transpose_matrix' stamp: 'bgf 9/29/2009 23:27'!glMultTransposeMatrixfARB: m	"This method was automatically generated"	^glExt glMultTransposeMatrixfARB: m! !!OpenGL methodsFor: 'GL_NV_fence' stamp: 'bgf 9/29/2009 23:27'!glDeleteFencesNV: t1 with: t2	"This method was automatically generated"	^glExt glDeleteFencesNV: t1 with: t2! !!OpenGL methodsFor: 'GL_NV_fence' stamp: 'bgf 9/29/2009 23:27'!glGenFencesNV: t1 with: t2	"This method was automatically generated"	^glExt glGenFencesNV: t1 with: t2! !!OpenGL methodsFor: 'GL_NV_fence' stamp: 'bgf 9/29/2009 23:27'!glSetFenceNV: t1 with: t2	"This method was automatically generated"	^glExt glSetFenceNV: t1 with: t2! !!OpenGL methodsFor: 'GL_NV_fence' stamp: 'bgf 9/29/2009 23:27'!glTestFenceNV: t1	"This method was automatically generated"	^glExt glTestFenceNV: t1! !!OpenGL methodsFor: 'GL_APPLE_fence' stamp: 'bgf 9/29/2009 23:27'!glDeleteFencesAPPLE: t1 with: t2	"This method was automatically generated"	^glExt glDeleteFencesAPPLE: t1 with: t2! !!OpenGL methodsFor: 'GL_APPLE_fence' stamp: 'bgf 9/29/2009 23:27'!glGenFencesAPPLE: t1 with: t2	"This method was automatically generated"	^glExt glGenFencesAPPLE: t1 with: t2! !!OpenGL methodsFor: 'GL_APPLE_fence' stamp: 'bgf 9/29/2009 23:27'!glSetFenceAPPLE: t1	"This method was automatically generated"	^glExt glSetFenceAPPLE: t1! !!OpenGL methodsFor: 'GL_APPLE_fence' stamp: 'bgf 9/29/2009 23:27'!glTestFenceAPPLE: t1	"This method was automatically generated"	^glExt glTestFenceAPPLE: t1! !!QwaqParticipantUI methodsFor: 'render' stamp: 'bgf 9/29/2009 21:52'!onRender	| box loadmsg |	<on: render>	DropAllButLastEvent signal.	Processor activeProcess hand: Processor activeProject primaryHand.	self checkHeartbeatLag.	session ifNil:[^nil].	session step. 	session ifNil:[^nil].	self documentManager ifNil: [ ^ nil ].	usersPane lastActivity: (session lastEventTime).	loadmsg := self documentManager resourceLoadingStatus.	loadmsg ifNotNil: [ self signal: #infoMessage with: loadmsg ].	(flowControlFlag or: [ loadmsg notNil ]) ifTrue: [		| msecs|		session ifNil: [ ^ self].		msecs := 25 + ((session percentRenderTime max: 0.0) * 80) rounded.		exitTripped ifFalse: [(Delay forMilliseconds: msecs) wait ]				     ifTrue: [ ^ nil ].	].	session ifNil: [ ^ nil ].	box := self globalBounds.	box := box translateBy:  (window boundsInWorld origin + window borderWidth).	lastBounds ~= box ifTrue:[		self waitTick.		session ifNil: [ ^ nil ].		session renderLock critical: [ session globalBounds: box ].		lastBounds := box.	].	mainView ifNil: [ ^ nil ].	session ogl ifNotNil: [		session renderLock critical: [			self updateTweak.			session ogl ifNil: [ ^ nil ].			mainView ifNil: [ ^ nil ].			mainView camera viewAngle: self getCurrentViewAngle.			session ogl maxPortalDepth: 2.		].		session render.	] ifNil: [		exitTripped ifFalse: [ (Delay forMilliseconds: 10) wait ].	].! !!TWindowedSession methodsFor: 'render' stamp:'bgf 9/27/2009 12:29'!checkSwapBuffer	ogl		ifNil: [^ self].	ogl checkForErrorAt: 'Frame Swap'.	framesToKill > 0		ifTrue: [framesToKill := framesToKill - 1.			ogl				ifNotNil: [ogl discardFence].			ogl				ifNotNil: [ogl noSwap]]		ifFalse: [ogl				ifNotNil: [ogl endFence].			framesToKill < 0				ifTrue: [framesToKill := framesToKill + 1.					framesToKill == 0						ifTrue: [framesToKill := 1]]].	ogl		ifNotNil: [ogl swapBuffers]! !!TWindowedSession methodsFor: 'render' stamp: 'bgf 9/29/2009 22:46'!render	| renderProcess |	doRender ifFalse:[ ^nil ].	ogl ifNil:[ ^ nil ].	renderProcess := [ 		self renderLock critical: [ 			ogl ifNotNil: [ self renderOneFrame.].		].	   ] newProcess.	renderProcess priority: Processor activePriority+1.	renderProcess name: self class name,'>>renderProcess'.	renderProcess island: Processor activeIsland.	self processMessages.	renderProcess resume.! !!TWindowedSession methodsFor: 'render' stamp: 'bgf 9/29/2009 22:05'!renderWorld	| tries trying |	ogl ifNil: [ ^ nil ].	lastCountTime ifNil: [ 		ogl clearWindow: (self class defaultSpaceColor).		lastCountTime := Time millisecondClockValue.	].	ogl ifNil: [  ^ nil ].	self contentManager updateList: ogl.	ogl ifNil: [ ^ nil ].	ogl makeCurrent.	ogl ifNil: [ ^ nil ].	self checkSwapBuffer.	ogl ifNil: [  ^ nil ].	self aboutToRender.	ogl ifNil: [  ^ nil ].	self polyCount: 0; objectCount: 0.	tries := 0.	trying := true.	[ trying and: [ tries < 6 ] ] whileTrue: [		self allIslandsCritical: [			self renderWorldWithIslands.			trying := false.		] ifLocked: [			tries := tries + 1.			(Delay forMilliseconds: 5) wait.		]].	tries > 2 ifTrue: [ QLogger logInfo: 'Render tries: ', tries ].	trying ifTrue: [ self renderWorldWithoutIslands ].	ogl ifNotNil: [ ogl beginFence ].	ogl ifNotNil: [ ogl glFlush ].! !!TWindowedSession methodsFor: 'private' stamp:'bgf 9/27/2009 12:29'!renderWorldWithIslands	| t1 |	ogl		ifNil: [^ nil].	ogl makeCurrent.	ogl		ifNil: [^ nil].	ogl glLoadIdentity.	t1 := Time millisecondClockValue.	ogl		ifNil: [^ nil].	ogl changeMaterial: materialsEnabled.	ogl		ifNil: [^ nil].	self mainView		ifNotNilDo: [:t2 | ogl				clearWindow: ((t2 space get: #color)						ifNil: [self class defaultSpaceColor])].	self panes		do: [:t2 | 			ogl				ifNil: [^ nil].			t2 checkSaveScene: ogl].	snapshots		do: [:t2 | 			ogl				ifNil: [^ nil].			(ogl view notNil					and: [t2 update])				ifTrue: [self renderSnapshot: t2]].	ogl		ifNil: [^ nil].	self panes		do: [:t2 | 			ogl				ifNil: [^ nil].			t2 render: ogl.			t2 = mainView				ifTrue: [self polyCount: ogl polyCount]].	ogl changeMaterial: true.	ogl		ifNil: [^ nil].	ogl camera initFrustum: ogl.	ogl beginFrame.	overlays		do: [:t2 | 			ogl				ifNil: [^ nil].			t2 renderOverlay: ogl].	ogl		ifNil: [^ nil].	ogl endFrame.	self countRenderTime: t1! !!TWindowedSession methodsFor: 'private' stamp:'bgf 9/27/2009 12:29'!renderWorldWithoutIslands	| t1 |	ogl		ifNil: [^ nil].	ogl makeCurrent.	t1 := Time millisecondClockValue.	ogl		ifNil: [^ nil].	ogl changeMaterial: true.	ogl beginFrame.	self panes		do: [:t2 | 			ogl				ifNil: [^ nil].			t2 drawSavedScene: ogl].	ogl		ifNil: [^ nil].	ogl endFrame.	ogl		ifNil: [^ nil].	ogl camera initFrustum: ogl.	ogl beginFrame.	overlays		do: [:t2 | 			ogl				ifNil: [^ nil].			t2 renderOverlay: ogl].	ogl		ifNil: [^ nil].	ogl endFrame.	self countRenderTime: t1! !!TContentManager methodsFor: 'accessing' stamp: 'bgf 9/29/2009 23:55'!resolveSHA: sha	(mutex critical:[contentDictionary at: sha ifAbsent:[nil]])  	ifNotNilDo: [ : entry |		entry content ifNotNilDo: [ : obj |			obj timeStamp: Time millisecondClockValue.			^ obj ]].	^ nil! !
!CPlayer methodsFor: 'private' stamp: 'bgf 9/30/2009 09:45'!onDragMove	| nextPos moved cursor delta wasLocked offset |	container ifNil:[^self].	wasLocked := self locked.	self transformBy: container localToWorld.	self world add: self.	self locked: true.	cursor := self mouseCursor.	self mouseCursor: (cursor ifNil:[Cursor normal]) asForm.	self hand cursorFocus: self.	offset := self cursorPoint.	moved := false.	self hand forEach: #mouseMove do:[		nextPos := self cursorPoint.		delta := nextPos - offset.		moved ifFalse:[			moved := true.		].		self transform: ((COffsetTransform withOffset: delta) transformedBy: self transform).	] until: #mouseUp.	self mouseCursor: cursor.	self hand releaseMouseFocus: self.	self locked: wasLocked.	self hand releaseCursorFocus: self.! !OGLExtManager initialize!