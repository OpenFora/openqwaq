'From Croquet1.0beta of 11 April 2006 [latest update: #1] on 12 January 2010 at 6:23:31 pm'!QSharedDocument subclass: #PyPanelDocCS	instanceVariableNames: 'userSource appName docName startupOwner wasCopied originalServiceURL tpzName version'	classVariableNames: ''	poolDictionaries: ''	category: 'PyBridge-Panels'!!PyPanelApp methodsFor: 'accessing' stamp: 'das 1/2/2010 16:04'!pyShortName	"For convenience"	^document ifNotNil:[document sharedName ifNotNil:[ document sharedName copyAfterLast: $/]]! !!PyPanelDocCS methodsFor: 'accessing' stamp: 'das 12/20/2009 15:17'!asServiceManagerCodePath	"QServiceManager get/put argument we use to refer to this document ."	^ '/services/', (self serviceName), '/', self tpzName.! !!PyPanelDocCS methodsFor: 'accessing' stamp: 'das 12/30/2009 19:53'!sharedName	^ sharedName.! !!PyPanelDocCS methodsFor: 'accessing' stamp: 'das 12/20/2009 16:29'!sharedName: sn	| sfx |	sn ifNotNil:[		sfx :=sn copyAfterLast: $..		(sfx = 'tpz' or:[sfx = 'qpz'])ifTrue:[self tpzName: sn]		ifFalse:[super sharedName: sn].	].! !!PyPanelDocCS methodsFor: 'accessing' stamp: 'das 1/3/2010 19:36'!shortName	| name |	name :=self docName ifNil:[tpzName ifNotNil:[tpzName copyAfterLast:$/]].	name ifNotNil:[		(name beginsWith: '%5B')ifTrue:[name := name copyAfterSubString: '%5D'].	].	^ name.! !!PyPanelDocCS methodsFor: 'accessing' stamp: 'das 12/20/2009 14:43'!tpzName	^ tpzName.! !!PyPanelDocCS methodsFor: 'accessing' stamp: 'das 12/20/2009 14:42'!tpzName: tpzn	tpzName := tpzn.! !!PyPanelDocCS methodsFor: 'accessing' stamp: 'das 12/20/2009 14:45'!version		^ version.! !!PyPanelDocCS methodsFor: 'accessing' stamp: 'das 12/20/2009 14:45'!version: v		version := v.! !!PyPanelDocCS methodsFor: 'protocol' stamp: 'das 12/20/2009 15:05'!canBeExecuted	^ tpzName notNil.! !!PyPanelDocCS methodsFor: 'save' stamp: 'das 12/20/2009 15:07'!doInstallPython: anAvatarReplica	"Open the document privately in an application on the user's computer."	QInstallPython open: self forUser: anAvatarReplica.! !!PyPanelDocCS class methodsFor: 'as yet unclassified' stamp: 'das 1/3/2010 19:49'!version	^ '2.0'.! !!PyPanelDocCS class methodsFor: 'installing' stamp: 'das 12/20/2009 15:18'!getCode: document forClient:owner	"Harness-side operation to acquire the Python code file content as a byte array."	| serviceMgr path data |	serviceMgr := owner serviceMgr.	path := (document get:#asServiceManagerCodePath).	owner statusStatus: 'Downloading ', (document get:#tpzName).	owner flowControlFlag: true.	[[ ^ 		CProgressBar displayProgress: 'Retrieving data ...' 			at: owner bounds center from: 0.0 to: 1.0 			during: [:bar|				data := serviceMgr get: path informing: bar.			].	] on: Error do: [ :exc|		| msg |		data := nil.		owner flowControlFlag:false.		(exc messageText beginsWith: 'FileDoesNotExist') ifTrue: [			msg := 'The original could not be found.'		] ifFalse: [			msg := exc messageText.		].		self error: ('Cannot download ',((document get:#tpzName) ifNil: ['file']), ':\\', msg, '\') withCRs.	]] ensure: [		owner flowControlFlag:false.	].	^ data! !!PyPanelWorldCS methodsFor: 'persist' stamp: 'das 1/3/2010 17:58'!requestDownload: fileName	"Request a new download"	| handle req url  filePath |	QLogger panelLog:fileName.	fileName ifNil:[^self].	filePath := fileName.	url := TPostcard makeUrl: filePath relativeTo: ((session findIslandUrl: app island) copyUpToLast: $/).	handle := (TObjectID for:'PyPanelWorldCS>requestDownload:callback') hex.	req := PyDocumentRequest new.	req panel: self.	req handle: handle.	req downloadUrl: url.	req cacheFileName: (TObjectID for:'PyPanelWorldCS>requestDownload:callback') hex. "random"	req serviceManagerPath:  (session documentManager asServiceManagerPath: url).	req requestType: #pyPanelDoc.	resourceMap at: handle put: req.	session documentManager fetchRequest: req.	^handle! !!PyPanelApp methodsFor: 'accessing' stamp: 'das 1/5/2010 16:59'!includesCode	^ document tpzName notNil.! !!PyPanelApp methodsFor: 'accessing' stamp: 'das 12/20/2009 16:05'!isCodeDoc	^ (document pyAppName isNil and:[document tpzName notNil])! !!PyPanelApp methodsFor: 'accessing' stamp: 'das 1/4/2010 11:14'!newPyDocName	self pyDocName: (self pyAppName copyAfterLast:$.),((DateAndTime now asString findTokens:'-:' )mergeDelimited:''),'.tpd'.	self isDirty: true.	QLogger logInfo: 'New document name: ', self pyShortName.! !!PyPanelApp methodsFor: 'accessing' stamp: 'das 12/21/2009 17:30'!pyDocName	"For convenience"	^document ifNotNil:[document sharedName]! !!PyPanelApp methodsFor: 'properties' stamp: 'das 1/4/2010 11:11'!pyAppend: attrName value: attrValue from: userID	"Set a persistent property"	| data |	data := dict at: attrName ifAbsent:[dict at: attrName put: {attrValue}. ^self].	data class == Array ifTrue:[		dict at: attrName put: (data copyWith: attrValue).	].	self isDirty: true.! !!PyPanelApp methodsFor: 'properties' stamp: 'das 1/4/2010 11:10'!pyDel: attrName from: userID	"Remove a persistent property"	dict removeKey: attrName ifAbsent:[nil].	self signal: #attrChanged with: attrName with: nil with: userID.	self isDirty: true.! !!PyPanelApp methodsFor: 'properties' stamp: 'das 1/2/2010 15:04'!pyGet: attrName	"Answer a persistent property"	^attrName caseOf:{		"The 'special' attributes"		['_doc_name_']	-> [self pyShortName].	} otherwise:[dict at: attrName ifAbsent:[nil]]! !!PyPanelApp methodsFor: 'properties' stamp: 'das 1/4/2010 11:10'!pySet: attrName to: attrValue from: setterID	"Set a persistent property"	attrName caseOf:{		"The 'special' attributes"		['_doc_name_']	-> ["do nothing -deprecated self pyDocName: attrValue asString"].	} otherwise:[dict at: attrName put: attrValue].	self isDirty: true.	self signal: #attrChanged with: attrName with: attrValue with: setterID.! !!PyPanelApp methodsFor: 'events' stamp: 'das 12/20/2009 16:38'!onPyAppInstalled	appName := document tpzName.	appName ifNil:[^self].	appName := appName copyAfterLast:$/.	(appName includes: $.) ifTrue:[appName  := appName copyUpToLast: $..].	(appName includes: $-) ifTrue:[appName  := appName copyUpToLast: $-.].	self pyAppName: 'TeleplacePythonUserApps.',appName.	self startRunning: pyInstalledUserID.! !!PyPanelApp methodsFor: 'persist' stamp: 'das 1/3/2010 19:03'!forceUniqueDocName	"this document name should not match any other document name"	|  list |	self root ifNotNil:[		list := self root find:[:frm | frm class = PyPanelApp].		(self testUnique: list) ifFalse:[			self newPyDocName.		].	].		! !!PyPanelApp methodsFor: 'persist' stamp: 'das 1/3/2010 18:47'!getDataZip	| writer container |	writer := TSceneWriter new.	writer initResourceList.		container := PyContainer new.	version ifNotNil:[dict at:'version' put: version].	dict at:'extent' put: displayPanel extent.	dict at: 'appExtent' put: self appExtent.	container dictionary:dict.	^ self pyDocName ifNotNil:[		writer storeSceneAsZip: container sceneName: 'TeleplacePythonData'.	].! !!PyPanelApp methodsFor: 'persist' stamp: 'das 1/4/2010 11:10'!setDataZip: xml	| reader vcurrent vdata appExt archive|	reader := TSceneReader new.	[		dict := (reader readSceneFromZip: xml sceneName: 'TeleplacePythonData') dictionary.	] on: Error do:[:ex|		"this must be an old named type - read its name and try again"		[			archive := ZipArchive new.			archive readFrom: xml asByteArray readStream.			dict := (reader readSceneFromZip: xml sceneName: archive memberNames first) dictionary.		] on: Error do:[:ey |			self loadFailed.			QLogger logError: ey.			^nil.		].	].	vdata := dict at: 'version' ifAbsent:[nil].	"Check to see if v is <= version. If so - we may not work"	vdata ifNotNil:[		vcurrent := (version at:1)*100 + (version at:2)*10 + (version at:3).		vdata := (vdata at:1)*100 + (vdata at:2)*10 + (vdata at:3).		vcurrent < vdata ifTrue:["we have a problem - deal with it sometime soon"].	].	" Don't do this - it makes the drag and drop of a document resize when if probably should not.	ext := dict at: 'extent' ifAbsent:[nil].	ext ifNotNil:[ displayPanel extent:ext.].	"	appExt := dict at: 'appExtent' ifAbsent:[nil].	appExt ifNotNil:[self appExtentUV1x1: appExt. ].	loaded := true.	self isDirty: false.	self forceUniqueDocName.	self signal: #loadComplete.! !!PyPanelDocCS methodsFor: 'accessing' stamp: 'das 1/5/2010 16:54'!contentSummary	| partial |	^self isCodeDoc ifTrue:[		partial := (self tpzName copyAfterLast:$/).	"Elide 'sharedDocuments/'"		partial := (partial copyUpToLast:$.). "Elide suffix"		userSource ifNotNil:[partial := userSource, ' - ', partial.] ifNil:[		partial := 'unknown - ', partial].		partial.	]ifFalse:[		partial := self docName.		partial ifNil:[ appName ifNotNil:[partial := appName copyAfterLast: $.].].		partial ifNil:[partial := 'undefined'].		(partial beginsWith: '%5B')ifTrue:[partial := partial copyAfterSubString: '%5D'].		partial.	].! !!PyPanelDocCS methodsFor: 'accessing' stamp: 'das 12/30/2009 11:16'!docName	"The name of the document being edited"	^docName ifNil:[sharedName ifNotNil:[sharedName copyAfterLast:$/.]].! !!PyPanelDocCS methodsFor: 'accessing' stamp: 'das 1/3/2010 18:52'!docName: aString	"The name of the document being edited"	docName = aString ifFalse: [		self signal: #docNameChanged.		docName := aString.		aString ifNil:[sharedName := nil] ifNotNil:[			sharedName ifNotNil:[				sharedName := (sharedName copyUpToLast:$/),'/', aString.			] ifNil:[ sharedName := 'sharedDocuments/', aString].		].	].	docName := nil.! !!PyPanelDocCS methodsFor: 'accessing' stamp: 'das 12/20/2009 16:04'!isCodeDoc	^ (self pyAppName isNil and:[self tpzName notNil])! !!PyPanelDocCS methodsFor: 'accessing' stamp: 'das 12/20/2009 15:57'!kindName	"The short name of the kind of document this is, for file-card labeling.   	 We use a heuristic conversion,  based on the convention	 that the application name is Module.<SpecificName>App"	| guess |	guess := self isCodeDoc ifTrue:[self tpzName.]	ifFalse:[self pyAppName.].	"If the app name is 'Module.ScribbleApp', this produces 'Scribble' "	((guess endsWith: 'tpz')or:[guess endsWith:'qpz']) ifTrue: [ guess := (guess copyFrom:1 to: (guess size - 3)) ].		(guess includes: $.) ifTrue: [guess := (guess copyAfterLast:$.) ].	^ guess! !!PyPanelDocCS methodsFor: 'persist' stamp: 'das 1/10/2010 23:29'!constructFrom: pStream	super constructFrom: pStream.	version:=(pStream readString: 'version' default: nil).	self pyAppName: (pStream readString: 'appName' default: appName).	version ifNotNil:[		tpzName := pStream readString:'tpzName' default: tpzName.	]ifNil:[ "an older file card that may have a tpz reference"		version := '1.0'. "this was an original format card - just a reminder"		docName := pStream readString: 'docName' default: docName.		"tpzName := sharedName. --- already done in #sharedName:"		docName ifNotNil:[			docName := docName encodeForHTTP.			sharedName := 'sharedDocuments/', docName. 		].	].	self userSource: (pStream readString: 'userSource' default: userSource).	self startupOwner: (pStream readString: 'startupOwner' default: startupOwner).! !!PyPanelDocCS methodsFor: 'persist' stamp: 'das 1/3/2010 19:05'!copyFrom: aDocument	super copyFrom: aDocument.	aDocument class = PyPanelDocCS ifTrue:[		version := aDocument version.		appName := aDocument pyAppName copy.		tpzName := aDocument tpzName copy.		docName := aDocument docName copy.		userSource := aDocument userSource copy.		startupOwner := aDocument startupOwner copy.	].! !!PyPanelDocCS methodsFor: 'persist' stamp: 'das 1/3/2010 19:05'!persistOn: pStream	super persistOn: pStream.	pStream storeString: 'version' value: version default: nil.	pStream storeString: 'appName' value: appName default: nil.	pStream storeString: 'docName' value: docName default: nil.	pStream storeString: 'tpzName' value: tpzName default: nil.	pStream storeString: 'userSource' value: userSource default: nil.	pStream storeString: 'startupOwner' value: startupOwner default: nil.! !!PyPanelDocCS methodsFor: 'initialize' stamp: 'das 1/3/2010 19:48'!initialize	super initialize.	appName := nil.	startupOwner := nil.	self suffix: 'tpd'.	self cacheLocally: false.	version := self class version.	! !!PyPanelDocCS class methodsFor: 'installing' stamp: 'das 1/12/2010 17:10'!copy: docRef toActiveForum: aParticipant	"Job support protocol: transfer into a forum from inventory."	| short newName response path me |	me := aParticipant simplerLogin.	short := docRef get:#shortName.	path := 'services/', (aParticipant serviceSvc name), '/sharedDocuments'.	QLogger logInfo: 'Copying ', short, ' to ', path.	"Record the action using only the file type suffix, not the full name."	QActivityCapture action: #CopyFromInventory details: (QActivityCapture fileDetails: short).	[		newName := aParticipant documentManager 						checkExistence: short 						path: path						policy: #makeUnique.		response := aParticipant serviceMgr 						copyFiles: (docRef get:#asServiceManagerPath)						to: (path, '/', newName).		response name == #ok 			ifFalse: [ 				aParticipant inform: 						('Cannot copy ', short, ' to the Teleplace:\\', response contentString) withCRs			] ifTrue: [ 				docRef isValidFarRef ifTrue: [					docRef future serviceURL: (aParticipant currentForumURL).					docRef future sharedName: ('sharedDocuments/', newName).				] ifFalse: [					docRef isValidRef ifTrue: [ 						docRef serviceURL: (aParticipant currentForumURL).						docRef sharedName: ('sharedDocuments/', newName).					]]]	] on: Error do: [ :exc | 		aParticipant inform: ('Cannot copy ', short,  ' to the Teleplace:\\', exc description) withCRs	].! !!PyPanelWorldCS methodsFor: 'events' stamp: 'das 1/3/2010 17:52'!onStartStop: bool	QLogger panelLog: bool asString.	self showSpecialName.	bool ifTrue:[		"only run the ownerAliveProcess if this is my application"		QLogger panelLog:'starting'.		(app get: #userID) = session userID ifTrue:[self startOwnerAliveProcess:2000.].	] ifFalse:[		QLogger panelLog:'stopping'.		self stopScript: #onStartStop:.		self stopOwnerAliveProcess.	].! !!PyPanelWorldCS methodsFor: 'client api' stamp: 'das 1/3/2010 19:19'!getDocName	^ app get: #pyShortName.! !!PyPanelWorldCS methodsFor: 'data api' stamp: 'das 1/2/2010 15:38'!docName	^app get: #pyDocName! !!PyPanelWorldCS methodsFor: 'initialize' stamp: 'das 1/3/2010 17:57'!initLoad	| docname |	QLogger panelLog.	self showSpecialName.	(app get: #isLoaded)  ifTrue:[^self].	app future version: self version.	docname := app get: #pyShortName.	docname  ifNotNil:[ 		QLogger logInfo: 'Loading Python document: ', docname.		self requestDownload: 'sharedDocuments/',docname.	].! !!PyPanelWorldCS methodsFor: 'persist' stamp: 'das 8/4/2009 19:20'!requestUpload: fileName data: data callback: callback	"Handle an upload"	fileName ifNil:[^self].	session owner signal: #pyUploadData with: data with: fileName.! !!PyPanelWorldCS methodsFor: 'persist' stamp: 'das 1/4/2010 11:17'!saveSharedContent	"Save the underlying data or document,        as if the user had done a  'save' operation in the app."	| data |	(app get: #isDirty) ifFalse:["do nothing, already saved"		QLogger logInfo:'Python document unchanged: ', (app get: #pyShortName). ^self.]. 	QLogger logInfo:'Save Python data for ', self docName.	(app isValidFarRef and:[(data := app get: #persistData) notNil]) ifTrue:[		self requestUpload: (app get: #pyShortName) data: data callback: nil.	].	"This relies on the form bits onscreen, not the python situation,	 so do it now before the form goes away."	isValidImage ifTrue:[		self savePreview	].	self markClean.! !!QDocumentManager methodsFor: 'cache' stamp: 'das 1/12/2010 17:07'!doOneFetch: request	"Private to the fetch process - fetch a given request."	| serviceMgr path data msg short |	"Fetching is set but not cleared, so we can use it in asynchronous status-line messages."	mutex critical: [		fetching := request.	].	serviceMgr := owner serviceMgr.	path := fetching serviceManagerPath.	short := path copyAfterLast: $/.			[		"Fetching is counted in count to fetch, hence the 1 below."		(self countToFetch > 1) ifTrue: [owner flowControlFlag: true ].		[ 			"One last check to see if this was already fetched..."			request refetch ifFalse: [				data := (cacheMgr find: (request cacheFileName)) ].			data ifNil: [				self reportIntent: path shortName: short kind: (request requestType).				data := serviceMgr get: path informing: [:value|					owner flowControlFlag: true.					fetching fetchProgress: value				].				data ifNil: [ self error: 'Empty fetch result.' ].				fetching cacheFileName notNil ifTrue: [					cacheMgr cache: data to: fetching cacheFileName.				] ifFalse: [					self error: 'Fetched but no cache file name.'.				]].		] on: Error do: [:ex|			| nofile| 			nofile := (ex description includesSubString: 'FileDoesNotExist').			msg := nofile 						ifTrue: [ 'Not found: ', path ]						ifFalse: [ 'Cannot fetch: ', path, ': ', (ex description) ].						(nofile and: [ reportedMissing includes: short ]) ifFalse: [				self reportAbsence: path shortName: short message: msg.			].			data := nil.				].		mutex critical: [ 			fetching := nil.		].		"Inform interested parties about completion of this fetch		 (listeners can observe the request, or the Document-Manager itself)"		self signal: #fetchComplete with: request.		request fetchComplete: data.		self discount: request.		data ifNotNil:[QLogger logInfo: 'File loaded: ',path].	]  ensure: [		owner flowControlFlag: false.	].! !!QInstallPython class methodsFor: 'as yet unclassified' stamp: 'das 12/20/2009 15:23'!doNotice: document	"Remind the user of a little fine print..."	| msg result userSource |	msg := 'The file ', ((document get:#tpzName)copyAfterLast:$/), '\will be copied to your Python applications and will\be available for execution once this is complete.\\Warning:\This Python application may contain code that\can harm your system.\'withCRs.	userSource := document get: #userSource.	userSource ifNotNil:[msg := (msg, '\This file was uploaded by:\', userSource) withCRs.].	result := CDialog confirm: msg label: 'Installing Python Application'.	result := result ifNil: [ false ].	^ result! !!QInstallPython class methodsFor: 'as yet unclassified' stamp: 'das 1/3/2010 19:12'!doOpenPrivateCopy: document forClient: aUI	"Get a local copy of the Python application file if we don't already have one,	 and create a menu item for it so that it can be launched via the client."	| data cacheDir pyDir unzipper menuDir menuFile menuString initFile appName userSource sha tpzName cacheLocally |	document wait.	[[		data := (document get:#class) getCode: document forClient: aUI.		appName := (document get: #tpzName)copyAfterLast:$/.		userSource := document get: #userSource.		sha := document get: #sha.		tpzName := document get: #tpzName.		cacheLocally := document get: #cacheLocally.		(appName includes: $.) ifTrue:[appName  := appName copyUpToLast: $..].		(appName includes: $-) ifTrue:[appName  := appName copyUpToLast: $-.].		data ifNil: [			self inform: 'Cannot install Python Application.'.			^ self 		].		cacheDir := FileDirectory cacheDirectory.		cacheDir assureExistenceOfPath: 'TeleplacePythonUserApps'.		cacheDir assureExistenceOfPath: 'Installed Applications'.		pyDir := cacheDir directoryNamed: 'TeleplacePythonUserApps'.		(pyDir fileExists:'__init__.py') ifFalse:[ "we need an empty __init__.py file in this directory"			initFile := pyDir forceNewFileNamed:'__init__.py'.			initFile close.		].		unzipper := ZipArchive new.		unzipper readFrom: (ReadStream on:data).		unzipper extractAllTo: pyDir informing: nil overwrite: true.		menuDir := cacheDir directoryNamed:'Installed Applications'.		menuFile := menuDir forceNewFileNamed: appName,'.c3x'. "(document get: #initialName),'.c3x'."		menuString  := '<group id="1" class="QFileCard">	<name>', appName, '</name>	<kind>panelApp</kind>	<content>		<object id="2" class="PyPanelDocCS">			<appName>TeleplacePythonUserApps.', appName, '</appName>'.			sha ifNotNil:[menuString := menuString,'			<sha>',sha, '</sha>'.].			tpzName ifNotNil:[menuString := menuString,'			<tpzName>',tpzName, '</tpzName>'.].			cacheLocally ifNotNil:[menuString := menuString,'			<cacheLocally>',cacheLocally, '</cacheLocally>'.].			"docName ifNotNil:[menuString := menuString,'			<docName>',docName, '</docName>'.]."			userSource ifNotNil:[menuString := menuString,'			<userSource>', userSource, '</userSource>'.].			menuString := menuString,'		</object>	</content></group>'.		[menuFile nextPutAll: menuString] ensure: [menuFile close].	document future pyAppInstalled."				fileName := 'Python',  FileDirectory slash,  (document get:#shortName).		file := [cacheDir forceNewFileNamed:fileName] 			on: Error do:[:ex| 				QLogger logError: ex from: self.				nil].		file ifNil:[			self inform: 'Cannot install Python Application'. ^self].		data := (document get:#class) getContent: document forClient: aUI.		data ifNil: [			self inform: 'Cannot install Python Application.'.			^ self 		]."		"file := FileStream newFileNamed: fileName.""		file perform: (document get:#fileModeSelector).		[file nextPutAll: data] ensure: [file close]."	 ] on: CProgressCancel do: [		QLogger logInfo: 'Canceled Python install.'.		^self	 ]	] on: Error do: [ :exc|		self inform: ('Cannot install the Python application.\\', exc description) withCRs.		QLogger logError: exc from: self.		^ self	].		QActivityCapture action: #InstallPythonApplication details: (QActivityCapture fileDetails:  (document get:#shortName)).	"aUI shellOpen: fileName documentDescription: 'document' applicationDescription: 'application'."! !!QwaqParticipantUI methodsFor: 'events' stamp: 'das 1/2/2010 15:34'!onPyUploadDocumentData: data shortName: fileName	<on: pyUploadData>		session documentManager uploadDocumentData: data 			shortName: fileName 			collisions: #clobber owner: false.	! !QSharedDocument subclass: #PyPanelDocCS	instanceVariableNames: 'version tpzName userSource appName docName startupOwner'	classVariableNames: ''	poolDictionaries: ''	category: 'PyBridge-Panels'!