'From Croquet1.0beta of 11 April 2006 [latest update: #1] on 20 March 2010 at 1:23:21 pm'!!QFileDialog methodsFor: 'private' stamp: 'eem 3/20/2010 10:33'!fallbackFilters	"Convert my filter spec		#( #( 'Label ' '*.patt;*.erns') #( 'Next Label' ; '*.patt;*.erns' ) )	 into the Tweak dialogs' format		#( #( 'Label ' #('*.patt' '*.erns')) #( 'Next Label' ; #('*.patt' '*.erns' ) ) )"	^filters ifNotNil:		[filters collect: [:pair| { pair first. pair last findTokens: $; } ]]! !!QFileDialog methodsFor: 'running' stamp: 'eem 3/20/2010 10:28'!openFileFallback	"Run the Tweak open file dialog"	| dialog |	dialog := CFileOpenDialog new.	(filePath notNil and: [filePath notEmpty]) ifTrue:		[dialog directory: (FileDirectory forFileName: filePath)].	^dialog openFile: self fallbackFilters label: label	"FileDirectory forFileName: '/Users/eliot' UnixFileDirectory on '/Users'	 FileDirectory forFileName: '/Users/eliot/' UnixFileDirectory on '/Users/eliot'"! !!QFileDialog methodsFor: 'running' stamp: 'eem 3/20/2010 10:28'!saveFileFallback	"Run the Tweak save file dialog"	| dialog |	dialog := CFileOpenDialog new.	(filePath notNil and: [filePath notEmpty]) ifTrue:		[dialog			fileName: (FileDirectory localNameFor: filePath);			directory: (FileDirectory forFileName: filePath)].	^dialog openFile: self fallbackFilters label: label	"FileDirectory forFileName: '/Users/eliot' UnixFileDirectory on '/Users'	 FileDirectory forFileName: '/Users/eliot/' UnixFileDirectory on '/Users/eliot'"! !!QFileDialog methodsFor: 'running' stamp: 'eem 3/19/2010 17:27'!openFile: fileSpec path: aPath label: aString	self filters: fileSpec.	self label: aString.	self filePath: aPath.	^self openFile! !!QFileDialog methodsFor: 'running' stamp: 'eem 3/19/2010 17:21'!saveFile: fileSpec path: aPath label: aString	self filters: fileSpec.	self label: aString.	self filePath: aPath.	^self saveFileAs! !!QFileDialog class methodsFor: 'open file' stamp: 'eem 3/19/2010 17:27'!openFile: fileSpec path: aPath label: aString	^self new openFile: fileSpec path: aPath label: aString! !!QFileDialog class methodsFor: 'save file' stamp: 'eem 3/19/2010 17:21'!saveFile: fileSpec path: aPath label: aString	^self new saveFile: fileSpec path: aPath label: aString! !!QFileDialog class methodsFor: 'private' stamp: 'eem 3/19/2010 17:15'!primitiveFileDialogGetResult: handle	<primitive: 'primitiveFileDialogGetResult' module: 'FileDialogPlugin'>	^#failed! !!QFileDialog class methodsFor: 'utility' stamp: 'eem 3/20/2010 12:35'!hasNativeDialogPluginSupport	"Hopefully temporary.  Should be a specific primitive that answers if native dialogs are supported."	^(self primitiveFileDialogGetResult: 0) ~~ #failed! !!CFileDirectoryTreeItem methodsFor: 'templates' stamp: 'eem 3/20/2010 12:30'!hasChildren	^value exists and: [value hasSubDirectories]! !!MViewPane methodsFor: 'write theme' stamp: 'eem 3/19/2010 17:41'!writeTheme	| fileToExport label themeElements exampleFileName fileName theme |	exampleFileName := 'ThemeName.c3z'.	label := 'Name the new theme file (should start with ''Theme'')'.	[		"Native dialog if available."		fileToExport := QFileDialog					saveFile: { {'Theme file' . '*.c3z'} }					path: exampleFileName					label: label.	] on: Error do: [		self inform: 'Could not open file chooser.'.		^self	].	fileToExport ifNil:[ ^self ].	"cancel"	fileName := self baseFromPath: fileToExport.	(fileName = exampleFileName) ifTrue:[		self owner signalInformDialog: 'Change ''Name'' to name of theme'				label: 'Invalid theme name'.		^self writeTheme.	].	((fileName beginsWith: 'Theme') and:[ fileName endsWith: '.c3z' ]) ifTrue:[		theme := fileName allButLast: 4.	] ifFalse:[		self owner signalInformDialog: 'File name must start with ''Theme'' and end with ''.c3z''.'				label: 'Invalid file name'.		^self writeTheme.	].	"Collect the scenery from the scene, which removes them temporarily"	themeElements := space future collectThemeElements: theme.	"Write them out."	QStoreObjectJob saveFrame: themeElements to: fileToExport for: self owner.	"Restore them to the scene."	"space future restoreThemeElements."! !!MViewPane methodsFor: 'themes' stamp: 'eem 3/19/2010 17:40'!loadTheme	| fileToExport label fileName themeName |	label := 'Load the new theme file'.	[		"Native dialog if available."		fileToExport := QFileDialog						openFile: { {'Theme file' . '*.c3z'} }						"path: exampleFileName"						label: label.	] on: Error do: [		self inform: 'Could not open file chooser.'.		^self	].	fileToExport ifNil:[ ^self ].	"cancel"	fileName := self baseFromPath: fileToExport.	((fileName beginsWith: 'Theme') and:[ fileName endsWith: '.c3z' ]) ifFalse:[		self owner signalInformDialog: 'File name must start with ''Theme'' and end with ''.c3z''.'				label: 'Invalid file name'.		^self loadTheme.	].	themeName := (fileName allButFirst: 5) allButLast: 4.	self instantiateTheme: themeName path: fileToExport.! !!PyPanelWorldCS methodsFor: 'client api' stamp: 'eem 3/20/2010 13:18'!doFind: fileDescription file: ext label: label callbackID: callbackID		| fileToImport data |	[	"native dialog if available"		fileToImport := QFileDialog openFile: {{fileDescription. ext}} label: label	] on: Error do: [		^self notify: 'Could not open file chooser.'	].	fileToImport ifNotNil:[		data := self readFile: fileToImport.		app future pySet: fileToImport to: data from: session sessionID asUIDString.		app future onCallbackEvent:{callbackID. fileToImport}.	].! !!PyPanelWorldCS methodsFor: 'client api' stamp: 'eem 3/20/2010 13:18'!doPath: path save: fileDescription file: ext label: label callbackID: callbackID		| fileToExport data extension fileExt |	[	"native dialog if available"		fileToExport := QFileDialog						saveFile: {{fileDescription. ext}}						path: path						label: label	] on: Error do: [		^self notify: 'Could not open file chooser.'	].	fileToExport ifNotNil:[		"default to the last extension if there is more than one"		extension := ext copyAfterLast: $..		extension size = 0 ifTrue:[extension := ext].		fileExt := fileToExport copyAfterLast: $..		fileExt = extension ifFalse:[fileToExport := fileToExport,'.',extension.].		data := app get: #pyGet: with: '__saveFileData__'.		self writeFile: fileToExport data: data.		app future onCallbackEvent:{callbackID. fileToExport}.	].! !!PyPanelWorldCS methodsFor: 'client api' stamp: 'eem 3/20/2010 13:17'!doSave: fileDescription file: ext label: label callbackID: callbackID		| fileToExport data |	[	"native dialog if available"		fileToExport := QFileDialog saveFile: {{fileDescription. ext}} label: label	] on: Error do: [		^self notify: 'Could not open file chooser.'	].	fileToExport ifNotNil:[		data := app get: #pyGet: with: '__saveFileData__'.		self writeFile: fileToExport data: data.		app future onCallbackEvent:{callbackID. fileToExport}.	].! !!QChatPlayer methodsFor: 'events' stamp: 'eem 3/19/2010 17:39'!saveTranscript	"Menu command - save the chat content to a transcript."	| fname file log |	self readyForEvents ifFalse: [ ^ self ].	"Get target file."	fname := QFileDialog				saveFile: QFileDialog defaultTextSpec				path: 'discussion-text.txt'				label: 'Save Chat Transcript'.	fname ifNil: [ ^ self ].	QActivityCapture action: #TextChatSaveTranscript.	"Be sure we got the suffix... some edits in the dialog can remove it..."	(fname endsWith: '.txt') ifFalse: [ fname := fname, '.txt' ].	"Try to fetch an untrimmed chat log from the space; fall back on my working copy."	log  := self chatLogFromRef: chatRef maxMessages: (QChatLog maxMessages).	log ifNil: [ log := chatLog ].	[ 		file := CrLfFileStream forceNewFileNamed: fname.		file converter: Latin1TextConverter new.		file ascii.		file nextPutAll: 'Discussion Transcript: ', owner serviceSvc name.		file cr; cr.		log writeTranscriptOn: file.		file close.	] on: Error do: [ :exc |		self inform: 'Could not save chat transcript.\\' withCRs, exc asString.		[ file close ] on: Error do: [].	].	! !!QFileDialog methodsFor: 'running' stamp: 'eem 3/19/2010 17:56'!openFile	"Run the native open file dialog, falling back to the Tweak one if native dialogs are not available"	self class hasNativeDialogPluginSupport ifFalse:		[^self openFileFallback].	self oldFilesOnly: true.	^self runDialog: false! !!QFileDialog methodsFor: 'running' stamp: 'eem 3/19/2010 17:57'!saveFileAs	"Run the native save file as dialog, falling back to the Tweak one if native dialogs are not available"	self class hasNativeDialogPluginSupport ifFalse:		[^self saveFileFallback].	self overwritePrompt: true.	^self runDialog: true! !!QInspector methodsFor: 'tree menu' stamp: 'eem 3/19/2010 17:38'!userFileName: obj" user has a chance to specify the file name"	| newName c3zName |	[ 		newName := obj get:#objectName.		c3zName := (newName copyUpToLast: $.), '.c3z'.		newName := QFileDialog					saveFile: #(('Saved Object' '*.c3z'))					path:(QFileDialog getFileLocation:'desktop'),							FileDirectory slash, c3zName					label:'Save ', (obj get:#objectName)	] on: Error do: [		self inform: 'Could not open file chooser.'.		^ nil	].	^ newName.! !!QPlainAvatarDetails methodsFor: 'events' stamp: 'eem 3/19/2010 17:30'!getPictureFromUser: prompt scaledToSize: aSize cropToSquare: doSquareCrop	"Choose a picture from disk; return a Form or nil."	| fullPath form size | 	[		fullPath := QFileDialog					openFile: QFileDialog defaultImageSpec					path: (QFileDialog getFileLocation: #pictures)					label: prompt	] on: Error do: [		self inform: 'Could not open file chooser.'.		^ nil	].	fullPath isEmptyOrNil ifTrue:[ ^ nil ].	[		form := ImageReadWriter formFromFileNamed: fullPath.	] on: Error do: [		self inform: 'That picture cannot be read.'.		^ nil	].	form ifNil: [ ^ nil ].	doSquareCrop ifTrue: [		"Take a square out of the middle."		size := form extent copy.		size x > size y ifTrue: [			form := form contentsOfArea: 				(((size x - size y / 2) rounded @0) extent: (size y@size y)).		].		size x < size y ifTrue: [			form := form contentsOfArea: 				(0@((size y - size x / 2) rounded) extent: (size x@size x)).		].	].	^ form scaledToSize: aSize	! !!QToolPane class methodsFor: 'user interface' stamp: 'eem 3/19/2010 17:25'!saveLocal: textContents	"Offer to save a local text file with this text,	 usually the contents of a text pane in a panel."	| fileName |	[		fileName := QFileDialog					saveFile: #( ('Text Files (*.txt)' '*.txt'))					path: (QFileDialog getFileLocation: 'desktop'), 						FileDirectory slash, 						'Untitled.txt'					label: 'Save as Text File'	] on: Error do: [ :ex |		^ self inform: 'Cannot save file:', String cr, ex description	].	fileName ifNil: [ ^ self ].	[		| file |		(fileName endsWith: '.txt' caseSensitive:false) ifFalse: [			fileName := fileName,'.txt'.		].		file := CrLfFileStream forceNewFileNamed: fileName.		file converter: Latin1TextConverter new.		file text.		[file nextPutAll: textContents ] ensure: [file close].	] on: Error do: [ :ex|		^ self inform: 'Cannot save file:', String cr, ex description	].! !!QFloatingPane class methodsFor: 'user interface' stamp: 'eem 3/19/2010 17:24'!saveLocal: textContents	"Offer to save a local text file with this text,	 usually the contents of a text pane in a panel."	| fileName |	[		fileName := QFileDialog					saveFile: #( ('Text Files (*.txt)' '*.txt'))					path: (QFileDialog getFileLocation: 'desktop'), 						FileDirectory slash, 						'Untitled.txt'					label: 'Save as Text File'	] on: Error do: [ :ex |		^ self inform: 'Cannot save file:', String cr, ex description	].	fileName ifNil: [ ^ self ].	[		| file |		(fileName endsWith: '.txt' caseSensitive:false) ifFalse: [			fileName := fileName,'.txt'.		].		file := CrLfFileStream forceNewFileNamed: fileName.		file converter: Latin1TextConverter new.		file text.		[file nextPutAll: textContents ] ensure: [file close].	] on: Error do: [ :ex|		^ self inform: 'Cannot save file:', String cr, ex description	].! !!QwaqParticipantUI methodsFor: 'menu' stamp: 'eem 3/20/2010 10:11'!fileImport	| fileToImport |	self readyForEvents ifFalse: [ ^ self ].	self canModifyForum ifFalse: [ ^ self ].	[		"Native dialog if available.  The file types supported are an open-ended set,	       so we allow anything at the chooser and then get more specific in the dropFile: method."		fileToImport := QFileDialog openFile: {				{'Documents' . '*.*'} }			label: 'Choose a File to Import'.	] on: Error do: [		^self inform: 'Could not open file chooser.'	].	fileToImport ifNotNil: [		| f | 		[			QActivityCapture action: #ImportFileMenu 						       details: (QActivityCapture fileDetails: fileToImport).			f := FileDirectory default readOnlyFileNamed: fileToImport.		] on: Error do: [ :ex |			^ self inform: ('Cannot read file\  ', fileToImport) withCRs		].		f ifNotNil: [ session dropFile: f event: nil editBox: true]	] ifNil: [		QActivityCapture action: #ImportFileMenuAbandoned	].! !!QwaqParticipantUI methodsFor: 'menu' stamp: 'eem 3/19/2010 17:28'!testVoiceTransportRepeatedlyWithUserFile	| fileName |		[		fileName := QFileDialog					openFile: #(('WAV files (*.wav)' '*.wav')) 					path: (QFileDialog getFileLocation: #home)					label: 'Select 8kHz or 16kHz WAV file'.	] on: Error do: [		self inform: 'Could not open file chooser'.	].	fileName ifNotNil: [self testVoiceTransportRepeatedly: fileName]! !!QwaqPrefsPane methodsFor: 'events' stamp: 'eem 3/19/2010 18:05'!onPhotoClick	"Choose a picture from disk and install it as the avatar picture."	| fullPath form size | 	<on: mouseDown in: photo>	[		fullPath := QFileDialog					openFile: QFileDialog defaultImageSpec					path: (QFileDialog getFileLocation: #pictures)					label: 'Avatar Picture'	] on: Error do: [		^self inform: 'Could not open file chooser.'	].	fullPath isEmptyOrNil ifTrue:[ ^ self ].	[		form := ImageReadWriter formFromFileNamed: fullPath.	] on: Error do: [		^ self inform: 'That picture cannot be read.'.	].	form ifNil: [ ^ self ].	"Got a picture.  Take a square out of the middle and scale it to our shareable size."	size := form extent copy.	size x > size y ifTrue: [		form := form contentsOfArea: 			(((size x - size y / 2) rounded @0) extent: (size y@size y)).	].	size x < size y ifTrue: [		form := form contentsOfArea: 			(0@((size y - size x / 2) rounded) extent: (size x@size x)).		].	form := form scaledToSize: (96@96).	(self photo)			graphicForm: form;			graphicFit: #scale.! !