/* Automatically generated by
	VMPluginCodeGenerator VMMaker-eem.666 uuid: 4edd7d00-3db5-48ef-b579-5d95fae49120
   from
	PSharePlugin Qwaq-Plugins-jcg.108 uuid: be07d71f-9c53-4c06-8e16-66431a11bfe4
 */
static char __buildInfo[] = "PSharePlugin Qwaq-Plugins-jcg.108 uuid: be07d71f-9c53-4c06-8e16-66431a11bfe4 " __DATE__ ;




#include <math.h>
#include <stdio.h>
#include <stdlib.h>
#include <string.h>
#include <time.h>

/* Default EXPORT macro that does nothing (see comment in sq.h): */
#define EXPORT(returnType) returnType

/* Do not include the entire sq.h file but just those parts needed. */
/*  The virtual machine proxy definition */
#include "sqVirtualMachine.h"
/* Configuration options */
#include "sqConfig.h"
/* Platform specific definitions */
#include "sqPlatformSpecific.h"

#define true 1
#define false 0
#define null 0  /* using 'null' because nil is predefined in Think C */
#ifdef SQUEAK_BUILTIN_PLUGIN
#undef EXPORT
// was #undef EXPORT(returnType) but screws NorCroft cc
#define EXPORT(returnType) static returnType
#endif
#include "PSharePlugin.h"

#include "sqMemoryAccess.h"


/*** Constants ***/


/*** Function Prototypes ***/
static VirtualMachine * getInterpreter(void);
EXPORT(const char*) getModuleName(void);
static sqInt halt(void);
EXPORT(sqInt) initialiseModule(void);
static sqInt msg(char *s);
static sqInt oopFromString(char*cString);
EXPORT(sqInt) primitiveEnableDebug(void);
EXPORT(sqInt) primitiveGetDocumentIcon(void);
EXPORT(sqInt) primitiveGetWindowAppName(void);
EXPORT(sqInt) primitiveGetWindowBitmap(void);
EXPORT(sqInt) primitiveGetWindowIcon(void);
EXPORT(sqInt) primitiveGetWindowID(void);
EXPORT(sqInt) primitiveGetWindowLabel(void);
EXPORT(sqInt) primitiveGetWindowOwner(void);
EXPORT(sqInt) primitiveGetWindowProcessID(void);
EXPORT(sqInt) primitiveGetWindowRect(void);
EXPORT(sqInt) primitiveIsWindowMinimized(void);
EXPORT(sqInt) primitiveIsWindowSharable(void);
EXPORT(sqInt) primitiveIsWindowValid(void);
EXPORT(sqInt) primitiveIsWindowVisible(void);
EXPORT(sqInt) primitiveLaunchFile(void);
EXPORT(sqInt) primitivePostKeyboardEvent(void);
EXPORT(sqInt) primitivePostMouseEvent(void);
EXPORT(sqInt) primitiveShareWindow(void);
EXPORT(sqInt) primitiveUnobscureWindow(void);
EXPORT(sqInt) setInterpreter(struct VirtualMachine*anInterpreter);
EXPORT(sqInt) shutdownModule(void);
static void* stringFromOop(sqInt strOop);


/*** Variables ***/

#ifdef SQUEAK_BUILTIN_PLUGIN
extern
#endif
struct VirtualMachine* interpreterProxy;
static const char *moduleName =
#ifdef SQUEAK_BUILTIN_PLUGIN
	"PSharePlugin Qwaq-Plugins-jcg.108 (i)"
#else
	"PSharePlugin Qwaq-Plugins-jcg.108 (e)"
#endif
;



/*	Note: This is coded so that plugins can be run from Squeak. */

static VirtualMachine *
getInterpreter(void) {
	return interpreterProxy;
}


/*	Note: This is hardcoded so it can be run from Squeak.
	The module name is used for validating a module *after*
	it is loaded to check if it does really contain the module
	we're thinking it contains. This is important! */

EXPORT(const char*)
getModuleName(void) {
	return moduleName;
}

static sqInt
halt(void) {
	;
	return 0;
}

EXPORT(sqInt)
initialiseModule(void) {
	return pShareInit();
}

static sqInt
msg(char *s) {
	fprintf(stderr, "\n%s: %s", moduleName, s);
	return 0;
}

static sqInt
oopFromString(char*cString) {
    char*dstPtr;
    sqInt i;
    sqInt result;
    sqInt sz;

	if (cString == null) {
		return interpreterProxy->nilObject();
	}
	sz = strlen(cString);
	result = interpreterProxy->instantiateClassindexableSize(interpreterProxy->classString(), sz);
	dstPtr = interpreterProxy->firstIndexableField(result);
	for (i = 0; i <= (sz - 1); i += 1) {
		dstPtr[i] = (cString[i]);
	}
	return result;
}


/*	Primitive. Enable pshare debug output. */

EXPORT(sqInt)
primitiveEnableDebug(void) {
    sqInt debugOn;

	if (!((interpreterProxy->methodArgumentCount()) == 1)) {
		return interpreterProxy->primitiveFail();
	}
	debugOn = interpreterProxy->booleanValueOf(interpreterProxy->stackValue(0));
	if (interpreterProxy->failed()) {
		return null;
	}
	pShareEnableDebug(debugOn);
	interpreterProxy->pop(interpreterProxy->methodArgumentCount());
}


/*	Primitive. Return the icon for a document file. */

EXPORT(sqInt)
primitiveGetDocumentIcon(void) {
    sqInt bits;
    void*bitsPtr;
    sqInt d;
    sqInt filePtr;
    sqInt form;
    sqInt h;
    sqInt ok;
    sqInt ppw;
    sqInt w;

	if (!((interpreterProxy->methodArgumentCount()) == 2)) {
		return interpreterProxy->primitiveFail();
	}
	form = interpreterProxy->stackValue(0);
	if (!((interpreterProxy->isPointers(form))
		 && ((interpreterProxy->slotSizeOf(form)) >= 4))) {
		return interpreterProxy->primitiveFail();
	}
	bits = interpreterProxy->fetchPointerofObject(0, form);
	w = interpreterProxy->fetchIntegerofObject(1, form);
	h = interpreterProxy->fetchIntegerofObject(2, form);
	d = interpreterProxy->fetchIntegerofObject(3, form);
	ppw = 32 / d;
	if (!(interpreterProxy->isWords(bits))) {
		return interpreterProxy->primitiveFail();
	}
	if (!((interpreterProxy->slotSizeOf(bits)) == ((((w + ppw) - 1) / ppw) * h))) {
		return interpreterProxy->primitiveFail();
	}
	bitsPtr = interpreterProxy->firstIndexableField(bits);
	filePtr = stringFromOop(interpreterProxy->stackValue(1));
	if (filePtr == null) {
		return interpreterProxy->primitiveFail();
	}
	if (interpreterProxy->failed()) {
		return null;
	}
	ok = pShareGetDocumentIcon(filePtr, w, h, d, bitsPtr);
	if (!(ok)) {
		return interpreterProxy->primitiveFail();
	}
	interpreterProxy->popthenPush(3, form);
}


/*	Primitive. Return the app name for a window with a given ID. */

EXPORT(sqInt)
primitiveGetWindowAppName(void) {
    char*labelString;
    sqInt windowID;

	if (!((interpreterProxy->methodArgumentCount()) == 1)) {
		return interpreterProxy->primitiveFail();
	}
	windowID = interpreterProxy->positive32BitValueOf(interpreterProxy->stackValue(0));
	if (interpreterProxy->failed()) {
		return null;
	}
	labelString = pShareGetWindowAppName(windowID);
	if (labelString == null) {
		return interpreterProxy->primitiveFail();
	}
	interpreterProxy->pop((interpreterProxy->methodArgumentCount()) + 1);
	interpreterProxy->push(oopFromString(labelString));
}


/*	Primitive. Return the window bitmap for a window with a given ID. */

EXPORT(sqInt)
primitiveGetWindowBitmap(void) {
    sqInt arg;
    sqInt array;
    sqInt bits;
    void*bitsPtr;
    sqInt d;
    sqInt diff;
    sqInt form;
    sqInt h;
    sqInt i;
    sqInt ppw;
    int*rect;
    sqInt w;
    sqInt windowID;

	if (!((interpreterProxy->methodArgumentCount()) == 3)) {
		return interpreterProxy->primitiveFail();
	}
	diff = interpreterProxy->booleanValueOf(interpreterProxy->stackValue(0));
	form = interpreterProxy->stackValue(1);
	if (!((interpreterProxy->isPointers(form))
		 && ((interpreterProxy->slotSizeOf(form)) >= 4))) {
		return interpreterProxy->primitiveFail();
	}
	bits = interpreterProxy->fetchPointerofObject(0, form);
	w = interpreterProxy->fetchIntegerofObject(1, form);
	h = interpreterProxy->fetchIntegerofObject(2, form);
	d = interpreterProxy->fetchIntegerofObject(3, form);
	ppw = 32 / d;
	if (!(interpreterProxy->isWords(bits))) {
		return interpreterProxy->primitiveFail();
	}
	if (!((interpreterProxy->slotSizeOf(bits)) == ((((w + ppw) - 1) / ppw) * h))) {
		return interpreterProxy->primitiveFail();
	}
	bitsPtr = interpreterProxy->firstIndexableField(bits);
	windowID = interpreterProxy->positive32BitValueOf(interpreterProxy->stackValue(2));
	if (interpreterProxy->failed()) {
		return null;
	}
	rect = pShareGetWindowBitmap(windowID, w, h, d, bitsPtr, diff);
	if (rect == null) {
		return interpreterProxy->primitiveFail();
	}
	array = interpreterProxy->instantiateClassindexableSize(interpreterProxy->classArray(), 4);
	for (i = 0; i <= 3; i += 1) {
		interpreterProxy->pushRemappableOop(array);
		arg = interpreterProxy->signed32BitIntegerFor(rect[i]);
		array = interpreterProxy->popRemappableOop();
		interpreterProxy->storePointerofObjectwithValue(i, array, arg);
	}
	interpreterProxy->popthenPush((interpreterProxy->methodArgumentCount()) + 1, array);
}


/*	Primitive. Return the window label for a window with a given ID. */

EXPORT(sqInt)
primitiveGetWindowIcon(void) {
    sqInt bits;
    void*bitsPtr;
    sqInt d;
    sqInt form;
    sqInt h;
    sqInt ok;
    sqInt ppw;
    sqInt w;
    sqInt windowID;

	if (!((interpreterProxy->methodArgumentCount()) == 2)) {
		return interpreterProxy->primitiveFail();
	}
	form = interpreterProxy->stackValue(0);
	if (!((interpreterProxy->isPointers(form))
		 && ((interpreterProxy->slotSizeOf(form)) >= 4))) {
		return interpreterProxy->primitiveFail();
	}
	bits = interpreterProxy->fetchPointerofObject(0, form);
	w = interpreterProxy->fetchIntegerofObject(1, form);
	h = interpreterProxy->fetchIntegerofObject(2, form);
	d = interpreterProxy->fetchIntegerofObject(3, form);
	ppw = 32 / d;
	if (!(interpreterProxy->isWords(bits))) {
		return interpreterProxy->primitiveFail();
	}
	if (!((interpreterProxy->slotSizeOf(bits)) == ((((w + ppw) - 1) / ppw) * h))) {
		return interpreterProxy->primitiveFail();
	}
	bitsPtr = interpreterProxy->firstIndexableField(bits);
	windowID = interpreterProxy->positive32BitValueOf(interpreterProxy->stackValue(1));
	if (interpreterProxy->failed()) {
		return null;
	}
	ok = pShareGetWindowIcon(windowID, w, h, d, bitsPtr);
	if (!(ok)) {
		return interpreterProxy->primitiveFail();
	}
	interpreterProxy->popthenPush(3, form);
}


/*	Primitive. Return the ID for the n-th top-level window. */

EXPORT(sqInt)
primitiveGetWindowID(void) {
    sqInt windowID;
    sqInt windowIndex;

	if (!((interpreterProxy->methodArgumentCount()) == 1)) {
		return interpreterProxy->primitiveFail();
	}
	windowIndex = interpreterProxy->stackIntegerValue(0);
	if (interpreterProxy->failed()) {
		return null;
	}
	windowID = pShareGetWindowID(windowIndex);
	if (windowID == -1) {
		return interpreterProxy->primitiveFail();
	}
	interpreterProxy->pop((interpreterProxy->methodArgumentCount()) + 1);
	interpreterProxy->push(interpreterProxy->positive32BitIntegerFor(windowID));
}


/*	Primitive. Return the window label for a window with a given ID. */

EXPORT(sqInt)
primitiveGetWindowLabel(void) {
    char*labelString;
    sqInt windowID;

	if (!((interpreterProxy->methodArgumentCount()) == 1)) {
		return interpreterProxy->primitiveFail();
	}
	windowID = interpreterProxy->positive32BitValueOf(interpreterProxy->stackValue(0));
	if (interpreterProxy->failed()) {
		return null;
	}
	labelString = pShareGetWindowLabel(windowID);
	if (labelString == null) {
		return interpreterProxy->primitiveFail();
	}
	interpreterProxy->pop((interpreterProxy->methodArgumentCount()) + 1);
	interpreterProxy->push(oopFromString(labelString));
}


/*	Primitive. Return the id for the owner of a window */

EXPORT(sqInt)
primitiveGetWindowOwner(void) {
    sqInt ownerID;
    sqInt windowID;

	if (!((interpreterProxy->methodArgumentCount()) == 1)) {
		return interpreterProxy->primitiveFail();
	}
	windowID = interpreterProxy->positive32BitValueOf(interpreterProxy->stackValue(0));
	if (interpreterProxy->failed()) {
		return null;
	}
	ownerID = pShareGetWindowOwner(windowID);
	if (ownerID == -1) {
		return interpreterProxy->primitiveFail();
	}
	interpreterProxy->pop((interpreterProxy->methodArgumentCount()) + 1);
	interpreterProxy->push(interpreterProxy->positive32BitIntegerFor(ownerID));
}


/*	Primitive. Return the ID for the n-th top-level sharable window. */

EXPORT(sqInt)
primitiveGetWindowProcessID(void) {
    sqInt pid;
    sqInt windowID;

	if (!((interpreterProxy->methodArgumentCount()) == 1)) {
		return interpreterProxy->primitiveFail();
	}
	windowID = interpreterProxy->positive32BitValueOf(interpreterProxy->stackValue(0));
	if (interpreterProxy->failed()) {
		return null;
	}
	pid = pShareGetWindowProcessID(windowID);
	interpreterProxy->pop((interpreterProxy->methodArgumentCount()) + 1);
	interpreterProxy->push(interpreterProxy->positive32BitIntegerFor(pid));
}


/*	Primitive. Return the bounding box for a window with a given ID. */

EXPORT(sqInt)
primitiveGetWindowRect(void) {
    sqInt arg;
    sqInt array;
    sqInt i;
    int*rect;
    sqInt windowID;

	if (!((interpreterProxy->methodArgumentCount()) == 1)) {
		return interpreterProxy->primitiveFail();
	}
	windowID = interpreterProxy->positive32BitValueOf(interpreterProxy->stackValue(0));
	if (interpreterProxy->failed()) {
		return null;
	}
	rect = pShareGetWindowRect(windowID);
	if (rect == null) {
		return interpreterProxy->primitiveFail();
	}
	array = interpreterProxy->instantiateClassindexableSize(interpreterProxy->classArray(), 4);
	for (i = 0; i <= 3; i += 1) {
		interpreterProxy->pushRemappableOop(array);
		arg = interpreterProxy->signed32BitIntegerFor(rect[i]);
		array = interpreterProxy->popRemappableOop();
		interpreterProxy->storePointerofObjectwithValue(i, array, arg);
	}
	interpreterProxy->popthenPush(2, array);
}


/*	Primitive. Return true if the given window is minimized. */

EXPORT(sqInt)
primitiveIsWindowMinimized(void) {
    sqInt result;
    sqInt windowID;

	if (!((interpreterProxy->methodArgumentCount()) == 1)) {
		return interpreterProxy->primitiveFail();
	}
	windowID = interpreterProxy->positive32BitValueOf(interpreterProxy->stackValue(0));
	if (interpreterProxy->failed()) {
		return null;
	}
	result = pShareIsWindowMinimized(windowID);
	if (result == -1) {
		return interpreterProxy->primitiveFail();
	}
	interpreterProxy->pop((interpreterProxy->methodArgumentCount()) + 1);
	interpreterProxy->pushBool(result);
}


/*	Primitive. Return true if the given window is valid. */

EXPORT(sqInt)
primitiveIsWindowSharable(void) {
    sqInt visible;
    sqInt windowID;

	if (!((interpreterProxy->methodArgumentCount()) == 1)) {
		return interpreterProxy->primitiveFail();
	}
	windowID = interpreterProxy->positive32BitValueOf(interpreterProxy->stackValue(0));
	if (interpreterProxy->failed()) {
		return null;
	}
	visible = pShareIsWindowSharable(windowID);
	if (visible == -1) {
		return interpreterProxy->primitiveFail();
	}
	interpreterProxy->pop((interpreterProxy->methodArgumentCount()) + 1);
	interpreterProxy->pushBool(visible);
}


/*	Primitive. Return true if the given window is valid. */

EXPORT(sqInt)
primitiveIsWindowValid(void) {
    sqInt visible;
    sqInt windowID;

	if (!((interpreterProxy->methodArgumentCount()) == 1)) {
		return interpreterProxy->primitiveFail();
	}
	windowID = interpreterProxy->positive32BitValueOf(interpreterProxy->stackValue(0));
	if (interpreterProxy->failed()) {
		return null;
	}
	visible = pShareIsWindowValid(windowID);
	if (visible == -1) {
		return interpreterProxy->primitiveFail();
	}
	interpreterProxy->pop((interpreterProxy->methodArgumentCount()) + 1);
	interpreterProxy->pushBool(visible);
}


/*	Primitive. Return true if the given window is visible. */

EXPORT(sqInt)
primitiveIsWindowVisible(void) {
    sqInt visible;
    sqInt windowID;

	if (!((interpreterProxy->methodArgumentCount()) == 1)) {
		return interpreterProxy->primitiveFail();
	}
	windowID = interpreterProxy->positive32BitValueOf(interpreterProxy->stackValue(0));
	if (interpreterProxy->failed()) {
		return null;
	}
	visible = pShareIsWindowVisible(windowID);
	if (visible == -1) {
		return interpreterProxy->primitiveFail();
	}
	interpreterProxy->pop((interpreterProxy->methodArgumentCount()) + 1);
	interpreterProxy->pushBool(visible);
}


/*	Primitive. Launch the application that handles files of the type of the
	file argument with that file. Answer the process id of the application.
	Fail for an invalid argument or if launching is not possible. */

EXPORT(sqInt)
primitiveLaunchFile(void) {
    sqInt labelString;
    sqInt pid;

	if (!((interpreterProxy->methodArgumentCount()) == 1)) {
		return interpreterProxy->primitiveFail();
	}
	labelString = interpreterProxy->stackValue(0);
	if (!(interpreterProxy->isBytes(labelString))) {
		return interpreterProxy->primitiveFail();
	}
	if (interpreterProxy->failed()) {
		return null;
	}
	pid = pShareLaunchFileOfSize(interpreterProxy->firstIndexableField(labelString), interpreterProxy->byteSizeOf(labelString));
	if (pid == -1) {
		return interpreterProxy->primitiveFail();
	}
	interpreterProxy->pop((interpreterProxy->methodArgumentCount()) + 1);
	interpreterProxy->push(interpreterProxy->positive32BitIntegerFor(pid));
}


/*	Primitive. Synthesise a keyboard event from the type, x, y, keyval,
	buttons arguments and deliver it to the win first argument's event queue. */

EXPORT(sqInt)
primitivePostKeyboardEvent(void) {
    sqInt buttons;
    sqInt keyVal;
    sqInt ok;
    sqInt type;
    sqInt wid;
    sqInt x;
    sqInt y;

	if (!((interpreterProxy->methodArgumentCount()) == 6)) {
		return interpreterProxy->primitiveFail();
	}
	buttons = interpreterProxy->stackIntegerValue(0);
	keyVal = interpreterProxy->stackIntegerValue(1);
	y = interpreterProxy->stackIntegerValue(2);
	x = interpreterProxy->stackIntegerValue(3);
	type = interpreterProxy->stackIntegerValue(4);
	wid = interpreterProxy->positive32BitValueOf(interpreterProxy->stackValue(5));
	if (interpreterProxy->failed()) {
		return null;
	}
	ok = pSharePostKeyboardEvent(wid, type, x, y, keyVal, buttons);
	if (!(ok)) {
		return interpreterProxy->primitiveFail();
	}
	interpreterProxy->pop(interpreterProxy->methodArgumentCount());
}


/*	Primitive. Synthesise a mouse event from the type, x, y, buttons
	arguments and deliver it to the win first argument's event queue. */

EXPORT(sqInt)
primitivePostMouseEvent(void) {
    sqInt buttons;
    sqInt ok;
    sqInt type;
    sqInt wid;
    sqInt x;
    sqInt y;

	if (!((interpreterProxy->methodArgumentCount()) == 5)) {
		return interpreterProxy->primitiveFail();
	}
	buttons = interpreterProxy->stackIntegerValue(0);
	y = interpreterProxy->stackIntegerValue(1);
	x = interpreterProxy->stackIntegerValue(2);
	type = interpreterProxy->stackIntegerValue(3);
	wid = interpreterProxy->positive32BitValueOf(interpreterProxy->stackValue(4));
	if (interpreterProxy->failed()) {
		return null;
	}
	ok = pSharePostMouseEvent(wid, type, x, y, buttons);
	if (!(ok)) {
		return interpreterProxy->primitiveFail();
	}
	interpreterProxy->pop(interpreterProxy->methodArgumentCount());
}


/*	Primitive. Share / unshare a window with a given ID. */

EXPORT(sqInt)
primitiveShareWindow(void) {
    sqInt ok;
    sqInt shareOn;
    sqInt windowID;

	if (!((interpreterProxy->methodArgumentCount()) == 2)) {
		return interpreterProxy->primitiveFail();
	}
	shareOn = interpreterProxy->booleanValueOf(interpreterProxy->stackValue(0));
	windowID = interpreterProxy->positive32BitValueOf(interpreterProxy->stackValue(1));
	if (interpreterProxy->failed()) {
		return null;
	}
	ok = pShareActivateWindow(windowID, shareOn);
	if (!(ok)) {
		return interpreterProxy->primitiveFail();
	}
	interpreterProxy->pop(interpreterProxy->methodArgumentCount());
}


/*	Primitive. If a window is not iconic arrange that it is unobscured so that
	primitiveGetWindowBitmap can access an unobscured image of the window's
	contents. Depending on the window manager this
	may require raising the window to the top of the stacking order.. Answer
	if the window is unobscured
	(i.e. false if minimised). Fail for an invalid windowId. */

EXPORT(sqInt)
primitiveUnobscureWindow(void) {
    sqInt result;
    sqInt windowID;

	if (!((interpreterProxy->methodArgumentCount()) == 1)) {
		return interpreterProxy->primitiveFail();
	}
	windowID = interpreterProxy->positive32BitValueOf(interpreterProxy->stackValue(0));
	if (interpreterProxy->failed()) {
		return null;
	}
	result = pShareUnobscureWindow(windowID);
	if (result == -1) {
		return interpreterProxy->primitiveFail();
	}
	interpreterProxy->pop((interpreterProxy->methodArgumentCount()) + 1);
	interpreterProxy->pushBool(result);
}


/*	Note: This is coded so that is can be run from Squeak. */

EXPORT(sqInt)
setInterpreter(struct VirtualMachine*anInterpreter) {
    sqInt ok;

	interpreterProxy = anInterpreter;
	ok = interpreterProxy->majorVersion() == VM_PROXY_MAJOR;
	if (ok == 0) {
		return 0;
	}
	ok = interpreterProxy->minorVersion() >= VM_PROXY_MINOR;
	return ok;
}

EXPORT(sqInt)
shutdownModule(void) {
	return pShareShutdown();
}

static void*
stringFromOop(sqInt strOop) {
    sqInt i;
    char*srcPtr;
    static char strBuf[1024];
    sqInt sz;

	;
	if (!(interpreterProxy->isBytes(strOop))) {
		return null;
	}
	sz = interpreterProxy->byteSizeOf(strOop);
	if (!(sz < 1024)) {
		return null;
	}
	srcPtr = interpreterProxy->firstIndexableField(strOop);
	for (i = 0; i <= (sz - 1); i += 1) {
		strBuf[i] = (srcPtr[i]);
	}
	strBuf[sz] = 0;
	return strBuf;
}


#ifdef SQUEAK_BUILTIN_PLUGIN

void* PSharePlugin_exports[][3] = {
	{"PSharePlugin", "getModuleName", (void*)getModuleName},
	{"PSharePlugin", "initialiseModule", (void*)initialiseModule},
	{"PSharePlugin", "primitiveEnableDebug", (void*)primitiveEnableDebug},
	{"PSharePlugin", "primitiveGetDocumentIcon", (void*)primitiveGetDocumentIcon},
	{"PSharePlugin", "primitiveGetWindowAppName", (void*)primitiveGetWindowAppName},
	{"PSharePlugin", "primitiveGetWindowBitmap", (void*)primitiveGetWindowBitmap},
	{"PSharePlugin", "primitiveGetWindowIcon", (void*)primitiveGetWindowIcon},
	{"PSharePlugin", "primitiveGetWindowID", (void*)primitiveGetWindowID},
	{"PSharePlugin", "primitiveGetWindowLabel", (void*)primitiveGetWindowLabel},
	{"PSharePlugin", "primitiveGetWindowOwner", (void*)primitiveGetWindowOwner},
	{"PSharePlugin", "primitiveGetWindowProcessID", (void*)primitiveGetWindowProcessID},
	{"PSharePlugin", "primitiveGetWindowRect", (void*)primitiveGetWindowRect},
	{"PSharePlugin", "primitiveIsWindowMinimized", (void*)primitiveIsWindowMinimized},
	{"PSharePlugin", "primitiveIsWindowSharable", (void*)primitiveIsWindowSharable},
	{"PSharePlugin", "primitiveIsWindowValid", (void*)primitiveIsWindowValid},
	{"PSharePlugin", "primitiveIsWindowVisible", (void*)primitiveIsWindowVisible},
	{"PSharePlugin", "primitiveLaunchFile", (void*)primitiveLaunchFile},
	{"PSharePlugin", "primitivePostKeyboardEvent", (void*)primitivePostKeyboardEvent},
	{"PSharePlugin", "primitivePostMouseEvent", (void*)primitivePostMouseEvent},
	{"PSharePlugin", "primitiveShareWindow", (void*)primitiveShareWindow},
	{"PSharePlugin", "primitiveUnobscureWindow", (void*)primitiveUnobscureWindow},
	{"PSharePlugin", "setInterpreter", (void*)setInterpreter},
	{"PSharePlugin", "shutdownModule", (void*)shutdownModule},
	{NULL, NULL, NULL}
};

#endif /* ifdef SQ_BUILTIN_PLUGIN */
