/* Automatically generated by
	VMPluginCodeGenerator VMMaker-eem.727 uuid: ddd40ec5-cf16-45d0-876f-d465abbddd04
   from
	QVideoCodecPluginFree * Qwaq-Plugins-jcg.108 uuid: be07d71f-9c53-4c06-8e16-66431a11bfe4
 */
static char __buildInfo[] = "QVideoCodecPluginFree * Qwaq-Plugins-jcg.108 uuid: be07d71f-9c53-4c06-8e16-66431a11bfe4 " __DATE__ ;



#include <math.h>
#include <stdio.h>
#include <stdlib.h>
#include <string.h>
#include <time.h>

/* Default EXPORT macro that does nothing (see comment in sq.h): */
#define EXPORT(returnType) returnType

/* Do not include the entire sq.h file but just those parts needed. */
/*  The virtual machine proxy definition */
#include "sqVirtualMachine.h"
/* Configuration options */
#include "sqConfig.h"
/* Platform specific definitions */
#include "sqPlatformSpecific.h"

#define true 1
#define false 0
#define null 0  /* using 'null' because nil is predefined in Think C */
#ifdef SQUEAK_BUILTIN_PLUGIN
#undef EXPORT
// was #undef EXPORT(returnType) but screws NorCroft cc
#define EXPORT(returnType) static returnType
#endif

#include "QVideoCodecPlugin.h"
#include "QVideoCodecPluginFree.h"
#include "sqMemoryAccess.h"


/*** Constants ***/


/*** Function Prototypes ***/
static VirtualMachine * getInterpreter(void);
EXPORT(const char*) getModuleName(void);
static sqInt halt(void);
EXPORT(sqInt) initialiseModule(void);
EXPORT(sqInt) moduleUnloaded(char *aModuleName);
static sqInt msg(char *s);
EXPORT(sqInt) primitiveCreateDecoder(void);
EXPORT(sqInt) primitiveCreateEncoder(void);
EXPORT(sqInt) primitiveDecode(void);
EXPORT(sqInt) primitiveDecoderIsValid(void);
EXPORT(sqInt) primitiveDecoderReadIntoBitmap(void);
EXPORT(sqInt) primitiveDecoderReadIntoBitmapAndMetadata(void);
EXPORT(sqInt) primitiveDestroyDecoder(void);
EXPORT(sqInt) primitiveDestroyEncoder(void);
EXPORT(sqInt) primitiveEncode(void);
EXPORT(sqInt) primitiveEncoderGetProperty(void);
EXPORT(sqInt) primitiveEncoderIsValid(void);
EXPORT(sqInt) primitiveEncoderReadIntoBytes(void);
EXPORT(sqInt) primitiveGetLogVerbosity(void);
EXPORT(sqInt) primitiveLogMsg(void);
EXPORT(sqInt) primitiveSetLogFile(void);
EXPORT(sqInt) primitiveSetLogVerbosity(void);
EXPORT(sqInt) setInterpreter(struct VirtualMachine*anInterpreter);
static char* stackCharPointer(sqInt index);
static void * stackStringValue(sqInt index);
static sqInt validateArgCount(sqInt expectedArgCount);


/*** Variables ***/

#ifdef SQUEAK_BUILTIN_PLUGIN
extern
#endif
struct VirtualMachine* interpreterProxy;
static const char *moduleName =
#ifdef SQUEAK_BUILTIN_PLUGIN
	"QVideoCodecPluginFree * Qwaq-Plugins-jcg.108 (i)"
#else
	"QVideoCodecPluginFree * Qwaq-Plugins-jcg.108 (e)"
#endif
;



/*	Note: This is coded so that plugins can be run from Squeak. */

static VirtualMachine *
getInterpreter(void)
{
	return interpreterProxy;
}


/*	Note: This is hardcoded so it can be run from Squeak.
	The module name is used for validating a module *after*
	it is loaded to check if it does really contain the module
	we're thinking it contains. This is important! */

EXPORT(const char*)
getModuleName(void)
{
	return moduleName;
}

static sqInt
halt(void)
{
	;
	return 0;
}

EXPORT(sqInt)
initialiseModule(void)
{
	qVideoCodecStartup();
	return 1;
}


/*	The module with the given name was just unloaded. 
	Make sure we have no dangling references. */

EXPORT(sqInt)
moduleUnloaded(char *aModuleName)
{
	
		printf("UNLOADING: %s\n", aModuleName);
		if(!strncmp(aModuleName, "QVideoCodecPlugin", 17)) {
			qVideoCodecShutdown();
		}
	return 0;
}

static sqInt
msg(char *s)
{
	fprintf(stderr, "\n%s: %s", moduleName, s);
	return 0;
}


/*	Answers an integer that represents
	- the index of the newly created decoded (if >= 0)
	- an error condition (if < 0)
	arguments: name(type, stack offset)
	decoderArgs(ByteArray, 3)
	semIndex(integer, 2)
	width(integer, 1)
	height(integer, 0) */

EXPORT(sqInt)
primitiveCreateDecoder(void)
{
    char* decoderArgs;
    sqInt decoderArgsSize;
    sqInt height;
    sqInt obj;
    char* ptr;
    sqInt result;
    sqInt semIndex;
    sqInt width;

	if (!(validateArgCount(4))) {
		return null;
	}
	/* begin stackCharPointer: */
	obj = interpreterProxy->stackObjectValue(3);
	interpreterProxy->success(interpreterProxy->isBytes(obj));
	ptr = interpreterProxy->firstIndexableField(obj);
	if (interpreterProxy->failed()) {
		decoderArgs = null;
		goto l1;
	}
	else {
		decoderArgs = ptr;
		goto l1;
	}
l1:	/* end stackCharPointer: */;
	semIndex = interpreterProxy->stackIntegerValue(2);
	width = interpreterProxy->stackIntegerValue(1);
	height = interpreterProxy->stackIntegerValue(0);
	if (interpreterProxy->failed()) {
		return null;
	}

	/* Make the compiler happy. */

	decoderArgsSize = interpreterProxy->byteSizeOf(interpreterProxy->stackValue(3));
	;
	;
	;
	;
	;
	result = qCreateDecoder(decoderArgs, decoderArgsSize, semIndex, width, height);
	return interpreterProxy->popthenPush(5, interpreterProxy->signed32BitIntegerFor(result));
}


/*	Answers an integer that represents
	- the index of the newly created decoded (if >= 0)
	- an error condition (if < 0)
	arguments: name(type, stack offset)
	decoderArgs(ByteArray, 3)
	semIndex(integer, 2)
	width(integer, 1)
	height(integer, 0) */

EXPORT(sqInt)
primitiveCreateEncoder(void)
{
    char* encoderArgs;
    sqInt encoderArgsSize;
    sqInt height;
    sqInt obj;
    char* ptr;
    sqInt result;
    sqInt semIndex;
    sqInt width;

	if (!((interpreterProxy->methodArgumentCount()) == 4)) {
		return interpreterProxy->primitiveFail();
	}
	/* begin stackCharPointer: */
	obj = interpreterProxy->stackObjectValue(3);
	interpreterProxy->success(interpreterProxy->isBytes(obj));
	ptr = interpreterProxy->firstIndexableField(obj);
	if (interpreterProxy->failed()) {
		encoderArgs = null;
		goto l1;
	}
	else {
		encoderArgs = ptr;
		goto l1;
	}
l1:	/* end stackCharPointer: */;
	semIndex = interpreterProxy->stackIntegerValue(2);
	width = interpreterProxy->stackIntegerValue(1);
	height = interpreterProxy->stackIntegerValue(0);
	if (interpreterProxy->failed()) {
		return null;
	}

	/* Make the compiler happy. */

	encoderArgsSize = interpreterProxy->byteSizeOf(interpreterProxy->stackValue(3));
	;
	;
	;
	;
	;
	result = qCreateEncoder(encoderArgs, encoderArgsSize, semIndex, width, height);
	return interpreterProxy->popthenPush(5, interpreterProxy->signed32BitIntegerFor(result));
}


/*	Use the specified decoder to decode the input data, starting at the
	specified offset.
	arguments: name(type, stack offset)
	decoderIndex (integer, 3)
	bytes (ByteArray, 2)
	byteSize (integer, 1)
	offset (integer, 0) */

EXPORT(sqInt)
primitiveDecode(void)
{
    sqInt byteSize;
    void* bytes;
    sqInt decoderIndex;
    sqInt obj;
    sqInt offset;
    char* ptr;
    sqInt result;

	if (!(validateArgCount(4))) {
		return null;
	}
	decoderIndex = interpreterProxy->stackIntegerValue(3);
	/* begin stackCharPointer: */
	obj = interpreterProxy->stackObjectValue(2);
	interpreterProxy->success(interpreterProxy->isBytes(obj));
	ptr = interpreterProxy->firstIndexableField(obj);
	if (interpreterProxy->failed()) {
		bytes = ((char*) null);
		goto l1;
	}
	else {
		bytes = ((char*) ptr);
		goto l1;
	}
l1:	/* end stackCharPointer: */;
	byteSize = interpreterProxy->stackIntegerValue(1);

	/* Make the compiler happy. */

	offset = interpreterProxy->stackIntegerValue(0);
	;
	;
	;
	if (!((byteSize + offset) <= (interpreterProxy->slotSizeOf(interpreterProxy->stackObjectValue(2))))) {
		return interpreterProxy->primitiveFail();
	}
	result = qDecode(decoderIndex, bytes, byteSize, offset);
	interpreterProxy->pop(5);
	return interpreterProxy->pushInteger(result);
}


/*	Answer true if the decoder handle is valid, and false otherwise. */

EXPORT(sqInt)
primitiveDecoderIsValid(void)
{
    sqInt decoderIndex;
    sqInt result;

	if (!(validateArgCount(1))) {
		return null;
	}
	decoderIndex = interpreterProxy->stackIntegerValue(0);
	if (interpreterProxy->failed()) {
		return null;
	}
	;
	result = qDecoderIsValid(decoderIndex);
	interpreterProxy->pop(2);
	if (result) {
		interpreterProxy->push(interpreterProxy->trueObject());
	}
	else {
		interpreterProxy->push(interpreterProxy->falseObject());
	}
	return null;
}


/*	arguments:
	decoderIndex (integer, 1) - identifies the decoder to use
	bits (Bitmap, 0) - data is copied to here */

EXPORT(sqInt)
primitiveDecoderReadIntoBitmap(void)
{
    char* bitPtr;
    sqInt bits;
    sqInt decoderIndex;
    sqInt maxLength;
    sqInt result;

	if (!(validateArgCount(2))) {
		return null;
	}
	decoderIndex = interpreterProxy->stackIntegerValue(1);
	bits = interpreterProxy->stackObjectValue(0);
	bitPtr = interpreterProxy->firstIndexableField(bits);
	maxLength = interpreterProxy->byteSizeOf(bits);
	if (interpreterProxy->failed()) {
		return null;
	}
	;
	;
	;
	result = qDecoderRead(decoderIndex, bitPtr, maxLength, 0, 0);
	interpreterProxy->pop(3);
	return interpreterProxy->pushInteger(result);
}


/*	arguments:
	decoderIndex (integer, 2) - identifies the decoder to use
	bits (Bitmap, 1) - data is copied to here
	metadata (ByteArray, 0) - metadata describing the frame is copied to here */

EXPORT(sqInt)
primitiveDecoderReadIntoBitmapAndMetadata(void)
{
    char* bitPtr;
    sqInt bits;
    sqInt decoderIndex;
    sqInt maxLength;
    sqInt metadata;
    sqInt metadataLength;
    char* metadataPtr;
    sqInt result;

	if (!(validateArgCount(3))) {
		return null;
	}
	decoderIndex = interpreterProxy->stackIntegerValue(2);
	bits = interpreterProxy->stackObjectValue(1);
	bitPtr = interpreterProxy->firstIndexableField(bits);
	maxLength = interpreterProxy->byteSizeOf(bits);
	metadata = interpreterProxy->stackObjectValue(0);
	metadataPtr = interpreterProxy->firstIndexableField(metadata);
	metadataLength = interpreterProxy->byteSizeOf(metadata);
	if (interpreterProxy->failed()) {
		return null;
	}
	;
	;
	;
	;
	;
	result = qDecoderRead(decoderIndex, bitPtr, maxLength, metadataPtr, metadataLength);
	interpreterProxy->pop(4);
	return interpreterProxy->pushInteger(result);
}


/*	Destroy the decoder at the specified index. If the the index does not
	correspond to a valid decoder, do nothing. */

EXPORT(sqInt)
primitiveDestroyDecoder(void)
{
    sqInt index;

	if (!(validateArgCount(1))) {
		return null;
	}
	index = interpreterProxy->stackIntegerValue(0);
	;
	qDestroyDecoder(index);
	return interpreterProxy->pop(1);
}


/*	Destroy the decoder at the specified index. If the the index does not
	correspond to a valid encoder, do nothing. */

EXPORT(sqInt)
primitiveDestroyEncoder(void)
{
    sqInt index;

	if (!((interpreterProxy->methodArgumentCount()) == 1)) {
		return interpreterProxy->primitiveFail();
	}
	index = interpreterProxy->stackIntegerValue(0);
	;
	qDestroyEncoder(index);
	return interpreterProxy->pop(1);
}


/*	arguments:
	encoderIndex (integer, 1)
	bits (Bitmap, 0) */

EXPORT(sqInt)
primitiveEncode(void)
{
    char* bitPtr;
    sqInt bits;
    sqInt bitsLength;
    sqInt encoderIndex;
    sqInt result;

	if (!((interpreterProxy->methodArgumentCount()) == 2)) {
		return interpreterProxy->primitiveFail();
	}
	encoderIndex = interpreterProxy->stackIntegerValue(1);
	bits = interpreterProxy->stackObjectValue(0);
	bitPtr = interpreterProxy->firstIndexableField(bits);

	/* Make Squeak's compiler happy. */

	bitsLength = interpreterProxy->byteSizeOf(bits);
	;
	;
	;
	result = qEncode(encoderIndex, bitPtr, bitsLength);
	interpreterProxy->pop(3);
	return interpreterProxy->pushInteger(result);
}


/*	Answer the value of the property with the specified name (a String). The
	result takes the form of a ByteArray, or nil if the property does not
	exist. arguments: name(type, stack offset)
	encoderIndex (integer, 1)
	parameterName (String, 0) */

EXPORT(sqInt)
primitiveEncoderGetProperty(void)
{
    sqInt encoderIndex;
    char*propertyName;
    char*result;
    sqInt resultObj;
    char*resultPtr;
    int resultSize;

	if (!((interpreterProxy->methodArgumentCount()) == 2)) {
		return interpreterProxy->primitiveFail();
	}
	encoderIndex = interpreterProxy->stackIntegerValue(1);
	propertyName = stackStringValue(0);
	if (interpreterProxy->failed()) {
		free(propertyName);
		return null;
	}
	resultPtr = NULL;
	resultSize = 0;
	;
	;
	result = qEncoderGetProperty(encoderIndex, propertyName, &resultSize);
	free(propertyName);
	if (resultSize == 0) {
		return interpreterProxy->popthenPush(3, interpreterProxy->nilObject());
	}
	resultObj = interpreterProxy->instantiateClassindexableSize(interpreterProxy->classByteArray(), resultSize);
	if (interpreterProxy->failed()) {
		free(result);
		return null;
	}
	resultPtr = interpreterProxy->firstIndexableField(resultObj);
	memcpy(resultPtr, result, resultSize);
	free(result);
	return interpreterProxy->popthenPush(3, resultObj);
}


/*	Answer true if the encoder handle is valid, and false otherwise. */

EXPORT(sqInt)
primitiveEncoderIsValid(void)
{
    sqInt encoderIndex;
    sqInt result;

	if (!((interpreterProxy->methodArgumentCount()) == 1)) {
		return interpreterProxy->primitiveFail();
	}
	encoderIndex = interpreterProxy->stackIntegerValue(0);
	if (interpreterProxy->failed()) {
		return null;
	}
	;
	result = qEncoderIsValid(encoderIndex);
	interpreterProxy->pop(2);
	if (result) {
		interpreterProxy->push(interpreterProxy->trueObject());
	}
	else {
		interpreterProxy->push(interpreterProxy->falseObject());
	}
	return null;
}


/*	
	arguments: name(type, stack offset)
	encoderIndex (integer, 2)
	bytes (ByteArray, 1)
	byteSize (integer, 0) */

EXPORT(sqInt)
primitiveEncoderReadIntoBytes(void)
{
    sqInt byteSize;
    void* bytes;
    sqInt encoderIndex;
    sqInt obj;
    char* ptr;
    sqInt result;

	if (!((interpreterProxy->methodArgumentCount()) == 3)) {
		return interpreterProxy->primitiveFail();
	}
	encoderIndex = interpreterProxy->stackIntegerValue(2);
	/* begin stackCharPointer: */
	obj = interpreterProxy->stackObjectValue(1);
	interpreterProxy->success(interpreterProxy->isBytes(obj));
	ptr = interpreterProxy->firstIndexableField(obj);
	if (interpreterProxy->failed()) {
		bytes = ((char*) null);
		goto l1;
	}
	else {
		bytes = ((char*) ptr);
		goto l1;
	}
l1:	/* end stackCharPointer: */;

	/* Make the compiler happy. */

	byteSize = interpreterProxy->stackIntegerValue(0);
	;
	;
	if (!(byteSize == (interpreterProxy->slotSizeOf(interpreterProxy->stackObjectValue(1))))) {
		return interpreterProxy->primitiveFail();
	}
	result = qEncoderRead(encoderIndex, bytes, byteSize);
	interpreterProxy->pop(4);
	return interpreterProxy->pushInteger(result);
}


/*	Get the current logging verbosity level. 0 is the lowest/default
	verbosity; higher numbers are more verbose. */

EXPORT(sqInt)
primitiveGetLogVerbosity(void)
{
    sqInt result;

	if (!(validateArgCount(0))) {
		return null;
	}
	result = interpreterProxy->signed32BitIntegerFor(qGetLogVerbosity());
	return interpreterProxy->popthenPush(1, result);
}


/*	Allows us to log to the current plugin log-file (typically
	QAudioPlugin.log). 
 */

EXPORT(sqInt)
primitiveLogMsg(void)
{
    char*logString;

	if (!(validateArgCount(1))) {
		return null;
	}
	logString = stackStringValue(0);
	if (interpreterProxy->failed()) {
		free(logString);
		return null;
	}
	qLogFromC(logString);
	free(logString);
	return interpreterProxy->pop(1);
}

EXPORT(sqInt)
primitiveSetLogFile(void)
{
    char*filePath;

	if (!(validateArgCount(1))) {
		return null;
	}
	filePath = stackStringValue(0);
	if (interpreterProxy->failed()) {
		free(filePath);
		return null;
	}
	qLogToFile(filePath);
	free(filePath);
	return interpreterProxy->pop(1);
}


/*	Set the verbosity level of the logging. 0 is the lowest/default verbosity;
	higher numbers are more verbose. */

EXPORT(sqInt)
primitiveSetLogVerbosity(void)
{
    sqInt newVerbosity;

	if (!(validateArgCount(1))) {
		return null;
	}
	newVerbosity = interpreterProxy->stackIntegerValue(0);
	if (interpreterProxy->failed()) {
		return null;
	}
	qSetLogVerbosity(newVerbosity);
	return interpreterProxy->pop(1);
}


/*	Note: This is coded so that is can be run from Squeak. */

EXPORT(sqInt)
setInterpreter(struct VirtualMachine*anInterpreter)
{
    sqInt ok;

	interpreterProxy = anInterpreter;
	ok = interpreterProxy->majorVersion() == VM_PROXY_MAJOR;
	if (ok == 0) {
		return 0;
	}
	ok = interpreterProxy->minorVersion() >= VM_PROXY_MINOR;
	return ok;
}


/*	The stack object at 'index' should be an ExternalAddress; this function
	answers a pointer to the actual address (skip the object header).
 */

static char*
stackCharPointer(sqInt index)
{
    sqInt obj;
    char* ptr;

	obj = interpreterProxy->stackObjectValue(index);
	interpreterProxy->success(interpreterProxy->isBytes(obj));
	ptr = interpreterProxy->firstIndexableField(obj);
	if (interpreterProxy->failed()) {
		return null;
	}
	else {
		return ptr;
	}
}

static void *
stackStringValue(sqInt index)
{
    char*dstPtr;
    sqInt i;
    sqInt obj;
    char*srcPtr;
    sqInt sz;

	obj = interpreterProxy->stackValue(index);
	if (!(interpreterProxy->isBytes(obj))) {
		interpreterProxy->primitiveFail();
		return null;
	}
	sz = interpreterProxy->byteSizeOf(obj);
	dstPtr = malloc(sz + 1);
	srcPtr = interpreterProxy->firstIndexableField(obj);
	for (i = 0; i <= (sz - 1); i += 1) {
		dstPtr[i] = (srcPtr[i]);
	}
	dstPtr[sz] = 0;
	return dstPtr;
}

static sqInt
validateArgCount(sqInt expectedArgCount)
{
    sqInt ok;

	ok = (interpreterProxy->methodArgumentCount()) == expectedArgCount;
	if (!(ok)) {
		interpreterProxy->primitiveFail();
	}
	return ok;
}


#ifdef SQUEAK_BUILTIN_PLUGIN

void* QVideoCodecPluginFree_exports[][3] = {
	{"QVideoCodecPluginFree", "getModuleName", (void*)getModuleName},
	{"QVideoCodecPluginFree", "initialiseModule", (void*)initialiseModule},
	{"QVideoCodecPluginFree", "moduleUnloaded", (void*)moduleUnloaded},
	{"QVideoCodecPluginFree", "primitiveCreateDecoder", (void*)primitiveCreateDecoder},
	{"QVideoCodecPluginFree", "primitiveCreateEncoder", (void*)primitiveCreateEncoder},
	{"QVideoCodecPluginFree", "primitiveDecode", (void*)primitiveDecode},
	{"QVideoCodecPluginFree", "primitiveDecoderIsValid", (void*)primitiveDecoderIsValid},
	{"QVideoCodecPluginFree", "primitiveDecoderReadIntoBitmap", (void*)primitiveDecoderReadIntoBitmap},
	{"QVideoCodecPluginFree", "primitiveDecoderReadIntoBitmapAndMetadata", (void*)primitiveDecoderReadIntoBitmapAndMetadata},
	{"QVideoCodecPluginFree", "primitiveDestroyDecoder", (void*)primitiveDestroyDecoder},
	{"QVideoCodecPluginFree", "primitiveDestroyEncoder", (void*)primitiveDestroyEncoder},
	{"QVideoCodecPluginFree", "primitiveEncode", (void*)primitiveEncode},
	{"QVideoCodecPluginFree", "primitiveEncoderGetProperty", (void*)primitiveEncoderGetProperty},
	{"QVideoCodecPluginFree", "primitiveEncoderIsValid", (void*)primitiveEncoderIsValid},
	{"QVideoCodecPluginFree", "primitiveEncoderReadIntoBytes", (void*)primitiveEncoderReadIntoBytes},
	{"QVideoCodecPluginFree", "primitiveGetLogVerbosity", (void*)primitiveGetLogVerbosity},
	{"QVideoCodecPluginFree", "primitiveLogMsg", (void*)primitiveLogMsg},
	{"QVideoCodecPluginFree", "primitiveSetLogFile", (void*)primitiveSetLogFile},
	{"QVideoCodecPluginFree", "primitiveSetLogVerbosity", (void*)primitiveSetLogVerbosity},
	{"QVideoCodecPluginFree", "setInterpreter", (void*)setInterpreter},
	{NULL, NULL, NULL}
};

#endif /* ifdef SQ_BUILTIN_PLUGIN */
