/* This file has been post-processed for GNU C */


/* Automatically generated by
	CCodeGeneratorGlobalStructure VMMaker-eem.727 uuid: ddd40ec5-cf16-45d0-876f-d465abbddd04
   from
	CoInterpreter VMMaker-eem.727 uuid: ddd40ec5-cf16-45d0-876f-d465abbddd04
 */
static char __buildInfo[] = "CoInterpreter VMMaker-eem.727 uuid: ddd40ec5-cf16-45d0-876f-d465abbddd04 " __DATE__ ;
char *__interpBuildInfo = __buildInfo;



#if USE_GLOBAL_STRUCT
# define SQ_USE_GLOBAL_STRUCT 1
#else
# define SQ_USE_GLOBAL_STRUCT 0
#endif

#include <stddef.h> /* for e.g. alloca */
#include <setjmp.h>
#include "sqGnu.h"
#include "vmCallback.h"
#include "sqMemoryFence.h"
#include "dispdbg.h"
#include "sqCogStackAlignment.h"
#include "cogmethod.h"
#include "cointerp.h"
#include "cogit.h"
#include "sqMemoryAccess.h"


void printCallStack(void);

/* Disable Intel compiler inlining of warning which is used for breakpoints */
#pragma auto_inline off
void
warning(char *s) { /* Print an error message but don't exit. */
	printf("\n%s\n", s);
}
#pragma auto_inline on

void
invalidCompactClassError(char *s) { /* Print a compact class index error message and exit. */
	static sqInt printingStack = true; /* not running at this point */

	printf("\nClass %s does not have the required compact class index\n", s);
	exit(-1);
}

/*
 * Define sigsetjmp and siglongjmp to be the most minimal setjmp/longjmp available on the platform.
 */
#if WIN32
# define sigsetjmp(jb,ssmf) setjmp(jb)
# define siglongjmp(jb,v) longjmp(jb,v)
#else
# define sigsetjmp(jb,ssmf) _setjmp(jb)
# define siglongjmp(jb,v) _longjmp(jb,v)
#endif

typedef struct _StackPage {
	char *stackLimit;
	char *headSP;
	char *headFP;
	char *baseFP;
	char *baseAddress;
	char *realStackLimit;
	char *lastAddress;
	int	trace;
	struct _StackPage *nextPage;
	struct _StackPage *prevPage;
 } StackPage;

#define CogStackPage StackPage



/*** Constants ***/
#define ActiveProcessIndex 1
#define AllButHashBits 0xE001FFFFUL
#define AllButMarkBit 0x7FFFFFFFUL
#define AllButMarkBitAndTypeMask 0x7FFFFFFC
#define AllButRootBit 0xBFFFFFFFUL
#define AllButTypeMask 0xFFFFFFFCUL
#if !defined(AllocationCheckFiller)
# define AllocationCheckFiller 0x55AA55AA
#endif
#define AtCacheFixedFields 4
#define AtCacheFmt 3
#define AtCacheMask 0x1C
#define AtCacheOop 1
#define AtCacheSize 2
#define AtCacheTotalSize 64
#define AtPutBase 32
#define BaseHeaderSize 4
#define Byte0Mask 0xFF
#define Byte1Mask 0xFF00
#define Byte1Shift 8
#define Byte1ShiftNegated -8
#define Byte2Mask 0xFF0000
#define Byte3Mask 0xFF000000UL
#define Byte3Shift 24
#define Byte3ShiftNegated -24
#define Byte4Mask 0x0
#define Byte4Shift 0
#define Byte4ShiftNegated 0
#define Byte5Mask 0x0
#define Byte5Shift 0
#define Byte5ShiftNegated 0
#define Byte6Mask 0x0
#define Byte7Mask 0x0
#define Byte7Shift 0
#define Byte7ShiftNegated 0
#define Bytes3to0Mask 0x0
#define Bytes7to4Mask 0x0
#define BytesPerOop 4
#define BytesPerWord 4
#define CacheProbeMax 3
#define CharacterTable 24
#define CharacterValueIndex 0
#define ClassAlien 52
#define ClassArray 7
#define ClassArrayCompactIndex 3
#define ClassBitmap 4
#define ClassBlockClosure 36
#define ClassBlockClosureCompactIndex 0
#define ClassByteArray 26
#define ClassByteString 6
#define ClassByteStringCompactIndex 11
#define ClassCharacter 19
#define ClassExternalAddress 43
#define ClassExternalData 45
#define ClassExternalFunction 46
#define ClassExternalLibrary 47
#define ClassExternalStructure 44
#define ClassFloat 9
#define ClassFloatCompactIndex 6
#define ClassInteger 5
#define ClassLargeNegativeInteger 42
#define ClassLargeNegativeIntegerCompactIndex 4
#define ClassLargePositiveInteger 13
#define ClassLargePositiveIntegerCompactIndex 5
#define ClassMessage 15
#define ClassMethodContext 10
#define ClassMethodContextCompactIndex 14
#define ClassMutex 39
#define ClassPoint 12
#define ClassSemaphore 18
#define ClassString 6
#define ClassUnsafeAlien 54
#define ClosureFirstCopiedValueIndex 3
#define ClosureIndex 4
#define ClosureNumArgsIndex 2
#define ClosureOuterContextIndex 0
#define ClosureStartPCIndex 1
#define CMBlock 3
#define CMClosedPIC 4
#define CMMethod 2
#define CMOpenPIC 5
#define CompactClasses 28
#define CompactClassMask 0x1F000
#define ConstMinusOne -1
#define ConstOne 3
#define ConstTwo 5
#define ConstZero 1
#define CrossedX 258
#define CSCallbackLeave 4
#define CSEnterCriticalSection 5
#define CSExitCriticalSection 6
#define CSResume 7
#define CSSignal 8
#define CSSuspend 9
#define CSWait 10
#define CSYield 11
#define CtxtTempFrameStart 6
#define DoAssertionChecks (!PRODUCTION)
#define DoExpensiveAssertionChecks 0
#define Done 4
#define DumpStackOnLowSpace 0
#define EndOfRun 0x101
#define ExcessSignalsIndex 2
#define ExternalObjectsArray 38
#define ExtraRootSize 2048
#define FailImbalancedPrimitives 1
#define FalseObject 1
#define FirstLinkIndex 0
#define FoxCallerSavedIP 4
#define FoxIFReceiver -20
#define FoxIFrameFlags -12
#define FoxIFSavedIP -16
#define FoxMethod -4
#define FoxMFReceiver -12
#define FoxSavedFP 0
#define FoxThisContext -8
#define GCTopMarker 3
#define HasBeenReturnedFromMCPC -1
#define HashBits 0x1FFE0000
#define HashBitsOffset 17
#define HashMaskUnshifted 0xFFF
#define HeaderFlagBitPosition 29
#define HeaderIndex 0
#define HeaderTypeClass 1
#define HeaderTypeFree 2
#define HeaderTypeGC 2
#define HeaderTypeShort 3
#define HeaderTypeSizeAndClass 0
#define IFrameSlots 7
#define InstanceSpecificationIndex 2
#define InstructionPointerIndex 1
#define LargeContextBit 0x40000
#define LargeContextBytes 252
#define LargeContextSize 252
#define LastLinkIndex 1
#define LiteralStart 1
#define LongSizeMask 0xFFFFFFFCUL
#define MarkBit 0x80000000UL
#define MaxExternalPrimitiveTableSize 4096
#define MaxJumpBuf 32
#define MaxLiteralCountForCompile 60
#define MaxPrimitiveIndex 575
#define MaxQuickPrimitiveIndex 519
#define MessageArgumentsIndex 1
#define MessageLookupClassIndex 2
#define MessageSelectorIndex 0
#define MethodArrayIndex 1
#define MethodCacheClass 2
#define MethodCacheEntries 0x400
#define MethodCacheEntrySize 4
#define MethodCacheMask 0xFFC
#define MethodCacheMethod 3
#define MethodCachePrimFunction 4
#define MethodCacheSelector 1
#define MethodCacheSize 4096
#define MethodDictionaryIndex 1
#define MethodIndex 3
#define MFMethodFlagHasContextFlag 1
#define MFMethodFlagIsBlockFlag 2
#define MFMethodFlagsMask 0x3
#define MFMethodMask -0x4
#define MFrameSlots 5
#define MillisecondClockMask 0x1FFFFFFF
#define MinBackwardJumpCountForCompile 10
#define MyListIndex 3
#define NextLinkIndex 0
#define NilObject 0
#define PrimCallCollectsProfileSamples 8
#define PrimCallMayCallBack 4
#define PrimCallNeedsNewMethod 1
#define PrimCallNeedsPrimitiveFunction 2
#define PrimErrBadArgument 3
#define PrimErrBadIndex 4
#define PrimErrBadMethod 12
#define PrimErrBadNumArgs 5
#define PrimErrBadReceiver 2
#define PrimErrGenericFailure 1
#define PrimErrInappropriate 6
#define PrimErrNamedInternal 13
#define PrimErrNoCMemory 10
#define PrimErrNoMemory 9
#define PrimErrNotFound 11
#define PrimErrTableIndex 51
#define PrimErrUnsupported 7
#define PrimitiveExternalCallIndex 117
#define PrimNoErr 0
#define PrimTraceLogSize 256
#define PriorityIndex 2
#define ProcessListsIndex 0
#define ProcessSignalingLowSpace 22
#define ReceiverIndex 5
#define RemapBufferSize 25
#define ReturnToInterpreter 1
#define RootBit 0x40000000
#define RootTableRedZone 2400
#define RootTableSize 2500
#define SchedulerAssociation 3
#define SelectorAboutToReturn 48
#define SelectorCannotInterpret 34
#define SelectorCannotReturn 21
#define SelectorDoesNotUnderstand 20
#define SelectorInvokeCallback 53
#define SelectorMustBeBoolean 25
#define SelectorRunWithIn 49
#define SelectorStart 2
#define SenderIndex 0
#define ShiftForWord 2
#define Size4Bit 0
#define SizeMask 0xFC
#define SmallContextSize 92
#define SpecialSelectors 23
#define StackPointerIndex 2
#define StartField 1
#define StartObj 2
#define SuperclassIndex 0
#define SuspendedContextIndex 1
#define TheDisplay 14
#define TheFinalizationSemaphore 41
#define TheInputSemaphore null
#define TheInterruptSemaphore 30
#define TheLowSpaceSemaphore 17
#define TheTimerSemaphore 29
#define TraceBlockActivation 5
#define TraceBlockCreation 7
#define TraceBufferSize 768
#define TraceCodeCompaction 13
#define TraceContextSwitch 3
#define TraceFullGC 11
#define TraceIncrementalGC 9
#define TraceIsFromInterpreter 2
#define TraceIsFromMachineCode 1
#define TraceVMCallback 23
#define TraceVMCallbackReturn 25
#define TrueObject 2
#define TypeMask 0x3
#define Upward 3
#define ValueIndex 1
#define WeakRootTableSize 2625
#define WordMask 0xFFFFFFFFUL
#define XIndex 0
#define YIndex 1


/*** Function Prototypes ***/
sqInt interpret(void);
static void activateCoggedNewMethod(sqInt inInterpreter);
static sqInt activateInterpreterMethodFromMachineCode(void);
static void activateNewMethod(void);
EXPORT(sqInt) addGCRoot(sqInt *varLoc);
static void addLastLinktoList(sqInt proc, sqInt aList);
static void addNewMethodToCache(sqInt class);
static sqInt addressCouldBeObjWhileForwarding(sqInt address);
sqInt addressCouldBeObj(sqInt address);
sqInt addressCouldBeOop(sqInt address);
static sqInt addressIsInPage(StackPage * self_in_addressIsInPage, char *address);
static sqInt adjustAllOopsBy(sqInt bytesToShift);
static sqInt allYoungand(sqInt array1, sqInt array2);
usqInt argumentCountAddress(void);
sqInt argumentCountOfMethodHeader(sqInt header);
sqInt argumentCountOf(sqInt methodPointer);
void * arrayValueOf(sqInt arrayOop);
static CogMethod * asCogHomeMethod(CogBlockMethod *aCogMethod);
static sqInt asciiOfCharacter(sqInt characterObj);
void assertValidExecutionPointers(usqInt lip, char *lifp, char *lisp);
static void assertValidExecutionPointersimbar(usqInt lip, char *lifp, char *lisp, sqInt inInterpreter);
void assertValidMachineCodeFrame(sqInt instrPtr);
static void assertValidStackLimits(void);
static void attemptToSwitchToMachineCode(sqInt bcpc);
static sqInt baseHeader(sqInt oop);
sqInt becomewith(sqInt array1, sqInt array2);
static sqInt becomewithtwoWaycopyHash(sqInt array1, sqInt array2, sqInt twoWayFlag, sqInt copyHashFlag);
void beRootIfOld(sqInt oop);
sqInt booleanValueOf(sqInt obj);
static sqInt byteLengthOf(sqInt oop);
sqInt byteSizeOf(sqInt oop);
sqInt byteSwapped(sqInt w);
EXPORT(sqInt) callbackEnter(sqInt *callbackID);
EXPORT(sqInt) callbackLeave(sqInt cbID);
static void callExternalPrimitive(void (*functionID)());
void callForCogCompiledCodeCompaction(void);
sqInt canContextSwitchIfActivating(sqInt methodHeader);
void ceActivateFailingPrimitiveMethod(sqInt aPrimitiveMethod);
sqInt ceBaseFrameReturn(sqInt returnValue);
sqInt ceCannotResume(void);
void ceCheckForInterrupts(void);
void ceCheckProfileTick(void);
sqInt ceContextinstVar(sqInt maybeContext, sqInt slotIndex);
sqInt ceContextinstVarvalue(sqInt maybeMarriedContext, sqInt slotIndex, sqInt anOop);
sqInt ceInterpretMethodFromPICreceiver(sqInt aMethodObj, sqInt rcvr);
void ceMNUFromPICMNUMethodreceiver(sqInt aMethodObj, sqInt rcvr);
sqInt ceNewArraySlotSize(sqInt slotSize);
sqInt ceNonLocalReturn(sqInt returnValue);
sqInt cePositive32BitIntegerFor(usqInt anInteger);
sqInt cePushActiveContext(void);
sqInt ceReturnToInterpreter(sqInt anOop);
sqInt ceSendFromInLineCacheMiss(CogMethod *oPIC);
sqInt ceSendMustBeBoolean(sqInt anObject);
sqInt ceSendsupertonumArgs(sqInt selector, sqInt superNormalBar, sqInt rcvr, sqInt numArgs);
void ceStackOverflow(sqInt contextSwitchIfNotNil);
sqInt ceStoreCheck(sqInt anOop);
void ceTraceBlockActivation(void);
void ceTraceLinkedSend(sqInt theReceiver);
void ceTraceStoreOfinto(sqInt aValue, sqInt anObject);
sqInt characterForAscii(sqInt ascii);
sqInt characterTable(void);
void checkAssertsEnabledInCoInterpreter(void);
static sqInt checkCodeIntegrity(sqInt fullGCFlag);
static sqInt checkDeliveryOfLongRunningPrimitiveSignal(void);
sqInt checkedIntegerValueOf(sqInt intOop);
sqInt checkedLongAt(sqInt byteAddress);
static sqInt checkForEventsMayContextSwitch(sqInt mayContextSwitch);
static sqInt checkHeapIntegrity(void);
static sqInt checkInterpreterIntegrity(void);
static sqInt checkIsStillMarriedContextcurrentFP(sqInt aContext, char *currentFP);
static sqInt checkLogIntegrity(void);
static sqInt checkOopIntegritynamed(sqInt obj, char *name);
static sqInt checkOopIntegritynamedindex(sqInt obj, char *name, sqInt i);
static void checkProfileTick(sqInt aPrimitiveMethod);
static sqInt checkStackIntegrity(void);
sqInt classAlien(void);
sqInt classArray(void);
sqInt classBitmap(void);
sqInt classByteArray(void);
sqInt classCharacter(void);
sqInt classExternalAddress(void);
sqInt classExternalData(void);
sqInt classExternalFunction(void);
sqInt classExternalLibrary(void);
sqInt classExternalStructure(void);
sqInt classFieldOffset(void);
sqInt classFloat(void);
sqInt classFloatCompactIndex(void);
sqInt classHeader(sqInt oop);
sqInt classLargeNegativeInteger(void);
sqInt classLargePositiveInteger(void);
static sqInt classNameOfIs(sqInt aClass, char *className);
sqInt classPoint(void);
sqInt classSemaphore(void);
sqInt classSmallInteger(void);
sqInt classString(void);
sqInt classUnsafeAlien(void);
static void clearLeakMapAndMapAccessibleObjects(void);
void clearTraceLog(void);
sqInt clone(sqInt oop);
static CogMethod * cmHomeMethod(CogBlockMethod * self_in_cmHomeMethod);
CogMethod * cogMethodOf(sqInt aMethodOop);
static void commenceCogCompiledCodeCompaction(void);
static void commonAtPut(sqInt stringy);
static void commonAt(sqInt stringy);
sqInt compactClassAt(sqInt ccIndex);
sqInt compactClassFieldLSB(void);
sqInt compactClassFieldWidth(void);
sqInt compactClassIndexOfHeader(sqInt header);
sqInt compactClassIndexOf(sqInt oop);
sqInt compactClassTable(void);
static sqInt compare31or32Bitsequal(sqInt obj1, sqInt obj2);
void compilationBreakpointFor(sqInt selectorOop);
static sqInt containOnlyOops(sqInt array);
static sqInt containOnlyOopsand(sqInt array1, sqInt array2);
static sqInt contextInstructionPointerframe(sqInt theIP, char *theFP);
static sqInt contexthasSender(sqInt thisCntx, sqInt aContext);
sqInt copyBits(void);
sqInt copyBitsFromtoat(sqInt x0, sqInt x1, sqInt y);
static sqInt copyObjtoSegmentaddrstopAtsaveOopAtheaderAt(sqInt oop, sqInt segmentWordArray, sqInt lastSeg, sqInt stopAddr, sqInt oopPtr, sqInt hdrPtr);
static void cr(void);
static void createActualMessageTo(sqInt lookupClass);
sqInt createClosureNumArgsnumCopiedstartpc(sqInt numArgs, sqInt numCopied, sqInt initialIP);
char * cStringOrNullFor(sqInt oop);
static double dbgFloatValueOf(sqInt oop);
static sqInt defaultCogCodeSize(void);
static sqInt defaultEdenBytes(void);
static sqInt defaultNumStackPages(void);
static void deferStackLimitSmashAround(void (*functionSymbol)(void));
static void displayBitsOfLeftTopRightBottom(sqInt aForm, sqInt l, sqInt t, sqInt r, sqInt b);
sqInt displayObject(void);
static sqInt divorceAllFrames(void);
static void divorceFramesIn(StackPage *aStackPage);
static sqInt doPrimitiveDivby(sqInt rcvr, sqInt arg);
static sqInt doPrimitiveModby(sqInt rcvr, sqInt arg);
sqInt doSignalSemaphoreWithIndex(sqInt index);
static void dummyReferToProxy(void);
EXPORT(sqInt) dumpImage(sqInt fileName);
void dumpPrimTraceLog(void);
void dumpTraceLog(void);
static sqInt eeInstantiateAndInitializeClassindexableSize(sqInt classPointer, sqInt size);
sqInt eeInstantiateClassindexableSize(sqInt classPointer, sqInt size);
static sqInt eeInstantiateSmallClasssizeInBytes(sqInt classPointer, sqInt sizeInBytes);
static sqInt encodedNativePCOfcogMethod(sqInt mcpc, CogBlockMethod *cogMethod);
static sqInt ensureCallerContext(char *theFP);
static void ensureContextIsExecutionSafeAfterAssignToStackPointer(sqInt aContext);
static void ensureImageFormatIsUpToDate(sqInt swapBytes);
static void enterRegisterArgCogMethodatreceiver(CogMethod *cogMethod, sqInt entryOffset, sqInt rcvr);
static sqInt enterSmalltalkExecutiveImplementation(void);
static char * establishFrameForContextToReturnTo(sqInt contextToReturnTo);
void executeCogMethodFromLinkedSendwithReceiver(CogMethod *cogMethod, sqInt rcvr);
void executeCogMethodFromLinkedSendwithReceiverandCacheTag(CogMethod *cogMethod, sqInt rcvr, sqInt cacheTag);
static void executeCogMethodFromUnlinkedSendwithReceiver(CogMethod *cogMethod, sqInt rcvr);
static void executeNewMethod(void);
static void externalDivorceFrameandContext(char *theFP, sqInt ctxt);
static char * externalEnsureIsBaseFrame(char *aFramePtr);
static sqInt externalInstVarofContext(sqInt offset, sqInt aContext);
static void externalInstVarofContextput(sqInt index, sqInt maybeMarriedContext, sqInt anOop);
static sqInt externalQuickPrimitiveResponse(void);
sqInt failed(void);
static void failUnbalancedPrimitive(void);
sqInt falseObject(void);
void * fetchArrayofObject(sqInt fieldIndex, sqInt objectPointer);
sqInt fetchByteofObject(sqInt byteIndex, sqInt oop);
static sqInt fetchClassOfNonInt(sqInt oop);
sqInt fetchClassOf(sqInt oop);
double fetchFloatofObject(sqInt fieldIndex, sqInt objectPointer);
sqInt fetchIntegerofObject(sqInt fieldIndex, sqInt objectPointer);
sqInt fetchLong32ofObject(sqInt fieldIndex, sqInt oop);
sqInt fetchPointerofObject(sqInt fieldIndex, sqInt oop);
static sqInt fetchStackPointerOf(sqInt aContext);
static sqInt fetchWordLengthOf(sqInt objectPointer);
static void finalizeReference(usqInt oop);
sqInt findClassOfMethodforReceiver(sqInt meth, sqInt rcvr);
static char * findFrameAboveinPage(char *theFP, StackPage *thePage);
static sqInt findHomeForContext(sqInt aContext);
static sqInt findMethodWithPrimitiveFromContextUpToContext(sqInt primitive, sqInt senderContext, sqInt homeContext);
static sqInt findMethodWithPrimitiveFromFPUpToContext(sqInt primitive, char *startFP, sqInt homeContext);
static void findNewMethodInClass(sqInt class);
sqInt findSelectorOfMethodforReceiver(sqInt meth, sqInt rcvr);
static char * findSPOfon(char *theFP, StackPage *thePage);
void findString(char *aCString);
void * firstFixedField(sqInt oop);
void * firstIndexableField(sqInt oop);
double floatArg(sqInt index);
sqInt floatObjectOf(double aFloat);
double floatValueOf(sqInt oop);
static void flushExternalPrimitiveOf(sqInt methodObj);
static void flushExternalPrimitives(void);
void forceInterruptCheck(void);
void forceInterruptCheckFromHeartbeat(void);
sqInt formatOfClass(sqInt classPointer);
static sqInt frameCallerContext(char *theFP);
static sqInt frameCallerContextput(char *theFP, sqInt aValue);
static char * frameCallerFP(char *theFP);
static char * frameCallerSavedIP(char *theFP);
static char * frameCallerSP(char *theFP);
static sqInt frameContext(char *theFP);
static sqInt frameHasContext(char *theFP);
static sqInt frameIsBlockActivation(char *theFP);
static sqInt frameNumArgs(char *theFP);
static char * frameOfMarriedContext(sqInt aContext);
usqInt framePointerAddress(void);
static sqInt frameReceiver(char *theFP);
static sqInt frameStackedReceiverOffset(char *theFP);
static void freeStackPageNoAssert(StackPage *aPage);
usqInt freeStartAddress(void);
sqInt fullDisplayUpdate(void);
void fullGC(void);
static void (*functionForPrimitiveCallout())(void) ;
static void (*functionForPrimitiveExternalCall(sqInt methodObj))(void) ;
void (*functionPointerForCompiledMethodprimitiveIndex(sqInt methodObj, sqInt primIndex))(void) ;
void (*functionPointerForinClass(sqInt primIdx,sqInt theClass))(void) ;
static sqInt fwdBlockValid(sqInt addr);
static sqInt fwdTableInit(sqInt blkSize);
static sqInt fwdTableSize(sqInt blkSize);
sqInt getCurrentBytecode(void);
sqInt getFullScreenFlag(void);
sqInt getInterruptKeycode(void);
sqInt getInterruptPending(void);
static sqInt getLongFromFileswap(sqImageFile  aFile, sqInt swapFlag);
usqLong getNextWakeupUsecs(void);
sqInt getSavedWindowSize(void);
static sqInt getShortFromFileswap(sqImageFile aFile, sqInt swapFlag);
sqInt getThisSessionID(void);
static sqInt handleMNUInMachineCodeToclassForMessagemayLink(sqInt selectorIndex, sqInt rcvr, sqInt classForMessage, sqInt mayLinkBoolean);
static void handleStackOverflow(void);
static sqInt handleStackOverflowOrEventAllowContextSwitch(sqInt mayContextSwitch);
static sqInt headerOf(sqInt methodPointer);
sqInt highBit(usqInt anUnsignedValue);
static sqInt iframeIsBlockActivation(char *theFP);
static sqInt iframeMethod(char *theFP);
static sqInt iframeReceiver(char *theFP);
static sqInt iframeSavedIP(char *theFP);
void ifValidWriteBackStackPointersSaveTo(void *theCFP, void *theCSP, char **savedFPP, char **savedSPP);
static sqInt imageSegmentVersion(void);
static sqInt incCompBody(void);
static sqInt incCompMakeFwd(void);
static sqInt incCompMove(sqInt bytesFreed);
sqInt includesBehaviorThatOf(sqInt aClass, sqInt aSuperclass);
void incrementalGC(void);
static void initializeInterpreter(sqInt bytesToShift);
static void initializeMemoryFirstFree(sqInt firstFree);
static void initializeObjectMemory(sqInt bytesToShift);
static void initializeStacknumSlotspageSizestackLimitOffsetstackPageHeadroom(char *theStackPages, sqInt stackSlots, sqInt slotsPerPage, sqInt stackLimitOffsetBytes, sqInt stackPageHeadroomBytes);
static sqInt initStackPagesAndInterpret(void);
static void installinAtCacheatstring(sqInt rcvr, sqInt *cache, sqInt atIx, sqInt stringy);
sqInt instanceSizeOf(sqInt classObj);
sqInt instantiateClassindexableSize(sqInt classPointer, sqInt size);
usqInt instructionPointerAddress(void);
sqInt integerArg(sqInt index);
sqInt integerObjectOf(sqInt value);
sqInt integerValueOf(sqInt objectPointer);
static sqInt interpreterAllocationReserveBytes(void);
void ioFilenamefromStringofLengthresolveAliases(char *aCharBuffer, char *aFilenameString, sqInt filenameLength, sqInt aBoolean);
sqInt isArray(sqInt oop);
static sqInt isBaseFrame(char *theFP);
sqInt isBytes(sqInt oop);
static sqInt isClassOfNonImmequalTo(sqInt oop, sqInt classOop);
static sqInt isCogMethodReference(sqInt methodHeader);
static sqInt isContextHeader(sqInt aHeader);
static sqInt isContext(sqInt oop);
sqInt isFloatObject(sqInt oop);
static sqInt isFree(StackPage * self_in_isFree);
static sqInt isFreeObject(sqInt oop);
sqInt isIndexable(sqInt oop);
sqInt isInMemory(sqInt address);
sqInt isIntegerObject(sqInt objectPointer);
sqInt isIntegerValue(sqInt intValue);
static sqInt isLiveContext(sqInt oop);
static sqInt isMachineCodeFrame(char *theFP);
sqInt isMarked(sqInt oop);
static sqInt isMarriedOrWidowedContext(sqInt aContext);
sqInt isNonIntegerObject(sqInt objectPointer);
sqInt isOopCompiledMethod(sqInt oop);
sqInt isPointers(sqInt oop);
static sqInt isPrimitiveFunctionPointerAnIndex(void);
sqInt isQuickPrimitiveIndex(sqInt anInteger);
sqInt isReallyYoungObject(sqInt obj);
static sqInt isSingleContext(sqInt aContext);
static sqInt isWeakNonInt(sqInt oop);
sqInt isWeak(sqInt oop);
static sqInt isWidowedContext(sqInt aOnceMarriedContext);
static sqInt isWordsOrBytesNonInt(sqInt oop);
sqInt isWordsOrBytes(sqInt oop);
sqInt isWords(sqInt oop);
sqInt isYoung(sqInt oop);
static sqInt isinstanceOfcompactClassIndex(sqInt oop, sqInt classOop, sqInt compactClassIndex);
sqInt isKindOfClass(sqInt oop, sqInt aClass);
sqInt isKindOf(sqInt oop, char *className);
sqInt isMemberOf(sqInt oop, char *className);
sqInt lastPointerOf(sqInt oop);
sqInt leakCheckBecome(void);
sqInt leakCheckFullGC(void);
sqInt leakCheckIncrementalGC(void);
static sqInt lengthOfNameOfClass(sqInt classOop);
sqInt lengthOf(sqInt oop);
static sqInt lengthOfbaseHeaderformat(sqInt oop, sqInt hdr, sqInt fmt);
sqInt literalCountOfHeader(sqInt headerPointer);
sqInt literalCountOf(sqInt methodPointer);
sqInt literalofMethod(sqInt offset, sqInt methodPointer);
sqInt loadBitBltFrom(sqInt bb);
static sqInt loadImageSegmentFromoutPointers(sqInt segmentWordArray, sqInt outPointerArray);
void loadInitialContext(void);
static sqInt lookupInMethodCacheSelclass(sqInt selector, sqInt class);
static sqInt lookupMethodInClass(sqInt class);
static sqInt lookupMethodInDictionary(sqInt dictionary);
static sqInt lookupMethodNoMNUEtcInClass(sqInt class);
sqInt lookupreceiver(sqInt selector, sqInt rcvr);
static sqInt lowestFreeAfter(sqInt chunk);
static StackPage * makeBaseFrameFor(sqInt aContext);
sqInt makePointwithxValueyValue(sqInt xValue, sqInt yValue);
static void mapPointersInObjectsFromto(sqInt memStart, sqInt memEnd);
static void mapPrimTraceLog(void);
static void mapStackPages(void);
static void mapTraceLog(void);
void markActiveMethodsAndReferents(void);
static void markAndTraceAndMaybeFreeStackPages(sqInt fullGCFlag);
static void markAndTraceInterpreterOops(sqInt fullGCFlag);
static void markAndTracePrimTraceLog(void);
static void markAndTraceStackPages(sqInt fullGCFlag);
static void markAndTraceStackPage(StackPage *thePage);
static void markAndTraceTraceLog(void);
void markAndTrace(sqInt oop);
static void markCogMethodsAndReferentsOnPage(StackPage *thePage);
static void markPhase(sqInt fullGCFlag);
static void markStackPageMostRecentlyUsed(StackPage *page);
static void markStackPageNextMostRecentlyUsed(StackPage *page);
static sqInt marriedContextpointsTostackDeltaForCurrentFrame(sqInt spouseContext, sqInt anOop, sqInt stackDeltaForCurrentFrame);
static sqInt marryFrameSP(char *theFP, char *theSP);
static void maybeFlagMethodAsInterpreted(sqInt aMethod);
sqInt maybeSplObj(sqInt index);
sqInt methodArgumentCount(void);
sqInt methodArg(sqInt index);
void * methodCacheAddress(void);
sqInt methodHasCogMethod(sqInt aMethodOop);
sqInt methodPrimitiveIndex(void);
sqInt methodReturnValue(sqInt oop);
sqInt methodShouldBeCogged(sqInt aMethodObj);
static sqInt methodWithHeaderShouldBeCogged(sqInt methodHeader);
sqInt methodwithInitialPCHasErrorCode(sqInt methodObj, sqInt initialPC);
static CogBlockMethod * mframeCogMethod(char *theFP);
static CogMethod * mframeHomeMethod(char *theFP);
static sqInt mframeIsBlockActivation(char *theFP);
static sqInt mframeReceiver(char *theFP);
EXPORT(void) moduleUnloaded(char *aModuleName);
static char * moveFramesInthroughtoPage(StackPage *oldPage, char *theFP, StackPage *newPage);
static sqInt mustMapMachineCodePCcontext(sqInt theIP, sqInt aOnceMarriedContext);
static char * nameOfClass(sqInt classOop);
usqInt newMethodAddress(void);
static StackPage * newStackPage(void);
usqInt nextProfileTickAddress(void);
sqInt nilObject(void);
static void noAtCacheCommonAtPut(sqInt stringy);
static void noAtCacheCommonAt(sqInt stringy);
static sqInt noMarkedContextsOnPage(StackPage *thePage);
static sqInt nonWeakFieldsOf(sqInt oop);
sqInt nullHeaderForMachineCodeMethod(void);
sqInt objectAfter(sqInt oop);
sqInt objectArg(sqInt index);
sqInt objectBefore(sqInt address);
sqInt objectExactlyBefore(sqInt oop);
sqInt objectIsOld(sqInt anObject);
sqInt obsoleteDontUseThisFetchWordofObject(sqInt fieldIndex, sqInt oop);
static sqInt okayFields(sqInt oop);
static sqInt okayOop(sqInt signedOop);
sqInt oopFromChunk(sqInt chunk);
static sqInt oopHasAcceptableClass(sqInt signedOop);
static sqInt oopHasOkayClass(sqInt signedOop);
static sqInt oopisGreaterThanOrEqualTo(sqInt anOop, sqInt otherOop);
static sqInt oopisGreaterThanandLessThan(sqInt anOop, sqInt baseOop, sqInt limitOop);
static sqInt oopisLessThan(sqInt anOop, sqInt otherOop);
static sqInt pageIndexFor(void *pointer);
static sqInt pageListIsWellFormed(void);
sqInt popRemappableOop(void);
sqInt popStack(void);
sqInt pop(sqInt nItems);
void popthenPush(sqInt nItems, sqInt oop);
sqInt positive32BitIntegerFor(sqInt integerValue);
sqInt positive32BitValueOf(sqInt oop);
sqInt positive64BitIntegerFor(sqLong integerValue);
sqLong positive64BitValueOf(sqInt oop);
unsigned long positiveMachineIntegerValueOf(sqInt oop);
static void possibleRootStoreIntovalue(sqInt oop, sqInt valueObj);
static sqInt prepareForwardingTableForBecomingwithtwoWay(sqInt array1, sqInt array2, sqInt twoWayFlag);
sqInt primErrTable(void);
usqInt primFailCodeAddress(void);
static void primitiveAdd(void);
EXPORT(void) primitiveAddLargeIntegers(void);
static void primitiveAdoptInstance(void);
static void primitiveArctan(void);
static void primitiveArrayBecome(void);
static void primitiveArrayBecomeOneWay(void);
static void primitiveArrayBecomeOneWayCopyHash(void);
static void primitiveAsFloat(void);
static void primitiveAt(void);
static void primitiveAtPut(void);
static void primitiveBeCursor(void);
static void primitiveBeDisplay(void);
static void primitiveBeep(void);
static void primitiveBehaviorHash(void);
static void primitiveBitAnd(void);
EXPORT(void) primitiveBitAndLargeIntegers(void);
static void primitiveBitOr(void);
EXPORT(void) primitiveBitOrLargeIntegers(void);
static void primitiveBitShift(void);
EXPORT(void) primitiveBitShiftLargeIntegers(void);
static void primitiveBitXor(void);
EXPORT(void) primitiveBitXorLargeIntegers(void);
static void primitiveBytesLeft(void);
static void primitiveCalloutToFFI(void);
static void primitiveChangeClass(void);
static void primitiveClass(void);
static void primitiveClearVMProfile(void);
static void primitiveClipboardText(void);
EXPORT(sqInt) primitiveClockLogAddresses(void);
static void primitiveClone(void);
static void primitiveClosureCopyWithCopiedValues(void);
static void primitiveClosureValue(void);
void primitiveClosureValueNoContextSwitch(void);
static void primitiveClosureValueWithArgs(void);
static void primitiveCollectCogCodeConstituents(void);
EXPORT(sqInt) primitiveCompareBytes(void);
static void primitiveConstantFill(void);
static void primitiveContextAt(void);
static void primitiveContextAtPut(void);
static void primitiveContextSize(void);
static void primitiveContextXray(void);
static void primitiveControlVMProfiling(void);
static void primitiveCopyObject(void);
EXPORT(sqInt) primitiveCrashVM(void);
static void primitiveDeferDisplayUpdates(void);
EXPORT(sqInt) primitiveDisablePowerManager(void);
static void primitiveDiv(void);
static void primitiveDivide(void);
EXPORT(void) primitiveDivideLargeIntegers(void);
EXPORT(void) primitiveDivLargeIntegers(void);
static void primitiveDoNamedPrimitiveWithArgs(void);
static void primitiveDoPrimitiveWithArgs(void);
static void primitiveEnterCriticalSection(void);
static void primitiveEqual(void);
EXPORT(void) primitiveEqualLargeIntegers(void);
sqInt primitiveErrorTable(void);
EXPORT(void) primitiveEventProcessingControl(void);
static void primitiveExecuteMethod(void);
static void primitiveExecuteMethodArgsArray(void);
static void primitiveExitCriticalSection(void);
static void primitiveExitToDebugger(void);
static void primitiveExp(void);
static void primitiveExponent(void);
static void primitiveExternalCall(void);
sqInt primitiveFail(void);
sqInt primitiveFailFor(sqInt reasonCode);
sqInt primitiveFailureCode(void);
static void primitiveFindHandlerContext(void);
static void primitiveFindNextUnwindContext(void);
static void primitiveFloatAdd(void);
static void primitiveFloatAt(void);
static void primitiveFloatAtPut(void);
static void primitiveFloatDivide(void);
static void primitiveFloatEqual(void);
static void primitiveFloatGreaterOrEqual(void);
static void primitiveFloatGreaterThan(void);
static void primitiveFloatLessOrEqual(void);
static void primitiveFloatLessThan(void);
static void primitiveFloatMultiply(void);
static void primitiveFloatNotEqual(void);
static void primitiveFloatSubtract(void);
static void primitiveFlushCache(void);
static void primitiveFlushCacheByMethod(void);
static void primitiveFlushCacheBySelector(void);
static void primitiveFlushExternalPrimitives(void);
static void primitiveForceDisplayUpdate(void);
EXPORT(sqInt) primitiveForceTenure(void);
static void primitiveFormPrint(void);
static void primitiveFractionalPart(void);
static void primitiveFullGC(void);
usqInt primitiveFunctionPointerAddress(void);
static void primitiveGetAttribute(void);
EXPORT(sqInt) primitiveGetLogDirectory(void);
static void primitiveGetNextEvent(void);
EXPORT(sqInt) primitiveGetWindowLabel(void);
EXPORT(sqInt) primitiveGetWindowSize(void);
static void primitiveGreaterOrEqual(void);
EXPORT(void) primitiveGreaterOrEqualLargeIntegers(void);
static void primitiveGreaterThan(void);
EXPORT(void) primitiveGreaterThanLargeIntegers(void);
EXPORT(sqInt) primitiveHeartbeatFrequency(void);
EXPORT(sqInt) primitiveHighResClock(void);
static void primitiveIdentical(void);
static void primitiveIdentityHash(void);
static void primitiveImageName(void);
static void primitiveIncrementalGC(void);
sqInt primitiveIndexOfMethodHeader(sqInt methodHeader);
sqInt primitiveIndexOf(sqInt methodPointer);
static void primitiveInputSemaphore(void);
static void primitiveInputWord(void);
static void primitiveInstVarAt(void);
static void primitiveInstVarAtPut(void);
static void primitiveIntegerAt(void);
static void primitiveIntegerAtPut(void);
EXPORT(sqInt) primitiveInterruptChecksPerMSec(void);
static void primitiveInterruptSemaphore(void);
static void primitiveInvokeObjectAsMethod(void);
EXPORT(sqInt) primitiveIsRoot(void);
EXPORT(sqInt) primitiveIsWindowObscured(void);
EXPORT(sqInt) primitiveIsYoung(void);
static void primitiveKbdNext(void);
static void primitiveKbdPeek(void);
static void primitiveLessOrEqual(void);
EXPORT(void) primitiveLessOrEqualLargeIntegers(void);
static void primitiveLessThan(void);
EXPORT(void) primitiveLessThanLargeIntegers(void);
static void primitiveListBuiltinModule(void);
static void primitiveListExternalModule(void);
static void primitiveLoadImageSegment(void);
static void primitiveLocalMicrosecondClock(void);
static void primitiveLogN(void);
EXPORT(void) primitiveLongRunningPrimitive(void);
EXPORT(void) primitiveLongRunningPrimitiveSemaphore(void);
static void primitiveLowSpaceSemaphore(void);
static void primitiveMakePoint(void);
static void primitiveMarkHandlerMethod(void);
static void primitiveMarkUnwindMethod(void);
static void primitiveMaxIdentityHash(void);
sqInt primitiveMethod(void);
static void primitiveMillisecondClock(void);
static void primitiveMod(void);
EXPORT(void) primitiveModLargeIntegers(void);
static void primitiveMouseButtons(void);
static void primitiveMousePoint(void);
static void primitiveMultiply(void);
EXPORT(void) primitiveMultiplyLargeIntegers(void);
static void primitiveNew(void);
static void primitiveNewMethod(void);
static void primitiveNewWithArg(void);
static void primitiveNextInstance(void);
static void primitiveNextObject(void);
static void primitiveNoAtCacheAt(void);
static void primitiveNoAtCacheAtPut(void);
static void primitiveNoAtCacheStringAt(void);
static void primitiveNoAtCacheStringAtPut(void);
static void primitiveNoop(void);
static void primitiveNotEqual(void);
EXPORT(void) primitiveNotEqualLargeIntegers(void);
static void primitiveObjectAt(void);
static void primitiveObjectAtPut(void);
static void primitiveObjectPointsTo(void);
static sqInt primitiveObjectperformwithArgumentslookedUpIn(sqInt actualReceiver, sqInt selector, sqInt argumentArray, sqInt lookupClass);
EXPORT(sqInt) primitiveOriginalMillisecondClock(void);
static void primitivePerform(void);
static void primitivePerformInSuperclass(void);
static void primitivePerformWithArgs(void);
EXPORT(sqInt) primitiveProfilePrimitive(void);
EXPORT(sqInt) primitiveProfileSample(void);
EXPORT(void) primitiveProfileSemaphore(void);
EXPORT(sqInt) primitiveProfileStart(void);
sqInt primitivePropertyFlags(sqInt primIndex);
static void primitiveQuit(void);
static void primitiveQuo(void);
EXPORT(void) primitiveQuoLargeIntegers(void);
static void primitiveRelinquishProcessor(void);
static void primitiveResume(void);
EXPORT(sqInt) primitiveRootTable(void);
EXPORT(sqInt) primitiveRootTableAt(void);
static void primitiveScanCharacters(void);
EXPORT(sqInt) primitiveScreenDepth(void);
static void primitiveScreenSize(void);
static void primitiveSecondsClock(void);
static void primitiveSetDisplayMode(void);
static void primitiveSetFullScreen(void);
EXPORT(sqInt) primitiveSetGCBiasToGrow(void);
EXPORT(sqInt) primitiveSetGCBiasToGrowGCLimit(void);
EXPORT(void) primitiveSetGCSemaphore(void);
static void primitiveSetIdentityHash(void);
static void primitiveSetInterruptKey(void);
EXPORT(sqInt) primitiveSetLogDirectory(void);
EXPORT(sqInt) primitiveSetWindowLabel(void);
EXPORT(sqInt) primitiveSetWindowSize(void);
static void primitiveShortAt(void);
static void primitiveShortAtPut(void);
static void primitiveShowDisplayRect(void);
static void primitiveSignal(void);
static void primitiveSignalAtBytesLeft(void);
static void primitiveSignalAtMilliseconds(void);
static void primitiveSignalAtUTCMicroseconds(void);
static void primitiveSine(void);
static void primitiveSize(void);
static void primitiveSnapshot(void);
static void primitiveSnapshotEmbedded(void);
static void primitiveSomeInstance(void);
static void primitiveSomeObject(void);
static void primitiveSpecialObjectsOop(void);
static void primitiveSquareRoot(void);
static void primitiveStoreImageSegment(void);
static void primitiveStoreStackp(void);
static void primitiveStringAt(void);
static void primitiveStringAtPut(void);
static void primitiveStringReplace(void);
static void primitiveSubtract(void);
EXPORT(void) primitiveSubtractLargeIntegers(void);
static void primitiveSuspend(void);
static void primitiveTerminateTo(void);
static void primitiveTestAndSetOwnershipOfCriticalSection(void);
static void primitiveTestDisplayDepth(void);
static void primitiveTimesTwoPower(void);
static void primitiveTruncated(void);
static void primitiveUnloadModule(void);
static void primitiveUpdateTimezone(void);
static void primitiveUTCMicrosecondClock(void);
static void primitiveVMParameter(void);
static void primitiveVMPath(void);
static void primitiveVMProfileSamplesInto(void);
EXPORT(void) primitiveVoidReceiver(void);
static void primitiveVoidVMState(void);
static void primitiveWait(void);
static void primitiveYield(void);
void * primTraceLogAddress(void);
usqInt primTraceLogIndexAddress(void);
static void printActivationNameForreceiverisBlockfirstTemporary(sqInt aMethod, sqInt anObject, sqInt isBlock, sqInt maybeMessage);
void printAllStacks(void);
void printCallStack(void);
static void printCallStackFP(char *theFP);
void printCallStackOfContext(sqInt aContext);
static void printCallStackOfcurrentFP(sqInt aContext, char *currFP);
void printChar(sqInt aByte);
void printCogMethod(CogMethod *cogMethod);
static sqInt printContextCallStackOf(sqInt aContext);
void printContext(sqInt aContext);
void printExternalHeadFrame(void);
static void printFrameAndCallersSP(char *theFP, char *theSP);
static void printFrameFlagsForFP(char *theFP);
static void printFrameMethodFor(char *theFP);
static void printFrameOopat(char *name, char *address);
static void printFrameOopindexat(char *name, sqInt idx, char *address);
void printFramesInPage(StackPage *thePage);
static void printFrameThingat(char *name, char *address);
static void printFrameThingatextra(char *name, char *address, sqInt extraValue);
void printFrame(char *theFP);
static void printFrameWithSP(char *theFP, char *theSP);
void printHex(sqInt n);
void printInstancesOf(sqInt aClassOop);
static void printLogEntryAt(sqInt i);
void printMemory(void);
void printMethodReferencesTo(sqInt anOop);
static void printNameOfClasscount(sqInt classOop, sqInt cnt);
static void printNum(sqInt n);
void printObjectsFromto(sqInt startAddress, sqInt endAddress);
static void printOopShort(sqInt oop);
void printOop(sqInt oop);
static void printProcessStack(sqInt aProcess);
static void printProcsOnList(sqInt procList);
void printReferencesTo(sqInt anOop);
void printStackPageList(void);
void printStackPageListInUse(void);
void printStackPages(void);
void printStackPagesInUse(void);
static void printStackPage(StackPage *page);
static void printStringOf(sqInt oop);
void print(char *s);
void pushBool(sqInt trueOrFalse);
static sqInt pushedReceiverOrClosureOfFrame(char *theFP);
void pushFloat(double f);
sqInt pushInteger(sqInt integerValue);
void pushRemappableOop(sqInt oop);
void push(sqInt object);
static void putLongtoFile(sqInt aWord, sqImageFile  aFile);
static void putShorttoFile(sqInt aShort, sqImageFile  aFile);
static void putToSleepyieldingIf(sqInt aProcess, sqInt yieldImplicitly);
static sqInt quickFetchIntegerofObject(sqInt fieldIndex, sqInt objectPointer);
sqInt quickPrimitiveConstantFor(sqInt aQuickPrimitiveIndex);
int (*quickPrimitiveGeneratorFor(sqInt aQuickPrimitiveIndex))(void) ;
sqInt quickPrimitiveInstVarIndexFor(sqInt primIndex);
sqInt rawHeaderOf(sqInt methodPointer);
void rawHeaderOfput(sqInt methodOop, void *cogMethod);
sqInt readableFormat(sqInt imageVersion);
sqInt readImageFromFileHeapSizeStartingAt(sqImageFile  f, usqInt desiredHeapSize, squeakFileOffsetType  imageOffset);
EXPORT(sqInt) reestablishContextPriorToCallback(sqInt callbackContext);
sqInt remap(sqInt oop);
static sqInt removeFirstLinkOfList(sqInt aList);
EXPORT(sqInt) removeGCRoot(sqInt *varLoc);
static void restoreHeadersFromtofromandtofrom(sqInt firstIn, sqInt lastIn, sqInt hdrBaseIn, sqInt firstOut, sqInt lastOut, sqInt hdrBaseOut);
static sqInt resumepreemptedYieldingIffrom(sqInt aProcess, sqInt yieldImplicitly, sqInt sourceCode);
EXPORT(sqInt) returnAsThroughCallbackContext(sqInt returnTypeOop, VMCallbackContext *vmCallbackContext, sqInt callbackMethodContext);
static sqInt returnToExecutivepostContextSwitch(sqInt inInterpreter, sqInt switchedContext);
static sqInt returntoExecutive(sqInt returnValue, sqInt inInterpreter);
static void reverseDisplayFromto(sqInt startIndex, sqInt endIndex);
static void rewriteMethodCacheEntryForExternalPrimitiveToFunction(void (*localPrimAddress)(void));
static sqInt roomToPushNArgs(sqInt n);
static void runLeakCheckerForFullGC(sqInt fullGCFlag);
static sqInt safeObjectAfter(sqInt oop);
static sqInt safePrintStringOf(sqInt oop);
usqInt scavengeThresholdAddress(void);
void scheduleIncrementalGC(void);
EXPORT(sqInt) sendInvokeCallbackContext(VMCallbackContext *vmCallbackContext);
EXPORT(sqInt) sendInvokeCallbackStackRegistersJmpbuf(sqInt thunkPtr, sqInt stackPtr, sqInt regsPtr, sqInt jmpBufPtr);
void setBreakSelector(char *aString);
void setFullScreenFlag(sqInt value);
EXPORT(void (*setInterruptCheckChain(void (*aFunction)(void)))()) ;
void setInterruptKeycode(sqInt value);
void setInterruptPending(sqInt value);
void setNextWakeupUsecs(usqLong value);
void setSavedWindowSize(sqInt value);
static void setSignalLowSpaceFlagAndSaveProcess(void);
static void shortPrintContext(sqInt aContext);
static void shortPrintFrameAndCallers(char *theFP);
static void shortPrintFrame(char *theFP);
static void shortPrintOop(sqInt oop);
static sqInt shortReversePrintFrameAndCallers(char *aFramePointer);
void showDisplayBitsLeftTopRightBottom(sqInt aForm, sqInt l, sqInt t, sqInt r, sqInt b);
static sqInt signalExternalSemaphores(void);
sqInt signed32BitIntegerFor(sqInt integerValue);
int signed32BitValueOf(sqInt oop);
sqInt signed64BitIntegerFor(sqLong integerValue);
sqLong signed64BitValueOf(sqInt oop);
long signedMachineIntegerValueOf(sqInt oop);
static sqInt sizeBitsOfSafe(sqInt oop);
static sqInt sizeBitsOf(sqInt oop);
usqInt sizeOfAlienData(sqInt oop);
static sqInt sizeOfFree(sqInt oop);
sqInt sizeOfSTArrayFromCPrimitive(void *cPtr);
sqInt slotSizeOf(sqInt oop);
static sqInt slowPrimitiveResponse(void);
static void snapshot(sqInt embedded);
static void space(void);
sqInt specialSelectorNumArgs(sqInt index);
sqInt specialSelector(sqInt index);
sqInt splObj(sqInt index);
double stackFloatValue(sqInt offset);
sqInt stackIntegerValue(sqInt offset);
usqInt stackLimitAddress(void);
static sqInt stackLimitOffset(void);
sqInt stackObjectValue(sqInt offset);
static StackPage * stackPageAt(sqInt index);
static sqInt stackPageByteSize(void);
static StackPage * stackPageFor(void *pointer);
usqInt stackPointerAddress(void);
static sqInt stackPointerIndexForFrame(char *theFP);
sqInt stackPositiveMachineIntegerValue(sqInt offset);
sqInt stackSignedMachineIntegerValue(sqInt offset);
sqInt stackTop(void);
sqInt stackValue(sqInt offset);
void * startOfAlienData(sqInt oop);
sqInt startOfMemory(void);
sqInt startPCOfMethodHeader(sqInt aCompiledMethodHeader);
sqInt startPCOfMethod(sqInt aCompiledMethod);
sqInt stObjectat(sqInt array, sqInt index);
void stObjectatput(sqInt array, sqInt index, sqInt value);
static sqInt storeImageSegmentIntooutPointersroots(sqInt segmentWordArray, sqInt outPointerArray, sqInt arrayOfRoots);
sqInt storeIntegerofObjectwithValue(sqInt fieldIndex, sqInt objectPointer, sqInt integerValue);
sqInt storePointerUncheckedofObjectwithValue(sqInt fieldIndex, sqInt oop, sqInt valuePointer);
sqInt storePointerofObjectwithValue(sqInt fieldIndex, sqInt oop, sqInt valuePointer);
static char * storeSenderOfFramewithValue(char *theFP, sqInt anOop);
sqInt stringForCString(const char *aCString);
sqInt stSizeOf(sqInt oop);
sqInt success(sqInt successBoolean);
static sqInt sufficientSpaceAfterGC(sqInt minFree);
static sqInt sufficientSpaceToAllocate(sqInt bytes);
sqInt superclassOf(sqInt classPointer);
static sqInt sweepPhase(void);
static sqInt sweepPhaseForFullGC(void);
static sqInt synchronousSignal(sqInt aSemaphore);
static void tearDownAndRebuildFrameForCannotReturnBaseFrameReturnFromtoreturnValue(sqInt contextToReturnFrom, sqInt contextToReturnTo, sqInt returnValue);
sqInt tempCountOfMethodHeader(sqInt header);
sqInt tempCountOf(sqInt methodPointer);
void tenuringIncrementalGC(void);
sqInt topRemappableOop(void);
static void transferTofrom(sqInt newProc, sqInt sourceCode);
sqInt trueObject(void);
static void updatePointersInRangeFromto(sqInt memStart, sqInt memEnd);
static void updatePointersInRootObjectsFromto(sqInt memStart, sqInt memEnd);
void updateStackZoneReferencesToCompiledCodePreCompaction(void);
static void updateStateOfSpouseContextForFrameWithSP(char *theFP, char *theSP);
static sqInt validInstructionPointerinFrame(usqInt anInstrPointer, char *fp);
sqInt validInstructionPointerinMethodframePointer(usqInt anInstrPointer, usqInt aMethod, char *fp);
static sqInt validStackPageBaseFrames(void);
static void verifyCleanHeaders(void);
sqInt vmEndianness(void);
static void voidLongRunningPrimitive(char *reason);
static sqInt wakeHighestPriority(void);
static sqInt withSmallIntegerTags(char *value);
static sqInt wordSwapped(sqInt w);
static void writeImageFileIO(sqInt imageBytes);
static void writeImageFile(sqInt imageBytes);
usqInt youngStartAddress(void);

/*** Variables ***/
#if SQ_USE_GLOBAL_STRUCT
# define _iss /* define in-struct static as void */
static struct foo {
#else
# define _iss static
#endif
_iss char * stackPointer;
_iss sqInt primFailCode;
_iss char * framePointer;
_iss sqInt specialObjectsOop;
_iss StackPage * stackPage;
_iss sqInt nilObj;
_iss usqInt instructionPointer;
_iss usqInt method;
_iss usqInt freeStart;
_iss sqInt argumentCount;
_iss usqInt newMethod;
_iss StackPage * pages;
_iss sqInt messageSelector;
_iss usqInt youngStart;
_iss char * stackBasePlus1;
_iss usqInt endOfMemory;
_iss sqInt rootTableCount;
_iss sqInt trueObj;
_iss sqInt falseObj;
_iss sqInt lkupClass;
_iss sqInt remapBufferCount;
_iss sqInt bytesPerPage;
_iss sqInt traceLogIndex;
_iss char * stackLimit;
_iss usqInt reserveStart;
_iss usqInt memoryLimit;
_iss StackPage * mostRecentlyUsedPage;
_iss sqInt needGCFlag;
_iss usqInt scavengeThreshold;
_iss sqLong nextProfileTick;
_iss sqInt numStackPages;
_iss unsigned char primTraceLogIndex;
_iss sqInt jmpDepth;
_iss usqInt fwdTableNext;
_iss sqInt longRunningPrimitiveCheckSemaphore;
_iss usqInt compStart;
_iss sqInt profileSemaphore;
_iss sqInt growHeadroom;
_iss sqInt profileProcess;
_iss sqInt extraRootCount;
_iss sqInt tempOop;
_iss sqInt weakRootCount;
_iss usqLong nextWakeupUsecs;
_iss sqInt preemptionYields;
_iss sqInt profileMethod;
_iss sqInt cogCompiledCodeCompactionCalledFor;
_iss sqInt highestRunnableProcessPriority;
_iss sqInt longRunningPrimitiveCheckMethod;
_iss usqLong longRunningPrimitiveStartUsecs;
_iss usqLong longRunningPrimitiveStopUsecs;
_iss sqInt statCheckForEvents;
_iss sqInt statGrowMemory;
_iss sqInt statMarkCount;
_iss sqInt classNameIndex;
_iss sqInt lastCoggableInterpretedBlockMethod;
_iss sqInt lastMethodCacheProbeWrite;
_iss sqInt lastUncoggableInterpretedBlockMethod;
_iss sqInt lowSpaceThreshold;
_iss usqLong statGCEndUsecs;
_iss sqInt statSweepCount;
_iss usqInt compEnd;
_iss sqInt flagInterpretedMethods;
_iss sqInt metaclassSizeBytes;
_iss sqInt pendingFinalizationSignals;
_iss sqInt shrinkThreshold;
_iss sqInt statShrinkMemory;
_iss sqInt cogCodeSize;
_iss usqInt fwdTableLast;
_iss usqLong gcStartUsecs;
_iss sqInt inFullGC;
_iss sqInt noThreadingOfGUIThread;
_iss sqInt processHasThreadId;
_iss sqInt statCompMoveCount;
_iss sqInt statMkFwdCount;
_iss sqInt tenuringThreshold;
_iss sqInt thisClassIndex;
_iss sqInt edenBytes;
_iss sqInt forceTenureFlag;
_iss sqInt interruptPending;
_iss sqInt longRunningPrimitiveCheckSequenceNumber;
_iss sqInt signalLowSpace;
_iss sqInt statForceInterruptCheck;
_iss usqLong statFullGCUsecs;
_iss sqInt statFullGCs;
_iss sqInt statIOProcessEvents;
_iss usqLong statIncrGCUsecs;
_iss sqInt statIncrGCs;
_iss sqInt statPendingFinalizationSignals;
_iss sqInt statProcessSwitch;
_iss sqInt statRootTableOverflows;
_iss sqInt statSpecialMarkCount;
_iss sqInt statStackOverflow;
_iss sqInt statStackPageDivorce;
_iss sqInt statTenures;
_iss sqInt totalObjectCount;
_iss sqInt cogMethodZone;
_iss sqInt externalPrimitiveTableFirstFreeIndex;
_iss sqInt extraFramesToMoveOnOverflow;
_iss sqInt fullScreenFlag;
_iss usqInt gcBiasToGrowThreshold;
_iss sqInt globalSessionID;
_iss sqInt interruptKeycode;
_iss sqInt maxExtSemTabSizeSet;
_iss usqLong statIGCDeltaUsecs;
_iss sqInt classByteArrayCompactIndex;
_iss sqInt deferSmash;
_iss sqInt deferredSmash;
_iss sqInt gcBiasToGrow;
_iss sqInt gcBiasToGrowGCLimit;
_iss sqInt gcSemaphoreIndex;
_iss sqInt imageFloatsBigEndian;
_iss sqInt longRunningPrimitiveSignalUndelivered;
_iss usqLong nextPollUsecs;
_iss StackPage * overflowedPage;
_iss sqInt savedWindowSize;
_iss sqInt statCodeCompactionCount;
_iss usqLong statCodeCompactionUsecs;
_iss sqInt statRootTableCount;
_iss sqInt statSurvivorCount;
_iss sqInt fullGCLock;
_iss sqInt imageHeaderFlags;
_iss sqInt linkSends;
_iss usqLong longRunningPrimitiveGCUsecs;
_iss sqInt overflowLimit;
_iss long methodCache[MethodCacheSize + 1 /* 4097 */];
_iss sqInt traceLog[TraceBufferSize /* 768 */];
_iss sqInt remapBuffer[RemapBufferSize + 1 /* 26 */];
_iss sqInt atCache[AtCacheTotalSize + 1 /* 65 */];
_iss sqInt rootTable[RootTableSize + 1 /* 2501 */];
_iss sqInt primTraceLog[256];
_iss sqInt* extraRoots[ExtraRootSize + 1 /* 2049 */];
_iss usqInt suspendedCallbacks[MaxJumpBuf + 1 /* 33 */];
_iss usqInt suspendedMethods[MaxJumpBuf + 1 /* 33 */];
_iss sqInt weakRoots[WeakRootTableSize + 1 /* 2626 */];
_iss jmp_buf jmpBuf[MaxJumpBuf + 1 /* 33 */];
_iss unsigned long byteCount;
_iss sqInt interruptCheckCounter;
_iss char * stackMemory;
_iss sqInt theUnknownShort;
#undef _iss
#if SQ_USE_GLOBAL_STRUCT
 } fum;
# define DECL_MAYBE_SQ_GLOBAL_STRUCT register struct foo * foo = &fum;
# define DECL_MAYBE_VOLATILE_SQ_GLOBAL_STRUCT volatile register struct foo * foo = &fum;
# define GIV(interpreterInstVar) (foo->interpreterInstVar)
#else
# define DECL_MAYBE_SQ_GLOBAL_STRUCT /* oh, no mr bill! */
# define DECL_MAYBE_VOLATILE_SQ_GLOBAL_STRUCT /* oh no, mr bill! */
# define GIV(interpreterInstVar) interpreterInstVar
#endif
#if SQ_USE_GLOBAL_STRUCT
static struct foo * foo = &fum;
#endif
static usqInt heapBase;
static void (*primitiveFunctionPointer)();
jmp_buf reenterInterpreter; /* private export */;
sqInt maxLiteralCountForCompile = MaxLiteralCountForCompile /* 60 */;
sqInt inIOProcessEvents;
sqInt checkForLeaks;
sqInt desiredEdenBytes;
sqInt desiredNumStackPages;
sqInt extraVMMemory;
sqInt desiredCogCodeSize;
sqInt breakSelectorLength = -1;
sqInt deferDisplayUpdates;
static usqInt memory;
void * showSurfaceFn;
char * breakSelector;
struct VirtualMachine* interpreterProxy;
static void (*interruptCheckChain)(void) = 0;
sqInt suppressHeartbeatFlag;
static const sqInt headerTypeBytes[] = {
8, 4, 0, 0};
static void (*primitiveTable[MaxPrimitiveIndex + 2 /* 577 */])(void) = {
	/* 0 */ (void (*)(void))0,
	/* 1 */ primitiveAdd,
	/* 2 */ primitiveSubtract,
	/* 3 */ primitiveLessThan,
	/* 4 */ primitiveGreaterThan,
	/* 5 */ primitiveLessOrEqual,
	/* 6 */ primitiveGreaterOrEqual,
	/* 7 */ primitiveEqual,
	/* 8 */ primitiveNotEqual,
	/* 9 */ primitiveMultiply,
	/* 10 */ primitiveDivide,
	/* 11 */ primitiveMod,
	/* 12 */ primitiveDiv,
	/* 13 */ primitiveQuo,
	/* 14 */ primitiveBitAnd,
	/* 15 */ primitiveBitOr,
	/* 16 */ primitiveBitXor,
	/* 17 */ primitiveBitShift,
	/* 18 */ primitiveMakePoint,
	/* 19 */ (void (*)(void))0,
	/* 20 */ (void (*)(void))0,
	/* 21 */ primitiveAddLargeIntegers,
	/* 22 */ primitiveSubtractLargeIntegers,
	/* 23 */ primitiveLessThanLargeIntegers,
	/* 24 */ primitiveGreaterThanLargeIntegers,
	/* 25 */ primitiveLessOrEqualLargeIntegers,
	/* 26 */ primitiveGreaterOrEqualLargeIntegers,
	/* 27 */ primitiveEqualLargeIntegers,
	/* 28 */ primitiveNotEqualLargeIntegers,
	/* 29 */ primitiveMultiplyLargeIntegers,
	/* 30 */ primitiveDivideLargeIntegers,
	/* 31 */ primitiveModLargeIntegers,
	/* 32 */ primitiveDivLargeIntegers,
	/* 33 */ primitiveQuoLargeIntegers,
	/* 34 */ primitiveBitAndLargeIntegers,
	/* 35 */ primitiveBitOrLargeIntegers,
	/* 36 */ primitiveBitXorLargeIntegers,
	/* 37 */ primitiveBitShiftLargeIntegers,
	/* 38 */ primitiveFloatAt,
	/* 39 */ primitiveFloatAtPut,
	/* 40 */ primitiveAsFloat,
	/* 41 */ primitiveFloatAdd,
	/* 42 */ primitiveFloatSubtract,
	/* 43 */ primitiveFloatLessThan,
	/* 44 */ primitiveFloatGreaterThan,
	/* 45 */ primitiveFloatLessOrEqual,
	/* 46 */ primitiveFloatGreaterOrEqual,
	/* 47 */ primitiveFloatEqual,
	/* 48 */ primitiveFloatNotEqual,
	/* 49 */ primitiveFloatMultiply,
	/* 50 */ primitiveFloatDivide,
	/* 51 */ primitiveTruncated,
	/* 52 */ primitiveFractionalPart,
	/* 53 */ primitiveExponent,
	/* 54 */ primitiveTimesTwoPower,
	/* 55 */ primitiveSquareRoot,
	/* 56 */ primitiveSine,
	/* 57 */ primitiveArctan,
	/* 58 */ primitiveLogN,
	/* 59 */ primitiveExp,
	/* 60 */ primitiveAt,
	/* 61 */ primitiveAtPut,
	/* 62 */ primitiveSize,
	/* 63 */ primitiveStringAt,
	/* 64 */ primitiveStringAtPut,
	/* 65 */ (void (*)(void))0,
	/* 66 */ (void (*)(void))0,
	/* 67 */ (void (*)(void))0,
	/* 68 */ primitiveObjectAt,
	/* 69 */ primitiveObjectAtPut,
	/* 70 */ primitiveNew,
	/* 71 */ primitiveNewWithArg,
	/* 72 */ primitiveArrayBecomeOneWay,
	/* 73 */ primitiveInstVarAt,
	/* 74 */ primitiveInstVarAtPut,
	/* 75 */ primitiveIdentityHash,
	/* 76 */ primitiveStoreStackp,
	/* 77 */ primitiveSomeInstance,
	/* 78 */ primitiveNextInstance,
	/* 79 */ primitiveNewMethod,
	/* 80 */ (void (*)(void))0,
	/* 81 */ (void (*)(void))0,
	/* 82 */ (void (*)(void))0,
	/* 83 */ primitivePerform,
	/* 84 */ primitivePerformWithArgs,
	/* 85 */ primitiveSignal,
	/* 86 */ primitiveWait,
	/* 87 */ primitiveResume,
	/* 88 */ primitiveSuspend,
	/* 89 */ primitiveFlushCache,
	/* 90 */ primitiveMousePoint,
	/* 91 */ primitiveTestDisplayDepth,
	/* 92 */ primitiveSetDisplayMode,
	/* 93 */ primitiveInputSemaphore,
	/* 94 */ primitiveGetNextEvent,
	/* 95 */ primitiveInputWord,
	/* 96 */ (void (*)(void))0,
	/* 97 */ primitiveSnapshot,
	/* 98 */ primitiveStoreImageSegment,
	/* 99 */ primitiveLoadImageSegment,
	/* 100 */ primitivePerformInSuperclass,
	/* 101 */ primitiveBeCursor,
	/* 102 */ primitiveBeDisplay,
	/* 103 */ primitiveScanCharacters,
	/* 104 */ (void (*)(void))0,
	/* 105 */ primitiveStringReplace,
	/* 106 */ primitiveScreenSize,
	/* 107 */ primitiveMouseButtons,
	/* 108 */ primitiveKbdNext,
	/* 109 */ primitiveKbdPeek,
	/* 110 */ primitiveIdentical,
	/* 111 */ primitiveClass,
	/* 112 */ primitiveBytesLeft,
	/* 113 */ primitiveQuit,
	/* 114 */ primitiveExitToDebugger,
	/* 115 */ primitiveChangeClass,
	/* 116 */ primitiveFlushCacheByMethod,
	/* 117 */ primitiveExternalCall,
	/* 118 */ primitiveDoPrimitiveWithArgs,
	/* 119 */ primitiveFlushCacheBySelector,
	/* 120 */ primitiveCalloutToFFI,
	/* 121 */ primitiveImageName,
	/* 122 */ primitiveNoop,
	/* 123 */ (void (*)(void))0,
	/* 124 */ primitiveLowSpaceSemaphore,
	/* 125 */ primitiveSignalAtBytesLeft,
	/* 126 */ primitiveDeferDisplayUpdates,
	/* 127 */ primitiveShowDisplayRect,
	/* 128 */ primitiveArrayBecome,
	/* 129 */ primitiveSpecialObjectsOop,
	/* 130 */ primitiveFullGC,
	/* 131 */ primitiveIncrementalGC,
	/* 132 */ primitiveObjectPointsTo,
	/* 133 */ primitiveSetInterruptKey,
	/* 134 */ primitiveInterruptSemaphore,
	/* 135 */ primitiveMillisecondClock,
	/* 136 */ primitiveSignalAtMilliseconds,
	/* 137 */ primitiveSecondsClock,
	/* 138 */ primitiveSomeObject,
	/* 139 */ primitiveNextObject,
	/* 140 */ primitiveBeep,
	/* 141 */ primitiveClipboardText,
	/* 142 */ primitiveVMPath,
	/* 143 */ primitiveShortAt,
	/* 144 */ primitiveShortAtPut,
	/* 145 */ primitiveConstantFill,
	/* 146 */ (void (*)(void))0,
	/* 147 */ (void (*)(void))0,
	/* 148 */ primitiveClone,
	/* 149 */ primitiveGetAttribute,
	/* 150 */ (void (*)(void))0,
	/* 151 */ (void (*)(void))0,
	/* 152 */ (void (*)(void))0,
	/* 153 */ (void (*)(void))0,
	/* 154 */ (void (*)(void))0,
	/* 155 */ (void (*)(void))0,
	/* 156 */ (void (*)(void))0,
	/* 157 */ (void (*)(void))0,
	/* 158 */ (void (*)(void))0,
	/* 159 */ (void (*)(void))0,
	/* 160 */ primitiveAdoptInstance,
	/* 161 */ primitiveSetIdentityHash,
	/* 162 */ (void (*)(void))0,
	/* 163 */ (void (*)(void))0,
	/* 164 */ (void (*)(void))0,
	/* 165 */ primitiveIntegerAt,
	/* 166 */ primitiveIntegerAtPut,
	/* 167 */ primitiveYield,
	/* 168 */ primitiveCopyObject,
	/* 169 */ (void (*)(void))0,
	/* 170 */ (void (*)(void))0,
	/* 171 */ (void (*)(void))0,
	/* 172 */ (void (*)(void))0,
	/* 173 */ (void (*)(void))0,
	/* 174 */ (void (*)(void))0,
	/* 175 */ primitiveBehaviorHash,
	/* 176 */ primitiveMaxIdentityHash,
	/* 177 */ (void (*)(void))0,
	/* 178 */ (void (*)(void))0,
	/* 179 */ (void (*)(void))0,
	/* 180 */ (void (*)(void))0,
	/* 181 */ (void (*)(void))0,
	/* 182 */ (void (*)(void))0,
	/* 183 */ (void (*)(void))0,
	/* 184 */ (void (*)(void))0,
	/* 185 */ primitiveExitCriticalSection,
	/* 186 */ primitiveEnterCriticalSection,
	/* 187 */ primitiveTestAndSetOwnershipOfCriticalSection,
	/* 188 */ primitiveExecuteMethodArgsArray,
	/* 189 */ primitiveExecuteMethod,
	/* 190 */ (void (*)(void))0,
	/* 191 */ (void (*)(void))0,
	/* 192 */ (void (*)(void))0,
	/* 193 */ (void (*)(void))0,
	/* 194 */ (void (*)(void))0,
	/* 195 */ primitiveFindNextUnwindContext,
	/* 196 */ primitiveTerminateTo,
	/* 197 */ primitiveFindHandlerContext,
	/* 198 */ primitiveMarkUnwindMethod,
	/* 199 */ primitiveMarkHandlerMethod,
	/* 200 */ primitiveClosureCopyWithCopiedValues,
	/* 201 */ primitiveClosureValue,
	/* 202 */ primitiveClosureValue,
	/* 203 */ primitiveClosureValue,
	/* 204 */ primitiveClosureValue,
	/* 205 */ primitiveClosureValue,
	/* 206 */ primitiveClosureValueWithArgs,
	/* 207 */ (void (*)(void))0,
	/* 208 */ (void (*)(void))0,
	/* 209 */ (void (*)(void))0,
	/* 210 */ primitiveContextAt,
	/* 211 */ primitiveContextAtPut,
	/* 212 */ primitiveContextSize,
	/* 213 */ primitiveContextXray,
	/* 214 */ primitiveVoidVMState,
	/* 215 */ (void (*)(void))0,
	/* 216 */ (void (*)(void))0,
	/* 217 */ (void (*)(void))0,
	/* 218 */ primitiveDoNamedPrimitiveWithArgs,
	/* 219 */ (void (*)(void))0,
	/* 220 */ (void (*)(void))0,
	/* 221 */ primitiveClosureValueNoContextSwitch,
	/* 222 */ primitiveClosureValueNoContextSwitch,
	/* 223 */ (void (*)(void))0,
	/* 224 */ (void (*)(void))0,
	/* 225 */ (void (*)(void))0,
	/* 226 */ (void (*)(void))0,
	/* 227 */ (void (*)(void))0,
	/* 228 */ (void (*)(void))0,
	/* 229 */ (void (*)(void))0,
	/* 230 */ primitiveRelinquishProcessor,
	/* 231 */ primitiveForceDisplayUpdate,
	/* 232 */ primitiveFormPrint,
	/* 233 */ primitiveSetFullScreen,
	/* 234 */ (void (*)(void))0,
	/* 235 */ (void (*)(void))0,
	/* 236 */ (void (*)(void))0,
	/* 237 */ (void (*)(void))0,
	/* 238 */ (void (*)(void))0,
	/* 239 */ (void (*)(void))0,
	/* 240 */ primitiveUTCMicrosecondClock,
	/* 241 */ primitiveLocalMicrosecondClock,
	/* 242 */ primitiveSignalAtUTCMicroseconds,
	/* 243 */ primitiveUpdateTimezone,
	/* 244 */ (void (*)(void))0,
	/* 245 */ (void (*)(void))0,
	/* 246 */ (void (*)(void))0,
	/* 247 */ primitiveSnapshotEmbedded,
	/* 248 */ (void (*)(void))0,
	/* 249 */ primitiveArrayBecomeOneWayCopyHash,
	/* 250 */ primitiveClearVMProfile,
	/* 251 */ primitiveControlVMProfiling,
	/* 252 */ primitiveVMProfileSamplesInto,
	/* 253 */ primitiveCollectCogCodeConstituents,
	/* 254 */ primitiveVMParameter,
	/* 255 */ (void (*)(void))0,
	/* 256 */ (void (*)(void))256,
	/* 257 */ (void (*)(void))257,
	/* 258 */ (void (*)(void))258,
	/* 259 */ (void (*)(void))259,
	/* 260 */ (void (*)(void))260,
	/* 261 */ (void (*)(void))261,
	/* 262 */ (void (*)(void))262,
	/* 263 */ (void (*)(void))263,
	/* 264 */ (void (*)(void))264,
	/* 265 */ (void (*)(void))265,
	/* 266 */ (void (*)(void))266,
	/* 267 */ (void (*)(void))267,
	/* 268 */ (void (*)(void))268,
	/* 269 */ (void (*)(void))269,
	/* 270 */ (void (*)(void))270,
	/* 271 */ (void (*)(void))271,
	/* 272 */ (void (*)(void))272,
	/* 273 */ (void (*)(void))273,
	/* 274 */ (void (*)(void))274,
	/* 275 */ (void (*)(void))275,
	/* 276 */ (void (*)(void))276,
	/* 277 */ (void (*)(void))277,
	/* 278 */ (void (*)(void))278,
	/* 279 */ (void (*)(void))279,
	/* 280 */ (void (*)(void))280,
	/* 281 */ (void (*)(void))281,
	/* 282 */ (void (*)(void))282,
	/* 283 */ (void (*)(void))283,
	/* 284 */ (void (*)(void))284,
	/* 285 */ (void (*)(void))285,
	/* 286 */ (void (*)(void))286,
	/* 287 */ (void (*)(void))287,
	/* 288 */ (void (*)(void))288,
	/* 289 */ (void (*)(void))289,
	/* 290 */ (void (*)(void))290,
	/* 291 */ (void (*)(void))291,
	/* 292 */ (void (*)(void))292,
	/* 293 */ (void (*)(void))293,
	/* 294 */ (void (*)(void))294,
	/* 295 */ (void (*)(void))295,
	/* 296 */ (void (*)(void))296,
	/* 297 */ (void (*)(void))297,
	/* 298 */ (void (*)(void))298,
	/* 299 */ (void (*)(void))299,
	/* 300 */ (void (*)(void))300,
	/* 301 */ (void (*)(void))301,
	/* 302 */ (void (*)(void))302,
	/* 303 */ (void (*)(void))303,
	/* 304 */ (void (*)(void))304,
	/* 305 */ (void (*)(void))305,
	/* 306 */ (void (*)(void))306,
	/* 307 */ (void (*)(void))307,
	/* 308 */ (void (*)(void))308,
	/* 309 */ (void (*)(void))309,
	/* 310 */ (void (*)(void))310,
	/* 311 */ (void (*)(void))311,
	/* 312 */ (void (*)(void))312,
	/* 313 */ (void (*)(void))313,
	/* 314 */ (void (*)(void))314,
	/* 315 */ (void (*)(void))315,
	/* 316 */ (void (*)(void))316,
	/* 317 */ (void (*)(void))317,
	/* 318 */ (void (*)(void))318,
	/* 319 */ (void (*)(void))319,
	/* 320 */ (void (*)(void))320,
	/* 321 */ (void (*)(void))321,
	/* 322 */ (void (*)(void))322,
	/* 323 */ (void (*)(void))323,
	/* 324 */ (void (*)(void))324,
	/* 325 */ (void (*)(void))325,
	/* 326 */ (void (*)(void))326,
	/* 327 */ (void (*)(void))327,
	/* 328 */ (void (*)(void))328,
	/* 329 */ (void (*)(void))329,
	/* 330 */ (void (*)(void))330,
	/* 331 */ (void (*)(void))331,
	/* 332 */ (void (*)(void))332,
	/* 333 */ (void (*)(void))333,
	/* 334 */ (void (*)(void))334,
	/* 335 */ (void (*)(void))335,
	/* 336 */ (void (*)(void))336,
	/* 337 */ (void (*)(void))337,
	/* 338 */ (void (*)(void))338,
	/* 339 */ (void (*)(void))339,
	/* 340 */ (void (*)(void))340,
	/* 341 */ (void (*)(void))341,
	/* 342 */ (void (*)(void))342,
	/* 343 */ (void (*)(void))343,
	/* 344 */ (void (*)(void))344,
	/* 345 */ (void (*)(void))345,
	/* 346 */ (void (*)(void))346,
	/* 347 */ (void (*)(void))347,
	/* 348 */ (void (*)(void))348,
	/* 349 */ (void (*)(void))349,
	/* 350 */ (void (*)(void))350,
	/* 351 */ (void (*)(void))351,
	/* 352 */ (void (*)(void))352,
	/* 353 */ (void (*)(void))353,
	/* 354 */ (void (*)(void))354,
	/* 355 */ (void (*)(void))355,
	/* 356 */ (void (*)(void))356,
	/* 357 */ (void (*)(void))357,
	/* 358 */ (void (*)(void))358,
	/* 359 */ (void (*)(void))359,
	/* 360 */ (void (*)(void))360,
	/* 361 */ (void (*)(void))361,
	/* 362 */ (void (*)(void))362,
	/* 363 */ (void (*)(void))363,
	/* 364 */ (void (*)(void))364,
	/* 365 */ (void (*)(void))365,
	/* 366 */ (void (*)(void))366,
	/* 367 */ (void (*)(void))367,
	/* 368 */ (void (*)(void))368,
	/* 369 */ (void (*)(void))369,
	/* 370 */ (void (*)(void))370,
	/* 371 */ (void (*)(void))371,
	/* 372 */ (void (*)(void))372,
	/* 373 */ (void (*)(void))373,
	/* 374 */ (void (*)(void))374,
	/* 375 */ (void (*)(void))375,
	/* 376 */ (void (*)(void))376,
	/* 377 */ (void (*)(void))377,
	/* 378 */ (void (*)(void))378,
	/* 379 */ (void (*)(void))379,
	/* 380 */ (void (*)(void))380,
	/* 381 */ (void (*)(void))381,
	/* 382 */ (void (*)(void))382,
	/* 383 */ (void (*)(void))383,
	/* 384 */ (void (*)(void))384,
	/* 385 */ (void (*)(void))385,
	/* 386 */ (void (*)(void))386,
	/* 387 */ (void (*)(void))387,
	/* 388 */ (void (*)(void))388,
	/* 389 */ (void (*)(void))389,
	/* 390 */ (void (*)(void))390,
	/* 391 */ (void (*)(void))391,
	/* 392 */ (void (*)(void))392,
	/* 393 */ (void (*)(void))393,
	/* 394 */ (void (*)(void))394,
	/* 395 */ (void (*)(void))395,
	/* 396 */ (void (*)(void))396,
	/* 397 */ (void (*)(void))397,
	/* 398 */ (void (*)(void))398,
	/* 399 */ (void (*)(void))399,
	/* 400 */ (void (*)(void))400,
	/* 401 */ (void (*)(void))401,
	/* 402 */ (void (*)(void))402,
	/* 403 */ (void (*)(void))403,
	/* 404 */ (void (*)(void))404,
	/* 405 */ (void (*)(void))405,
	/* 406 */ (void (*)(void))406,
	/* 407 */ (void (*)(void))407,
	/* 408 */ (void (*)(void))408,
	/* 409 */ (void (*)(void))409,
	/* 410 */ (void (*)(void))410,
	/* 411 */ (void (*)(void))411,
	/* 412 */ (void (*)(void))412,
	/* 413 */ (void (*)(void))413,
	/* 414 */ (void (*)(void))414,
	/* 415 */ (void (*)(void))415,
	/* 416 */ (void (*)(void))416,
	/* 417 */ (void (*)(void))417,
	/* 418 */ (void (*)(void))418,
	/* 419 */ (void (*)(void))419,
	/* 420 */ (void (*)(void))420,
	/* 421 */ (void (*)(void))421,
	/* 422 */ (void (*)(void))422,
	/* 423 */ (void (*)(void))423,
	/* 424 */ (void (*)(void))424,
	/* 425 */ (void (*)(void))425,
	/* 426 */ (void (*)(void))426,
	/* 427 */ (void (*)(void))427,
	/* 428 */ (void (*)(void))428,
	/* 429 */ (void (*)(void))429,
	/* 430 */ (void (*)(void))430,
	/* 431 */ (void (*)(void))431,
	/* 432 */ (void (*)(void))432,
	/* 433 */ (void (*)(void))433,
	/* 434 */ (void (*)(void))434,
	/* 435 */ (void (*)(void))435,
	/* 436 */ (void (*)(void))436,
	/* 437 */ (void (*)(void))437,
	/* 438 */ (void (*)(void))438,
	/* 439 */ (void (*)(void))439,
	/* 440 */ (void (*)(void))440,
	/* 441 */ (void (*)(void))441,
	/* 442 */ (void (*)(void))442,
	/* 443 */ (void (*)(void))443,
	/* 444 */ (void (*)(void))444,
	/* 445 */ (void (*)(void))445,
	/* 446 */ (void (*)(void))446,
	/* 447 */ (void (*)(void))447,
	/* 448 */ (void (*)(void))448,
	/* 449 */ (void (*)(void))449,
	/* 450 */ (void (*)(void))450,
	/* 451 */ (void (*)(void))451,
	/* 452 */ (void (*)(void))452,
	/* 453 */ (void (*)(void))453,
	/* 454 */ (void (*)(void))454,
	/* 455 */ (void (*)(void))455,
	/* 456 */ (void (*)(void))456,
	/* 457 */ (void (*)(void))457,
	/* 458 */ (void (*)(void))458,
	/* 459 */ (void (*)(void))459,
	/* 460 */ (void (*)(void))460,
	/* 461 */ (void (*)(void))461,
	/* 462 */ (void (*)(void))462,
	/* 463 */ (void (*)(void))463,
	/* 464 */ (void (*)(void))464,
	/* 465 */ (void (*)(void))465,
	/* 466 */ (void (*)(void))466,
	/* 467 */ (void (*)(void))467,
	/* 468 */ (void (*)(void))468,
	/* 469 */ (void (*)(void))469,
	/* 470 */ (void (*)(void))470,
	/* 471 */ (void (*)(void))471,
	/* 472 */ (void (*)(void))472,
	/* 473 */ (void (*)(void))473,
	/* 474 */ (void (*)(void))474,
	/* 475 */ (void (*)(void))475,
	/* 476 */ (void (*)(void))476,
	/* 477 */ (void (*)(void))477,
	/* 478 */ (void (*)(void))478,
	/* 479 */ (void (*)(void))479,
	/* 480 */ (void (*)(void))480,
	/* 481 */ (void (*)(void))481,
	/* 482 */ (void (*)(void))482,
	/* 483 */ (void (*)(void))483,
	/* 484 */ (void (*)(void))484,
	/* 485 */ (void (*)(void))485,
	/* 486 */ (void (*)(void))486,
	/* 487 */ (void (*)(void))487,
	/* 488 */ (void (*)(void))488,
	/* 489 */ (void (*)(void))489,
	/* 490 */ (void (*)(void))490,
	/* 491 */ (void (*)(void))491,
	/* 492 */ (void (*)(void))492,
	/* 493 */ (void (*)(void))493,
	/* 494 */ (void (*)(void))494,
	/* 495 */ (void (*)(void))495,
	/* 496 */ (void (*)(void))496,
	/* 497 */ (void (*)(void))497,
	/* 498 */ (void (*)(void))498,
	/* 499 */ (void (*)(void))499,
	/* 500 */ (void (*)(void))500,
	/* 501 */ (void (*)(void))501,
	/* 502 */ (void (*)(void))502,
	/* 503 */ (void (*)(void))503,
	/* 504 */ (void (*)(void))504,
	/* 505 */ (void (*)(void))505,
	/* 506 */ (void (*)(void))506,
	/* 507 */ (void (*)(void))507,
	/* 508 */ (void (*)(void))508,
	/* 509 */ (void (*)(void))509,
	/* 510 */ (void (*)(void))510,
	/* 511 */ (void (*)(void))511,
	/* 512 */ (void (*)(void))512,
	/* 513 */ (void (*)(void))513,
	/* 514 */ (void (*)(void))514,
	/* 515 */ (void (*)(void))515,
	/* 516 */ (void (*)(void))516,
	/* 517 */ (void (*)(void))517,
	/* 518 */ (void (*)(void))518,
	/* 519 */ (void (*)(void))519,
	/* 520 */ (void (*)(void))0,
	/* 521 */ (void (*)(void))0,
	/* 522 */ (void (*)(void))0,
	/* 523 */ (void (*)(void))0,
	/* 524 */ (void (*)(void))0,
	/* 525 */ (void (*)(void))0,
	/* 526 */ (void (*)(void))0,
	/* 527 */ (void (*)(void))0,
	/* 528 */ (void (*)(void))0,
	/* 529 */ (void (*)(void))0,
	/* 530 */ (void (*)(void))0,
	/* 531 */ (void (*)(void))0,
	/* 532 */ (void (*)(void))0,
	/* 533 */ (void (*)(void))0,
	/* 534 */ (void (*)(void))0,
	/* 535 */ (void (*)(void))0,
	/* 536 */ (void (*)(void))0,
	/* 537 */ (void (*)(void))0,
	/* 538 */ (void (*)(void))0,
	/* 539 */ (void (*)(void))0,
	/* 540 */ (void (*)(void))0,
	/* 541 */ (void (*)(void))0,
	/* 542 */ (void (*)(void))0,
	/* 543 */ (void (*)(void))0,
	/* 544 */ (void (*)(void))0,
	/* 545 */ (void (*)(void))0,
	/* 546 */ (void (*)(void))0,
	/* 547 */ (void (*)(void))0,
	/* 548 */ (void (*)(void))0,
	/* 549 */ (void (*)(void))0,
	/* 550 */ (void (*)(void))0,
	/* 551 */ (void (*)(void))0,
	/* 552 */ (void (*)(void))0,
	/* 553 */ (void (*)(void))0,
	/* 554 */ (void (*)(void))0,
	/* 555 */ (void (*)(void))0,
	/* 556 */ (void (*)(void))0,
	/* 557 */ (void (*)(void))0,
	/* 558 */ (void (*)(void))0,
	/* 559 */ (void (*)(void))0,
	/* 560 */ (void (*)(void))0,
	/* 561 */ (void (*)(void))0,
	/* 562 */ (void (*)(void))0,
	/* 563 */ (void (*)(void))0,
	/* 564 */ (void (*)(void))0,
	/* 565 */ (void (*)(void))0,
	/* 566 */ (void (*)(void))0,
	/* 567 */ (void (*)(void))0,
	/* 568 */ (void (*)(void))0,
	/* 569 */ (void (*)(void))0,
	/* 570 */ primitiveFlushExternalPrimitives,
	/* 571 */ primitiveUnloadModule,
	/* 572 */ primitiveListBuiltinModule,
	/* 573 */ primitiveListExternalModule,
	/* 574 */ (void (*)(void))0,
	/* 575 */ (void (*)(void))0,
 0 };
static void (*externalPrimitiveTable[MaxExternalPrimitiveTableSize + 1 /* 4097 */])(void);
const char *interpreterVersion = "Croquet Closure Cog VM [CoInterpreter VMMaker-eem.727]";
sqInt minBackwardJumpCountForCompile = MinBackwardJumpCountForCompile /* 10 */;
static volatile int sendTrace;


/*** Macros ***/
#define compilationBreakpoint(sel, len) do { \
	if ((len) == breakSelectorLength \
	 && !strncmp((char *)((sel) + BaseHeaderSize), breakSelector, breakSelectorLength)) { \
		suppressHeartbeatFlag = 1; \
		compilationBreakpointFor(sel); \
	} \
} while (0)
#define cPICNumCases stackCheckOffset
#define cPICNumCasesHack hack hack hack i.e. the getter macro does all the work
#define dispatchFunctionPointer(aFunctionPointer) (aFunctionPointer)()
#define enterSmalltalkExecutive() enterSmalltalkExecutiveImplementation()
#define flush() fflush(stdout)
#define getCodeCompactionCount() integerObjectOf(GIV(statCodeCompactionCount))
#define getCodeCompactionMSecs() integerObjectOf((GIV(statCodeCompactionUsecs) + 500) / 1000)
#define getCogCodeSize() integerObjectOf(GIV(cogCodeSize))
#define getDesiredCogCodeSize() integerObjectOf(desiredCogCodeSize)
#define initialEnterSmalltalkExecutive() enterSmalltalkExecutiveImplementation()
#define memory() memory
#define mostRecentlyUsedPage() GIV(mostRecentlyUsedPage)
#define nextOpenPIC methodObject
#define nextOpenPICHack hack hack hack i.e. the getter macro does all the work
#define pageIndexForstackBasePlus1bytesPerPage(pointer,stkBasePlus1,pageByteSize) (((char *)(pointer) - (stkBasePlus1)) / (pageByteSize))
#define primTraceLogIndex(aValue) (GIV(primTraceLogIndex) = (aValue))
#define printFloat(f) printf("%g", f)
#define remapBufferCount() GIV(remapBufferCount)
#define setDesiredCogCodeSize(dccs) (desiredCogCodeSize = (dccs))
#define stackPageAtpages(index,pages) ((pages) + (index))
#define typeEtAlWord(cm) (((long *)(cm))[1])
#define validate() 0
#define youngStart() GIV(youngStart)



/*	This is the main interpreter loop. It normally loops forever, fetching and
	executing bytecodes. When running in the context of a browser plugin VM,
	however, it must return control to the browser periodically. This should
	done only when the state of the currently running Squeak thread is safely
	stored in the object heap. Since this is the case at the moment that a
	check for interrupts is performed, that is when we return to the browser
	if it is time to do so. Interrupt checks happen quite frequently.
 */
/*	If stacklimit is zero then the stack pages have not been initialized. */

sqInt
interpret(void)
{   DECL_MAYBE_SQ_GLOBAL_STRUCT
    sqInt backwardJumpCount;
    sqInt currentBytecode CB_REG;
    sqInt lastBackwardJumpMethod;
    char* localFP FP_REG;
    char* localIP IP_REG;
    sqInt localReturnValue;
    char* localSP SP_REG;
    JUMP_TABLE;

	if (GIV(stackLimit) == 0) {
		return initStackPagesAndInterpret();
	}
	browserPluginInitialiseIfNeeded();
	/* begin internalizeIPandSP */
	assert(GIV(instructionPointer) != (ceReturnToInterpreterPC()));
	localIP = pointerForOop(GIV(instructionPointer));
	localSP = pointerForOop(GIV(stackPointer));
	localFP = pointerForOop(GIV(framePointer));
	/* begin fetchNextBytecode */
	currentBytecode = byteAtPointer(++localIP);
	while (1) {
		bytecodeDispatchDebugHook();

		VM_LABEL(0bytecodeDispatch);
		switch (currentBytecode) {
		CASE(0)
			/* pushReceiverVariableBytecode */
			{

				VM_LABEL(0pushReceiverVariableBytecode);
								/* begin fetchNextBytecode */
				currentBytecode = byteAtPointer(++localIP);
				/* begin pushReceiverVariable: */
				/* begin internalPush: */
				longAtPointerput(localSP -= BytesPerWord, longAt(((longAt(localFP + FoxIFReceiver)) + BaseHeaderSize) + ((0 & 15) << ShiftForWord)));
			}
;
			BREAK;
		CASE(1)
			/* pushReceiverVariableBytecode */
			{

				VM_LABEL(1pushReceiverVariableBytecode);
								/* begin fetchNextBytecode */
				currentBytecode = byteAtPointer(++localIP);
				/* begin pushReceiverVariable: */
				/* begin internalPush: */
				longAtPointerput(localSP -= BytesPerWord, longAt(((longAt(localFP + FoxIFReceiver)) + BaseHeaderSize) + ((1 & 15) << ShiftForWord)));
			}
;
			BREAK;
		CASE(2)
			/* pushReceiverVariableBytecode */
			{

				VM_LABEL(2pushReceiverVariableBytecode);
								/* begin fetchNextBytecode */
				currentBytecode = byteAtPointer(++localIP);
				/* begin pushReceiverVariable: */
				/* begin internalPush: */
				longAtPointerput(localSP -= BytesPerWord, longAt(((longAt(localFP + FoxIFReceiver)) + BaseHeaderSize) + ((2 & 15) << ShiftForWord)));
			}
;
			BREAK;
		CASE(3)
			/* pushReceiverVariableBytecode */
			{

				VM_LABEL(3pushReceiverVariableBytecode);
								/* begin fetchNextBytecode */
				currentBytecode = byteAtPointer(++localIP);
				/* begin pushReceiverVariable: */
				/* begin internalPush: */
				longAtPointerput(localSP -= BytesPerWord, longAt(((longAt(localFP + FoxIFReceiver)) + BaseHeaderSize) + ((3 & 15) << ShiftForWord)));
			}
;
			BREAK;
		CASE(4)
			/* pushReceiverVariableBytecode */
			{

				VM_LABEL(4pushReceiverVariableBytecode);
								/* begin fetchNextBytecode */
				currentBytecode = byteAtPointer(++localIP);
				/* begin pushReceiverVariable: */
				/* begin internalPush: */
				longAtPointerput(localSP -= BytesPerWord, longAt(((longAt(localFP + FoxIFReceiver)) + BaseHeaderSize) + ((4 & 15) << ShiftForWord)));
			}
;
			BREAK;
		CASE(5)
			/* pushReceiverVariableBytecode */
			{

				VM_LABEL(5pushReceiverVariableBytecode);
								/* begin fetchNextBytecode */
				currentBytecode = byteAtPointer(++localIP);
				/* begin pushReceiverVariable: */
				/* begin internalPush: */
				longAtPointerput(localSP -= BytesPerWord, longAt(((longAt(localFP + FoxIFReceiver)) + BaseHeaderSize) + ((5 & 15) << ShiftForWord)));
			}
;
			BREAK;
		CASE(6)
			/* pushReceiverVariableBytecode */
			{

				VM_LABEL(6pushReceiverVariableBytecode);
								/* begin fetchNextBytecode */
				currentBytecode = byteAtPointer(++localIP);
				/* begin pushReceiverVariable: */
				/* begin internalPush: */
				longAtPointerput(localSP -= BytesPerWord, longAt(((longAt(localFP + FoxIFReceiver)) + BaseHeaderSize) + ((6 & 15) << ShiftForWord)));
			}
;
			BREAK;
		CASE(7)
			/* pushReceiverVariableBytecode */
			{

				VM_LABEL(7pushReceiverVariableBytecode);
								/* begin fetchNextBytecode */
				currentBytecode = byteAtPointer(++localIP);
				/* begin pushReceiverVariable: */
				/* begin internalPush: */
				longAtPointerput(localSP -= BytesPerWord, longAt(((longAt(localFP + FoxIFReceiver)) + BaseHeaderSize) + ((7 & 15) << ShiftForWord)));
			}
;
			BREAK;
		CASE(8)
			/* pushReceiverVariableBytecode */
			{

				VM_LABEL(8pushReceiverVariableBytecode);
								/* begin fetchNextBytecode */
				currentBytecode = byteAtPointer(++localIP);
				/* begin pushReceiverVariable: */
				/* begin internalPush: */
				longAtPointerput(localSP -= BytesPerWord, longAt(((longAt(localFP + FoxIFReceiver)) + BaseHeaderSize) + ((8 & 15) << ShiftForWord)));
			}
;
			BREAK;
		CASE(9)
			/* pushReceiverVariableBytecode */
			{

				VM_LABEL(9pushReceiverVariableBytecode);
								/* begin fetchNextBytecode */
				currentBytecode = byteAtPointer(++localIP);
				/* begin pushReceiverVariable: */
				/* begin internalPush: */
				longAtPointerput(localSP -= BytesPerWord, longAt(((longAt(localFP + FoxIFReceiver)) + BaseHeaderSize) + ((9 & 15) << ShiftForWord)));
			}
;
			BREAK;
		CASE(10)
			/* pushReceiverVariableBytecode */
			{

				VM_LABEL(10pushReceiverVariableBytecode);
								/* begin fetchNextBytecode */
				currentBytecode = byteAtPointer(++localIP);
				/* begin pushReceiverVariable: */
				/* begin internalPush: */
				longAtPointerput(localSP -= BytesPerWord, longAt(((longAt(localFP + FoxIFReceiver)) + BaseHeaderSize) + ((10 & 15) << ShiftForWord)));
			}
;
			BREAK;
		CASE(11)
			/* pushReceiverVariableBytecode */
			{

				VM_LABEL(11pushReceiverVariableBytecode);
								/* begin fetchNextBytecode */
				currentBytecode = byteAtPointer(++localIP);
				/* begin pushReceiverVariable: */
				/* begin internalPush: */
				longAtPointerput(localSP -= BytesPerWord, longAt(((longAt(localFP + FoxIFReceiver)) + BaseHeaderSize) + ((11 & 15) << ShiftForWord)));
			}
;
			BREAK;
		CASE(12)
			/* pushReceiverVariableBytecode */
			{

				VM_LABEL(12pushReceiverVariableBytecode);
								/* begin fetchNextBytecode */
				currentBytecode = byteAtPointer(++localIP);
				/* begin pushReceiverVariable: */
				/* begin internalPush: */
				longAtPointerput(localSP -= BytesPerWord, longAt(((longAt(localFP + FoxIFReceiver)) + BaseHeaderSize) + ((12 & 15) << ShiftForWord)));
			}
;
			BREAK;
		CASE(13)
			/* pushReceiverVariableBytecode */
			{

				VM_LABEL(13pushReceiverVariableBytecode);
								/* begin fetchNextBytecode */
				currentBytecode = byteAtPointer(++localIP);
				/* begin pushReceiverVariable: */
				/* begin internalPush: */
				longAtPointerput(localSP -= BytesPerWord, longAt(((longAt(localFP + FoxIFReceiver)) + BaseHeaderSize) + ((13 & 15) << ShiftForWord)));
			}
;
			BREAK;
		CASE(14)
			/* pushReceiverVariableBytecode */
			{

				VM_LABEL(14pushReceiverVariableBytecode);
								/* begin fetchNextBytecode */
				currentBytecode = byteAtPointer(++localIP);
				/* begin pushReceiverVariable: */
				/* begin internalPush: */
				longAtPointerput(localSP -= BytesPerWord, longAt(((longAt(localFP + FoxIFReceiver)) + BaseHeaderSize) + ((14 & 15) << ShiftForWord)));
			}
;
			BREAK;
		CASE(15)
			/* pushReceiverVariableBytecode */
			{

				VM_LABEL(15pushReceiverVariableBytecode);
								/* begin fetchNextBytecode */
				currentBytecode = byteAtPointer(++localIP);
				/* begin pushReceiverVariable: */
				/* begin internalPush: */
				longAtPointerput(localSP -= BytesPerWord, longAt(((longAt(localFP + FoxIFReceiver)) + BaseHeaderSize) + ((15 & 15) << ShiftForWord)));
			}
;
			BREAK;
		CASE(16)
			/* pushTemporaryVariableBytecode */
			{
				sqInt frameNumArgs;
				sqInt object;

				VM_LABEL(0pushTemporaryVariableBytecode);
								/* begin fetchNextBytecode */
				currentBytecode = byteAtPointer(++localIP);
				/* begin pushTemporaryVariable: */
				VM_LABEL(0pushTemporaryVariable);
				/* begin internalPush: */
				object = ((16 & 15) < ((frameNumArgs = byteAt((localFP + FoxIFrameFlags) + 1)))
					? longAt((localFP + FoxCallerSavedIP) + ((frameNumArgs - (16 & 15)) * BytesPerWord))
					: longAt(((localFP + FoxIFReceiver) - BytesPerWord) + ((frameNumArgs - (16 & 15)) * BytesPerWord)));
				longAtPointerput(localSP -= BytesPerWord, object);
			}
;
			BREAK;
		CASE(17)
			/* pushTemporaryVariableBytecode */
			{
				sqInt frameNumArgs;
				sqInt object;

				VM_LABEL(1pushTemporaryVariableBytecode);
								/* begin fetchNextBytecode */
				currentBytecode = byteAtPointer(++localIP);
				/* begin pushTemporaryVariable: */
				VM_LABEL(1pushTemporaryVariable);
				/* begin internalPush: */
				object = ((17 & 15) < ((frameNumArgs = byteAt((localFP + FoxIFrameFlags) + 1)))
					? longAt((localFP + FoxCallerSavedIP) + ((frameNumArgs - (17 & 15)) * BytesPerWord))
					: longAt(((localFP + FoxIFReceiver) - BytesPerWord) + ((frameNumArgs - (17 & 15)) * BytesPerWord)));
				longAtPointerput(localSP -= BytesPerWord, object);
			}
;
			BREAK;
		CASE(18)
			/* pushTemporaryVariableBytecode */
			{
				sqInt frameNumArgs;
				sqInt object;

				VM_LABEL(2pushTemporaryVariableBytecode);
								/* begin fetchNextBytecode */
				currentBytecode = byteAtPointer(++localIP);
				/* begin pushTemporaryVariable: */
				VM_LABEL(2pushTemporaryVariable);
				/* begin internalPush: */
				object = ((18 & 15) < ((frameNumArgs = byteAt((localFP + FoxIFrameFlags) + 1)))
					? longAt((localFP + FoxCallerSavedIP) + ((frameNumArgs - (18 & 15)) * BytesPerWord))
					: longAt(((localFP + FoxIFReceiver) - BytesPerWord) + ((frameNumArgs - (18 & 15)) * BytesPerWord)));
				longAtPointerput(localSP -= BytesPerWord, object);
			}
;
			BREAK;
		CASE(19)
			/* pushTemporaryVariableBytecode */
			{
				sqInt frameNumArgs;
				sqInt object;

				VM_LABEL(3pushTemporaryVariableBytecode);
								/* begin fetchNextBytecode */
				currentBytecode = byteAtPointer(++localIP);
				/* begin pushTemporaryVariable: */
				VM_LABEL(3pushTemporaryVariable);
				/* begin internalPush: */
				object = ((19 & 15) < ((frameNumArgs = byteAt((localFP + FoxIFrameFlags) + 1)))
					? longAt((localFP + FoxCallerSavedIP) + ((frameNumArgs - (19 & 15)) * BytesPerWord))
					: longAt(((localFP + FoxIFReceiver) - BytesPerWord) + ((frameNumArgs - (19 & 15)) * BytesPerWord)));
				longAtPointerput(localSP -= BytesPerWord, object);
			}
;
			BREAK;
		CASE(20)
			/* pushTemporaryVariableBytecode */
			{
				sqInt frameNumArgs;
				sqInt object;

				VM_LABEL(4pushTemporaryVariableBytecode);
								/* begin fetchNextBytecode */
				currentBytecode = byteAtPointer(++localIP);
				/* begin pushTemporaryVariable: */
				VM_LABEL(4pushTemporaryVariable);
				/* begin internalPush: */
				object = ((20 & 15) < ((frameNumArgs = byteAt((localFP + FoxIFrameFlags) + 1)))
					? longAt((localFP + FoxCallerSavedIP) + ((frameNumArgs - (20 & 15)) * BytesPerWord))
					: longAt(((localFP + FoxIFReceiver) - BytesPerWord) + ((frameNumArgs - (20 & 15)) * BytesPerWord)));
				longAtPointerput(localSP -= BytesPerWord, object);
			}
;
			BREAK;
		CASE(21)
			/* pushTemporaryVariableBytecode */
			{
				sqInt frameNumArgs;
				sqInt object;

				VM_LABEL(5pushTemporaryVariableBytecode);
								/* begin fetchNextBytecode */
				currentBytecode = byteAtPointer(++localIP);
				/* begin pushTemporaryVariable: */
				VM_LABEL(5pushTemporaryVariable);
				/* begin internalPush: */
				object = ((21 & 15) < ((frameNumArgs = byteAt((localFP + FoxIFrameFlags) + 1)))
					? longAt((localFP + FoxCallerSavedIP) + ((frameNumArgs - (21 & 15)) * BytesPerWord))
					: longAt(((localFP + FoxIFReceiver) - BytesPerWord) + ((frameNumArgs - (21 & 15)) * BytesPerWord)));
				longAtPointerput(localSP -= BytesPerWord, object);
			}
;
			BREAK;
		CASE(22)
			/* pushTemporaryVariableBytecode */
			{
				sqInt frameNumArgs;
				sqInt object;

				VM_LABEL(6pushTemporaryVariableBytecode);
								/* begin fetchNextBytecode */
				currentBytecode = byteAtPointer(++localIP);
				/* begin pushTemporaryVariable: */
				VM_LABEL(6pushTemporaryVariable);
				/* begin internalPush: */
				object = ((22 & 15) < ((frameNumArgs = byteAt((localFP + FoxIFrameFlags) + 1)))
					? longAt((localFP + FoxCallerSavedIP) + ((frameNumArgs - (22 & 15)) * BytesPerWord))
					: longAt(((localFP + FoxIFReceiver) - BytesPerWord) + ((frameNumArgs - (22 & 15)) * BytesPerWord)));
				longAtPointerput(localSP -= BytesPerWord, object);
			}
;
			BREAK;
		CASE(23)
			/* pushTemporaryVariableBytecode */
			{
				sqInt frameNumArgs;
				sqInt object;

				VM_LABEL(7pushTemporaryVariableBytecode);
								/* begin fetchNextBytecode */
				currentBytecode = byteAtPointer(++localIP);
				/* begin pushTemporaryVariable: */
				VM_LABEL(7pushTemporaryVariable);
				/* begin internalPush: */
				object = ((23 & 15) < ((frameNumArgs = byteAt((localFP + FoxIFrameFlags) + 1)))
					? longAt((localFP + FoxCallerSavedIP) + ((frameNumArgs - (23 & 15)) * BytesPerWord))
					: longAt(((localFP + FoxIFReceiver) - BytesPerWord) + ((frameNumArgs - (23 & 15)) * BytesPerWord)));
				longAtPointerput(localSP -= BytesPerWord, object);
			}
;
			BREAK;
		CASE(24)
			/* pushTemporaryVariableBytecode */
			{
				sqInt frameNumArgs;
				sqInt object;

				VM_LABEL(8pushTemporaryVariableBytecode);
								/* begin fetchNextBytecode */
				currentBytecode = byteAtPointer(++localIP);
				/* begin pushTemporaryVariable: */
				VM_LABEL(8pushTemporaryVariable);
				/* begin internalPush: */
				object = ((24 & 15) < ((frameNumArgs = byteAt((localFP + FoxIFrameFlags) + 1)))
					? longAt((localFP + FoxCallerSavedIP) + ((frameNumArgs - (24 & 15)) * BytesPerWord))
					: longAt(((localFP + FoxIFReceiver) - BytesPerWord) + ((frameNumArgs - (24 & 15)) * BytesPerWord)));
				longAtPointerput(localSP -= BytesPerWord, object);
			}
;
			BREAK;
		CASE(25)
			/* pushTemporaryVariableBytecode */
			{
				sqInt frameNumArgs;
				sqInt object;

				VM_LABEL(9pushTemporaryVariableBytecode);
								/* begin fetchNextBytecode */
				currentBytecode = byteAtPointer(++localIP);
				/* begin pushTemporaryVariable: */
				VM_LABEL(9pushTemporaryVariable);
				/* begin internalPush: */
				object = ((25 & 15) < ((frameNumArgs = byteAt((localFP + FoxIFrameFlags) + 1)))
					? longAt((localFP + FoxCallerSavedIP) + ((frameNumArgs - (25 & 15)) * BytesPerWord))
					: longAt(((localFP + FoxIFReceiver) - BytesPerWord) + ((frameNumArgs - (25 & 15)) * BytesPerWord)));
				longAtPointerput(localSP -= BytesPerWord, object);
			}
;
			BREAK;
		CASE(26)
			/* pushTemporaryVariableBytecode */
			{
				sqInt frameNumArgs;
				sqInt object;

				VM_LABEL(10pushTemporaryVariableBytecode);
								/* begin fetchNextBytecode */
				currentBytecode = byteAtPointer(++localIP);
				/* begin pushTemporaryVariable: */
				VM_LABEL(10pushTemporaryVariable);
				/* begin internalPush: */
				object = ((26 & 15) < ((frameNumArgs = byteAt((localFP + FoxIFrameFlags) + 1)))
					? longAt((localFP + FoxCallerSavedIP) + ((frameNumArgs - (26 & 15)) * BytesPerWord))
					: longAt(((localFP + FoxIFReceiver) - BytesPerWord) + ((frameNumArgs - (26 & 15)) * BytesPerWord)));
				longAtPointerput(localSP -= BytesPerWord, object);
			}
;
			BREAK;
		CASE(27)
			/* pushTemporaryVariableBytecode */
			{
				sqInt frameNumArgs;
				sqInt object;

				VM_LABEL(11pushTemporaryVariableBytecode);
								/* begin fetchNextBytecode */
				currentBytecode = byteAtPointer(++localIP);
				/* begin pushTemporaryVariable: */
				VM_LABEL(11pushTemporaryVariable);
				/* begin internalPush: */
				object = ((27 & 15) < ((frameNumArgs = byteAt((localFP + FoxIFrameFlags) + 1)))
					? longAt((localFP + FoxCallerSavedIP) + ((frameNumArgs - (27 & 15)) * BytesPerWord))
					: longAt(((localFP + FoxIFReceiver) - BytesPerWord) + ((frameNumArgs - (27 & 15)) * BytesPerWord)));
				longAtPointerput(localSP -= BytesPerWord, object);
			}
;
			BREAK;
		CASE(28)
			/* pushTemporaryVariableBytecode */
			{
				sqInt frameNumArgs;
				sqInt object;

				VM_LABEL(12pushTemporaryVariableBytecode);
								/* begin fetchNextBytecode */
				currentBytecode = byteAtPointer(++localIP);
				/* begin pushTemporaryVariable: */
				VM_LABEL(12pushTemporaryVariable);
				/* begin internalPush: */
				object = ((28 & 15) < ((frameNumArgs = byteAt((localFP + FoxIFrameFlags) + 1)))
					? longAt((localFP + FoxCallerSavedIP) + ((frameNumArgs - (28 & 15)) * BytesPerWord))
					: longAt(((localFP + FoxIFReceiver) - BytesPerWord) + ((frameNumArgs - (28 & 15)) * BytesPerWord)));
				longAtPointerput(localSP -= BytesPerWord, object);
			}
;
			BREAK;
		CASE(29)
			/* pushTemporaryVariableBytecode */
			{
				sqInt frameNumArgs;
				sqInt object;

				VM_LABEL(13pushTemporaryVariableBytecode);
								/* begin fetchNextBytecode */
				currentBytecode = byteAtPointer(++localIP);
				/* begin pushTemporaryVariable: */
				VM_LABEL(13pushTemporaryVariable);
				/* begin internalPush: */
				object = ((29 & 15) < ((frameNumArgs = byteAt((localFP + FoxIFrameFlags) + 1)))
					? longAt((localFP + FoxCallerSavedIP) + ((frameNumArgs - (29 & 15)) * BytesPerWord))
					: longAt(((localFP + FoxIFReceiver) - BytesPerWord) + ((frameNumArgs - (29 & 15)) * BytesPerWord)));
				longAtPointerput(localSP -= BytesPerWord, object);
			}
;
			BREAK;
		CASE(30)
			/* pushTemporaryVariableBytecode */
			{
				sqInt frameNumArgs;
				sqInt object;

				VM_LABEL(14pushTemporaryVariableBytecode);
								/* begin fetchNextBytecode */
				currentBytecode = byteAtPointer(++localIP);
				/* begin pushTemporaryVariable: */
				VM_LABEL(14pushTemporaryVariable);
				/* begin internalPush: */
				object = ((30 & 15) < ((frameNumArgs = byteAt((localFP + FoxIFrameFlags) + 1)))
					? longAt((localFP + FoxCallerSavedIP) + ((frameNumArgs - (30 & 15)) * BytesPerWord))
					: longAt(((localFP + FoxIFReceiver) - BytesPerWord) + ((frameNumArgs - (30 & 15)) * BytesPerWord)));
				longAtPointerput(localSP -= BytesPerWord, object);
			}
;
			BREAK;
		CASE(31)
			/* pushTemporaryVariableBytecode */
			{
				sqInt frameNumArgs;
				sqInt object;

				VM_LABEL(15pushTemporaryVariableBytecode);
								/* begin fetchNextBytecode */
				currentBytecode = byteAtPointer(++localIP);
				/* begin pushTemporaryVariable: */
				VM_LABEL(15pushTemporaryVariable);
				/* begin internalPush: */
				object = ((31 & 15) < ((frameNumArgs = byteAt((localFP + FoxIFrameFlags) + 1)))
					? longAt((localFP + FoxCallerSavedIP) + ((frameNumArgs - (31 & 15)) * BytesPerWord))
					: longAt(((localFP + FoxIFReceiver) - BytesPerWord) + ((frameNumArgs - (31 & 15)) * BytesPerWord)));
				longAtPointerput(localSP -= BytesPerWord, object);
			}
;
			BREAK;
		CASE(32)
			/* pushLiteralConstantBytecode */
			{
				sqInt object;

				VM_LABEL(0pushLiteralConstantBytecode);
								/* begin fetchNextBytecode */
				currentBytecode = byteAtPointer(++localIP);
				/* begin pushLiteralConstant: */
				/* begin internalPush: */
				/* begin literal: */
				assert(GIV(method) == (iframeMethod(localFP)));
				object = longAt((GIV(method) + BaseHeaderSize) + (((32 & 31) + LiteralStart) << ShiftForWord));
				longAtPointerput(localSP -= BytesPerWord, object);
			}
;
			BREAK;
		CASE(33)
			/* pushLiteralConstantBytecode */
			{
				sqInt object;

				VM_LABEL(1pushLiteralConstantBytecode);
								/* begin fetchNextBytecode */
				currentBytecode = byteAtPointer(++localIP);
				/* begin pushLiteralConstant: */
				/* begin internalPush: */
				/* begin literal: */
				assert(GIV(method) == (iframeMethod(localFP)));
				object = longAt((GIV(method) + BaseHeaderSize) + (((33 & 31) + LiteralStart) << ShiftForWord));
				longAtPointerput(localSP -= BytesPerWord, object);
			}
;
			BREAK;
		CASE(34)
			/* pushLiteralConstantBytecode */
			{
				sqInt object;

				VM_LABEL(2pushLiteralConstantBytecode);
								/* begin fetchNextBytecode */
				currentBytecode = byteAtPointer(++localIP);
				/* begin pushLiteralConstant: */
				/* begin internalPush: */
				/* begin literal: */
				assert(GIV(method) == (iframeMethod(localFP)));
				object = longAt((GIV(method) + BaseHeaderSize) + (((34 & 31) + LiteralStart) << ShiftForWord));
				longAtPointerput(localSP -= BytesPerWord, object);
			}
;
			BREAK;
		CASE(35)
			/* pushLiteralConstantBytecode */
			{
				sqInt object;

				VM_LABEL(3pushLiteralConstantBytecode);
								/* begin fetchNextBytecode */
				currentBytecode = byteAtPointer(++localIP);
				/* begin pushLiteralConstant: */
				/* begin internalPush: */
				/* begin literal: */
				assert(GIV(method) == (iframeMethod(localFP)));
				object = longAt((GIV(method) + BaseHeaderSize) + (((35 & 31) + LiteralStart) << ShiftForWord));
				longAtPointerput(localSP -= BytesPerWord, object);
			}
;
			BREAK;
		CASE(36)
			/* pushLiteralConstantBytecode */
			{
				sqInt object;

				VM_LABEL(4pushLiteralConstantBytecode);
								/* begin fetchNextBytecode */
				currentBytecode = byteAtPointer(++localIP);
				/* begin pushLiteralConstant: */
				/* begin internalPush: */
				/* begin literal: */
				assert(GIV(method) == (iframeMethod(localFP)));
				object = longAt((GIV(method) + BaseHeaderSize) + (((36 & 31) + LiteralStart) << ShiftForWord));
				longAtPointerput(localSP -= BytesPerWord, object);
			}
;
			BREAK;
		CASE(37)
			/* pushLiteralConstantBytecode */
			{
				sqInt object;

				VM_LABEL(5pushLiteralConstantBytecode);
								/* begin fetchNextBytecode */
				currentBytecode = byteAtPointer(++localIP);
				/* begin pushLiteralConstant: */
				/* begin internalPush: */
				/* begin literal: */
				assert(GIV(method) == (iframeMethod(localFP)));
				object = longAt((GIV(method) + BaseHeaderSize) + (((37 & 31) + LiteralStart) << ShiftForWord));
				longAtPointerput(localSP -= BytesPerWord, object);
			}
;
			BREAK;
		CASE(38)
			/* pushLiteralConstantBytecode */
			{
				sqInt object;

				VM_LABEL(6pushLiteralConstantBytecode);
								/* begin fetchNextBytecode */
				currentBytecode = byteAtPointer(++localIP);
				/* begin pushLiteralConstant: */
				/* begin internalPush: */
				/* begin literal: */
				assert(GIV(method) == (iframeMethod(localFP)));
				object = longAt((GIV(method) + BaseHeaderSize) + (((38 & 31) + LiteralStart) << ShiftForWord));
				longAtPointerput(localSP -= BytesPerWord, object);
			}
;
			BREAK;
		CASE(39)
			/* pushLiteralConstantBytecode */
			{
				sqInt object;

				VM_LABEL(7pushLiteralConstantBytecode);
								/* begin fetchNextBytecode */
				currentBytecode = byteAtPointer(++localIP);
				/* begin pushLiteralConstant: */
				/* begin internalPush: */
				/* begin literal: */
				assert(GIV(method) == (iframeMethod(localFP)));
				object = longAt((GIV(method) + BaseHeaderSize) + (((39 & 31) + LiteralStart) << ShiftForWord));
				longAtPointerput(localSP -= BytesPerWord, object);
			}
;
			BREAK;
		CASE(40)
			/* pushLiteralConstantBytecode */
			{
				sqInt object;

				VM_LABEL(8pushLiteralConstantBytecode);
								/* begin fetchNextBytecode */
				currentBytecode = byteAtPointer(++localIP);
				/* begin pushLiteralConstant: */
				/* begin internalPush: */
				/* begin literal: */
				assert(GIV(method) == (iframeMethod(localFP)));
				object = longAt((GIV(method) + BaseHeaderSize) + (((40 & 31) + LiteralStart) << ShiftForWord));
				longAtPointerput(localSP -= BytesPerWord, object);
			}
;
			BREAK;
		CASE(41)
			/* pushLiteralConstantBytecode */
			{
				sqInt object;

				VM_LABEL(9pushLiteralConstantBytecode);
								/* begin fetchNextBytecode */
				currentBytecode = byteAtPointer(++localIP);
				/* begin pushLiteralConstant: */
				/* begin internalPush: */
				/* begin literal: */
				assert(GIV(method) == (iframeMethod(localFP)));
				object = longAt((GIV(method) + BaseHeaderSize) + (((41 & 31) + LiteralStart) << ShiftForWord));
				longAtPointerput(localSP -= BytesPerWord, object);
			}
;
			BREAK;
		CASE(42)
			/* pushLiteralConstantBytecode */
			{
				sqInt object;

				VM_LABEL(10pushLiteralConstantBytecode);
								/* begin fetchNextBytecode */
				currentBytecode = byteAtPointer(++localIP);
				/* begin pushLiteralConstant: */
				/* begin internalPush: */
				/* begin literal: */
				assert(GIV(method) == (iframeMethod(localFP)));
				object = longAt((GIV(method) + BaseHeaderSize) + (((42 & 31) + LiteralStart) << ShiftForWord));
				longAtPointerput(localSP -= BytesPerWord, object);
			}
;
			BREAK;
		CASE(43)
			/* pushLiteralConstantBytecode */
			{
				sqInt object;

				VM_LABEL(11pushLiteralConstantBytecode);
								/* begin fetchNextBytecode */
				currentBytecode = byteAtPointer(++localIP);
				/* begin pushLiteralConstant: */
				/* begin internalPush: */
				/* begin literal: */
				assert(GIV(method) == (iframeMethod(localFP)));
				object = longAt((GIV(method) + BaseHeaderSize) + (((43 & 31) + LiteralStart) << ShiftForWord));
				longAtPointerput(localSP -= BytesPerWord, object);
			}
;
			BREAK;
		CASE(44)
			/* pushLiteralConstantBytecode */
			{
				sqInt object;

				VM_LABEL(12pushLiteralConstantBytecode);
								/* begin fetchNextBytecode */
				currentBytecode = byteAtPointer(++localIP);
				/* begin pushLiteralConstant: */
				/* begin internalPush: */
				/* begin literal: */
				assert(GIV(method) == (iframeMethod(localFP)));
				object = longAt((GIV(method) + BaseHeaderSize) + (((44 & 31) + LiteralStart) << ShiftForWord));
				longAtPointerput(localSP -= BytesPerWord, object);
			}
;
			BREAK;
		CASE(45)
			/* pushLiteralConstantBytecode */
			{
				sqInt object;

				VM_LABEL(13pushLiteralConstantBytecode);
								/* begin fetchNextBytecode */
				currentBytecode = byteAtPointer(++localIP);
				/* begin pushLiteralConstant: */
				/* begin internalPush: */
				/* begin literal: */
				assert(GIV(method) == (iframeMethod(localFP)));
				object = longAt((GIV(method) + BaseHeaderSize) + (((45 & 31) + LiteralStart) << ShiftForWord));
				longAtPointerput(localSP -= BytesPerWord, object);
			}
;
			BREAK;
		CASE(46)
			/* pushLiteralConstantBytecode */
			{
				sqInt object;

				VM_LABEL(14pushLiteralConstantBytecode);
								/* begin fetchNextBytecode */
				currentBytecode = byteAtPointer(++localIP);
				/* begin pushLiteralConstant: */
				/* begin internalPush: */
				/* begin literal: */
				assert(GIV(method) == (iframeMethod(localFP)));
				object = longAt((GIV(method) + BaseHeaderSize) + (((46 & 31) + LiteralStart) << ShiftForWord));
				longAtPointerput(localSP -= BytesPerWord, object);
			}
;
			BREAK;
		CASE(47)
			/* pushLiteralConstantBytecode */
			{
				sqInt object;

				VM_LABEL(15pushLiteralConstantBytecode);
								/* begin fetchNextBytecode */
				currentBytecode = byteAtPointer(++localIP);
				/* begin pushLiteralConstant: */
				/* begin internalPush: */
				/* begin literal: */
				assert(GIV(method) == (iframeMethod(localFP)));
				object = longAt((GIV(method) + BaseHeaderSize) + (((47 & 31) + LiteralStart) << ShiftForWord));
				longAtPointerput(localSP -= BytesPerWord, object);
			}
;
			BREAK;
		CASE(48)
			/* pushLiteralConstantBytecode */
			{
				sqInt object;

				VM_LABEL(16pushLiteralConstantBytecode);
								/* begin fetchNextBytecode */
				currentBytecode = byteAtPointer(++localIP);
				/* begin pushLiteralConstant: */
				/* begin internalPush: */
				/* begin literal: */
				assert(GIV(method) == (iframeMethod(localFP)));
				object = longAt((GIV(method) + BaseHeaderSize) + (((48 & 31) + LiteralStart) << ShiftForWord));
				longAtPointerput(localSP -= BytesPerWord, object);
			}
;
			BREAK;
		CASE(49)
			/* pushLiteralConstantBytecode */
			{
				sqInt object;

				VM_LABEL(17pushLiteralConstantBytecode);
								/* begin fetchNextBytecode */
				currentBytecode = byteAtPointer(++localIP);
				/* begin pushLiteralConstant: */
				/* begin internalPush: */
				/* begin literal: */
				assert(GIV(method) == (iframeMethod(localFP)));
				object = longAt((GIV(method) + BaseHeaderSize) + (((49 & 31) + LiteralStart) << ShiftForWord));
				longAtPointerput(localSP -= BytesPerWord, object);
			}
;
			BREAK;
		CASE(50)
			/* pushLiteralConstantBytecode */
			{
				sqInt object;

				VM_LABEL(18pushLiteralConstantBytecode);
								/* begin fetchNextBytecode */
				currentBytecode = byteAtPointer(++localIP);
				/* begin pushLiteralConstant: */
				/* begin internalPush: */
				/* begin literal: */
				assert(GIV(method) == (iframeMethod(localFP)));
				object = longAt((GIV(method) + BaseHeaderSize) + (((50 & 31) + LiteralStart) << ShiftForWord));
				longAtPointerput(localSP -= BytesPerWord, object);
			}
;
			BREAK;
		CASE(51)
			/* pushLiteralConstantBytecode */
			{
				sqInt object;

				VM_LABEL(19pushLiteralConstantBytecode);
								/* begin fetchNextBytecode */
				currentBytecode = byteAtPointer(++localIP);
				/* begin pushLiteralConstant: */
				/* begin internalPush: */
				/* begin literal: */
				assert(GIV(method) == (iframeMethod(localFP)));
				object = longAt((GIV(method) + BaseHeaderSize) + (((51 & 31) + LiteralStart) << ShiftForWord));
				longAtPointerput(localSP -= BytesPerWord, object);
			}
;
			BREAK;
		CASE(52)
			/* pushLiteralConstantBytecode */
			{
				sqInt object;

				VM_LABEL(20pushLiteralConstantBytecode);
								/* begin fetchNextBytecode */
				currentBytecode = byteAtPointer(++localIP);
				/* begin pushLiteralConstant: */
				/* begin internalPush: */
				/* begin literal: */
				assert(GIV(method) == (iframeMethod(localFP)));
				object = longAt((GIV(method) + BaseHeaderSize) + (((52 & 31) + LiteralStart) << ShiftForWord));
				longAtPointerput(localSP -= BytesPerWord, object);
			}
;
			BREAK;
		CASE(53)
			/* pushLiteralConstantBytecode */
			{
				sqInt object;

				VM_LABEL(21pushLiteralConstantBytecode);
								/* begin fetchNextBytecode */
				currentBytecode = byteAtPointer(++localIP);
				/* begin pushLiteralConstant: */
				/* begin internalPush: */
				/* begin literal: */
				assert(GIV(method) == (iframeMethod(localFP)));
				object = longAt((GIV(method) + BaseHeaderSize) + (((53 & 31) + LiteralStart) << ShiftForWord));
				longAtPointerput(localSP -= BytesPerWord, object);
			}
;
			BREAK;
		CASE(54)
			/* pushLiteralConstantBytecode */
			{
				sqInt object;

				VM_LABEL(22pushLiteralConstantBytecode);
								/* begin fetchNextBytecode */
				currentBytecode = byteAtPointer(++localIP);
				/* begin pushLiteralConstant: */
				/* begin internalPush: */
				/* begin literal: */
				assert(GIV(method) == (iframeMethod(localFP)));
				object = longAt((GIV(method) + BaseHeaderSize) + (((54 & 31) + LiteralStart) << ShiftForWord));
				longAtPointerput(localSP -= BytesPerWord, object);
			}
;
			BREAK;
		CASE(55)
			/* pushLiteralConstantBytecode */
			{
				sqInt object;

				VM_LABEL(23pushLiteralConstantBytecode);
								/* begin fetchNextBytecode */
				currentBytecode = byteAtPointer(++localIP);
				/* begin pushLiteralConstant: */
				/* begin internalPush: */
				/* begin literal: */
				assert(GIV(method) == (iframeMethod(localFP)));
				object = longAt((GIV(method) + BaseHeaderSize) + (((55 & 31) + LiteralStart) << ShiftForWord));
				longAtPointerput(localSP -= BytesPerWord, object);
			}
;
			BREAK;
		CASE(56)
			/* pushLiteralConstantBytecode */
			{
				sqInt object;

				VM_LABEL(24pushLiteralConstantBytecode);
								/* begin fetchNextBytecode */
				currentBytecode = byteAtPointer(++localIP);
				/* begin pushLiteralConstant: */
				/* begin internalPush: */
				/* begin literal: */
				assert(GIV(method) == (iframeMethod(localFP)));
				object = longAt((GIV(method) + BaseHeaderSize) + (((56 & 31) + LiteralStart) << ShiftForWord));
				longAtPointerput(localSP -= BytesPerWord, object);
			}
;
			BREAK;
		CASE(57)
			/* pushLiteralConstantBytecode */
			{
				sqInt object;

				VM_LABEL(25pushLiteralConstantBytecode);
								/* begin fetchNextBytecode */
				currentBytecode = byteAtPointer(++localIP);
				/* begin pushLiteralConstant: */
				/* begin internalPush: */
				/* begin literal: */
				assert(GIV(method) == (iframeMethod(localFP)));
				object = longAt((GIV(method) + BaseHeaderSize) + (((57 & 31) + LiteralStart) << ShiftForWord));
				longAtPointerput(localSP -= BytesPerWord, object);
			}
;
			BREAK;
		CASE(58)
			/* pushLiteralConstantBytecode */
			{
				sqInt object;

				VM_LABEL(26pushLiteralConstantBytecode);
								/* begin fetchNextBytecode */
				currentBytecode = byteAtPointer(++localIP);
				/* begin pushLiteralConstant: */
				/* begin internalPush: */
				/* begin literal: */
				assert(GIV(method) == (iframeMethod(localFP)));
				object = longAt((GIV(method) + BaseHeaderSize) + (((58 & 31) + LiteralStart) << ShiftForWord));
				longAtPointerput(localSP -= BytesPerWord, object);
			}
;
			BREAK;
		CASE(59)
			/* pushLiteralConstantBytecode */
			{
				sqInt object;

				VM_LABEL(27pushLiteralConstantBytecode);
								/* begin fetchNextBytecode */
				currentBytecode = byteAtPointer(++localIP);
				/* begin pushLiteralConstant: */
				/* begin internalPush: */
				/* begin literal: */
				assert(GIV(method) == (iframeMethod(localFP)));
				object = longAt((GIV(method) + BaseHeaderSize) + (((59 & 31) + LiteralStart) << ShiftForWord));
				longAtPointerput(localSP -= BytesPerWord, object);
			}
;
			BREAK;
		CASE(60)
			/* pushLiteralConstantBytecode */
			{
				sqInt object;

				VM_LABEL(28pushLiteralConstantBytecode);
								/* begin fetchNextBytecode */
				currentBytecode = byteAtPointer(++localIP);
				/* begin pushLiteralConstant: */
				/* begin internalPush: */
				/* begin literal: */
				assert(GIV(method) == (iframeMethod(localFP)));
				object = longAt((GIV(method) + BaseHeaderSize) + (((60 & 31) + LiteralStart) << ShiftForWord));
				longAtPointerput(localSP -= BytesPerWord, object);
			}
;
			BREAK;
		CASE(61)
			/* pushLiteralConstantBytecode */
			{
				sqInt object;

				VM_LABEL(29pushLiteralConstantBytecode);
								/* begin fetchNextBytecode */
				currentBytecode = byteAtPointer(++localIP);
				/* begin pushLiteralConstant: */
				/* begin internalPush: */
				/* begin literal: */
				assert(GIV(method) == (iframeMethod(localFP)));
				object = longAt((GIV(method) + BaseHeaderSize) + (((61 & 31) + LiteralStart) << ShiftForWord));
				longAtPointerput(localSP -= BytesPerWord, object);
			}
;
			BREAK;
		CASE(62)
			/* pushLiteralConstantBytecode */
			{
				sqInt object;

				VM_LABEL(30pushLiteralConstantBytecode);
								/* begin fetchNextBytecode */
				currentBytecode = byteAtPointer(++localIP);
				/* begin pushLiteralConstant: */
				/* begin internalPush: */
				/* begin literal: */
				assert(GIV(method) == (iframeMethod(localFP)));
				object = longAt((GIV(method) + BaseHeaderSize) + (((62 & 31) + LiteralStart) << ShiftForWord));
				longAtPointerput(localSP -= BytesPerWord, object);
			}
;
			BREAK;
		CASE(63)
			/* pushLiteralConstantBytecode */
			{
				sqInt object;

				VM_LABEL(31pushLiteralConstantBytecode);
								/* begin fetchNextBytecode */
				currentBytecode = byteAtPointer(++localIP);
				/* begin pushLiteralConstant: */
				/* begin internalPush: */
				/* begin literal: */
				assert(GIV(method) == (iframeMethod(localFP)));
				object = longAt((GIV(method) + BaseHeaderSize) + (((63 & 31) + LiteralStart) << ShiftForWord));
				longAtPointerput(localSP -= BytesPerWord, object);
			}
;
			BREAK;
		CASE(64)
			/* pushLiteralVariableBytecode */
			{
				sqInt object;
				sqInt oop;

				VM_LABEL(0pushLiteralVariableBytecode);
								/* begin fetchNextBytecode */
				currentBytecode = byteAtPointer(++localIP);
				/* begin pushLiteralVariable: */
				/* begin internalPush: */
				/* begin fetchPointer:ofObject: */
				/* begin literal: */
				assert(GIV(method) == (iframeMethod(localFP)));
				oop = longAt((GIV(method) + BaseHeaderSize) + (((64 & 31) + LiteralStart) << ShiftForWord));
				object = longAt((oop + BaseHeaderSize) + (ValueIndex << ShiftForWord));
				longAtPointerput(localSP -= BytesPerWord, object);
			}
;
			BREAK;
		CASE(65)
			/* pushLiteralVariableBytecode */
			{
				sqInt object;
				sqInt oop;

				VM_LABEL(1pushLiteralVariableBytecode);
								/* begin fetchNextBytecode */
				currentBytecode = byteAtPointer(++localIP);
				/* begin pushLiteralVariable: */
				/* begin internalPush: */
				/* begin fetchPointer:ofObject: */
				/* begin literal: */
				assert(GIV(method) == (iframeMethod(localFP)));
				oop = longAt((GIV(method) + BaseHeaderSize) + (((65 & 31) + LiteralStart) << ShiftForWord));
				object = longAt((oop + BaseHeaderSize) + (ValueIndex << ShiftForWord));
				longAtPointerput(localSP -= BytesPerWord, object);
			}
;
			BREAK;
		CASE(66)
			/* pushLiteralVariableBytecode */
			{
				sqInt object;
				sqInt oop;

				VM_LABEL(2pushLiteralVariableBytecode);
								/* begin fetchNextBytecode */
				currentBytecode = byteAtPointer(++localIP);
				/* begin pushLiteralVariable: */
				/* begin internalPush: */
				/* begin fetchPointer:ofObject: */
				/* begin literal: */
				assert(GIV(method) == (iframeMethod(localFP)));
				oop = longAt((GIV(method) + BaseHeaderSize) + (((66 & 31) + LiteralStart) << ShiftForWord));
				object = longAt((oop + BaseHeaderSize) + (ValueIndex << ShiftForWord));
				longAtPointerput(localSP -= BytesPerWord, object);
			}
;
			BREAK;
		CASE(67)
			/* pushLiteralVariableBytecode */
			{
				sqInt object;
				sqInt oop;

				VM_LABEL(3pushLiteralVariableBytecode);
								/* begin fetchNextBytecode */
				currentBytecode = byteAtPointer(++localIP);
				/* begin pushLiteralVariable: */
				/* begin internalPush: */
				/* begin fetchPointer:ofObject: */
				/* begin literal: */
				assert(GIV(method) == (iframeMethod(localFP)));
				oop = longAt((GIV(method) + BaseHeaderSize) + (((67 & 31) + LiteralStart) << ShiftForWord));
				object = longAt((oop + BaseHeaderSize) + (ValueIndex << ShiftForWord));
				longAtPointerput(localSP -= BytesPerWord, object);
			}
;
			BREAK;
		CASE(68)
			/* pushLiteralVariableBytecode */
			{
				sqInt object;
				sqInt oop;

				VM_LABEL(4pushLiteralVariableBytecode);
								/* begin fetchNextBytecode */
				currentBytecode = byteAtPointer(++localIP);
				/* begin pushLiteralVariable: */
				/* begin internalPush: */
				/* begin fetchPointer:ofObject: */
				/* begin literal: */
				assert(GIV(method) == (iframeMethod(localFP)));
				oop = longAt((GIV(method) + BaseHeaderSize) + (((68 & 31) + LiteralStart) << ShiftForWord));
				object = longAt((oop + BaseHeaderSize) + (ValueIndex << ShiftForWord));
				longAtPointerput(localSP -= BytesPerWord, object);
			}
;
			BREAK;
		CASE(69)
			/* pushLiteralVariableBytecode */
			{
				sqInt object;
				sqInt oop;

				VM_LABEL(5pushLiteralVariableBytecode);
								/* begin fetchNextBytecode */
				currentBytecode = byteAtPointer(++localIP);
				/* begin pushLiteralVariable: */
				/* begin internalPush: */
				/* begin fetchPointer:ofObject: */
				/* begin literal: */
				assert(GIV(method) == (iframeMethod(localFP)));
				oop = longAt((GIV(method) + BaseHeaderSize) + (((69 & 31) + LiteralStart) << ShiftForWord));
				object = longAt((oop + BaseHeaderSize) + (ValueIndex << ShiftForWord));
				longAtPointerput(localSP -= BytesPerWord, object);
			}
;
			BREAK;
		CASE(70)
			/* pushLiteralVariableBytecode */
			{
				sqInt object;
				sqInt oop;

				VM_LABEL(6pushLiteralVariableBytecode);
								/* begin fetchNextBytecode */
				currentBytecode = byteAtPointer(++localIP);
				/* begin pushLiteralVariable: */
				/* begin internalPush: */
				/* begin fetchPointer:ofObject: */
				/* begin literal: */
				assert(GIV(method) == (iframeMethod(localFP)));
				oop = longAt((GIV(method) + BaseHeaderSize) + (((70 & 31) + LiteralStart) << ShiftForWord));
				object = longAt((oop + BaseHeaderSize) + (ValueIndex << ShiftForWord));
				longAtPointerput(localSP -= BytesPerWord, object);
			}
;
			BREAK;
		CASE(71)
			/* pushLiteralVariableBytecode */
			{
				sqInt object;
				sqInt oop;

				VM_LABEL(7pushLiteralVariableBytecode);
								/* begin fetchNextBytecode */
				currentBytecode = byteAtPointer(++localIP);
				/* begin pushLiteralVariable: */
				/* begin internalPush: */
				/* begin fetchPointer:ofObject: */
				/* begin literal: */
				assert(GIV(method) == (iframeMethod(localFP)));
				oop = longAt((GIV(method) + BaseHeaderSize) + (((71 & 31) + LiteralStart) << ShiftForWord));
				object = longAt((oop + BaseHeaderSize) + (ValueIndex << ShiftForWord));
				longAtPointerput(localSP -= BytesPerWord, object);
			}
;
			BREAK;
		CASE(72)
			/* pushLiteralVariableBytecode */
			{
				sqInt object;
				sqInt oop;

				VM_LABEL(8pushLiteralVariableBytecode);
								/* begin fetchNextBytecode */
				currentBytecode = byteAtPointer(++localIP);
				/* begin pushLiteralVariable: */
				/* begin internalPush: */
				/* begin fetchPointer:ofObject: */
				/* begin literal: */
				assert(GIV(method) == (iframeMethod(localFP)));
				oop = longAt((GIV(method) + BaseHeaderSize) + (((72 & 31) + LiteralStart) << ShiftForWord));
				object = longAt((oop + BaseHeaderSize) + (ValueIndex << ShiftForWord));
				longAtPointerput(localSP -= BytesPerWord, object);
			}
;
			BREAK;
		CASE(73)
			/* pushLiteralVariableBytecode */
			{
				sqInt object;
				sqInt oop;

				VM_LABEL(9pushLiteralVariableBytecode);
								/* begin fetchNextBytecode */
				currentBytecode = byteAtPointer(++localIP);
				/* begin pushLiteralVariable: */
				/* begin internalPush: */
				/* begin fetchPointer:ofObject: */
				/* begin literal: */
				assert(GIV(method) == (iframeMethod(localFP)));
				oop = longAt((GIV(method) + BaseHeaderSize) + (((73 & 31) + LiteralStart) << ShiftForWord));
				object = longAt((oop + BaseHeaderSize) + (ValueIndex << ShiftForWord));
				longAtPointerput(localSP -= BytesPerWord, object);
			}
;
			BREAK;
		CASE(74)
			/* pushLiteralVariableBytecode */
			{
				sqInt object;
				sqInt oop;

				VM_LABEL(10pushLiteralVariableBytecode);
								/* begin fetchNextBytecode */
				currentBytecode = byteAtPointer(++localIP);
				/* begin pushLiteralVariable: */
				/* begin internalPush: */
				/* begin fetchPointer:ofObject: */
				/* begin literal: */
				assert(GIV(method) == (iframeMethod(localFP)));
				oop = longAt((GIV(method) + BaseHeaderSize) + (((74 & 31) + LiteralStart) << ShiftForWord));
				object = longAt((oop + BaseHeaderSize) + (ValueIndex << ShiftForWord));
				longAtPointerput(localSP -= BytesPerWord, object);
			}
;
			BREAK;
		CASE(75)
			/* pushLiteralVariableBytecode */
			{
				sqInt object;
				sqInt oop;

				VM_LABEL(11pushLiteralVariableBytecode);
								/* begin fetchNextBytecode */
				currentBytecode = byteAtPointer(++localIP);
				/* begin pushLiteralVariable: */
				/* begin internalPush: */
				/* begin fetchPointer:ofObject: */
				/* begin literal: */
				assert(GIV(method) == (iframeMethod(localFP)));
				oop = longAt((GIV(method) + BaseHeaderSize) + (((75 & 31) + LiteralStart) << ShiftForWord));
				object = longAt((oop + BaseHeaderSize) + (ValueIndex << ShiftForWord));
				longAtPointerput(localSP -= BytesPerWord, object);
			}
;
			BREAK;
		CASE(76)
			/* pushLiteralVariableBytecode */
			{
				sqInt object;
				sqInt oop;

				VM_LABEL(12pushLiteralVariableBytecode);
								/* begin fetchNextBytecode */
				currentBytecode = byteAtPointer(++localIP);
				/* begin pushLiteralVariable: */
				/* begin internalPush: */
				/* begin fetchPointer:ofObject: */
				/* begin literal: */
				assert(GIV(method) == (iframeMethod(localFP)));
				oop = longAt((GIV(method) + BaseHeaderSize) + (((76 & 31) + LiteralStart) << ShiftForWord));
				object = longAt((oop + BaseHeaderSize) + (ValueIndex << ShiftForWord));
				longAtPointerput(localSP -= BytesPerWord, object);
			}
;
			BREAK;
		CASE(77)
			/* pushLiteralVariableBytecode */
			{
				sqInt object;
				sqInt oop;

				VM_LABEL(13pushLiteralVariableBytecode);
								/* begin fetchNextBytecode */
				currentBytecode = byteAtPointer(++localIP);
				/* begin pushLiteralVariable: */
				/* begin internalPush: */
				/* begin fetchPointer:ofObject: */
				/* begin literal: */
				assert(GIV(method) == (iframeMethod(localFP)));
				oop = longAt((GIV(method) + BaseHeaderSize) + (((77 & 31) + LiteralStart) << ShiftForWord));
				object = longAt((oop + BaseHeaderSize) + (ValueIndex << ShiftForWord));
				longAtPointerput(localSP -= BytesPerWord, object);
			}
;
			BREAK;
		CASE(78)
			/* pushLiteralVariableBytecode */
			{
				sqInt object;
				sqInt oop;

				VM_LABEL(14pushLiteralVariableBytecode);
								/* begin fetchNextBytecode */
				currentBytecode = byteAtPointer(++localIP);
				/* begin pushLiteralVariable: */
				/* begin internalPush: */
				/* begin fetchPointer:ofObject: */
				/* begin literal: */
				assert(GIV(method) == (iframeMethod(localFP)));
				oop = longAt((GIV(method) + BaseHeaderSize) + (((78 & 31) + LiteralStart) << ShiftForWord));
				object = longAt((oop + BaseHeaderSize) + (ValueIndex << ShiftForWord));
				longAtPointerput(localSP -= BytesPerWord, object);
			}
;
			BREAK;
		CASE(79)
			/* pushLiteralVariableBytecode */
			{
				sqInt object;
				sqInt oop;

				VM_LABEL(15pushLiteralVariableBytecode);
								/* begin fetchNextBytecode */
				currentBytecode = byteAtPointer(++localIP);
				/* begin pushLiteralVariable: */
				/* begin internalPush: */
				/* begin fetchPointer:ofObject: */
				/* begin literal: */
				assert(GIV(method) == (iframeMethod(localFP)));
				oop = longAt((GIV(method) + BaseHeaderSize) + (((79 & 31) + LiteralStart) << ShiftForWord));
				object = longAt((oop + BaseHeaderSize) + (ValueIndex << ShiftForWord));
				longAtPointerput(localSP -= BytesPerWord, object);
			}
;
			BREAK;
		CASE(80)
			/* pushLiteralVariableBytecode */
			{
				sqInt object;
				sqInt oop;

				VM_LABEL(16pushLiteralVariableBytecode);
								/* begin fetchNextBytecode */
				currentBytecode = byteAtPointer(++localIP);
				/* begin pushLiteralVariable: */
				/* begin internalPush: */
				/* begin fetchPointer:ofObject: */
				/* begin literal: */
				assert(GIV(method) == (iframeMethod(localFP)));
				oop = longAt((GIV(method) + BaseHeaderSize) + (((80 & 31) + LiteralStart) << ShiftForWord));
				object = longAt((oop + BaseHeaderSize) + (ValueIndex << ShiftForWord));
				longAtPointerput(localSP -= BytesPerWord, object);
			}
;
			BREAK;
		CASE(81)
			/* pushLiteralVariableBytecode */
			{
				sqInt object;
				sqInt oop;

				VM_LABEL(17pushLiteralVariableBytecode);
								/* begin fetchNextBytecode */
				currentBytecode = byteAtPointer(++localIP);
				/* begin pushLiteralVariable: */
				/* begin internalPush: */
				/* begin fetchPointer:ofObject: */
				/* begin literal: */
				assert(GIV(method) == (iframeMethod(localFP)));
				oop = longAt((GIV(method) + BaseHeaderSize) + (((81 & 31) + LiteralStart) << ShiftForWord));
				object = longAt((oop + BaseHeaderSize) + (ValueIndex << ShiftForWord));
				longAtPointerput(localSP -= BytesPerWord, object);
			}
;
			BREAK;
		CASE(82)
			/* pushLiteralVariableBytecode */
			{
				sqInt object;
				sqInt oop;

				VM_LABEL(18pushLiteralVariableBytecode);
								/* begin fetchNextBytecode */
				currentBytecode = byteAtPointer(++localIP);
				/* begin pushLiteralVariable: */
				/* begin internalPush: */
				/* begin fetchPointer:ofObject: */
				/* begin literal: */
				assert(GIV(method) == (iframeMethod(localFP)));
				oop = longAt((GIV(method) + BaseHeaderSize) + (((82 & 31) + LiteralStart) << ShiftForWord));
				object = longAt((oop + BaseHeaderSize) + (ValueIndex << ShiftForWord));
				longAtPointerput(localSP -= BytesPerWord, object);
			}
;
			BREAK;
		CASE(83)
			/* pushLiteralVariableBytecode */
			{
				sqInt object;
				sqInt oop;

				VM_LABEL(19pushLiteralVariableBytecode);
								/* begin fetchNextBytecode */
				currentBytecode = byteAtPointer(++localIP);
				/* begin pushLiteralVariable: */
				/* begin internalPush: */
				/* begin fetchPointer:ofObject: */
				/* begin literal: */
				assert(GIV(method) == (iframeMethod(localFP)));
				oop = longAt((GIV(method) + BaseHeaderSize) + (((83 & 31) + LiteralStart) << ShiftForWord));
				object = longAt((oop + BaseHeaderSize) + (ValueIndex << ShiftForWord));
				longAtPointerput(localSP -= BytesPerWord, object);
			}
;
			BREAK;
		CASE(84)
			/* pushLiteralVariableBytecode */
			{
				sqInt object;
				sqInt oop;

				VM_LABEL(20pushLiteralVariableBytecode);
								/* begin fetchNextBytecode */
				currentBytecode = byteAtPointer(++localIP);
				/* begin pushLiteralVariable: */
				/* begin internalPush: */
				/* begin fetchPointer:ofObject: */
				/* begin literal: */
				assert(GIV(method) == (iframeMethod(localFP)));
				oop = longAt((GIV(method) + BaseHeaderSize) + (((84 & 31) + LiteralStart) << ShiftForWord));
				object = longAt((oop + BaseHeaderSize) + (ValueIndex << ShiftForWord));
				longAtPointerput(localSP -= BytesPerWord, object);
			}
;
			BREAK;
		CASE(85)
			/* pushLiteralVariableBytecode */
			{
				sqInt object;
				sqInt oop;

				VM_LABEL(21pushLiteralVariableBytecode);
								/* begin fetchNextBytecode */
				currentBytecode = byteAtPointer(++localIP);
				/* begin pushLiteralVariable: */
				/* begin internalPush: */
				/* begin fetchPointer:ofObject: */
				/* begin literal: */
				assert(GIV(method) == (iframeMethod(localFP)));
				oop = longAt((GIV(method) + BaseHeaderSize) + (((85 & 31) + LiteralStart) << ShiftForWord));
				object = longAt((oop + BaseHeaderSize) + (ValueIndex << ShiftForWord));
				longAtPointerput(localSP -= BytesPerWord, object);
			}
;
			BREAK;
		CASE(86)
			/* pushLiteralVariableBytecode */
			{
				sqInt object;
				sqInt oop;

				VM_LABEL(22pushLiteralVariableBytecode);
								/* begin fetchNextBytecode */
				currentBytecode = byteAtPointer(++localIP);
				/* begin pushLiteralVariable: */
				/* begin internalPush: */
				/* begin fetchPointer:ofObject: */
				/* begin literal: */
				assert(GIV(method) == (iframeMethod(localFP)));
				oop = longAt((GIV(method) + BaseHeaderSize) + (((86 & 31) + LiteralStart) << ShiftForWord));
				object = longAt((oop + BaseHeaderSize) + (ValueIndex << ShiftForWord));
				longAtPointerput(localSP -= BytesPerWord, object);
			}
;
			BREAK;
		CASE(87)
			/* pushLiteralVariableBytecode */
			{
				sqInt object;
				sqInt oop;

				VM_LABEL(23pushLiteralVariableBytecode);
								/* begin fetchNextBytecode */
				currentBytecode = byteAtPointer(++localIP);
				/* begin pushLiteralVariable: */
				/* begin internalPush: */
				/* begin fetchPointer:ofObject: */
				/* begin literal: */
				assert(GIV(method) == (iframeMethod(localFP)));
				oop = longAt((GIV(method) + BaseHeaderSize) + (((87 & 31) + LiteralStart) << ShiftForWord));
				object = longAt((oop + BaseHeaderSize) + (ValueIndex << ShiftForWord));
				longAtPointerput(localSP -= BytesPerWord, object);
			}
;
			BREAK;
		CASE(88)
			/* pushLiteralVariableBytecode */
			{
				sqInt object;
				sqInt oop;

				VM_LABEL(24pushLiteralVariableBytecode);
								/* begin fetchNextBytecode */
				currentBytecode = byteAtPointer(++localIP);
				/* begin pushLiteralVariable: */
				/* begin internalPush: */
				/* begin fetchPointer:ofObject: */
				/* begin literal: */
				assert(GIV(method) == (iframeMethod(localFP)));
				oop = longAt((GIV(method) + BaseHeaderSize) + (((88 & 31) + LiteralStart) << ShiftForWord));
				object = longAt((oop + BaseHeaderSize) + (ValueIndex << ShiftForWord));
				longAtPointerput(localSP -= BytesPerWord, object);
			}
;
			BREAK;
		CASE(89)
			/* pushLiteralVariableBytecode */
			{
				sqInt object;
				sqInt oop;

				VM_LABEL(25pushLiteralVariableBytecode);
								/* begin fetchNextBytecode */
				currentBytecode = byteAtPointer(++localIP);
				/* begin pushLiteralVariable: */
				/* begin internalPush: */
				/* begin fetchPointer:ofObject: */
				/* begin literal: */
				assert(GIV(method) == (iframeMethod(localFP)));
				oop = longAt((GIV(method) + BaseHeaderSize) + (((89 & 31) + LiteralStart) << ShiftForWord));
				object = longAt((oop + BaseHeaderSize) + (ValueIndex << ShiftForWord));
				longAtPointerput(localSP -= BytesPerWord, object);
			}
;
			BREAK;
		CASE(90)
			/* pushLiteralVariableBytecode */
			{
				sqInt object;
				sqInt oop;

				VM_LABEL(26pushLiteralVariableBytecode);
								/* begin fetchNextBytecode */
				currentBytecode = byteAtPointer(++localIP);
				/* begin pushLiteralVariable: */
				/* begin internalPush: */
				/* begin fetchPointer:ofObject: */
				/* begin literal: */
				assert(GIV(method) == (iframeMethod(localFP)));
				oop = longAt((GIV(method) + BaseHeaderSize) + (((90 & 31) + LiteralStart) << ShiftForWord));
				object = longAt((oop + BaseHeaderSize) + (ValueIndex << ShiftForWord));
				longAtPointerput(localSP -= BytesPerWord, object);
			}
;
			BREAK;
		CASE(91)
			/* pushLiteralVariableBytecode */
			{
				sqInt object;
				sqInt oop;

				VM_LABEL(27pushLiteralVariableBytecode);
								/* begin fetchNextBytecode */
				currentBytecode = byteAtPointer(++localIP);
				/* begin pushLiteralVariable: */
				/* begin internalPush: */
				/* begin fetchPointer:ofObject: */
				/* begin literal: */
				assert(GIV(method) == (iframeMethod(localFP)));
				oop = longAt((GIV(method) + BaseHeaderSize) + (((91 & 31) + LiteralStart) << ShiftForWord));
				object = longAt((oop + BaseHeaderSize) + (ValueIndex << ShiftForWord));
				longAtPointerput(localSP -= BytesPerWord, object);
			}
;
			BREAK;
		CASE(92)
			/* pushLiteralVariableBytecode */
			{
				sqInt object;
				sqInt oop;

				VM_LABEL(28pushLiteralVariableBytecode);
								/* begin fetchNextBytecode */
				currentBytecode = byteAtPointer(++localIP);
				/* begin pushLiteralVariable: */
				/* begin internalPush: */
				/* begin fetchPointer:ofObject: */
				/* begin literal: */
				assert(GIV(method) == (iframeMethod(localFP)));
				oop = longAt((GIV(method) + BaseHeaderSize) + (((92 & 31) + LiteralStart) << ShiftForWord));
				object = longAt((oop + BaseHeaderSize) + (ValueIndex << ShiftForWord));
				longAtPointerput(localSP -= BytesPerWord, object);
			}
;
			BREAK;
		CASE(93)
			/* pushLiteralVariableBytecode */
			{
				sqInt object;
				sqInt oop;

				VM_LABEL(29pushLiteralVariableBytecode);
								/* begin fetchNextBytecode */
				currentBytecode = byteAtPointer(++localIP);
				/* begin pushLiteralVariable: */
				/* begin internalPush: */
				/* begin fetchPointer:ofObject: */
				/* begin literal: */
				assert(GIV(method) == (iframeMethod(localFP)));
				oop = longAt((GIV(method) + BaseHeaderSize) + (((93 & 31) + LiteralStart) << ShiftForWord));
				object = longAt((oop + BaseHeaderSize) + (ValueIndex << ShiftForWord));
				longAtPointerput(localSP -= BytesPerWord, object);
			}
;
			BREAK;
		CASE(94)
			/* pushLiteralVariableBytecode */
			{
				sqInt object;
				sqInt oop;

				VM_LABEL(30pushLiteralVariableBytecode);
								/* begin fetchNextBytecode */
				currentBytecode = byteAtPointer(++localIP);
				/* begin pushLiteralVariable: */
				/* begin internalPush: */
				/* begin fetchPointer:ofObject: */
				/* begin literal: */
				assert(GIV(method) == (iframeMethod(localFP)));
				oop = longAt((GIV(method) + BaseHeaderSize) + (((94 & 31) + LiteralStart) << ShiftForWord));
				object = longAt((oop + BaseHeaderSize) + (ValueIndex << ShiftForWord));
				longAtPointerput(localSP -= BytesPerWord, object);
			}
;
			BREAK;
		CASE(95)
			/* pushLiteralVariableBytecode */
			{
				sqInt object;
				sqInt oop;

				VM_LABEL(31pushLiteralVariableBytecode);
								/* begin fetchNextBytecode */
				currentBytecode = byteAtPointer(++localIP);
				/* begin pushLiteralVariable: */
				/* begin internalPush: */
				/* begin fetchPointer:ofObject: */
				/* begin literal: */
				assert(GIV(method) == (iframeMethod(localFP)));
				oop = longAt((GIV(method) + BaseHeaderSize) + (((95 & 31) + LiteralStart) << ShiftForWord));
				object = longAt((oop + BaseHeaderSize) + (ValueIndex << ShiftForWord));
				longAtPointerput(localSP -= BytesPerWord, object);
			}
;
			BREAK;
		CASE(96)
		CASE(97)
		CASE(98)
		CASE(99)
		CASE(100)
		CASE(101)
		CASE(102)
		CASE(103)
			/* storeAndPopReceiverVariableBytecode */
			{
				sqInt rcvr;
				sqInt top;

				VM_LABEL(0storeAndPopReceiverVariableBytecode);
								rcvr = longAt(localFP + FoxIFReceiver);
				top = longAtPointer(localSP);
				if (oopisLessThan(rcvr, youngStart())) {
					possibleRootStoreIntovalue(rcvr, top);
				}
				longAtput((rcvr + BaseHeaderSize) + ((currentBytecode & 7) << ShiftForWord), top);
				/* begin fetchNextBytecode */
				currentBytecode = byteAtPointer(++localIP);
				/* begin internalPop: */
				localSP += 1 * BytesPerWord;
			}
;
			BREAK;
		CASE(104)
			/* storeAndPopTemporaryVariableBytecode */
			{
				sqInt frameNumArgs;

				VM_LABEL(0storeAndPopTemporaryVariableBytecode);
								/* begin fetchNextBytecode */
				currentBytecode = byteAtPointer(++localIP);
				/* begin itemporary:in:put: */
				VM_LABEL(0itemporaryinput);
				if ((104 & 7) < ((frameNumArgs = byteAt((localFP + FoxIFrameFlags) + 1)))) {
					longAtput((localFP + FoxCallerSavedIP) + ((frameNumArgs - (104 & 7)) * BytesPerWord), longAtPointer(localSP));
				}
				else {
					longAtput(((localFP + FoxIFReceiver) - BytesPerWord) + ((frameNumArgs - (104 & 7)) * BytesPerWord), longAtPointer(localSP));
				}
				/* begin internalPop: */
				localSP += 1 * BytesPerWord;
			}
;
			BREAK;
		CASE(105)
			/* storeAndPopTemporaryVariableBytecode */
			{
				sqInt frameNumArgs;

				VM_LABEL(1storeAndPopTemporaryVariableBytecode);
								/* begin fetchNextBytecode */
				currentBytecode = byteAtPointer(++localIP);
				/* begin itemporary:in:put: */
				VM_LABEL(1itemporaryinput);
				if ((105 & 7) < ((frameNumArgs = byteAt((localFP + FoxIFrameFlags) + 1)))) {
					longAtput((localFP + FoxCallerSavedIP) + ((frameNumArgs - (105 & 7)) * BytesPerWord), longAtPointer(localSP));
				}
				else {
					longAtput(((localFP + FoxIFReceiver) - BytesPerWord) + ((frameNumArgs - (105 & 7)) * BytesPerWord), longAtPointer(localSP));
				}
				/* begin internalPop: */
				localSP += 1 * BytesPerWord;
			}
;
			BREAK;
		CASE(106)
			/* storeAndPopTemporaryVariableBytecode */
			{
				sqInt frameNumArgs;

				VM_LABEL(2storeAndPopTemporaryVariableBytecode);
								/* begin fetchNextBytecode */
				currentBytecode = byteAtPointer(++localIP);
				/* begin itemporary:in:put: */
				VM_LABEL(2itemporaryinput);
				if ((106 & 7) < ((frameNumArgs = byteAt((localFP + FoxIFrameFlags) + 1)))) {
					longAtput((localFP + FoxCallerSavedIP) + ((frameNumArgs - (106 & 7)) * BytesPerWord), longAtPointer(localSP));
				}
				else {
					longAtput(((localFP + FoxIFReceiver) - BytesPerWord) + ((frameNumArgs - (106 & 7)) * BytesPerWord), longAtPointer(localSP));
				}
				/* begin internalPop: */
				localSP += 1 * BytesPerWord;
			}
;
			BREAK;
		CASE(107)
			/* storeAndPopTemporaryVariableBytecode */
			{
				sqInt frameNumArgs;

				VM_LABEL(3storeAndPopTemporaryVariableBytecode);
								/* begin fetchNextBytecode */
				currentBytecode = byteAtPointer(++localIP);
				/* begin itemporary:in:put: */
				VM_LABEL(3itemporaryinput);
				if ((107 & 7) < ((frameNumArgs = byteAt((localFP + FoxIFrameFlags) + 1)))) {
					longAtput((localFP + FoxCallerSavedIP) + ((frameNumArgs - (107 & 7)) * BytesPerWord), longAtPointer(localSP));
				}
				else {
					longAtput(((localFP + FoxIFReceiver) - BytesPerWord) + ((frameNumArgs - (107 & 7)) * BytesPerWord), longAtPointer(localSP));
				}
				/* begin internalPop: */
				localSP += 1 * BytesPerWord;
			}
;
			BREAK;
		CASE(108)
			/* storeAndPopTemporaryVariableBytecode */
			{
				sqInt frameNumArgs;

				VM_LABEL(4storeAndPopTemporaryVariableBytecode);
								/* begin fetchNextBytecode */
				currentBytecode = byteAtPointer(++localIP);
				/* begin itemporary:in:put: */
				VM_LABEL(4itemporaryinput);
				if ((108 & 7) < ((frameNumArgs = byteAt((localFP + FoxIFrameFlags) + 1)))) {
					longAtput((localFP + FoxCallerSavedIP) + ((frameNumArgs - (108 & 7)) * BytesPerWord), longAtPointer(localSP));
				}
				else {
					longAtput(((localFP + FoxIFReceiver) - BytesPerWord) + ((frameNumArgs - (108 & 7)) * BytesPerWord), longAtPointer(localSP));
				}
				/* begin internalPop: */
				localSP += 1 * BytesPerWord;
			}
;
			BREAK;
		CASE(109)
			/* storeAndPopTemporaryVariableBytecode */
			{
				sqInt frameNumArgs;

				VM_LABEL(5storeAndPopTemporaryVariableBytecode);
								/* begin fetchNextBytecode */
				currentBytecode = byteAtPointer(++localIP);
				/* begin itemporary:in:put: */
				VM_LABEL(5itemporaryinput);
				if ((109 & 7) < ((frameNumArgs = byteAt((localFP + FoxIFrameFlags) + 1)))) {
					longAtput((localFP + FoxCallerSavedIP) + ((frameNumArgs - (109 & 7)) * BytesPerWord), longAtPointer(localSP));
				}
				else {
					longAtput(((localFP + FoxIFReceiver) - BytesPerWord) + ((frameNumArgs - (109 & 7)) * BytesPerWord), longAtPointer(localSP));
				}
				/* begin internalPop: */
				localSP += 1 * BytesPerWord;
			}
;
			BREAK;
		CASE(110)
			/* storeAndPopTemporaryVariableBytecode */
			{
				sqInt frameNumArgs;

				VM_LABEL(6storeAndPopTemporaryVariableBytecode);
								/* begin fetchNextBytecode */
				currentBytecode = byteAtPointer(++localIP);
				/* begin itemporary:in:put: */
				VM_LABEL(6itemporaryinput);
				if ((110 & 7) < ((frameNumArgs = byteAt((localFP + FoxIFrameFlags) + 1)))) {
					longAtput((localFP + FoxCallerSavedIP) + ((frameNumArgs - (110 & 7)) * BytesPerWord), longAtPointer(localSP));
				}
				else {
					longAtput(((localFP + FoxIFReceiver) - BytesPerWord) + ((frameNumArgs - (110 & 7)) * BytesPerWord), longAtPointer(localSP));
				}
				/* begin internalPop: */
				localSP += 1 * BytesPerWord;
			}
;
			BREAK;
		CASE(111)
			/* storeAndPopTemporaryVariableBytecode */
			{
				sqInt frameNumArgs;

				VM_LABEL(7storeAndPopTemporaryVariableBytecode);
								/* begin fetchNextBytecode */
				currentBytecode = byteAtPointer(++localIP);
				/* begin itemporary:in:put: */
				VM_LABEL(7itemporaryinput);
				if ((111 & 7) < ((frameNumArgs = byteAt((localFP + FoxIFrameFlags) + 1)))) {
					longAtput((localFP + FoxCallerSavedIP) + ((frameNumArgs - (111 & 7)) * BytesPerWord), longAtPointer(localSP));
				}
				else {
					longAtput(((localFP + FoxIFReceiver) - BytesPerWord) + ((frameNumArgs - (111 & 7)) * BytesPerWord), longAtPointer(localSP));
				}
				/* begin internalPop: */
				localSP += 1 * BytesPerWord;
			}
;
			BREAK;
		CASE(112)
			/* pushReceiverBytecode */
			{

				VM_LABEL(0pushReceiverBytecode);
								/* begin fetchNextBytecode */
				currentBytecode = byteAtPointer(++localIP);
				/* begin internalPush: */
				longAtPointerput(localSP -= BytesPerWord, longAt(localFP + FoxIFReceiver));
			}
;
			BREAK;
		CASE(113)
			/* pushConstantTrueBytecode */
			{

				VM_LABEL(0pushConstantTrueBytecode);
								/* begin fetchNextBytecode */
				currentBytecode = byteAtPointer(++localIP);
				/* begin internalPush: */
				longAtPointerput(localSP -= BytesPerWord, GIV(trueObj));
			}
;
			BREAK;
		CASE(114)
			/* pushConstantFalseBytecode */
			{

				VM_LABEL(0pushConstantFalseBytecode);
								/* begin fetchNextBytecode */
				currentBytecode = byteAtPointer(++localIP);
				/* begin internalPush: */
				longAtPointerput(localSP -= BytesPerWord, GIV(falseObj));
			}
;
			BREAK;
		CASE(115)
			/* pushConstantNilBytecode */
			{

				VM_LABEL(0pushConstantNilBytecode);
								/* begin fetchNextBytecode */
				currentBytecode = byteAtPointer(++localIP);
				/* begin internalPush: */
				longAtPointerput(localSP -= BytesPerWord, GIV(nilObj));
			}
;
			BREAK;
		CASE(116)
			/* pushConstantMinusOneBytecode */
			{

				VM_LABEL(0pushConstantMinusOneBytecode);
								/* begin fetchNextBytecode */
				currentBytecode = byteAtPointer(++localIP);
				/* begin internalPush: */
				longAtPointerput(localSP -= BytesPerWord, ConstMinusOne);
			}
;
			BREAK;
		CASE(117)
			/* pushConstantZeroBytecode */
			{

				VM_LABEL(0pushConstantZeroBytecode);
								/* begin fetchNextBytecode */
				currentBytecode = byteAtPointer(++localIP);
				/* begin internalPush: */
				longAtPointerput(localSP -= BytesPerWord, ConstZero);
			}
;
			BREAK;
		CASE(118)
			/* pushConstantOneBytecode */
			{

				VM_LABEL(0pushConstantOneBytecode);
								/* begin fetchNextBytecode */
				currentBytecode = byteAtPointer(++localIP);
				/* begin internalPush: */
				longAtPointerput(localSP -= BytesPerWord, ConstOne);
			}
;
			BREAK;
		CASE(119)
			/* pushConstantTwoBytecode */
			{

				VM_LABEL(0pushConstantTwoBytecode);
								/* begin fetchNextBytecode */
				currentBytecode = byteAtPointer(++localIP);
				/* begin internalPush: */
				longAtPointerput(localSP -= BytesPerWord, ConstTwo);
			}
;
			BREAK;
		CASE(120)
			/* returnReceiver */
			{

				VM_LABEL(0returnReceiver);
								localReturnValue = longAt(localFP + FoxIFReceiver);
				/* goto commonReturn */
			}
;
			
		commonReturn:
			/* commonReturn */
			{
				char *callerFP;
				sqInt closure;
				sqInt contextToReturnTo;
				sqInt currentCtx;
				char *frameToReturnTo;
				sqInt home;
				StackPage *newPage;
				sqInt nextCntx;
				char *theFP;
				StackPage *thePage;
				sqInt unwindContextOrNilOrZero;
				sqInt callerContextOrNil;
				StackPage *thePage1;
				sqInt value;
				sqInt value1;
				sqInt index;
				char *theFP1;
				sqInt callerContextOrNil1;
				StackPage *thePage2;
				char *theFP2;
				sqInt callerContextOrNil2;
				StackPage *thePage3;
				StackPage *aPage;
				sqInt ctxtOrNilOrZero;
				sqInt theMethod;
				sqInt index1;
				sqInt index2;
				sqInt index3;
				sqInt index4;
				sqInt ourContext;
				sqInt ourContext1;
				sqInt ourContext2;

				VM_LABEL(0commonReturn);
								if (!(((((usqInt)(longAt(localFP + FoxMethod)))) < heapBase
						? ((longAt(localFP + FoxMethod)) & MFMethodFlagIsBlockFlag) != 0
						: (byteAt((localFP + FoxIFrameFlags) + 3)) != 0))) {
					goto commonCallerReturn;
					goto l94;
				}
				closure = longAt(localFP + ((FoxCallerSavedIP + BytesPerWord) + ((((((usqInt)(longAt(localFP + FoxMethod)))) < heapBase
	? (mframeCogMethod(localFP)->cmNumArgs)
	: byteAt((localFP + FoxIFrameFlags) + 1))) << ShiftForWord)));

				/* Walk the closure's lexical chain to find the context or frame to return from (home). */

				home = null;
				while (closure != GIV(nilObj)) {
					home = longAt((closure + BaseHeaderSize) + (ClosureOuterContextIndex << ShiftForWord));
					closure = longAt((home + BaseHeaderSize) + (ClosureIndex << ShiftForWord));
				}
				/* begin writeBackHeadFramePointers */
				VM_LABEL(0writeBackHeadFramePointers);
				assert(GIV(stackPage) == (mostRecentlyUsedPage()));
				/* begin setHeadFP:andSP:inPage: */
				assert(localSP < localFP);
				assert((localSP < ((GIV(stackPage)->baseAddress)))
				 && (localSP > (((GIV(stackPage)->realStackLimit)) - LargeContextSize)));
				assert((localFP < ((GIV(stackPage)->baseAddress)))
				 && (localFP > (((GIV(stackPage)->realStackLimit)) - (((sqInt) LargeContextSize >> 1)))));
				(GIV(stackPage)->headFP = localFP);
				(GIV(stackPage)->headSP = localSP);
				assert(pageListIsWellFormed());
				/* begin internalFindUnwindThroughContext: */
				/* begin externalizeIPandSP */
				assert((((usqInt)localIP)) != (ceReturnToInterpreterPC()));
				GIV(instructionPointer) = oopForPointer(localIP);
				GIV(stackPointer) = localSP;
				GIV(framePointer) = localFP;
				/* begin findUnwindThroughContext: */
				ctxtOrNilOrZero = findMethodWithPrimitiveFromFPUpToContext(198, GIV(framePointer), home);
				if (ctxtOrNilOrZero == 0) {
					theMethod = longAt((home + BaseHeaderSize) + (MethodIndex << ShiftForWord));
					if ((primitiveIndexOf(theMethod)) == 198) {
						unwindContextOrNilOrZero = home;
						goto l95;
					}
				}
				unwindContextOrNilOrZero = ctxtOrNilOrZero;
			l95:	/* end internalFindUnwindThroughContext: */;
				if (unwindContextOrNilOrZero == GIV(nilObj)) {
					/* begin internalCannotReturn: */
					VM_LABEL(0internalCannotReturn);
					/* begin ensureFrameIsMarried:SP: */
					VM_LABEL(0ensureFrameIsMarriedSP);
					if (((((usqInt)(longAt(localFP + FoxMethod)))) < heapBase
						? ((longAt(localFP + FoxMethod)) & MFMethodFlagHasContextFlag) != 0
						: (byteAt((localFP + FoxIFrameFlags) + 2)) != 0)) {
						assert(isContext(frameContext(localFP)));
						ourContext = longAt(localFP + FoxThisContext);
						goto l96;
					}
					ourContext = marryFrameSP(localFP, localSP);
				l96:	/* end ensureFrameIsMarried:SP: */;
					/* begin internalPush: */
					longAtPointerput(localSP -= BytesPerWord, ourContext);
					/* begin internalPush: */
					longAtPointerput(localSP -= BytesPerWord, localReturnValue);
					GIV(messageSelector) = longAt((GIV(specialObjectsOop) + BaseHeaderSize) + (SelectorCannotReturn << ShiftForWord));
					GIV(argumentCount) = 1;
					goto normalSend;
					goto l94;
				}
				if (unwindContextOrNilOrZero != 0) {
					/* begin internalAboutToReturn:through: */
					VM_LABEL(0internalAboutToReturnthrough);
					/* begin ensureFrameIsMarried:SP: */
					VM_LABEL(1ensureFrameIsMarriedSP);
					if (((((usqInt)(longAt(localFP + FoxMethod)))) < heapBase
						? ((longAt(localFP + FoxMethod)) & MFMethodFlagHasContextFlag) != 0
						: (byteAt((localFP + FoxIFrameFlags) + 2)) != 0)) {
						assert(isContext(frameContext(localFP)));
						ourContext1 = longAt(localFP + FoxThisContext);
						goto l97;
					}
					ourContext1 = marryFrameSP(localFP, localSP);
				l97:	/* end ensureFrameIsMarried:SP: */;
					/* begin internalPush: */
					longAtPointerput(localSP -= BytesPerWord, ourContext1);
					/* begin internalPush: */
					longAtPointerput(localSP -= BytesPerWord, localReturnValue);
					/* begin internalPush: */
					longAtPointerput(localSP -= BytesPerWord, unwindContextOrNilOrZero);
					GIV(messageSelector) = longAt((GIV(specialObjectsOop) + BaseHeaderSize) + (SelectorAboutToReturn << ShiftForWord));
					GIV(argumentCount) = 2;
					goto normalSend;
					goto l94;
				}
				contextToReturnTo = null;
				if (((longAt((home + BaseHeaderSize) + (SenderIndex << ShiftForWord))) & 1)) {
					assert(checkIsStillMarriedContextcurrentFP(home, localFP));
					/* begin frameOfMarriedContext: */
					value = longAt((home + BaseHeaderSize) + (SenderIndex << ShiftForWord));
					/* begin withoutSmallIntegerTags: */
					assert((value & 1));
					theFP = pointerForOop(value - 1);
					if ((longAt(theFP + FoxSavedFP)) == 0) {
						/* begin frameCallerContext: */
						assert(isBaseFrame(theFP));
						/* begin stackPageFor: */
						/* begin stackPageAt: */
						/* begin pageIndexFor: */
						assert((((((char *) theFP)) >= (GIV(stackBasePlus1) - 1)) && ((((char *) theFP)) <= (((char *) GIV(pages))))));
						index2 = pageIndexForstackBasePlus1bytesPerPage(theFP, GIV(stackBasePlus1), GIV(bytesPerPage));
						thePage1 = stackPageAtpages(index2, GIV(pages));
						callerContextOrNil = longAt((thePage1->baseAddress));
						assert(addressCouldBeObj(callerContextOrNil));
						assert((callerContextOrNil == (nilObject()))
						 || (isContext(callerContextOrNil)));
						contextToReturnTo = callerContextOrNil;
					}
					else {
						/* begin frameCallerFP: */
						frameToReturnTo = pointerForOop(longAt(theFP + FoxSavedFP));
					}
				}
				else {
					contextToReturnTo = longAt((home + BaseHeaderSize) + (SenderIndex << ShiftForWord));
					if ((((contextToReturnTo & 1) == 0)
 && (((((usqInt) (longAt(contextToReturnTo))) >> 12) & 31) == ClassMethodContextCompactIndex))
					 && (((longAt((contextToReturnTo + BaseHeaderSize) + (SenderIndex << ShiftForWord))) & 1))) {
						assert(checkIsStillMarriedContextcurrentFP(contextToReturnTo, localFP));
						/* begin frameOfMarriedContext: */
						value1 = longAt((contextToReturnTo + BaseHeaderSize) + (SenderIndex << ShiftForWord));
						/* begin withoutSmallIntegerTags: */
						assert((value1 & 1));
						frameToReturnTo = pointerForOop(value1 - 1);
						contextToReturnTo = null;
					}
				}
				if (contextToReturnTo != null) {
					frameToReturnTo = establishFrameForContextToReturnTo(contextToReturnTo);
					if (frameToReturnTo == 0) {
						/* begin internalCannotReturn: */
						VM_LABEL(1internalCannotReturn);
						/* begin ensureFrameIsMarried:SP: */
						VM_LABEL(2ensureFrameIsMarriedSP);
						if (((((usqInt)(longAt(localFP + FoxMethod)))) < heapBase
							? ((longAt(localFP + FoxMethod)) & MFMethodFlagHasContextFlag) != 0
							: (byteAt((localFP + FoxIFrameFlags) + 2)) != 0)) {
							assert(isContext(frameContext(localFP)));
							ourContext2 = longAt(localFP + FoxThisContext);
							goto l98;
						}
						ourContext2 = marryFrameSP(localFP, localSP);
					l98:	/* end ensureFrameIsMarried:SP: */;
						/* begin internalPush: */
						longAtPointerput(localSP -= BytesPerWord, ourContext2);
						/* begin internalPush: */
						longAtPointerput(localSP -= BytesPerWord, localReturnValue);
						GIV(messageSelector) = longAt((GIV(specialObjectsOop) + BaseHeaderSize) + (SelectorCannotReturn << ShiftForWord));
						GIV(argumentCount) = 1;
						goto normalSend;
						goto l94;
					}
				}
				assert(pageListIsWellFormed());
				/* begin stackPageFor: */
				/* begin stackPageAt: */
				/* begin pageIndexFor: */
				assert((((((char *) frameToReturnTo)) >= (GIV(stackBasePlus1) - 1)) && ((((char *) frameToReturnTo)) <= (((char *) GIV(pages))))));
				index1 = pageIndexForstackBasePlus1bytesPerPage(frameToReturnTo, GIV(stackBasePlus1), GIV(bytesPerPage));
				newPage = stackPageAtpages(index1, GIV(pages));
				if (newPage != GIV(stackPage)) {
					/* begin frameCallerContext: */
					theFP2 = (GIV(stackPage)->baseFP);
					assert(isBaseFrame(theFP2));
					/* begin stackPageFor: */
					/* begin stackPageAt: */
					/* begin pageIndexFor: */
					assert((((((char *) theFP2)) >= (GIV(stackBasePlus1) - 1)) && ((((char *) theFP2)) <= (((char *) GIV(pages))))));
					index4 = pageIndexForstackBasePlus1bytesPerPage(theFP2, GIV(stackBasePlus1), GIV(bytesPerPage));
					thePage3 = stackPageAtpages(index4, GIV(pages));
					callerContextOrNil2 = longAt((thePage3->baseAddress));
					assert(addressCouldBeObj(callerContextOrNil2));
					assert((callerContextOrNil2 == (nilObject()))
					 || (isContext(callerContextOrNil2)));
					currentCtx = callerContextOrNil2;
					assert(isContext(currentCtx));
					/* begin freeStackPage: */
					aPage = GIV(stackPage);
					freeStackPageNoAssert(aPage);
					assert(pageListIsWellFormed());
					while (!((((longAt((currentCtx + BaseHeaderSize) + (SenderIndex << ShiftForWord))) & 1))
 && ((stackPageFor(theFP = frameOfMarriedContext(currentCtx))) == newPage))) {
						if (((longAt((currentCtx + BaseHeaderSize) + (SenderIndex << ShiftForWord))) & 1)) {
							/* begin stackPageFor: */
							/* begin stackPageAt: */
							/* begin pageIndexFor: */
							assert((((((char *) theFP)) >= (GIV(stackBasePlus1) - 1)) && ((((char *) theFP)) <= (((char *) GIV(pages))))));
							index = pageIndexForstackBasePlus1bytesPerPage(theFP, GIV(stackBasePlus1), GIV(bytesPerPage));
							thePage = stackPageAtpages(index, GIV(pages));
							if (theFP != ((thePage->headFP))) {
								moveFramesInthroughtoPage(thePage, findFrameAboveinPage(theFP, thePage), newStackPage());
							}
							/* begin frameCallerContext: */
							theFP1 = (thePage->baseFP);
							assert(isBaseFrame(theFP1));
							/* begin stackPageFor: */
							/* begin stackPageAt: */
							/* begin pageIndexFor: */
							assert((((((char *) theFP1)) >= (GIV(stackBasePlus1) - 1)) && ((((char *) theFP1)) <= (((char *) GIV(pages))))));
							index3 = pageIndexForstackBasePlus1bytesPerPage(theFP1, GIV(stackBasePlus1), GIV(bytesPerPage));
							thePage2 = stackPageAtpages(index3, GIV(pages));
							callerContextOrNil1 = longAt((thePage2->baseAddress));
							assert(addressCouldBeObj(callerContextOrNil1));
							assert((callerContextOrNil1 == (nilObject()))
							 || (isContext(callerContextOrNil1)));
							currentCtx = callerContextOrNil1;
							/* begin freeStackPage: */
							freeStackPageNoAssert(thePage);
							assert(pageListIsWellFormed());
						}
						else {
							nextCntx = longAt((currentCtx + BaseHeaderSize) + (SenderIndex << ShiftForWord));
							/* begin markContextAsDead: */
							assert(isContext(currentCtx));
							longAtput((currentCtx + BaseHeaderSize) + (SenderIndex << ShiftForWord), GIV(nilObj));
							longAtput((currentCtx + BaseHeaderSize) + (InstructionPointerIndex << ShiftForWord), GIV(nilObj));
							currentCtx = nextCntx;
						}
					}
					/* begin setStackPageAndLimit: */
					GIV(stackPage) = newPage;
					if (GIV(stackLimit) != (((char *) (((usqInt) -1))))) {
						GIV(stackLimit) = (GIV(stackPage)->stackLimit);
					}
					markStackPageMostRecentlyUsed(newPage);
					localSP = (GIV(stackPage)->headSP);
					localFP = (GIV(stackPage)->headFP);
				}
				if (localFP == frameToReturnTo) {
					localIP = pointerForOop(longAtPointer(localSP));
				}
				else {
					do {
						callerFP = localFP;
						/* begin frameCallerFP: */
						localFP = pointerForOop(longAt(localFP + FoxSavedFP));
					} while(localFP != frameToReturnTo);
					/* begin frameCallerSavedIP: */
					localIP = pointerForOop(longAt(callerFP + FoxCallerSavedIP));
					localSP = (frameCallerSP(callerFP)) - BytesPerWord;
				}
				if ((((usqInt)localIP)) < heapBase) {
					if ((((usqInt)localIP)) != (ceReturnToInterpreterPC())) {
						/* begin returnToMachineCodeFrame */
						VM_LABEL(0returnToMachineCodeFrame);
						assertCStackWellAligned();
						assert((((usqInt)localIP)) < (startOfMemory()));
						assert(isMachineCodeFrame(localFP));
						assertValidExecutionPointersimbar(((usqInt)localIP), localFP, localSP, 0);
						longAtPointerput(localSP, localIP);
						/* begin internalPush: */
						longAtPointerput(localSP -= BytesPerWord, localReturnValue);
						/* begin externalizeFPandSP */
						assert((localSP < ((GIV(stackPage)->baseAddress)))
						 && (localSP > (((GIV(stackPage)->realStackLimit)) - LargeContextSize)));
						GIV(stackPointer) = localSP;
						GIV(framePointer) = localFP;
						;
						ceEnterCogCodePopReceiverReg();
						goto l94;
					}
					localIP = pointerForOop(longAt(localFP + FoxIFSavedIP));
				}
				longAtPointerput(localSP, localReturnValue);
				/* begin setMethod: */
				assert((((usqInt)(longAt(localFP + FoxMethod)))) >= (startOfMemory()));
				GIV(method) = longAt(localFP + FoxMethod);
				/* begin fetchNextBytecode */
				currentBytecode = byteAtPointer(++localIP);
			}
;
		l94:	/* end case */;
			BREAK;
		CASE(121)
			/* returnTrue */
			{

				VM_LABEL(0returnTrue);
								localReturnValue = GIV(trueObj);
				goto commonReturn;
			}
;
			BREAK;
		CASE(122)
			/* returnFalse */
			{

				VM_LABEL(0returnFalse);
								localReturnValue = GIV(falseObj);
				goto commonReturn;
			}
;
			BREAK;
		CASE(123)
			/* returnNil */
			{

				VM_LABEL(0returnNil);
								localReturnValue = GIV(nilObj);
				goto commonReturn;
			}
;
			BREAK;
		CASE(124)
			/* returnTopFromMethod */
			{

				VM_LABEL(0returnTopFromMethod);
								localReturnValue = longAtPointer(localSP);
				goto commonReturn;
			}
;
			BREAK;
		CASE(125)
			/* returnTopFromBlock */
			{

				VM_LABEL(0returnTopFromBlock);
								localReturnValue = longAtPointer(localSP);
				/* goto commonCallerReturn */
			}
;
			
		commonCallerReturn:
			/* commonCallerReturn */
			{
				char *callersFPOrNull;
				sqInt contextToReturnFrom;
				sqInt contextToReturnTo;
				char *frameAbove;
				StackPage *newPage;
				sqInt retToContext;
				char *theFP;
				StackPage *thePage;
				char *theSP;
				char *callerFP;
				char *fp;
				StackPage *lruOrFree;
				sqInt value;
				sqInt index;
				sqInt callerContextOrNil;
				StackPage *thePage1;
				char *sp;
				char *sp1;
				char *sp2;
				sqInt index1;

				VM_LABEL(0commonCallerReturn);
								/* begin frameCallerFP: */
				callersFPOrNull = pointerForOop(longAt(localFP + FoxSavedFP));
				if (callersFPOrNull == 0) {
					assert(localFP == ((GIV(stackPage)->baseFP)));
					/* begin baseFrameReturn */
					VM_LABEL(0baseFrameReturn);
					/* begin frameCallerContext: */
					assert(isBaseFrame(localFP));
					/* begin stackPageFor: */
					/* begin stackPageAt: */
					/* begin pageIndexFor: */
					assert((((((char *) localFP)) >= (GIV(stackBasePlus1) - 1)) && ((((char *) localFP)) <= (((char *) GIV(pages))))));
					index1 = pageIndexForstackBasePlus1bytesPerPage(localFP, GIV(stackBasePlus1), GIV(bytesPerPage));
					thePage1 = stackPageAtpages(index1, GIV(pages));
					callerContextOrNil = longAt((thePage1->baseAddress));
					assert(addressCouldBeObj(callerContextOrNil));
					assert((callerContextOrNil == (nilObject()))
					 || (isContext(callerContextOrNil)));
					contextToReturnTo = callerContextOrNil;
					freeStackPageNoAssert(GIV(stackPage));
					retToContext = ((contextToReturnTo & 1) == 0)
					 && (((((usqInt) (longAt(contextToReturnTo))) >> 12) & 31) == ClassMethodContextCompactIndex);
					if (retToContext
					 && ((((longAt((contextToReturnTo + BaseHeaderSize) + (SenderIndex << ShiftForWord))) & 1))
 && (!(isWidowedContext(contextToReturnTo))))) {
						/* begin frameOfMarriedContext: */
						value = longAt((contextToReturnTo + BaseHeaderSize) + (SenderIndex << ShiftForWord));
						/* begin withoutSmallIntegerTags: */
						assert((value & 1));
						theFP = pointerForOop(value - 1);
						/* begin stackPageFor: */
						/* begin stackPageAt: */
						/* begin pageIndexFor: */
						assert((((((char *) theFP)) >= (GIV(stackBasePlus1) - 1)) && ((((char *) theFP)) <= (((char *) GIV(pages))))));
						index = pageIndexForstackBasePlus1bytesPerPage(theFP, GIV(stackBasePlus1), GIV(bytesPerPage));
						thePage = stackPageAtpages(index, GIV(pages));
						if (theFP == ((thePage->headFP))) {
							theSP = (thePage->headSP);
						}
						else {
							/* begin findFrameAbove:inPage: */
							fp = (thePage->headFP);
							if (fp == theFP) {
								frameAbove = 0;
								goto l100;
							}
							while (((callerFP = frameCallerFP(fp))) != 0) {
								if (callerFP == theFP) {
									frameAbove = fp;
									goto l100;
								}
								fp = callerFP;
							}
							error("did not find theFP in stack page");
							frameAbove = 0;
						l100:	/* end findFrameAbove:inPage: */;
							/* begin newStackPage */
							lruOrFree = (mostRecentlyUsedPage()->nextPage);
							if (isFree(lruOrFree)) {
								newPage = lruOrFree;
								goto l101;
							}
							divorceFramesIn(lruOrFree);
							newPage = lruOrFree;
						l101:	/* end newStackPage */;
							assert(newPage == GIV(stackPage));
							moveFramesInthroughtoPage(thePage, frameAbove, newPage);
							markStackPageMostRecentlyUsed(newPage);
							theFP = (thePage->headFP);
							theSP = (thePage->headSP);
						}
					}
					else {
						if (!(retToContext
							 && (((longAt((contextToReturnTo + BaseHeaderSize) + (InstructionPointerIndex << ShiftForWord))) & 1)))) {
							contextToReturnFrom = longAt(((GIV(stackPage)->baseAddress)) - BytesPerWord);
							tearDownAndRebuildFrameForCannotReturnBaseFrameReturnFromtoreturnValue(contextToReturnFrom, contextToReturnTo, localReturnValue);
							/* begin externalCannotReturn:from: */
							/* begin push: */
							longAtput(sp = GIV(stackPointer) - BytesPerWord, contextToReturnFrom);
							GIV(stackPointer) = sp;
							/* begin push: */
							longAtput(sp1 = GIV(stackPointer) - BytesPerWord, localReturnValue);
							GIV(stackPointer) = sp1;
							/* begin push: */
							longAtput(sp2 = GIV(stackPointer) - BytesPerWord, GIV(instructionPointer));
							GIV(stackPointer) = sp2;
							ceSendsupertonumArgs(longAt((GIV(specialObjectsOop) + BaseHeaderSize) + (SelectorCannotReturn << ShiftForWord)), 0, contextToReturnFrom, -1 - 1);
							goto l99;
						}
						GIV(instructionPointer) = 0;
						thePage = makeBaseFrameFor(contextToReturnTo);
						theFP = (thePage->headFP);
						theSP = (thePage->headSP);
					}
					/* begin setStackPageAndLimit: */
					GIV(stackPage) = thePage;
					if (GIV(stackLimit) != (((char *) (((usqInt) -1))))) {
						GIV(stackLimit) = (GIV(stackPage)->stackLimit);
					}
					markStackPageMostRecentlyUsed(thePage);
					assert((stackPageFor(theFP)) == GIV(stackPage));
					localSP = theSP;
					localFP = theFP;
					localIP = pointerForOop(longAtPointer(localSP));
					if ((((usqInt)localIP)) < heapBase) {
						if ((((usqInt)localIP)) != (ceReturnToInterpreterPC())) {
							/* begin returnToMachineCodeFrame */
							VM_LABEL(1returnToMachineCodeFrame);
							assertCStackWellAligned();
							assert((((usqInt)localIP)) < (startOfMemory()));
							assert(isMachineCodeFrame(localFP));
							assertValidExecutionPointersimbar(((usqInt)localIP), localFP, localSP, 0);
							longAtPointerput(localSP, localIP);
							/* begin internalPush: */
							longAtPointerput(localSP -= BytesPerWord, localReturnValue);
							/* begin externalizeFPandSP */
							assert((localSP < ((GIV(stackPage)->baseAddress)))
							 && (localSP > (((GIV(stackPage)->realStackLimit)) - LargeContextSize)));
							GIV(stackPointer) = localSP;
							GIV(framePointer) = localFP;
							;
							ceEnterCogCodePopReceiverReg();
							goto l99;
						}
						localIP = pointerForOop(longAt(localFP + FoxIFSavedIP));
					}
					assert(checkIsStillMarriedContextcurrentFP(contextToReturnTo, localFP));
					/* begin setMethod: */
					assert((((usqInt)(longAt(localFP + FoxMethod)))) >= (startOfMemory()));
					GIV(method) = longAt(localFP + FoxMethod);
					longAtPointerput(localSP, localReturnValue);
					/* begin fetchNextBytecode */
					currentBytecode = byteAtPointer(++localIP);
					goto l99;
				}
				/* begin frameCallerSavedIP: */
				localIP = pointerForOop(longAt(localFP + FoxCallerSavedIP));
				localSP = localFP + ((FoxCallerSavedIP + BytesPerWord) + ((((((usqInt)(longAt(localFP + FoxMethod)))) < heapBase
	? (mframeCogMethod(localFP)->cmNumArgs)
	: byteAt((localFP + FoxIFrameFlags) + 1))) << ShiftForWord));
				localFP = callersFPOrNull;
				if ((((usqInt)localIP)) < heapBase) {
					if ((((usqInt)localIP)) != (ceReturnToInterpreterPC())) {
						/* begin returnToMachineCodeFrame */
						VM_LABEL(2returnToMachineCodeFrame);
						assertCStackWellAligned();
						assert((((usqInt)localIP)) < (startOfMemory()));
						assert(isMachineCodeFrame(localFP));
						assertValidExecutionPointersimbar(((usqInt)localIP), localFP, localSP, 0);
						longAtPointerput(localSP, localIP);
						/* begin internalPush: */
						longAtPointerput(localSP -= BytesPerWord, localReturnValue);
						/* begin externalizeFPandSP */
						assert((localSP < ((GIV(stackPage)->baseAddress)))
						 && (localSP > (((GIV(stackPage)->realStackLimit)) - LargeContextSize)));
						GIV(stackPointer) = localSP;
						GIV(framePointer) = localFP;
						;
						ceEnterCogCodePopReceiverReg();
						goto l99;
					}
					localIP = pointerForOop(longAt(localFP + FoxIFSavedIP));
				}
				longAtPointerput(localSP, localReturnValue);
				/* begin setMethod: */
				assert((((usqInt)(longAt(localFP + FoxMethod)))) >= (startOfMemory()));
				GIV(method) = longAt(localFP + FoxMethod);
				/* begin fetchNextBytecode */
				currentBytecode = byteAtPointer(++localIP);
			}
;
		l99:	/* end case */;
			BREAK;
		CASE(126)
		CASE(127)
			/* unknownBytecode */
			{

				VM_LABEL(0unknownBytecode);
								error("Unknown bytecode");
			}
;
			BREAK;
		CASE(128)
			/* extendedPushBytecode */
			{
				sqInt descriptor;
				sqInt variableIndex;
				sqInt variableType;
				sqInt object;
				sqInt frameNumArgs;
				sqInt object1;
				sqInt object2;
				sqInt oop;

				VM_LABEL(0extendedPushBytecode);
								descriptor = byteAtPointer(++localIP);
				/* begin fetchNextBytecode */
				currentBytecode = byteAtPointer(++localIP);
				variableType = (((usqInt) descriptor) >> 6) & 3;
				variableIndex = descriptor & 63;
				if (variableType == 0) {
					/* begin pushReceiverVariable: */
					/* begin internalPush: */
					longAtPointerput(localSP -= BytesPerWord, longAt(((longAt(localFP + FoxIFReceiver)) + BaseHeaderSize) + (variableIndex << ShiftForWord)));
					goto l1;
				}
				if (variableType == 1) {
					/* begin pushTemporaryVariable: */
					/* begin internalPush: */
					object1 = (variableIndex < ((frameNumArgs = byteAt((localFP + FoxIFrameFlags) + 1)))
						? longAt((localFP + FoxCallerSavedIP) + ((frameNumArgs - variableIndex) * BytesPerWord))
						: longAt(((localFP + FoxIFReceiver) - BytesPerWord) + ((frameNumArgs - variableIndex) * BytesPerWord)));
					longAtPointerput(localSP -= BytesPerWord, object1);
					goto l1;
				}
				if (variableType == 2) {
					/* begin pushLiteralConstant: */
					/* begin internalPush: */
					/* begin literal: */
					assert(GIV(method) == (iframeMethod(localFP)));
					object = longAt((GIV(method) + BaseHeaderSize) + ((variableIndex + LiteralStart) << ShiftForWord));
					longAtPointerput(localSP -= BytesPerWord, object);
					goto l1;
				}
				if (variableType == 3) {
					/* begin pushLiteralVariable: */
					/* begin internalPush: */
					/* begin fetchPointer:ofObject: */
					/* begin literal: */
					assert(GIV(method) == (iframeMethod(localFP)));
					oop = longAt((GIV(method) + BaseHeaderSize) + ((variableIndex + LiteralStart) << ShiftForWord));
					object2 = longAt((oop + BaseHeaderSize) + (ValueIndex << ShiftForWord));
					longAtPointerput(localSP -= BytesPerWord, object2);
					goto l1;
				}
			}
;
		l1:	/* end case */;
			BREAK;
		CASE(129)
			/* extendedStoreBytecode */
			{
				sqInt association;
				sqInt descriptor;
				sqInt variableIndex;
				sqInt variableType;
				sqInt frameNumArgs;

				VM_LABEL(0extendedStoreBytecode);
								descriptor = byteAtPointer(++localIP);
				/* begin fetchNextBytecode */
				currentBytecode = byteAtPointer(++localIP);
				variableType = (((usqInt) descriptor) >> 6) & 3;
				variableIndex = descriptor & 63;
				if (variableType == 0) {
					/* begin storePointer:ofObject:withValue: */
					if ((((usqInt) (longAt(localFP + FoxIFReceiver)))) < (((usqInt) GIV(youngStart)))) {
						possibleRootStoreIntovalue(longAt(localFP + FoxIFReceiver), longAtPointer(localSP));
					}
					longAtput(((longAt(localFP + FoxIFReceiver)) + BaseHeaderSize) + (variableIndex << ShiftForWord), longAtPointer(localSP));
					goto l2;
				}
				if (variableType == 1) {
					/* begin itemporary:in:put: */
					if (variableIndex < ((frameNumArgs = byteAt((localFP + FoxIFrameFlags) + 1)))) {
						longAtput((localFP + FoxCallerSavedIP) + ((frameNumArgs - variableIndex) * BytesPerWord), longAtPointer(localSP));
					}
					else {
						longAtput(((localFP + FoxIFReceiver) - BytesPerWord) + ((frameNumArgs - variableIndex) * BytesPerWord), longAtPointer(localSP));
					}
					goto l2;
				}
				if (variableType == 3) {
					/* begin literal: */
					assert(GIV(method) == (iframeMethod(localFP)));
					association = longAt((GIV(method) + BaseHeaderSize) + ((variableIndex + LiteralStart) << ShiftForWord));
					/* begin storePointer:ofObject:withValue: */
					if ((((usqInt) association)) < (((usqInt) GIV(youngStart)))) {
						possibleRootStoreIntovalue(association, longAtPointer(localSP));
					}
					longAtput((association + BaseHeaderSize) + (ValueIndex << ShiftForWord), longAtPointer(localSP));
					goto l2;
				}
				error("illegal store");
			}
;
		l2:	/* end case */;
			BREAK;
		CASE(130)
			/* extendedStoreAndPopBytecode */
			{
				sqInt association;
				sqInt descriptor;
				sqInt variableIndex;
				sqInt variableType;
				sqInt frameNumArgs;

				VM_LABEL(0extendedStoreAndPopBytecode);
								/* begin extendedStoreBytecode */
				VM_LABEL(1extendedStoreBytecode);
				descriptor = byteAtPointer(++localIP);
				/* begin fetchNextBytecode */
				currentBytecode = byteAtPointer(++localIP);
				variableType = (((usqInt) descriptor) >> 6) & 3;
				variableIndex = descriptor & 63;
				if (variableType == 0) {
					/* begin storePointer:ofObject:withValue: */
					if ((((usqInt) (longAt(localFP + FoxIFReceiver)))) < (((usqInt) GIV(youngStart)))) {
						possibleRootStoreIntovalue(longAt(localFP + FoxIFReceiver), longAtPointer(localSP));
					}
					longAtput(((longAt(localFP + FoxIFReceiver)) + BaseHeaderSize) + (variableIndex << ShiftForWord), longAtPointer(localSP));
					goto l3;
				}
				if (variableType == 1) {
					/* begin itemporary:in:put: */
					if (variableIndex < ((frameNumArgs = byteAt((localFP + FoxIFrameFlags) + 1)))) {
						longAtput((localFP + FoxCallerSavedIP) + ((frameNumArgs - variableIndex) * BytesPerWord), longAtPointer(localSP));
					}
					else {
						longAtput(((localFP + FoxIFReceiver) - BytesPerWord) + ((frameNumArgs - variableIndex) * BytesPerWord), longAtPointer(localSP));
					}
					goto l3;
				}
				if (variableType == 3) {
					/* begin literal: */
					assert(GIV(method) == (iframeMethod(localFP)));
					association = longAt((GIV(method) + BaseHeaderSize) + ((variableIndex + LiteralStart) << ShiftForWord));
					/* begin storePointer:ofObject:withValue: */
					if ((((usqInt) association)) < (((usqInt) GIV(youngStart)))) {
						possibleRootStoreIntovalue(association, longAtPointer(localSP));
					}
					longAtput((association + BaseHeaderSize) + (ValueIndex << ShiftForWord), longAtPointer(localSP));
					goto l3;
				}
				error("illegal store");
			l3:	/* end extendedStoreBytecode */;
				/* begin internalPop: */
				localSP += 1 * BytesPerWord;
			}
;
			BREAK;
		CASE(131)
			/* singleExtendedSendBytecode */
			{
				sqInt descriptor;

				VM_LABEL(0singleExtendedSendBytecode);
								descriptor = byteAtPointer(++localIP);
				/* begin literal: */
				assert(GIV(method) == (iframeMethod(localFP)));
				GIV(messageSelector) = longAt((GIV(method) + BaseHeaderSize) + (((descriptor & 31) + LiteralStart) << ShiftForWord));
				GIV(argumentCount) = ((usqInt) descriptor) >> 5;
				/* goto normalSend */
			}
;
			
		normalSend:
			/* normalSend */
			{
				sqInt rcvr;
				sqInt ccIndex;

				VM_LABEL(0normalSend);
								rcvr = longAtPointer(localSP + (GIV(argumentCount) * BytesPerWord));
				/* begin fetchClassOf: */
				if ((rcvr & 1)) {
					GIV(lkupClass) = longAt((GIV(specialObjectsOop) + BaseHeaderSize) + (ClassInteger << ShiftForWord));
					goto l102;
				}
				if (((ccIndex = (((usqInt) (longAt(rcvr))) >> 12) & 31)) == 0) {
					GIV(lkupClass) = (longAt(rcvr - BaseHeaderSize)) & AllButTypeMask;
					goto l102;
				}
				else {
					GIV(lkupClass) = longAt(((longAt((GIV(specialObjectsOop) + BaseHeaderSize) + (CompactClasses << ShiftForWord))) + BaseHeaderSize) + ((ccIndex - 1) << ShiftForWord));
					goto l102;
				}
			l102:	/* end fetchClassOf: */;
				assert(GIV(lkupClass) != (nilObject()));
				/* goto commonSend */
			}
;
			
		commonSend:
			/* commonSend */
			{
				sqInt succeeded;
				sqInt localPrimIndex;
				sqInt nArgs;
				char *savedFramePointer;
				char *savedStackPointer;
				sqInt errorCode;
				sqInt i;
				sqInt methodHeader;
				sqInt numTemps;
				sqInt rcvr;
				sqInt switched;
				sqInt table;
				sqInt object;
				sqInt ok;
				sqInt hash;
				sqInt probe;
				CogMethod *cogMethod;
				sqInt methodHeader1;

				VM_LABEL(0commonSend);
								sendBreakpointreceiver(GIV(messageSelector) + BaseHeaderSize, lengthOf(GIV(messageSelector)), longAtPointer(localSP + (GIV(argumentCount) * BytesPerWord)));
				if (recordSendTrace()) {
					/* begin recordTrace:thing:source: */
					GIV(traceLog)[GIV(traceLogIndex)] = GIV(lkupClass);
					GIV(traceLog)[GIV(traceLogIndex) + 1] = GIV(messageSelector);
					GIV(traceLog)[GIV(traceLogIndex) + 2] = TraceIsFromInterpreter;
					GIV(traceLogIndex) = (GIV(traceLogIndex) + 3) % TraceBufferSize;
				}
				/* begin internalFindNewMethod */
				VM_LABEL(0internalFindNewMethod);
				/* begin lookupInMethodCacheSel:class: */

				/* shift drops two low-order zeros from addresses */

				hash = GIV(messageSelector) ^ GIV(lkupClass);

				/* first probe */

				probe = hash & MethodCacheMask;
				if (((GIV(methodCache)[probe + MethodCacheSelector]) == GIV(messageSelector))
				 && ((GIV(methodCache)[probe + MethodCacheClass]) == GIV(lkupClass))) {
					GIV(newMethod) = GIV(methodCache)[probe + MethodCacheMethod];
					primitiveFunctionPointer = ((void (*)()) (GIV(methodCache)[probe + MethodCachePrimFunction]));
					ok = 1;
					goto l106;
				}

				/* second probe */

				probe = (((usqInt) hash) >> 1) & MethodCacheMask;
				if (((GIV(methodCache)[probe + MethodCacheSelector]) == GIV(messageSelector))
				 && ((GIV(methodCache)[probe + MethodCacheClass]) == GIV(lkupClass))) {
					GIV(newMethod) = GIV(methodCache)[probe + MethodCacheMethod];
					primitiveFunctionPointer = ((void (*)()) (GIV(methodCache)[probe + MethodCachePrimFunction]));
					ok = 1;
					goto l106;
				}
				probe = (((usqInt) hash) >> 2) & MethodCacheMask;
				if (((GIV(methodCache)[probe + MethodCacheSelector]) == GIV(messageSelector))
				 && ((GIV(methodCache)[probe + MethodCacheClass]) == GIV(lkupClass))) {
					GIV(newMethod) = GIV(methodCache)[probe + MethodCacheMethod];
					primitiveFunctionPointer = ((void (*)()) (GIV(methodCache)[probe + MethodCachePrimFunction]));
					ok = 1;
					goto l106;
				}
				ok = 0;
			l106:	/* end lookupInMethodCacheSel:class: */;
				if (ok) {
					/* begin ifAppropriateCompileToNativeCode:selector: */
					methodHeader1 = longAt((GIV(newMethod) + BaseHeaderSize) + (HeaderIndex << ShiftForWord));
					if (isCogMethodReference(methodHeader1)) {

						/* makeBaseFrame: can create cog methods with nil selectors. */

						cogMethod = ((CogMethod *) methodHeader1);
						if (((cogMethod->selector)) == GIV(nilObj)) {
							setSelectorOfto(cogMethod, GIV(messageSelector));
						}
					}
					else {
						if (((((usqInt) methodHeader1) >> 10) & 255) <= maxLiteralCountForCompile) {
							cogselector(GIV(newMethod), GIV(messageSelector));
						}
						else {
							maybeFlagMethodAsInterpreted(GIV(newMethod));
						}
					}
				}
				else {
					/* begin externalizeIPandSP */
					assert((((usqInt)localIP)) != (ceReturnToInterpreterPC()));
					GIV(instructionPointer) = oopForPointer(localIP);
					GIV(stackPointer) = localSP;
					GIV(framePointer) = localFP;
					lookupMethodInClass(GIV(lkupClass));
					/* begin internalizeIPandSP */
					assert(GIV(instructionPointer) != (ceReturnToInterpreterPC()));
					localIP = pointerForOop(GIV(instructionPointer));
					localSP = pointerForOop(GIV(stackPointer));
					localFP = pointerForOop(GIV(framePointer));
					addNewMethodToCache(GIV(lkupClass));
				}
				/* begin internalExecuteNewMethod */
				VM_LABEL(0internalExecuteNewMethod);
				if (primitiveFunctionPointer != 0) {
					if ((((unsigned long) primitiveFunctionPointer)) <= MaxQuickPrimitiveIndex) {
						/* begin internalQuickPrimitiveResponse */
						VM_LABEL(0internalQuickPrimitiveResponse);
						assert(isPrimitiveFunctionPointerAnIndex());
						localPrimIndex = ((sqInt) primitiveFunctionPointer);
						assert((localPrimIndex > 255)
						 && (localPrimIndex < 520));
						if (localPrimIndex >= 264) {
							longAtPointerput(localSP, longAt(((longAtPointer(localSP)) + BaseHeaderSize) + ((localPrimIndex - 264) << ShiftForWord)));
							goto l104;
						}
						if (localPrimIndex == 256) {
							goto l104;
						}
						if (localPrimIndex == 257) {
							longAtPointerput(localSP, GIV(trueObj));
							goto l104;
						}
						if (localPrimIndex == 258) {
							longAtPointerput(localSP, GIV(falseObj));
							goto l104;
						}
						if (localPrimIndex == 259) {
							longAtPointerput(localSP, GIV(nilObj));
							goto l104;
						}
						longAtPointerput(localSP, (((localPrimIndex - 261) << 1) | 1));
					l104:	/* end internalQuickPrimitiveResponse */;
						goto l103;
					}
					/* begin externalizeIPandSP */
					assert((((usqInt)localIP)) != (ceReturnToInterpreterPC()));
					GIV(instructionPointer) = oopForPointer(localIP);
					GIV(stackPointer) = localSP;
					GIV(framePointer) = localFP;
					/* begin slowPrimitiveResponse */
					if (recordPrimTrace()) {
						/* begin fastLogPrim: */
						GIV(primTraceLog)[GIV(primTraceLogIndex)] = GIV(messageSelector);
						primTraceLogIndex(GIV(primTraceLogIndex) + 1);
					}
					if (FailImbalancedPrimitives) {
						nArgs = GIV(argumentCount);
						savedStackPointer = GIV(stackPointer);
						savedFramePointer = GIV(framePointer);
					}
					/* begin initPrimCall */
					GIV(primFailCode) = 0;
					dispatchFunctionPointer(primitiveFunctionPointer);
					if (FailImbalancedPrimitives
					 && ((GIV(primFailCode) == 0)
 && ((GIV(framePointer) == savedFramePointer)
 && (!((((usqInt)(longAt(GIV(framePointer) + FoxMethod)))) < heapBase))))) {
						if (GIV(stackPointer) != (savedStackPointer + (nArgs * BytesPerWord))) {
							flag("Would be nice to make this a message send of e.g. unbalancedPrimitive to the current process or context");
							GIV(stackPointer) = savedStackPointer;
							failUnbalancedPrimitive();
						}
					}
					if (GIV(nextProfileTick) > 0) {
						checkProfileTick(GIV(newMethod));
					}
					succeeded = GIV(primFailCode) == 0;
					/* begin internalizeIPandSP */
					assert(GIV(instructionPointer) != (ceReturnToInterpreterPC()));
					localIP = pointerForOop(GIV(instructionPointer));
					localSP = pointerForOop(GIV(stackPointer));
					localFP = pointerForOop(GIV(framePointer));
					if (succeeded) {
						returntoExecutive(popStack(), 0);
						browserPluginReturnIfNeeded();
						goto l103;
					}
				}
				if (methodHasCogMethod(GIV(newMethod))) {
					/* begin iframeSavedIP:put: */
					assert(!(isMachineCodeFrame(localFP)));
					longAtput(localFP + FoxIFSavedIP, ((sqInt)localIP));
					GIV(instructionPointer) = ceReturnToInterpreterPC();
					/* begin externalizeFPandSP */
					assert((localSP < ((GIV(stackPage)->baseAddress)))
					 && (localSP > (((GIV(stackPage)->realStackLimit)) - LargeContextSize)));
					GIV(stackPointer) = localSP;
					GIV(framePointer) = localFP;
					activateCoggedNewMethod(1);
					/* begin internalizeIPandSP */
					assert(GIV(instructionPointer) != (ceReturnToInterpreterPC()));
					localIP = pointerForOop(GIV(instructionPointer));
					localSP = pointerForOop(GIV(stackPointer));
					localFP = pointerForOop(GIV(framePointer));
				}
				else {
					/* begin internalActivateNewMethod */
					VM_LABEL(0internalActivateNewMethod);
					methodHeader = longAt((GIV(newMethod) + BaseHeaderSize) + (HeaderIndex << ShiftForWord));
					assert(!(isCogMethodReference(methodHeader)));
					numTemps = (((usqInt) methodHeader) >> 19) & 63;

					/* could new rcvr be set at point of send? */

					rcvr = longAtPointer(localSP + (GIV(argumentCount) * BytesPerWord));
					/* begin internalPush: */
					longAtPointerput(localSP -= BytesPerWord, localIP);
					/* begin internalPush: */
					longAtPointerput(localSP -= BytesPerWord, localFP);
					localFP = localSP;
					/* begin internalPush: */
					longAtPointerput(localSP -= BytesPerWord, GIV(newMethod));
					/* begin setMethod: */
					assert((((usqInt)GIV(newMethod))) >= (startOfMemory()));
					GIV(method) = GIV(newMethod);
					/* begin internalPush: */
					longAtPointerput(localSP -= BytesPerWord, GIV(nilObj));
					/* begin internalPush: */
					object = (VMBIGENDIAN
						? ((1 + (((((usqInt) methodHeader) >> 25) & 15) << ((BytesPerWord * 8) - 8))) + ((0
	? 1 << ((BytesPerWord * 8) - 16)
	: 0))) + ((0
	? 1 << ((BytesPerWord * 8) - 24)
	: 0))
						: ((1 + (((((usqInt) methodHeader) >> 25) & 15) << 8)) + ((0
	? 1 << 16
	: 0))) + ((0
	? 1 << 24
	: 0)));
					longAtPointerput(localSP -= BytesPerWord, object);
					/* begin internalPush: */
					longAtPointerput(localSP -= BytesPerWord, 0);
					/* begin internalPush: */
					longAtPointerput(localSP -= BytesPerWord, rcvr);
					for (i = (GIV(argumentCount) + 1); i <= numTemps; i += 1) {
						/* begin internalPush: */
						longAtPointerput(localSP -= BytesPerWord, GIV(nilObj));
					}

					/* Pass primitive error code to last temp if method receives it (indicated by an
	 initial long store temp bytecode).  We don't need to check that newMethod
	 actually has a primitive because the initial 129 only occurs if there is one. */

					localIP = pointerForOop(((GIV(newMethod) + ((LiteralStart + ((((usqInt) methodHeader) >> 10) & 255)) * BytesPerWord)) + BaseHeaderSize) - 1);
					if (GIV(primFailCode) != 0) {
						if ((byteAtPointer(localIP + 1)) == 129) {
							/* begin getErrorObjectFromPrimFailCode */
							if (GIV(primFailCode) > 0) {
								table = longAt((GIV(specialObjectsOop) + BaseHeaderSize) + (PrimErrTableIndex << ShiftForWord));
								if (GIV(primFailCode) <= (((sqInt) (lastPointerOf(table)) >> 2))) {
									errorCode = longAt((table + BaseHeaderSize) + ((GIV(primFailCode) - 1) << ShiftForWord));
									goto l105;
								}
							}
							errorCode = ((GIV(primFailCode) << 1) | 1);
						l105:	/* end getErrorObjectFromPrimFailCode */;
							longAtPointerput(localSP, errorCode);
						}
						GIV(primFailCode) = 0;
					}
					assert((frameNumArgs(localFP)) == GIV(argumentCount));
					assert(!(frameIsBlockActivation(localFP)));
					assert(!(frameHasContext(localFP)));
					if (localSP < GIV(stackLimit)) {
						/* begin externalizeIPandSP */
						assert((((usqInt)localIP)) != (ceReturnToInterpreterPC()));
						GIV(instructionPointer) = oopForPointer(localIP);
						GIV(stackPointer) = localSP;
						GIV(framePointer) = localFP;
						switched = handleStackOverflowOrEventAllowContextSwitch(canContextSwitchIfActivating(methodHeader));
						returnToExecutivepostContextSwitch(1, switched);
						/* begin internalizeIPandSP */
						assert(GIV(instructionPointer) != (ceReturnToInterpreterPC()));
						localIP = pointerForOop(GIV(instructionPointer));
						localSP = pointerForOop(GIV(stackPointer));
						localFP = pointerForOop(GIV(framePointer));
					}
				}
			l103:	/* end internalExecuteNewMethod */;
				/* begin fetchNextBytecode */
				currentBytecode = byteAtPointer(++localIP);
			}
;
			BREAK;
		CASE(132)
			/* doubleExtendedDoAnythingBytecode */
			{
				sqInt byte2;
				sqInt byte3;
				sqInt opType;
				sqInt top;
				sqInt object;
				sqInt oop;
				sqInt rcvr;
				sqInt object1;
				sqInt object2;
				sqInt oop1;
				sqInt rcvr1;
				sqInt onCurrentPage;
				char *theFP;
				StackPage *thePage;
				sqInt value;
				sqInt index1;
				char *spouseFP;
				char *theFPAbove;
				sqInt theIP;
				StackPage *thePage2;
				sqInt value2;
				sqInt result;
				char *callerFP;
				sqInt callerContextOrNil;
				StackPage *thePage1;
				char *callerFP1;
				char *fp;
				sqInt result1;
				sqInt value1;
				sqInt index;
				char *theSP;
				sqInt index11;

				VM_LABEL(0doubleExtendedDoAnythingBytecode);
								byte2 = byteAtPointer(++localIP);
				byte3 = byteAtPointer(++localIP);
				opType = ((usqInt) byte2) >> 5;
				if (opType == 0) {
					/* begin literal: */
					assert(GIV(method) == (iframeMethod(localFP)));
					GIV(messageSelector) = longAt((GIV(method) + BaseHeaderSize) + ((byte3 + LiteralStart) << ShiftForWord));
					GIV(argumentCount) = byte2 & 31;
					goto normalSend;
					goto l4;
				}
				if (opType == 1) {
					/* begin literal: */
					assert(GIV(method) == (iframeMethod(localFP)));
					GIV(messageSelector) = longAt((GIV(method) + BaseHeaderSize) + ((byte3 + LiteralStart) << ShiftForWord));
					GIV(argumentCount) = byte2 & 31;
					goto commonSupersend;
					goto l4;
				}
				/* begin fetchNextBytecode */
				currentBytecode = byteAtPointer(++localIP);
				if (opType == 2) {
					/* begin pushMaybeContextReceiverVariable: */
					rcvr = longAt(localFP + FoxIFReceiver);
					if ((byte3 < MethodIndex)
					 && (((((usqInt) (longAt(rcvr))) >> 12) & 31) == ClassMethodContextCompactIndex)) {
						/* begin internalPush: */
						/* begin instVar:ofContext: */
						VM_LABEL(0instVarofContext);
						assert(byte3 < MethodIndex);
						assert(isContext(rcvr));
						/* begin writeBackHeadFramePointers */
						VM_LABEL(1writeBackHeadFramePointers);
						assert(GIV(stackPage) == (mostRecentlyUsedPage()));
						/* begin setHeadFP:andSP:inPage: */
						assert(localSP < localFP);
						assert((localSP < ((GIV(stackPage)->baseAddress)))
						 && (localSP > (((GIV(stackPage)->realStackLimit)) - LargeContextSize)));
						assert((localFP < ((GIV(stackPage)->baseAddress)))
						 && (localFP > (((GIV(stackPage)->realStackLimit)) - (((sqInt) LargeContextSize >> 1)))));
						(GIV(stackPage)->headFP = localFP);
						(GIV(stackPage)->headSP = localSP);
						assert(pageListIsWellFormed());
						if (!(((longAt((rcvr + BaseHeaderSize) + (SenderIndex << ShiftForWord))) & 1))) {
							value2 = longAt((rcvr + BaseHeaderSize) + (byte3 << ShiftForWord));
							if ((byte3 == InstructionPointerIndex)
							 && (((value2 & 1))
 && ((((sqInt) value2)) < 0))) {
								/* begin internalMustMapMachineCodePC:context: */
								/* begin externalizeIPandSP */
								assert((((usqInt)localIP)) != (ceReturnToInterpreterPC()));
								GIV(instructionPointer) = oopForPointer(localIP);
								GIV(stackPointer) = localSP;
								GIV(framePointer) = localFP;
								result = mustMapMachineCodePCcontext((value2 >> 1), rcvr);
								/* begin internalizeIPandSP */
								assert(GIV(instructionPointer) != (ceReturnToInterpreterPC()));
								localIP = pointerForOop(GIV(instructionPointer));
								localSP = pointerForOop(GIV(stackPointer));
								localFP = pointerForOop(GIV(framePointer));
								value2 = result;
							}
							object1 = value2;
							goto l7;
						}
						if (isWidowedContext(rcvr)) {
							object1 = longAt((rcvr + BaseHeaderSize) + (byte3 << ShiftForWord));
							goto l7;
						}
						/* begin frameOfMarriedContext: */
						value1 = longAt((rcvr + BaseHeaderSize) + (SenderIndex << ShiftForWord));
						/* begin withoutSmallIntegerTags: */
						assert((value1 & 1));
						spouseFP = pointerForOop(value1 - 1);
						if (byte3 == SenderIndex) {
							/* begin ensureCallerContext: */
							/* begin frameCallerFP: */
							callerFP = pointerForOop(longAt(spouseFP + FoxSavedFP));
							if (callerFP == 0) {
								/* begin frameCallerContext: */
								assert(isBaseFrame(spouseFP));
								/* begin stackPageFor: */
								/* begin stackPageAt: */
								/* begin pageIndexFor: */
								assert((((((char *) spouseFP)) >= (GIV(stackBasePlus1) - 1)) && ((((char *) spouseFP)) <= (((char *) GIV(pages))))));
								index = pageIndexForstackBasePlus1bytesPerPage(spouseFP, GIV(stackBasePlus1), GIV(bytesPerPage));
								thePage1 = stackPageAtpages(index, GIV(pages));
								callerContextOrNil = longAt((thePage1->baseAddress));
								assert(addressCouldBeObj(callerContextOrNil));
								assert((callerContextOrNil == (nilObject()))
								 || (isContext(callerContextOrNil)));
								object1 = callerContextOrNil;
								goto l7;
							}
							/* begin ensureFrameIsMarried:SP: */
							VM_LABEL(3ensureFrameIsMarriedSP);
							/* begin frameCallerStackPointer: */
							assert(!(isBaseFrame(spouseFP)));
							theSP = (spouseFP + ((FoxCallerSavedIP + BytesPerWord) + ((((((usqInt)(longAt(spouseFP + FoxMethod)))) < heapBase
	? (mframeCogMethod(spouseFP)->cmNumArgs)
	: byteAt((spouseFP + FoxIFrameFlags) + 1))) << ShiftForWord))) + BytesPerWord;
							if (((((usqInt)(longAt(callerFP + FoxMethod)))) < heapBase
								? ((longAt(callerFP + FoxMethod)) & MFMethodFlagHasContextFlag) != 0
								: (byteAt((callerFP + FoxIFrameFlags) + 2)) != 0)) {
								assert(isContext(frameContext(callerFP)));
								object1 = longAt(callerFP + FoxThisContext);
								goto l7;
							}
							object1 = marryFrameSP(callerFP, theSP);
							goto l7;
						}
						if (byte3 == StackPointerIndex) {
							assert((ReceiverIndex + (stackPointerIndexForFrame(spouseFP))) < (lengthOf(rcvr)));
							object1 = (((stackPointerIndexForFrame(spouseFP)) << 1) | 1);
							goto l7;
						}
						if (byte3 == InstructionPointerIndex) {
							if (spouseFP == localFP) {
								theIP = oopForPointer(localIP);
							}
							else {
								/* begin stackPageFor: */
								/* begin stackPageAt: */
								/* begin pageIndexFor: */
								assert((((((char *) spouseFP)) >= (GIV(stackBasePlus1) - 1)) && ((((char *) spouseFP)) <= (((char *) GIV(pages))))));
								index11 = pageIndexForstackBasePlus1bytesPerPage(spouseFP, GIV(stackBasePlus1), GIV(bytesPerPage));
								thePage2 = stackPageAtpages(index11, GIV(pages));
								/* begin findFrameAbove:inPage: */
								fp = (thePage2->headFP);
								if (fp == spouseFP) {
									theFPAbove = 0;
									goto l6;
								}
								while (((callerFP1 = frameCallerFP(fp))) != 0) {
									if (callerFP1 == spouseFP) {
										theFPAbove = fp;
										goto l6;
									}
									fp = callerFP1;
								}
								error("did not find theFP in stack page");
								theFPAbove = 0;
							l6:	/* end findFrameAbove:inPage: */;
								theIP = (theFPAbove == 0
									? longAt((thePage2->headSP))
									: oopForPointer(frameCallerSavedIP(theFPAbove)));
							}
							value2 = contextInstructionPointerframe(theIP, spouseFP);
							if ((((sqInt) value2)) < 0) {
								/* begin internalMustMapMachineCodePC:context: */
								/* begin externalizeIPandSP */
								assert((((usqInt)localIP)) != (ceReturnToInterpreterPC()));
								GIV(instructionPointer) = oopForPointer(localIP);
								GIV(stackPointer) = localSP;
								GIV(framePointer) = localFP;
								result1 = mustMapMachineCodePCcontext((value2 >> 1), rcvr);
								/* begin internalizeIPandSP */
								assert(GIV(instructionPointer) != (ceReturnToInterpreterPC()));
								localIP = pointerForOop(GIV(instructionPointer));
								localSP = pointerForOop(GIV(stackPointer));
								localFP = pointerForOop(GIV(framePointer));
								value2 = result1;
							}
							object1 = value2;
							goto l7;
						}
						error("bad index");
						object1 = 0;
					l7:	/* end instVar:ofContext: */;
						longAtPointerput(localSP -= BytesPerWord, object1);
					}
					else {
						/* begin internalPush: */
						longAtPointerput(localSP -= BytesPerWord, longAt((rcvr + BaseHeaderSize) + (byte3 << ShiftForWord)));
					}
					goto l4;
				}
				if (opType == 3) {
					/* begin pushLiteralConstant: */
					/* begin internalPush: */
					/* begin literal: */
					assert(GIV(method) == (iframeMethod(localFP)));
					object = longAt((GIV(method) + BaseHeaderSize) + ((byte3 + LiteralStart) << ShiftForWord));
					longAtPointerput(localSP -= BytesPerWord, object);
					goto l4;
				}
				if (opType == 4) {
					/* begin pushLiteralVariable: */
					/* begin internalPush: */
					/* begin fetchPointer:ofObject: */
					/* begin literal: */
					assert(GIV(method) == (iframeMethod(localFP)));
					oop1 = longAt((GIV(method) + BaseHeaderSize) + ((byte3 + LiteralStart) << ShiftForWord));
					object2 = longAt((oop1 + BaseHeaderSize) + (ValueIndex << ShiftForWord));
					longAtPointerput(localSP -= BytesPerWord, object2);
					goto l4;
				}
				top = longAtPointer(localSP);
				if (opType == 7) {
					/* begin storePointer:ofObject:withValue: */
					/* begin literal: */
					assert(GIV(method) == (iframeMethod(localFP)));
					oop = longAt((GIV(method) + BaseHeaderSize) + ((byte3 + LiteralStart) << ShiftForWord));
					if ((((usqInt) oop)) < (((usqInt) GIV(youngStart)))) {
						possibleRootStoreIntovalue(oop, top);
					}
					longAtput((oop + BaseHeaderSize) + (ValueIndex << ShiftForWord), top);
					goto l4;
				}
				if (opType == 6) {
					/* begin internalPop: */
					localSP += 1 * BytesPerWord;
				}
				/* begin storeMaybeContextReceiverVariable:withValue: */
				VM_LABEL(0storeMaybeContextReceiverVariablewithValue);
				rcvr1 = longAt(localFP + FoxIFReceiver);
				if ((byte3 <= ReceiverIndex)
				 && ((((((usqInt) (longAt(rcvr1))) >> 12) & 31) == ClassMethodContextCompactIndex)
 && (((longAt((rcvr1 + BaseHeaderSize) + (SenderIndex << ShiftForWord))) & 1)))) {
					/* begin instVar:ofContext:put: */
					VM_LABEL(0instVarofContextput);
					assert(isMarriedOrWidowedContext(rcvr1));
					/* begin writeBackHeadFramePointers */
					VM_LABEL(2writeBackHeadFramePointers);
					assert(GIV(stackPage) == (mostRecentlyUsedPage()));
					/* begin setHeadFP:andSP:inPage: */
					assert(localSP < localFP);
					assert((localSP < ((GIV(stackPage)->baseAddress)))
					 && (localSP > (((GIV(stackPage)->realStackLimit)) - LargeContextSize)));
					assert((localFP < ((GIV(stackPage)->baseAddress)))
					 && (localFP > (((GIV(stackPage)->realStackLimit)) - (((sqInt) LargeContextSize >> 1)))));
					(GIV(stackPage)->headFP = localFP);
					(GIV(stackPage)->headSP = localSP);
					assert(pageListIsWellFormed());
					if (!((((longAt((rcvr1 + BaseHeaderSize) + (SenderIndex << ShiftForWord))) & 1))
						 && (!(isWidowedContext(rcvr1))))) {
						/* begin storePointer:ofObject:withValue: */
						if ((((usqInt) rcvr1)) < (((usqInt) GIV(youngStart)))) {
							possibleRootStoreIntovalue(rcvr1, top);
						}
						longAtput((rcvr1 + BaseHeaderSize) + (byte3 << ShiftForWord), top);
						if (byte3 == StackPointerIndex) {
							ensureContextIsExecutionSafeAfterAssignToStackPointer(rcvr1);
						}
						goto l5;
					}
					/* begin frameOfMarriedContext: */
					value = longAt((rcvr1 + BaseHeaderSize) + (SenderIndex << ShiftForWord));
					/* begin withoutSmallIntegerTags: */
					assert((value & 1));
					theFP = pointerForOop(value - 1);
					if (byte3 == SenderIndex) {
						/* begin stackPageFor: */
						/* begin stackPageAt: */
						/* begin pageIndexFor: */
						assert((((((char *) theFP)) >= (GIV(stackBasePlus1) - 1)) && ((((char *) theFP)) <= (((char *) GIV(pages))))));
						index1 = pageIndexForstackBasePlus1bytesPerPage(theFP, GIV(stackBasePlus1), GIV(bytesPerPage));
						thePage = stackPageAtpages(index1, GIV(pages));
						assert(GIV(stackPage) == (mostRecentlyUsedPage()));
						onCurrentPage = thePage == GIV(stackPage);
						storeSenderOfFramewithValue(theFP, top);
						if (onCurrentPage) {
							localFP = (GIV(stackPage)->headFP);
							localSP = (GIV(stackPage)->headSP);
						}
						else {
							markStackPageMostRecentlyUsed(GIV(stackPage));
						}
						goto l5;
					}
					/* begin externalizeIPandSP */
					assert((((usqInt)localIP)) != (ceReturnToInterpreterPC()));
					GIV(instructionPointer) = oopForPointer(localIP);
					GIV(stackPointer) = localSP;
					GIV(framePointer) = localFP;
					externalDivorceFrameandContext(theFP, rcvr1);
					/* begin storePointer:ofObject:withValue: */
					if ((((usqInt) rcvr1)) < (((usqInt) GIV(youngStart)))) {
						possibleRootStoreIntovalue(rcvr1, top);
					}
					longAtput((rcvr1 + BaseHeaderSize) + (byte3 << ShiftForWord), top);
					if (byte3 == StackPointerIndex) {
						ensureContextIsExecutionSafeAfterAssignToStackPointer(rcvr1);
					}
					/* begin internalizeIPandSP */
					assert(GIV(instructionPointer) != (ceReturnToInterpreterPC()));
					localIP = pointerForOop(GIV(instructionPointer));
					localSP = pointerForOop(GIV(stackPointer));
					localFP = pointerForOop(GIV(framePointer));
				l5:	/* end instVar:ofContext:put: */;
				}
				else {
					/* begin storePointer:ofObject:withValue: */
					if ((((usqInt) rcvr1)) < (((usqInt) GIV(youngStart)))) {
						possibleRootStoreIntovalue(rcvr1, top);
					}
					longAtput((rcvr1 + BaseHeaderSize) + (byte3 << ShiftForWord), top);
				}
			}
;
		l4:	/* end case */;
			BREAK;
		CASE(133)
			/* singleExtendedSuperBytecode */
			{
				sqInt descriptor;

				VM_LABEL(0singleExtendedSuperBytecode);
								descriptor = byteAtPointer(++localIP);
				/* begin literal: */
				assert(GIV(method) == (iframeMethod(localFP)));
				GIV(messageSelector) = longAt((GIV(method) + BaseHeaderSize) + (((descriptor & 31) + LiteralStart) << ShiftForWord));
				GIV(argumentCount) = ((usqInt) descriptor) >> 5;
				/* goto commonSupersend */
			}
;
			
		commonSupersend:
			/* superclassSend */
			{
				sqInt classPointer;
				sqInt oop;
				sqInt offset;

				VM_LABEL(0superclassSend);
								/* begin superclassOf: */
				/* begin methodClassOf: */
				/* begin fetchPointer:ofObject: */
				/* begin literal:ofMethod: */
				offset = (literalCountOf(GIV(method))) - 1;
				oop = longAt((GIV(method) + BaseHeaderSize) + ((offset + LiteralStart) << ShiftForWord));
				classPointer = longAt((oop + BaseHeaderSize) + (ValueIndex << ShiftForWord));
				GIV(lkupClass) = longAt((classPointer + BaseHeaderSize) + (SuperclassIndex << ShiftForWord));
				assert(GIV(lkupClass) != (nilObject()));
				goto commonSend;
			}
;
			BREAK;
		CASE(134)
			/* secondExtendedSendBytecode */
			{
				sqInt descriptor;

				VM_LABEL(0secondExtendedSendBytecode);
								descriptor = byteAtPointer(++localIP);
				/* begin literal: */
				assert(GIV(method) == (iframeMethod(localFP)));
				GIV(messageSelector) = longAt((GIV(method) + BaseHeaderSize) + (((descriptor & 63) + LiteralStart) << ShiftForWord));
				GIV(argumentCount) = ((usqInt) descriptor) >> 6;
				goto normalSend;
			}
;
			BREAK;
		CASE(135)
			/* popStackBytecode */
			{

				VM_LABEL(0popStackBytecode);
								/* begin fetchNextBytecode */
				currentBytecode = byteAtPointer(++localIP);
				/* begin internalPop: */
				localSP += 1 * BytesPerWord;
			}
;
			BREAK;
		CASE(136)
			/* duplicateTopBytecode */
			{
				sqInt object;

				VM_LABEL(0duplicateTopBytecode);
								/* begin fetchNextBytecode */
				currentBytecode = byteAtPointer(++localIP);
				/* begin internalPush: */
				object = longAtPointer(localSP);
				longAtPointerput(localSP -= BytesPerWord, object);
			}
;
			BREAK;
		CASE(137)
			/* pushActiveContextBytecode */
			{
				sqInt ourContext;
				char *theFP;
				char *theSP;

				VM_LABEL(0pushActiveContextBytecode);
								/* begin ensureFrameIsMarried:SP: */
				VM_LABEL(4ensureFrameIsMarriedSP);
				theFP = localFP;
				theSP = localSP;
				if (((((usqInt)(longAt(theFP + FoxMethod)))) < heapBase
					? ((longAt(theFP + FoxMethod)) & MFMethodFlagHasContextFlag) != 0
					: (byteAt((theFP + FoxIFrameFlags) + 2)) != 0)) {
					assert(isContext(frameContext(theFP)));
					ourContext = longAt(theFP + FoxThisContext);
					goto l8;
				}
				ourContext = marryFrameSP(theFP, theSP);
			l8:	/* end ensureFrameIsMarried:SP: */;
				/* begin fetchNextBytecode */
				currentBytecode = byteAtPointer(++localIP);
				/* begin internalPush: */
				longAtPointerput(localSP -= BytesPerWord, ourContext);
			}
;
			BREAK;
		CASE(138)
			/* pushNewArrayBytecode */
			{
				sqInt array;
				sqInt i;
				sqInt popValues;
				sqInt size;

				VM_LABEL(0pushNewArrayBytecode);
								size = byteAtPointer(++localIP);
				popValues = size > 127;
				size = size & 127;
				/* begin fetchNextBytecode */
				currentBytecode = byteAtPointer(++localIP);
				/* begin externalizeIPandSP */
				assert((((usqInt)localIP)) != (ceReturnToInterpreterPC()));
				GIV(instructionPointer) = oopForPointer(localIP);
				GIV(stackPointer) = localSP;
				GIV(framePointer) = localFP;
				array = eeInstantiateClassindexableSize(longAt((GIV(specialObjectsOop) + BaseHeaderSize) + (ClassArray << ShiftForWord)), size);
				/* begin internalizeIPandSP */
				assert(GIV(instructionPointer) != (ceReturnToInterpreterPC()));
				localIP = pointerForOop(GIV(instructionPointer));
				localSP = pointerForOop(GIV(stackPointer));
				localFP = pointerForOop(GIV(framePointer));
				if (popValues) {
					for (i = 0; i <= (size - 1); i += 1) {
						longAtput((array + BaseHeaderSize) + (i << ShiftForWord), longAtPointer(localSP + (((size - i) - 1) * BytesPerWord)));
					}
					/* begin internalPop: */
					localSP += size * BytesPerWord;
				}
				else {
					for (i = 0; i <= (size - 1); i += 1) {
						longAtput((array + BaseHeaderSize) + (i << ShiftForWord), GIV(nilObj));
					}
				}
				/* begin internalPush: */
				longAtPointerput(localSP -= BytesPerWord, array);
			}
;
			BREAK;
		CASE(139)
			/* unknownBytecode */
			{

				VM_LABEL(1unknownBytecode);
								error("Unknown bytecode");
			}
;
			BREAK;
		CASE(140)
			/* pushRemoteTempLongBytecode */
			{
				sqInt remoteTempIndex;
				sqInt tempVectorIndex;
				sqInt tempVector;
				sqInt frameNumArgs;

				VM_LABEL(0pushRemoteTempLongBytecode);
								remoteTempIndex = byteAtPointer(++localIP);
				tempVectorIndex = byteAtPointer(++localIP);
				/* begin fetchNextBytecode */
				currentBytecode = byteAtPointer(++localIP);
				/* begin pushRemoteTemp:inVectorAt: */
				VM_LABEL(0pushRemoteTempinVectorAt);
				tempVector = (tempVectorIndex < ((frameNumArgs = byteAt((localFP + FoxIFrameFlags) + 1)))
					? longAt((localFP + FoxCallerSavedIP) + ((frameNumArgs - tempVectorIndex) * BytesPerWord))
					: longAt(((localFP + FoxIFReceiver) - BytesPerWord) + ((frameNumArgs - tempVectorIndex) * BytesPerWord)));
				/* begin internalPush: */
				longAtPointerput(localSP -= BytesPerWord, longAt((tempVector + BaseHeaderSize) + (remoteTempIndex << ShiftForWord)));
			}
;
			BREAK;
		CASE(141)
			/* storeRemoteTempLongBytecode */
			{
				sqInt remoteTempIndex;
				sqInt tempVectorIndex;
				sqInt tempVector;
				sqInt frameNumArgs;

				VM_LABEL(0storeRemoteTempLongBytecode);
								remoteTempIndex = byteAtPointer(++localIP);
				tempVectorIndex = byteAtPointer(++localIP);
				/* begin fetchNextBytecode */
				currentBytecode = byteAtPointer(++localIP);
				/* begin storeRemoteTemp:inVectorAt: */
				VM_LABEL(0storeRemoteTempinVectorAt);
				tempVector = (tempVectorIndex < ((frameNumArgs = byteAt((localFP + FoxIFrameFlags) + 1)))
					? longAt((localFP + FoxCallerSavedIP) + ((frameNumArgs - tempVectorIndex) * BytesPerWord))
					: longAt(((localFP + FoxIFReceiver) - BytesPerWord) + ((frameNumArgs - tempVectorIndex) * BytesPerWord)));
				/* begin storePointer:ofObject:withValue: */
				if ((((usqInt) tempVector)) < (((usqInt) GIV(youngStart)))) {
					possibleRootStoreIntovalue(tempVector, longAtPointer(localSP));
				}
				longAtput((tempVector + BaseHeaderSize) + (remoteTempIndex << ShiftForWord), longAtPointer(localSP));
			}
;
			BREAK;
		CASE(142)
			/* storeAndPopRemoteTempLongBytecode */
			{
				sqInt remoteTempIndex;
				sqInt tempVectorIndex;
				sqInt tempVector;
				sqInt frameNumArgs;

				VM_LABEL(0storeAndPopRemoteTempLongBytecode);
								/* begin storeRemoteTempLongBytecode */
				remoteTempIndex = byteAtPointer(++localIP);
				tempVectorIndex = byteAtPointer(++localIP);
				/* begin fetchNextBytecode */
				currentBytecode = byteAtPointer(++localIP);
				/* begin storeRemoteTemp:inVectorAt: */
				VM_LABEL(1storeRemoteTempinVectorAt);
				tempVector = (tempVectorIndex < ((frameNumArgs = byteAt((localFP + FoxIFrameFlags) + 1)))
					? longAt((localFP + FoxCallerSavedIP) + ((frameNumArgs - tempVectorIndex) * BytesPerWord))
					: longAt(((localFP + FoxIFReceiver) - BytesPerWord) + ((frameNumArgs - tempVectorIndex) * BytesPerWord)));
				/* begin storePointer:ofObject:withValue: */
				if ((((usqInt) tempVector)) < (((usqInt) GIV(youngStart)))) {
					possibleRootStoreIntovalue(tempVector, longAtPointer(localSP));
				}
				longAtput((tempVector + BaseHeaderSize) + (remoteTempIndex << ShiftForWord), longAtPointer(localSP));
				/* begin internalPop: */
				localSP += 1 * BytesPerWord;
			}
;
			BREAK;
		CASE(143)
			/* pushClosureCopyCopiedValuesBytecode */
			{
				sqInt blockSize;
				sqInt context;
				sqInt i;
				sqInt newClosure;
				sqInt numArgs;
				sqInt numArgsNumCopied;
				sqInt numCopied;
				sqInt initialIP;
				sqInt newClosure1;
				char *theFP;
				char *theSP;

				VM_LABEL(0pushClosureCopyCopiedValuesBytecode);
								numArgsNumCopied = byteAtPointer(++localIP);
				numArgs = numArgsNumCopied & 15;

				/* Split blockSize := (self fetchByte * 256) + self fetchByte. into two because evaluation order in C is undefined. */

				numCopied = ((usqInt) numArgsNumCopied >> 4);
				blockSize = (byteAtPointer(++localIP)) << 8;
				blockSize += byteAtPointer(++localIP);
				/* begin ensureFrameIsMarried:SP: */
				VM_LABEL(5ensureFrameIsMarriedSP);
				theFP = localFP;
				theSP = localSP;
				if (((((usqInt)(longAt(theFP + FoxMethod)))) < heapBase
					? ((longAt(theFP + FoxMethod)) & MFMethodFlagHasContextFlag) != 0
					: (byteAt((theFP + FoxIFrameFlags) + 2)) != 0)) {
					assert(isContext(frameContext(theFP)));
					context = longAt(theFP + FoxThisContext);
					goto l9;
				}
				context = marryFrameSP(theFP, theSP);
			l9:	/* end ensureFrameIsMarried:SP: */;
				/* begin closureIn:numArgs:instructionPointer:numCopiedValues: */
				VM_LABEL(0closureInnumArgsinstructionPointernumCopiedValues);
				initialIP = ((oopForPointer(localIP)) + 2) - (GIV(method) + BaseHeaderSize);
				assert(((BytesPerWord * (ClosureFirstCopiedValueIndex + numCopied)) + BaseHeaderSize) <= 252);

				/* Assume: have just allocated a new closure; it must be young. Thus, can use unchecked stores. */

				newClosure1 = eeInstantiateSmallClasssizeInBytes(longAt((GIV(specialObjectsOop) + BaseHeaderSize) + (ClassBlockClosure << ShiftForWord)), (BytesPerWord * (ClosureFirstCopiedValueIndex + numCopied)) + BaseHeaderSize);
				longAtput((newClosure1 + BaseHeaderSize) + (ClosureOuterContextIndex << ShiftForWord), context);
				longAtput((newClosure1 + BaseHeaderSize) + (ClosureStartPCIndex << ShiftForWord), ((initialIP << 1) | 1));
				longAtput((newClosure1 + BaseHeaderSize) + (ClosureNumArgsIndex << ShiftForWord), ((numArgs << 1) | 1));
				newClosure = newClosure1;
				if (recordSendTrace()) {
					/* begin recordTrace:thing:source: */
					GIV(traceLog)[GIV(traceLogIndex)] = TraceBlockCreation;
					GIV(traceLog)[GIV(traceLogIndex) + 1] = newClosure;
					GIV(traceLog)[GIV(traceLogIndex) + 2] = TraceIsFromInterpreter;
					GIV(traceLogIndex) = (GIV(traceLogIndex) + 3) % TraceBufferSize;
				}
				if (numCopied > 0) {
					for (i = 0; i <= (numCopied - 1); i += 1) {
						longAtput((newClosure + BaseHeaderSize) + ((i + ClosureFirstCopiedValueIndex) << ShiftForWord), longAtPointer(localSP + (((numCopied - i) - 1) * BytesPerWord)));
					}
					/* begin internalPop: */
					localSP += numCopied * BytesPerWord;
				}
				localIP += blockSize;
				/* begin fetchNextBytecode */
				currentBytecode = byteAtPointer(++localIP);
				/* begin internalPush: */
				longAtPointerput(localSP -= BytesPerWord, newClosure);
			}
;
			BREAK;
		CASE(144)
			/* shortUnconditionalJump */
			{
				sqInt offset;

				VM_LABEL(0shortUnconditionalJump);
								/* begin jump: */
				offset = (144 & 7) + 1;
				localIP = (localIP + offset) + 1;
				currentBytecode = byteAtPointer(localIP);
			}
;
			BREAK;
		CASE(145)
			/* shortUnconditionalJump */
			{
				sqInt offset;

				VM_LABEL(1shortUnconditionalJump);
								/* begin jump: */
				offset = (145 & 7) + 1;
				localIP = (localIP + offset) + 1;
				currentBytecode = byteAtPointer(localIP);
			}
;
			BREAK;
		CASE(146)
			/* shortUnconditionalJump */
			{
				sqInt offset;

				VM_LABEL(2shortUnconditionalJump);
								/* begin jump: */
				offset = (146 & 7) + 1;
				localIP = (localIP + offset) + 1;
				currentBytecode = byteAtPointer(localIP);
			}
;
			BREAK;
		CASE(147)
			/* shortUnconditionalJump */
			{
				sqInt offset;

				VM_LABEL(3shortUnconditionalJump);
								/* begin jump: */
				offset = (147 & 7) + 1;
				localIP = (localIP + offset) + 1;
				currentBytecode = byteAtPointer(localIP);
			}
;
			BREAK;
		CASE(148)
			/* shortUnconditionalJump */
			{
				sqInt offset;

				VM_LABEL(4shortUnconditionalJump);
								/* begin jump: */
				offset = (148 & 7) + 1;
				localIP = (localIP + offset) + 1;
				currentBytecode = byteAtPointer(localIP);
			}
;
			BREAK;
		CASE(149)
			/* shortUnconditionalJump */
			{
				sqInt offset;

				VM_LABEL(5shortUnconditionalJump);
								/* begin jump: */
				offset = (149 & 7) + 1;
				localIP = (localIP + offset) + 1;
				currentBytecode = byteAtPointer(localIP);
			}
;
			BREAK;
		CASE(150)
			/* shortUnconditionalJump */
			{
				sqInt offset;

				VM_LABEL(6shortUnconditionalJump);
								/* begin jump: */
				offset = (150 & 7) + 1;
				localIP = (localIP + offset) + 1;
				currentBytecode = byteAtPointer(localIP);
			}
;
			BREAK;
		CASE(151)
			/* shortUnconditionalJump */
			{
				sqInt offset;

				VM_LABEL(7shortUnconditionalJump);
								/* begin jump: */
				offset = (151 & 7) + 1;
				localIP = (localIP + offset) + 1;
				currentBytecode = byteAtPointer(localIP);
			}
;
			BREAK;
		CASE(152)
		CASE(153)
		CASE(154)
		CASE(155)
		CASE(156)
		CASE(157)
		CASE(158)
		CASE(159)
			/* shortConditionalJump */
			{
				sqInt offset;
				sqInt boolean;

				VM_LABEL(0shortConditionalJump);
								/* begin jumplfFalseBy: */
				offset = (currentBytecode & 7) + 1;
				boolean = longAtPointer(localSP);
				if (boolean == GIV(falseObj)) {
					/* begin jump: */
					localIP = (localIP + offset) + 1;
					currentBytecode = byteAtPointer(localIP);
				}
				else {
					if (!(boolean == GIV(trueObj))) {
						/* begin internalMustBeBoolean */
						GIV(messageSelector) = longAt((GIV(specialObjectsOop) + BaseHeaderSize) + (SelectorMustBeBoolean << ShiftForWord));
						GIV(argumentCount) = 0;
						goto normalSend;
						goto l10;
					}
					/* begin fetchNextBytecode */
					currentBytecode = byteAtPointer(++localIP);
				}
				/* begin internalPop: */
				localSP += 1 * BytesPerWord;
			l10:	/* end jumplfFalseBy: */;
			}
;
			BREAK;
		CASE(160)
		CASE(161)
		CASE(162)
		CASE(163)
		CASE(164)
		CASE(165)
		CASE(166)
		CASE(167)
			/* longUnconditionalJump */
			{
				sqInt offset;
				sqInt switched;

				VM_LABEL(0longUnconditionalJump);
								offset = (((currentBytecode & 7) - 4) * 256) + (byteAtPointer(++localIP));

				/* backward jump means we're in a loop.
		- check for possible interrupts.
		- check for long-running loops and JIT if appropriate. */

				localIP += offset;
				if (offset < 0) {
					if (localSP < GIV(stackLimit)) {
						/* begin externalizeIPandSP */
						assert((((usqInt)localIP)) != (ceReturnToInterpreterPC()));
						GIV(instructionPointer) = oopForPointer(localIP);
						GIV(stackPointer) = localSP;
						GIV(framePointer) = localFP;
						switched = checkForEventsMayContextSwitch(1);
						returnToExecutivepostContextSwitch(1, switched);
						browserPluginReturnIfNeeded();
						/* begin internalizeIPandSP */
						assert(GIV(instructionPointer) != (ceReturnToInterpreterPC()));
						localIP = pointerForOop(GIV(instructionPointer));
						localSP = pointerForOop(GIV(stackPointer));
						localFP = pointerForOop(GIV(framePointer));
					}
					if (GIV(method) == lastBackwardJumpMethod) {
						if (((backwardJumpCount -= 1)) <= 0) {
							if (methodWithHeaderShouldBeCogged(headerOf(GIV(method)))) {
								/* begin externalizeFPandSP */
								assert((localSP < ((GIV(stackPage)->baseAddress)))
								 && (localSP > (((GIV(stackPage)->realStackLimit)) - LargeContextSize)));
								GIV(stackPointer) = localSP;
								GIV(framePointer) = localFP;
								attemptToSwitchToMachineCode(((((oopForPointer(localIP)) - offset) - GIV(method)) - BaseHeaderSize) - 1);
							}
							else {

								/* don't ask if one should compile a second time... */

								backwardJumpCount = ((((BytesPerWord * 8) - 2) < 0) ? ((usqInt) 1 >> -((BytesPerWord * 8) - 2)) : ((usqInt) 1 << ((BytesPerWord * 8) - 2)));
							}
						}
					}
					else {
						lastBackwardJumpMethod = GIV(method);
						backwardJumpCount = minBackwardJumpCountForCompile;
					}
				}
				/* begin fetchNextBytecode */
				currentBytecode = byteAtPointer(++localIP);
			}
;
			BREAK;
		CASE(168)
		CASE(169)
		CASE(170)
		CASE(171)
			/* longJumpIfTrue */
			{
				sqInt offset;
				sqInt boolean;

				VM_LABEL(0longJumpIfTrue);
								/* begin jumplfTrueBy: */
				offset = ((currentBytecode & 3) * 256) + (byteAtPointer(++localIP));
				boolean = longAtPointer(localSP);
				if (boolean == GIV(trueObj)) {
					/* begin jump: */
					localIP = (localIP + offset) + 1;
					currentBytecode = byteAtPointer(localIP);
				}
				else {
					if (!(boolean == GIV(falseObj))) {
						/* begin internalMustBeBoolean */
						GIV(messageSelector) = longAt((GIV(specialObjectsOop) + BaseHeaderSize) + (SelectorMustBeBoolean << ShiftForWord));
						GIV(argumentCount) = 0;
						goto normalSend;
						goto l11;
					}
					/* begin fetchNextBytecode */
					currentBytecode = byteAtPointer(++localIP);
				}
				/* begin internalPop: */
				localSP += 1 * BytesPerWord;
			l11:	/* end jumplfTrueBy: */;
			}
;
			BREAK;
		CASE(172)
		CASE(173)
		CASE(174)
		CASE(175)
			/* longJumpIfFalse */
			{
				sqInt offset;
				sqInt boolean;

				VM_LABEL(0longJumpIfFalse);
								/* begin jumplfFalseBy: */
				offset = ((currentBytecode & 3) * 256) + (byteAtPointer(++localIP));
				boolean = longAtPointer(localSP);
				if (boolean == GIV(falseObj)) {
					/* begin jump: */
					localIP = (localIP + offset) + 1;
					currentBytecode = byteAtPointer(localIP);
				}
				else {
					if (!(boolean == GIV(trueObj))) {
						/* begin internalMustBeBoolean */
						GIV(messageSelector) = longAt((GIV(specialObjectsOop) + BaseHeaderSize) + (SelectorMustBeBoolean << ShiftForWord));
						GIV(argumentCount) = 0;
						goto normalSend;
						goto l12;
					}
					/* begin fetchNextBytecode */
					currentBytecode = byteAtPointer(++localIP);
				}
				/* begin internalPop: */
				localSP += 1 * BytesPerWord;
			l12:	/* end jumplfFalseBy: */;
			}
;
			BREAK;
		CASE(176)
			/* bytecodePrimAdd */
			{
				sqInt arg;
				sqInt rcvr;
				sqInt result;
				double arg1;
				double rcvr1;
				char *sp;
				double result1;
				sqInt successBoolean;
				sqInt ccIndex;
				double result2;
				sqInt successBoolean1;
				sqInt ccIndex1;

				VM_LABEL(0bytecodePrimAdd);
								rcvr = longAtPointer(localSP + (1 * BytesPerWord));
				arg = longAtPointer(localSP + (0 * BytesPerWord));
				if (((rcvr & arg) & 1) != 0) {
					result = ((rcvr >> 1)) + ((arg >> 1));
					if ((result ^ (result << 1)) >= 0) {
						/* begin internalPop:thenPush: */
						longAtPointerput(localSP += (2 - 1) * BytesPerWord, ((result << 1) | 1));
						/* begin fetchNextBytecode */
						currentBytecode = byteAtPointer(++localIP);
						goto l13;
					}
				}
				else {
					/* begin initPrimCall */
					GIV(primFailCode) = 0;
					/* begin externalizeIPandSP */
					assert((((usqInt)localIP)) != (ceReturnToInterpreterPC()));
					GIV(instructionPointer) = oopForPointer(localIP);
					GIV(stackPointer) = localSP;
					GIV(framePointer) = localFP;
					/* begin primitiveFloatAdd:toArg: */
					/* begin loadFloatOrIntFrom: */
					if ((rcvr & 1)) {
						rcvr1 = ((double) ((rcvr >> 1)) );
						goto l15;
					}
					/* begin assertClassOf:is:compactClassIndex: */
					VM_LABEL(0assertClassOfiscompactClassIndex);
					/* begin success: */
					/* begin is:instanceOf:compactClassIndex: */
					if ((rcvr & 1)) {
						successBoolean = 0;
						goto l14;
					}
					ccIndex = (((usqInt) (longAt(rcvr))) >> 12) & 31;
					if (ClassFloatCompactIndex != 0) {
						successBoolean = ClassFloatCompactIndex == ccIndex;
						goto l14;
					}
					successBoolean = (ccIndex == 0)
					 && (((longAt(rcvr - BaseHeaderSize)) & AllButTypeMask) == (longAt((GIV(specialObjectsOop) + BaseHeaderSize) + (ClassFloat << ShiftForWord))));
				l14:	/* end is:instanceOf:compactClassIndex: */;
					if (!(successBoolean)) {
						if (GIV(primFailCode) == 0) {

							/* Don't overwrite an error code that has already been set. */

							GIV(primFailCode) = 1;
						}
					}
					;
					if (GIV(primFailCode) == 0) {
						fetchFloatAtinto(rcvr + BaseHeaderSize, result1);
					}
					rcvr1 = result1;
				l15:	/* end loadFloatOrIntFrom: */;
					/* begin loadFloatOrIntFrom: */
					if ((arg & 1)) {
						arg1 = ((double) ((arg >> 1)) );
						goto l17;
					}
					/* begin assertClassOf:is:compactClassIndex: */
					VM_LABEL(1assertClassOfiscompactClassIndex);
					/* begin success: */
					/* begin is:instanceOf:compactClassIndex: */
					if ((arg & 1)) {
						successBoolean1 = 0;
						goto l16;
					}
					ccIndex1 = (((usqInt) (longAt(arg))) >> 12) & 31;
					if (ClassFloatCompactIndex != 0) {
						successBoolean1 = ClassFloatCompactIndex == ccIndex1;
						goto l16;
					}
					successBoolean1 = (ccIndex1 == 0)
					 && (((longAt(arg - BaseHeaderSize)) & AllButTypeMask) == (longAt((GIV(specialObjectsOop) + BaseHeaderSize) + (ClassFloat << ShiftForWord))));
				l16:	/* end is:instanceOf:compactClassIndex: */;
					if (!(successBoolean1)) {
						if (GIV(primFailCode) == 0) {

							/* Don't overwrite an error code that has already been set. */

							GIV(primFailCode) = 1;
						}
					}
					;
					if (GIV(primFailCode) == 0) {
						fetchFloatAtinto(arg + BaseHeaderSize, result2);
					}
					arg1 = result2;
				l17:	/* end loadFloatOrIntFrom: */;
					if (GIV(primFailCode) == 0) {
						/* begin pop:thenPushFloat: */
						longAtput(sp = GIV(stackPointer) + ((2 - 1) * BytesPerWord), floatObjectOf(rcvr1 + arg1));
						GIV(stackPointer) = sp;
					}
					/* begin internalizeIPandSP */
					assert(GIV(instructionPointer) != (ceReturnToInterpreterPC()));
					localIP = pointerForOop(GIV(instructionPointer));
					localSP = pointerForOop(GIV(stackPointer));
					localFP = pointerForOop(GIV(framePointer));
					if (GIV(primFailCode) == 0) {
						/* begin fetchNextBytecode */
						currentBytecode = byteAtPointer(++localIP);
						goto l13;
					}
				}
				GIV(messageSelector) = longAt(((longAt((GIV(specialObjectsOop) + BaseHeaderSize) + (SpecialSelectors << ShiftForWord))) + BaseHeaderSize) + ((0 * 2) << ShiftForWord));
				GIV(argumentCount) = 1;
				goto normalSend;
			}
;
		l13:	/* end case */;
			BREAK;
		CASE(177)
			/* bytecodePrimSubtract */
			{
				sqInt arg;
				sqInt rcvr;
				sqInt result;
				double arg1;
				double rcvr1;
				char *sp;
				double result1;
				sqInt successBoolean;
				sqInt ccIndex;
				double result2;
				sqInt successBoolean1;
				sqInt ccIndex1;

				VM_LABEL(0bytecodePrimSubtract);
								rcvr = longAtPointer(localSP + (1 * BytesPerWord));
				arg = longAtPointer(localSP + (0 * BytesPerWord));
				if (((rcvr & arg) & 1) != 0) {
					result = ((rcvr >> 1)) - ((arg >> 1));
					if ((result ^ (result << 1)) >= 0) {
						/* begin internalPop:thenPush: */
						longAtPointerput(localSP += (2 - 1) * BytesPerWord, ((result << 1) | 1));
						/* begin fetchNextBytecode */
						currentBytecode = byteAtPointer(++localIP);
						goto l18;
					}
				}
				else {
					/* begin initPrimCall */
					GIV(primFailCode) = 0;
					/* begin externalizeIPandSP */
					assert((((usqInt)localIP)) != (ceReturnToInterpreterPC()));
					GIV(instructionPointer) = oopForPointer(localIP);
					GIV(stackPointer) = localSP;
					GIV(framePointer) = localFP;
					/* begin primitiveFloatSubtract:fromArg: */
					/* begin loadFloatOrIntFrom: */
					if ((rcvr & 1)) {
						rcvr1 = ((double) ((rcvr >> 1)) );
						goto l20;
					}
					/* begin assertClassOf:is:compactClassIndex: */
					VM_LABEL(2assertClassOfiscompactClassIndex);
					/* begin success: */
					/* begin is:instanceOf:compactClassIndex: */
					if ((rcvr & 1)) {
						successBoolean = 0;
						goto l19;
					}
					ccIndex = (((usqInt) (longAt(rcvr))) >> 12) & 31;
					if (ClassFloatCompactIndex != 0) {
						successBoolean = ClassFloatCompactIndex == ccIndex;
						goto l19;
					}
					successBoolean = (ccIndex == 0)
					 && (((longAt(rcvr - BaseHeaderSize)) & AllButTypeMask) == (longAt((GIV(specialObjectsOop) + BaseHeaderSize) + (ClassFloat << ShiftForWord))));
				l19:	/* end is:instanceOf:compactClassIndex: */;
					if (!(successBoolean)) {
						if (GIV(primFailCode) == 0) {

							/* Don't overwrite an error code that has already been set. */

							GIV(primFailCode) = 1;
						}
					}
					;
					if (GIV(primFailCode) == 0) {
						fetchFloatAtinto(rcvr + BaseHeaderSize, result1);
					}
					rcvr1 = result1;
				l20:	/* end loadFloatOrIntFrom: */;
					/* begin loadFloatOrIntFrom: */
					if ((arg & 1)) {
						arg1 = ((double) ((arg >> 1)) );
						goto l22;
					}
					/* begin assertClassOf:is:compactClassIndex: */
					VM_LABEL(3assertClassOfiscompactClassIndex);
					/* begin success: */
					/* begin is:instanceOf:compactClassIndex: */
					if ((arg & 1)) {
						successBoolean1 = 0;
						goto l21;
					}
					ccIndex1 = (((usqInt) (longAt(arg))) >> 12) & 31;
					if (ClassFloatCompactIndex != 0) {
						successBoolean1 = ClassFloatCompactIndex == ccIndex1;
						goto l21;
					}
					successBoolean1 = (ccIndex1 == 0)
					 && (((longAt(arg - BaseHeaderSize)) & AllButTypeMask) == (longAt((GIV(specialObjectsOop) + BaseHeaderSize) + (ClassFloat << ShiftForWord))));
				l21:	/* end is:instanceOf:compactClassIndex: */;
					if (!(successBoolean1)) {
						if (GIV(primFailCode) == 0) {

							/* Don't overwrite an error code that has already been set. */

							GIV(primFailCode) = 1;
						}
					}
					;
					if (GIV(primFailCode) == 0) {
						fetchFloatAtinto(arg + BaseHeaderSize, result2);
					}
					arg1 = result2;
				l22:	/* end loadFloatOrIntFrom: */;
					if (GIV(primFailCode) == 0) {
						/* begin pop:thenPushFloat: */
						longAtput(sp = GIV(stackPointer) + ((2 - 1) * BytesPerWord), floatObjectOf(rcvr1 - arg1));
						GIV(stackPointer) = sp;
					}
					/* begin internalizeIPandSP */
					assert(GIV(instructionPointer) != (ceReturnToInterpreterPC()));
					localIP = pointerForOop(GIV(instructionPointer));
					localSP = pointerForOop(GIV(stackPointer));
					localFP = pointerForOop(GIV(framePointer));
					if (GIV(primFailCode) == 0) {
						/* begin fetchNextBytecode */
						currentBytecode = byteAtPointer(++localIP);
						goto l18;
					}
				}
				GIV(messageSelector) = longAt(((longAt((GIV(specialObjectsOop) + BaseHeaderSize) + (SpecialSelectors << ShiftForWord))) + BaseHeaderSize) + ((1 * 2) << ShiftForWord));
				GIV(argumentCount) = 1;
				goto normalSend;
			}
;
		l18:	/* end case */;
			BREAK;
		CASE(178)
			/* bytecodePrimLessThan */
			{
				sqInt aBool;
				sqInt arg;
				sqInt rcvr;
				double arg1;
				double rcvr1;
				double result;
				sqInt successBoolean;
				sqInt ccIndex;
				double result1;
				sqInt successBoolean1;
				sqInt ccIndex1;

				VM_LABEL(0bytecodePrimLessThan);
								rcvr = longAtPointer(localSP + (1 * BytesPerWord));
				arg = longAtPointer(localSP + (0 * BytesPerWord));
				if (((rcvr & arg) & 1) != 0) {
					/* begin booleanCheat: */
					if (rcvr < arg) {
						/* goto booleanCheatTrue */
					}
					else {
						goto booleanCheatFalse;
					}
					goto l23;
				}
				/* begin initPrimCall */
				GIV(primFailCode) = 0;
				/* begin primitiveFloatLess:thanArg: */
				/* begin loadFloatOrIntFrom: */
				if ((rcvr & 1)) {
					rcvr1 = ((double) ((rcvr >> 1)) );
					goto l25;
				}
				/* begin assertClassOf:is:compactClassIndex: */
				VM_LABEL(4assertClassOfiscompactClassIndex);
				/* begin success: */
				/* begin is:instanceOf:compactClassIndex: */
				if ((rcvr & 1)) {
					successBoolean = 0;
					goto l24;
				}
				ccIndex = (((usqInt) (longAt(rcvr))) >> 12) & 31;
				if (ClassFloatCompactIndex != 0) {
					successBoolean = ClassFloatCompactIndex == ccIndex;
					goto l24;
				}
				successBoolean = (ccIndex == 0)
				 && (((longAt(rcvr - BaseHeaderSize)) & AllButTypeMask) == (longAt((GIV(specialObjectsOop) + BaseHeaderSize) + (ClassFloat << ShiftForWord))));
			l24:	/* end is:instanceOf:compactClassIndex: */;
				if (!(successBoolean)) {
					if (GIV(primFailCode) == 0) {

						/* Don't overwrite an error code that has already been set. */

						GIV(primFailCode) = 1;
					}
				}
				;
				if (GIV(primFailCode) == 0) {
					fetchFloatAtinto(rcvr + BaseHeaderSize, result);
				}
				rcvr1 = result;
			l25:	/* end loadFloatOrIntFrom: */;
				/* begin loadFloatOrIntFrom: */
				if ((arg & 1)) {
					arg1 = ((double) ((arg >> 1)) );
					goto l27;
				}
				/* begin assertClassOf:is:compactClassIndex: */
				VM_LABEL(5assertClassOfiscompactClassIndex);
				/* begin success: */
				/* begin is:instanceOf:compactClassIndex: */
				if ((arg & 1)) {
					successBoolean1 = 0;
					goto l26;
				}
				ccIndex1 = (((usqInt) (longAt(arg))) >> 12) & 31;
				if (ClassFloatCompactIndex != 0) {
					successBoolean1 = ClassFloatCompactIndex == ccIndex1;
					goto l26;
				}
				successBoolean1 = (ccIndex1 == 0)
				 && (((longAt(arg - BaseHeaderSize)) & AllButTypeMask) == (longAt((GIV(specialObjectsOop) + BaseHeaderSize) + (ClassFloat << ShiftForWord))));
			l26:	/* end is:instanceOf:compactClassIndex: */;
				if (!(successBoolean1)) {
					if (GIV(primFailCode) == 0) {

						/* Don't overwrite an error code that has already been set. */

						GIV(primFailCode) = 1;
					}
				}
				;
				if (GIV(primFailCode) == 0) {
					fetchFloatAtinto(arg + BaseHeaderSize, result1);
				}
				arg1 = result1;
			l27:	/* end loadFloatOrIntFrom: */;
				aBool = rcvr1 < arg1;
				if (GIV(primFailCode) == 0) {
					/* begin booleanCheat: */
					if (aBool) {
						/* goto booleanCheatTrue */
					}
					else {
						goto booleanCheatFalse;
					}
					goto l23;
				}
				GIV(messageSelector) = longAt(((longAt((GIV(specialObjectsOop) + BaseHeaderSize) + (SpecialSelectors << ShiftForWord))) + BaseHeaderSize) + ((2 * 2) << ShiftForWord));
				GIV(argumentCount) = 1;
				goto normalSend;
			}
;
		l23:	/* end case */;
			
		booleanCheatTrue:
			/* booleanCheatTrue */
			{
				sqInt bytecode;

				VM_LABEL(0booleanCheatTrue);
				
				/* assume next bytecode is jumpIfFalse (99%) */

				bytecode = byteAtPointer(++localIP);
				/* begin internalPop: */
				localSP += 2 * BytesPerWord;
				if ((bytecode < 160)
				 && (bytecode > 151)) {
					/* begin fetchNextBytecode */
					currentBytecode = byteAtPointer(++localIP);
					goto l107;
				}
				if (bytecode == 172) {
					byteAtPointer(++localIP);
					/* begin fetchNextBytecode */
					currentBytecode = byteAtPointer(++localIP);
					goto l107;
				}
				localIP -= 1;
				/* begin fetchNextBytecode */
				currentBytecode = byteAtPointer(++localIP);
				/* begin internalPush: */
				longAtPointerput(localSP -= BytesPerWord, GIV(trueObj));
			}
;
		l107:	/* end case */;
			BREAK;
		CASE(179)
			/* bytecodePrimGreaterThan */
			{
				sqInt aBool;
				sqInt arg;
				sqInt rcvr;
				double arg1;
				double rcvr1;
				double result;
				sqInt successBoolean;
				sqInt ccIndex;
				double result1;
				sqInt successBoolean1;
				sqInt ccIndex1;

				VM_LABEL(0bytecodePrimGreaterThan);
								rcvr = longAtPointer(localSP + (1 * BytesPerWord));
				arg = longAtPointer(localSP + (0 * BytesPerWord));
				if (((rcvr & arg) & 1) != 0) {
					/* begin booleanCheat: */
					if (rcvr > arg) {
						goto booleanCheatTrue;
					}
					else {
						/* goto booleanCheatFalse */
					}
					goto l28;
				}
				/* begin initPrimCall */
				GIV(primFailCode) = 0;
				/* begin primitiveFloatGreater:thanArg: */
				/* begin loadFloatOrIntFrom: */
				if ((rcvr & 1)) {
					rcvr1 = ((double) ((rcvr >> 1)) );
					goto l30;
				}
				/* begin assertClassOf:is:compactClassIndex: */
				VM_LABEL(6assertClassOfiscompactClassIndex);
				/* begin success: */
				/* begin is:instanceOf:compactClassIndex: */
				if ((rcvr & 1)) {
					successBoolean = 0;
					goto l29;
				}
				ccIndex = (((usqInt) (longAt(rcvr))) >> 12) & 31;
				if (ClassFloatCompactIndex != 0) {
					successBoolean = ClassFloatCompactIndex == ccIndex;
					goto l29;
				}
				successBoolean = (ccIndex == 0)
				 && (((longAt(rcvr - BaseHeaderSize)) & AllButTypeMask) == (longAt((GIV(specialObjectsOop) + BaseHeaderSize) + (ClassFloat << ShiftForWord))));
			l29:	/* end is:instanceOf:compactClassIndex: */;
				if (!(successBoolean)) {
					if (GIV(primFailCode) == 0) {

						/* Don't overwrite an error code that has already been set. */

						GIV(primFailCode) = 1;
					}
				}
				;
				if (GIV(primFailCode) == 0) {
					fetchFloatAtinto(rcvr + BaseHeaderSize, result);
				}
				rcvr1 = result;
			l30:	/* end loadFloatOrIntFrom: */;
				/* begin loadFloatOrIntFrom: */
				if ((arg & 1)) {
					arg1 = ((double) ((arg >> 1)) );
					goto l32;
				}
				/* begin assertClassOf:is:compactClassIndex: */
				VM_LABEL(7assertClassOfiscompactClassIndex);
				/* begin success: */
				/* begin is:instanceOf:compactClassIndex: */
				if ((arg & 1)) {
					successBoolean1 = 0;
					goto l31;
				}
				ccIndex1 = (((usqInt) (longAt(arg))) >> 12) & 31;
				if (ClassFloatCompactIndex != 0) {
					successBoolean1 = ClassFloatCompactIndex == ccIndex1;
					goto l31;
				}
				successBoolean1 = (ccIndex1 == 0)
				 && (((longAt(arg - BaseHeaderSize)) & AllButTypeMask) == (longAt((GIV(specialObjectsOop) + BaseHeaderSize) + (ClassFloat << ShiftForWord))));
			l31:	/* end is:instanceOf:compactClassIndex: */;
				if (!(successBoolean1)) {
					if (GIV(primFailCode) == 0) {

						/* Don't overwrite an error code that has already been set. */

						GIV(primFailCode) = 1;
					}
				}
				;
				if (GIV(primFailCode) == 0) {
					fetchFloatAtinto(arg + BaseHeaderSize, result1);
				}
				arg1 = result1;
			l32:	/* end loadFloatOrIntFrom: */;
				aBool = rcvr1 > arg1;
				if (GIV(primFailCode) == 0) {
					/* begin booleanCheat: */
					if (aBool) {
						goto booleanCheatTrue;
					}
					else {
						/* goto booleanCheatFalse */
					}
					goto l28;
				}
				GIV(messageSelector) = longAt(((longAt((GIV(specialObjectsOop) + BaseHeaderSize) + (SpecialSelectors << ShiftForWord))) + BaseHeaderSize) + ((3 * 2) << ShiftForWord));
				GIV(argumentCount) = 1;
				goto normalSend;
			}
;
		l28:	/* end case */;
			
		booleanCheatFalse:
			/* booleanCheatFalse */
			{
				sqInt bytecode;
				sqInt offset;

				VM_LABEL(0booleanCheatFalse);
				
				/* assume next bytecode is jumpIfFalse (99%) */

				bytecode = byteAtPointer(++localIP);
				/* begin internalPop: */
				localSP += 2 * BytesPerWord;
				if ((bytecode < 160)
				 && (bytecode > 151)) {
					/* begin jump: */
					localIP = (localIP + (bytecode - 151)) + 1;
					currentBytecode = byteAtPointer(localIP);
					goto l108;
				}
				if (bytecode == 172) {

					/* long jumpIfFalse */

					offset = byteAtPointer(++localIP);
					/* begin jump: */
					localIP = (localIP + offset) + 1;
					currentBytecode = byteAtPointer(localIP);
					goto l108;
				}
				localIP -= 1;
				/* begin fetchNextBytecode */
				currentBytecode = byteAtPointer(++localIP);
				/* begin internalPush: */
				longAtPointerput(localSP -= BytesPerWord, GIV(falseObj));
			}
;
		l108:	/* end case */;
			BREAK;
		CASE(180)
			/* bytecodePrimLessOrEqual */
			{
				sqInt aBool;
				sqInt arg;
				sqInt rcvr;
				double arg1;
				double rcvr1;
				double result;
				sqInt successBoolean;
				sqInt ccIndex;
				double result1;
				sqInt successBoolean1;
				sqInt ccIndex1;

				VM_LABEL(0bytecodePrimLessOrEqual);
								rcvr = longAtPointer(localSP + (1 * BytesPerWord));
				arg = longAtPointer(localSP + (0 * BytesPerWord));
				if (((rcvr & arg) & 1) != 0) {
					/* begin booleanCheat: */
					if (rcvr <= arg) {
						goto booleanCheatTrue;
					}
					else {
						goto booleanCheatFalse;
					}
					goto l33;
				}
				/* begin initPrimCall */
				GIV(primFailCode) = 0;
				/* begin primitiveFloatLessOrEqual:toArg: */
				/* begin loadFloatOrIntFrom: */
				if ((rcvr & 1)) {
					rcvr1 = ((double) ((rcvr >> 1)) );
					goto l35;
				}
				/* begin assertClassOf:is:compactClassIndex: */
				VM_LABEL(8assertClassOfiscompactClassIndex);
				/* begin success: */
				/* begin is:instanceOf:compactClassIndex: */
				if ((rcvr & 1)) {
					successBoolean = 0;
					goto l34;
				}
				ccIndex = (((usqInt) (longAt(rcvr))) >> 12) & 31;
				if (ClassFloatCompactIndex != 0) {
					successBoolean = ClassFloatCompactIndex == ccIndex;
					goto l34;
				}
				successBoolean = (ccIndex == 0)
				 && (((longAt(rcvr - BaseHeaderSize)) & AllButTypeMask) == (longAt((GIV(specialObjectsOop) + BaseHeaderSize) + (ClassFloat << ShiftForWord))));
			l34:	/* end is:instanceOf:compactClassIndex: */;
				if (!(successBoolean)) {
					if (GIV(primFailCode) == 0) {

						/* Don't overwrite an error code that has already been set. */

						GIV(primFailCode) = 1;
					}
				}
				;
				if (GIV(primFailCode) == 0) {
					fetchFloatAtinto(rcvr + BaseHeaderSize, result);
				}
				rcvr1 = result;
			l35:	/* end loadFloatOrIntFrom: */;
				/* begin loadFloatOrIntFrom: */
				if ((arg & 1)) {
					arg1 = ((double) ((arg >> 1)) );
					goto l37;
				}
				/* begin assertClassOf:is:compactClassIndex: */
				VM_LABEL(9assertClassOfiscompactClassIndex);
				/* begin success: */
				/* begin is:instanceOf:compactClassIndex: */
				if ((arg & 1)) {
					successBoolean1 = 0;
					goto l36;
				}
				ccIndex1 = (((usqInt) (longAt(arg))) >> 12) & 31;
				if (ClassFloatCompactIndex != 0) {
					successBoolean1 = ClassFloatCompactIndex == ccIndex1;
					goto l36;
				}
				successBoolean1 = (ccIndex1 == 0)
				 && (((longAt(arg - BaseHeaderSize)) & AllButTypeMask) == (longAt((GIV(specialObjectsOop) + BaseHeaderSize) + (ClassFloat << ShiftForWord))));
			l36:	/* end is:instanceOf:compactClassIndex: */;
				if (!(successBoolean1)) {
					if (GIV(primFailCode) == 0) {

						/* Don't overwrite an error code that has already been set. */

						GIV(primFailCode) = 1;
					}
				}
				;
				if (GIV(primFailCode) == 0) {
					fetchFloatAtinto(arg + BaseHeaderSize, result1);
				}
				arg1 = result1;
			l37:	/* end loadFloatOrIntFrom: */;
				aBool = rcvr1 <= arg1;
				if (GIV(primFailCode) == 0) {
					/* begin booleanCheat: */
					if (aBool) {
						goto booleanCheatTrue;
					}
					else {
						goto booleanCheatFalse;
					}
					goto l33;
				}
				GIV(messageSelector) = longAt(((longAt((GIV(specialObjectsOop) + BaseHeaderSize) + (SpecialSelectors << ShiftForWord))) + BaseHeaderSize) + ((4 * 2) << ShiftForWord));
				GIV(argumentCount) = 1;
				goto normalSend;
			}
;
		l33:	/* end case */;
			BREAK;
		CASE(181)
			/* bytecodePrimGreaterOrEqual */
			{
				sqInt aBool;
				sqInt arg;
				sqInt rcvr;
				double arg1;
				double rcvr1;
				double result;
				sqInt successBoolean;
				sqInt ccIndex;
				double result1;
				sqInt successBoolean1;
				sqInt ccIndex1;

				VM_LABEL(0bytecodePrimGreaterOrEqual);
								rcvr = longAtPointer(localSP + (1 * BytesPerWord));
				arg = longAtPointer(localSP + (0 * BytesPerWord));
				if (((rcvr & arg) & 1) != 0) {
					/* begin booleanCheat: */
					if (rcvr >= arg) {
						goto booleanCheatTrue;
					}
					else {
						goto booleanCheatFalse;
					}
					goto l38;
				}
				/* begin initPrimCall */
				GIV(primFailCode) = 0;
				/* begin primitiveFloatGreaterOrEqual:toArg: */
				/* begin loadFloatOrIntFrom: */
				if ((rcvr & 1)) {
					rcvr1 = ((double) ((rcvr >> 1)) );
					goto l40;
				}
				/* begin assertClassOf:is:compactClassIndex: */
				VM_LABEL(10assertClassOfiscompactClassIndex);
				/* begin success: */
				/* begin is:instanceOf:compactClassIndex: */
				if ((rcvr & 1)) {
					successBoolean = 0;
					goto l39;
				}
				ccIndex = (((usqInt) (longAt(rcvr))) >> 12) & 31;
				if (ClassFloatCompactIndex != 0) {
					successBoolean = ClassFloatCompactIndex == ccIndex;
					goto l39;
				}
				successBoolean = (ccIndex == 0)
				 && (((longAt(rcvr - BaseHeaderSize)) & AllButTypeMask) == (longAt((GIV(specialObjectsOop) + BaseHeaderSize) + (ClassFloat << ShiftForWord))));
			l39:	/* end is:instanceOf:compactClassIndex: */;
				if (!(successBoolean)) {
					if (GIV(primFailCode) == 0) {

						/* Don't overwrite an error code that has already been set. */

						GIV(primFailCode) = 1;
					}
				}
				;
				if (GIV(primFailCode) == 0) {
					fetchFloatAtinto(rcvr + BaseHeaderSize, result);
				}
				rcvr1 = result;
			l40:	/* end loadFloatOrIntFrom: */;
				/* begin loadFloatOrIntFrom: */
				if ((arg & 1)) {
					arg1 = ((double) ((arg >> 1)) );
					goto l42;
				}
				/* begin assertClassOf:is:compactClassIndex: */
				VM_LABEL(11assertClassOfiscompactClassIndex);
				/* begin success: */
				/* begin is:instanceOf:compactClassIndex: */
				if ((arg & 1)) {
					successBoolean1 = 0;
					goto l41;
				}
				ccIndex1 = (((usqInt) (longAt(arg))) >> 12) & 31;
				if (ClassFloatCompactIndex != 0) {
					successBoolean1 = ClassFloatCompactIndex == ccIndex1;
					goto l41;
				}
				successBoolean1 = (ccIndex1 == 0)
				 && (((longAt(arg - BaseHeaderSize)) & AllButTypeMask) == (longAt((GIV(specialObjectsOop) + BaseHeaderSize) + (ClassFloat << ShiftForWord))));
			l41:	/* end is:instanceOf:compactClassIndex: */;
				if (!(successBoolean1)) {
					if (GIV(primFailCode) == 0) {

						/* Don't overwrite an error code that has already been set. */

						GIV(primFailCode) = 1;
					}
				}
				;
				if (GIV(primFailCode) == 0) {
					fetchFloatAtinto(arg + BaseHeaderSize, result1);
				}
				arg1 = result1;
			l42:	/* end loadFloatOrIntFrom: */;
				aBool = rcvr1 >= arg1;
				if (GIV(primFailCode) == 0) {
					/* begin booleanCheat: */
					if (aBool) {
						goto booleanCheatTrue;
					}
					else {
						goto booleanCheatFalse;
					}
					goto l38;
				}
				GIV(messageSelector) = longAt(((longAt((GIV(specialObjectsOop) + BaseHeaderSize) + (SpecialSelectors << ShiftForWord))) + BaseHeaderSize) + ((5 * 2) << ShiftForWord));
				GIV(argumentCount) = 1;
				goto normalSend;
			}
;
		l38:	/* end case */;
			BREAK;
		CASE(182)
			/* bytecodePrimEqual */
			{
				sqInt aBool;
				sqInt arg;
				sqInt rcvr;
				double arg1;
				double rcvr1;
				double result;
				sqInt successBoolean;
				sqInt ccIndex;
				double result1;
				sqInt successBoolean1;
				sqInt ccIndex1;

				VM_LABEL(0bytecodePrimEqual);
								rcvr = longAtPointer(localSP + (1 * BytesPerWord));
				arg = longAtPointer(localSP + (0 * BytesPerWord));
				if (((rcvr & arg) & 1) != 0) {
					/* begin booleanCheat: */
					if (rcvr == arg) {
						goto booleanCheatTrue;
					}
					else {
						goto booleanCheatFalse;
					}
					goto l43;
				}
				/* begin initPrimCall */
				GIV(primFailCode) = 0;
				/* begin primitiveFloatEqual:toArg: */
				/* begin loadFloatOrIntFrom: */
				if ((rcvr & 1)) {
					rcvr1 = ((double) ((rcvr >> 1)) );
					goto l45;
				}
				/* begin assertClassOf:is:compactClassIndex: */
				VM_LABEL(12assertClassOfiscompactClassIndex);
				/* begin success: */
				/* begin is:instanceOf:compactClassIndex: */
				if ((rcvr & 1)) {
					successBoolean = 0;
					goto l44;
				}
				ccIndex = (((usqInt) (longAt(rcvr))) >> 12) & 31;
				if (ClassFloatCompactIndex != 0) {
					successBoolean = ClassFloatCompactIndex == ccIndex;
					goto l44;
				}
				successBoolean = (ccIndex == 0)
				 && (((longAt(rcvr - BaseHeaderSize)) & AllButTypeMask) == (longAt((GIV(specialObjectsOop) + BaseHeaderSize) + (ClassFloat << ShiftForWord))));
			l44:	/* end is:instanceOf:compactClassIndex: */;
				if (!(successBoolean)) {
					if (GIV(primFailCode) == 0) {

						/* Don't overwrite an error code that has already been set. */

						GIV(primFailCode) = 1;
					}
				}
				;
				if (GIV(primFailCode) == 0) {
					fetchFloatAtinto(rcvr + BaseHeaderSize, result);
				}
				rcvr1 = result;
			l45:	/* end loadFloatOrIntFrom: */;
				/* begin loadFloatOrIntFrom: */
				if ((arg & 1)) {
					arg1 = ((double) ((arg >> 1)) );
					goto l47;
				}
				/* begin assertClassOf:is:compactClassIndex: */
				VM_LABEL(13assertClassOfiscompactClassIndex);
				/* begin success: */
				/* begin is:instanceOf:compactClassIndex: */
				if ((arg & 1)) {
					successBoolean1 = 0;
					goto l46;
				}
				ccIndex1 = (((usqInt) (longAt(arg))) >> 12) & 31;
				if (ClassFloatCompactIndex != 0) {
					successBoolean1 = ClassFloatCompactIndex == ccIndex1;
					goto l46;
				}
				successBoolean1 = (ccIndex1 == 0)
				 && (((longAt(arg - BaseHeaderSize)) & AllButTypeMask) == (longAt((GIV(specialObjectsOop) + BaseHeaderSize) + (ClassFloat << ShiftForWord))));
			l46:	/* end is:instanceOf:compactClassIndex: */;
				if (!(successBoolean1)) {
					if (GIV(primFailCode) == 0) {

						/* Don't overwrite an error code that has already been set. */

						GIV(primFailCode) = 1;
					}
				}
				;
				if (GIV(primFailCode) == 0) {
					fetchFloatAtinto(arg + BaseHeaderSize, result1);
				}
				arg1 = result1;
			l47:	/* end loadFloatOrIntFrom: */;
				aBool = rcvr1 == arg1;
				if (GIV(primFailCode) == 0) {
					/* begin booleanCheat: */
					if (aBool) {
						goto booleanCheatTrue;
					}
					else {
						goto booleanCheatFalse;
					}
					goto l43;
				}
				GIV(messageSelector) = longAt(((longAt((GIV(specialObjectsOop) + BaseHeaderSize) + (SpecialSelectors << ShiftForWord))) + BaseHeaderSize) + ((6 * 2) << ShiftForWord));
				GIV(argumentCount) = 1;
				goto normalSend;
			}
;
		l43:	/* end case */;
			BREAK;
		CASE(183)
			/* bytecodePrimNotEqual */
			{
				sqInt aBool;
				sqInt arg;
				sqInt rcvr;
				double arg1;
				double rcvr1;
				double result;
				sqInt successBoolean;
				sqInt ccIndex;
				double result1;
				sqInt successBoolean1;
				sqInt ccIndex1;

				VM_LABEL(0bytecodePrimNotEqual);
								rcvr = longAtPointer(localSP + (1 * BytesPerWord));
				arg = longAtPointer(localSP + (0 * BytesPerWord));
				if (((rcvr & arg) & 1) != 0) {
					/* begin booleanCheat: */
					if (rcvr != arg) {
						goto booleanCheatTrue;
					}
					else {
						goto booleanCheatFalse;
					}
					goto l48;
				}
				/* begin initPrimCall */
				GIV(primFailCode) = 0;
				/* begin primitiveFloatEqual:toArg: */
				/* begin loadFloatOrIntFrom: */
				if ((rcvr & 1)) {
					rcvr1 = ((double) ((rcvr >> 1)) );
					goto l50;
				}
				/* begin assertClassOf:is:compactClassIndex: */
				VM_LABEL(14assertClassOfiscompactClassIndex);
				/* begin success: */
				/* begin is:instanceOf:compactClassIndex: */
				if ((rcvr & 1)) {
					successBoolean = 0;
					goto l49;
				}
				ccIndex = (((usqInt) (longAt(rcvr))) >> 12) & 31;
				if (ClassFloatCompactIndex != 0) {
					successBoolean = ClassFloatCompactIndex == ccIndex;
					goto l49;
				}
				successBoolean = (ccIndex == 0)
				 && (((longAt(rcvr - BaseHeaderSize)) & AllButTypeMask) == (longAt((GIV(specialObjectsOop) + BaseHeaderSize) + (ClassFloat << ShiftForWord))));
			l49:	/* end is:instanceOf:compactClassIndex: */;
				if (!(successBoolean)) {
					if (GIV(primFailCode) == 0) {

						/* Don't overwrite an error code that has already been set. */

						GIV(primFailCode) = 1;
					}
				}
				;
				if (GIV(primFailCode) == 0) {
					fetchFloatAtinto(rcvr + BaseHeaderSize, result);
				}
				rcvr1 = result;
			l50:	/* end loadFloatOrIntFrom: */;
				/* begin loadFloatOrIntFrom: */
				if ((arg & 1)) {
					arg1 = ((double) ((arg >> 1)) );
					goto l52;
				}
				/* begin assertClassOf:is:compactClassIndex: */
				VM_LABEL(15assertClassOfiscompactClassIndex);
				/* begin success: */
				/* begin is:instanceOf:compactClassIndex: */
				if ((arg & 1)) {
					successBoolean1 = 0;
					goto l51;
				}
				ccIndex1 = (((usqInt) (longAt(arg))) >> 12) & 31;
				if (ClassFloatCompactIndex != 0) {
					successBoolean1 = ClassFloatCompactIndex == ccIndex1;
					goto l51;
				}
				successBoolean1 = (ccIndex1 == 0)
				 && (((longAt(arg - BaseHeaderSize)) & AllButTypeMask) == (longAt((GIV(specialObjectsOop) + BaseHeaderSize) + (ClassFloat << ShiftForWord))));
			l51:	/* end is:instanceOf:compactClassIndex: */;
				if (!(successBoolean1)) {
					if (GIV(primFailCode) == 0) {

						/* Don't overwrite an error code that has already been set. */

						GIV(primFailCode) = 1;
					}
				}
				;
				if (GIV(primFailCode) == 0) {
					fetchFloatAtinto(arg + BaseHeaderSize, result1);
				}
				arg1 = result1;
			l52:	/* end loadFloatOrIntFrom: */;
				aBool = rcvr1 == arg1;
				if (GIV(primFailCode) == 0) {
					/* begin booleanCheat: */
					if (!aBool) {
						goto booleanCheatTrue;
					}
					else {
						goto booleanCheatFalse;
					}
					goto l48;
				}
				GIV(messageSelector) = longAt(((longAt((GIV(specialObjectsOop) + BaseHeaderSize) + (SpecialSelectors << ShiftForWord))) + BaseHeaderSize) + ((7 * 2) << ShiftForWord));
				GIV(argumentCount) = 1;
				goto normalSend;
			}
;
		l48:	/* end case */;
			BREAK;
		CASE(184)
			/* bytecodePrimMultiply */
			{
				sqInt arg;
				sqInt rcvr;
				sqInt result;
				double arg1;
				double rcvr1;
				char *sp;
				double result1;
				sqInt successBoolean;
				sqInt ccIndex;
				double result2;
				sqInt successBoolean1;
				sqInt ccIndex1;

				VM_LABEL(0bytecodePrimMultiply);
								rcvr = longAtPointer(localSP + (1 * BytesPerWord));
				arg = longAtPointer(localSP + (0 * BytesPerWord));
				if (((rcvr & arg) & 1) != 0) {
					rcvr = (rcvr >> 1);
					arg = (arg >> 1);
					result = rcvr * arg;
					if (((arg == 0)
 || ((result / arg) == rcvr))
					 && ((result ^ (result << 1)) >= 0)) {
						/* begin internalPop:thenPush: */
						longAtPointerput(localSP += (2 - 1) * BytesPerWord, ((result << 1) | 1));
						/* begin fetchNextBytecode */
						currentBytecode = byteAtPointer(++localIP);
						goto l53;
					}
				}
				else {
					/* begin initPrimCall */
					GIV(primFailCode) = 0;
					/* begin externalizeIPandSP */
					assert((((usqInt)localIP)) != (ceReturnToInterpreterPC()));
					GIV(instructionPointer) = oopForPointer(localIP);
					GIV(stackPointer) = localSP;
					GIV(framePointer) = localFP;
					/* begin primitiveFloatMultiply:byArg: */
					/* begin loadFloatOrIntFrom: */
					if ((rcvr & 1)) {
						rcvr1 = ((double) ((rcvr >> 1)) );
						goto l55;
					}
					/* begin assertClassOf:is:compactClassIndex: */
					VM_LABEL(16assertClassOfiscompactClassIndex);
					/* begin success: */
					/* begin is:instanceOf:compactClassIndex: */
					if ((rcvr & 1)) {
						successBoolean = 0;
						goto l54;
					}
					ccIndex = (((usqInt) (longAt(rcvr))) >> 12) & 31;
					if (ClassFloatCompactIndex != 0) {
						successBoolean = ClassFloatCompactIndex == ccIndex;
						goto l54;
					}
					successBoolean = (ccIndex == 0)
					 && (((longAt(rcvr - BaseHeaderSize)) & AllButTypeMask) == (longAt((GIV(specialObjectsOop) + BaseHeaderSize) + (ClassFloat << ShiftForWord))));
				l54:	/* end is:instanceOf:compactClassIndex: */;
					if (!(successBoolean)) {
						if (GIV(primFailCode) == 0) {

							/* Don't overwrite an error code that has already been set. */

							GIV(primFailCode) = 1;
						}
					}
					;
					if (GIV(primFailCode) == 0) {
						fetchFloatAtinto(rcvr + BaseHeaderSize, result1);
					}
					rcvr1 = result1;
				l55:	/* end loadFloatOrIntFrom: */;
					/* begin loadFloatOrIntFrom: */
					if ((arg & 1)) {
						arg1 = ((double) ((arg >> 1)) );
						goto l57;
					}
					/* begin assertClassOf:is:compactClassIndex: */
					VM_LABEL(17assertClassOfiscompactClassIndex);
					/* begin success: */
					/* begin is:instanceOf:compactClassIndex: */
					if ((arg & 1)) {
						successBoolean1 = 0;
						goto l56;
					}
					ccIndex1 = (((usqInt) (longAt(arg))) >> 12) & 31;
					if (ClassFloatCompactIndex != 0) {
						successBoolean1 = ClassFloatCompactIndex == ccIndex1;
						goto l56;
					}
					successBoolean1 = (ccIndex1 == 0)
					 && (((longAt(arg - BaseHeaderSize)) & AllButTypeMask) == (longAt((GIV(specialObjectsOop) + BaseHeaderSize) + (ClassFloat << ShiftForWord))));
				l56:	/* end is:instanceOf:compactClassIndex: */;
					if (!(successBoolean1)) {
						if (GIV(primFailCode) == 0) {

							/* Don't overwrite an error code that has already been set. */

							GIV(primFailCode) = 1;
						}
					}
					;
					if (GIV(primFailCode) == 0) {
						fetchFloatAtinto(arg + BaseHeaderSize, result2);
					}
					arg1 = result2;
				l57:	/* end loadFloatOrIntFrom: */;
					if (GIV(primFailCode) == 0) {
						/* begin pop:thenPushFloat: */
						longAtput(sp = GIV(stackPointer) + ((2 - 1) * BytesPerWord), floatObjectOf(rcvr1 * arg1));
						GIV(stackPointer) = sp;
					}
					/* begin internalizeIPandSP */
					assert(GIV(instructionPointer) != (ceReturnToInterpreterPC()));
					localIP = pointerForOop(GIV(instructionPointer));
					localSP = pointerForOop(GIV(stackPointer));
					localFP = pointerForOop(GIV(framePointer));
					if (GIV(primFailCode) == 0) {
						/* begin fetchNextBytecode */
						currentBytecode = byteAtPointer(++localIP);
						goto l53;
					}
				}
				GIV(messageSelector) = longAt(((longAt((GIV(specialObjectsOop) + BaseHeaderSize) + (SpecialSelectors << ShiftForWord))) + BaseHeaderSize) + ((8 * 2) << ShiftForWord));
				GIV(argumentCount) = 1;
				goto normalSend;
			}
;
		l53:	/* end case */;
			BREAK;
		CASE(185)
			/* bytecodePrimDivide */
			{
				sqInt arg;
				sqInt rcvr;
				sqInt result;
				double arg1;
				double rcvr1;
				char *sp;
				double result1;
				sqInt successBoolean;
				sqInt ccIndex;
				double result2;
				sqInt successBoolean1;
				sqInt ccIndex1;

				VM_LABEL(0bytecodePrimDivide);
								rcvr = longAtPointer(localSP + (1 * BytesPerWord));
				arg = longAtPointer(localSP + (0 * BytesPerWord));
				if (((rcvr & arg) & 1) != 0) {
					rcvr = (rcvr >> 1);
					arg = (arg >> 1);
					if ((arg != 0)
					 && ((rcvr % arg) == 0)) {

						/* generates C / operation */

						result = rcvr / arg;
						if ((result ^ (result << 1)) >= 0) {
							/* begin internalPop:thenPush: */
							longAtPointerput(localSP += (2 - 1) * BytesPerWord, ((result << 1) | 1));
							/* begin fetchNextBytecode */
							currentBytecode = byteAtPointer(++localIP);
							goto l58;
						}
					}
				}
				else {
					/* begin initPrimCall */
					GIV(primFailCode) = 0;
					/* begin externalizeIPandSP */
					assert((((usqInt)localIP)) != (ceReturnToInterpreterPC()));
					GIV(instructionPointer) = oopForPointer(localIP);
					GIV(stackPointer) = localSP;
					GIV(framePointer) = localFP;
					/* begin primitiveFloatDivide:byArg: */
					/* begin loadFloatOrIntFrom: */
					if ((rcvr & 1)) {
						rcvr1 = ((double) ((rcvr >> 1)) );
						goto l60;
					}
					/* begin assertClassOf:is:compactClassIndex: */
					VM_LABEL(18assertClassOfiscompactClassIndex);
					/* begin success: */
					/* begin is:instanceOf:compactClassIndex: */
					if ((rcvr & 1)) {
						successBoolean = 0;
						goto l59;
					}
					ccIndex = (((usqInt) (longAt(rcvr))) >> 12) & 31;
					if (ClassFloatCompactIndex != 0) {
						successBoolean = ClassFloatCompactIndex == ccIndex;
						goto l59;
					}
					successBoolean = (ccIndex == 0)
					 && (((longAt(rcvr - BaseHeaderSize)) & AllButTypeMask) == (longAt((GIV(specialObjectsOop) + BaseHeaderSize) + (ClassFloat << ShiftForWord))));
				l59:	/* end is:instanceOf:compactClassIndex: */;
					if (!(successBoolean)) {
						if (GIV(primFailCode) == 0) {

							/* Don't overwrite an error code that has already been set. */

							GIV(primFailCode) = 1;
						}
					}
					;
					if (GIV(primFailCode) == 0) {
						fetchFloatAtinto(rcvr + BaseHeaderSize, result1);
					}
					rcvr1 = result1;
				l60:	/* end loadFloatOrIntFrom: */;
					/* begin loadFloatOrIntFrom: */
					if ((arg & 1)) {
						arg1 = ((double) ((arg >> 1)) );
						goto l62;
					}
					/* begin assertClassOf:is:compactClassIndex: */
					VM_LABEL(19assertClassOfiscompactClassIndex);
					/* begin success: */
					/* begin is:instanceOf:compactClassIndex: */
					if ((arg & 1)) {
						successBoolean1 = 0;
						goto l61;
					}
					ccIndex1 = (((usqInt) (longAt(arg))) >> 12) & 31;
					if (ClassFloatCompactIndex != 0) {
						successBoolean1 = ClassFloatCompactIndex == ccIndex1;
						goto l61;
					}
					successBoolean1 = (ccIndex1 == 0)
					 && (((longAt(arg - BaseHeaderSize)) & AllButTypeMask) == (longAt((GIV(specialObjectsOop) + BaseHeaderSize) + (ClassFloat << ShiftForWord))));
				l61:	/* end is:instanceOf:compactClassIndex: */;
					if (!(successBoolean1)) {
						if (GIV(primFailCode) == 0) {

							/* Don't overwrite an error code that has already been set. */

							GIV(primFailCode) = 1;
						}
					}
					;
					if (GIV(primFailCode) == 0) {
						fetchFloatAtinto(arg + BaseHeaderSize, result2);
					}
					arg1 = result2;
				l62:	/* end loadFloatOrIntFrom: */;
					/* begin success: */
					if (!(arg1 != 0.0)) {
						if (GIV(primFailCode) == 0) {

							/* Don't overwrite an error code that has already been set. */

							GIV(primFailCode) = 1;
						}
					}
					if (GIV(primFailCode) == 0) {
						/* begin pop:thenPushFloat: */
						longAtput(sp = GIV(stackPointer) + ((2 - 1) * BytesPerWord), floatObjectOf(rcvr1 / arg1));
						GIV(stackPointer) = sp;
					}
					/* begin internalizeIPandSP */
					assert(GIV(instructionPointer) != (ceReturnToInterpreterPC()));
					localIP = pointerForOop(GIV(instructionPointer));
					localSP = pointerForOop(GIV(stackPointer));
					localFP = pointerForOop(GIV(framePointer));
					if (GIV(primFailCode) == 0) {
						/* begin fetchNextBytecode */
						currentBytecode = byteAtPointer(++localIP);
						goto l58;
					}
				}
				GIV(messageSelector) = longAt(((longAt((GIV(specialObjectsOop) + BaseHeaderSize) + (SpecialSelectors << ShiftForWord))) + BaseHeaderSize) + ((9 * 2) << ShiftForWord));
				GIV(argumentCount) = 1;
				goto normalSend;
			}
;
		l58:	/* end case */;
			BREAK;
		CASE(186)
			/* bytecodePrimMod */
			{
				sqInt mod;

				VM_LABEL(0bytecodePrimMod);
								/* begin initPrimCall */
				GIV(primFailCode) = 0;
				mod = doPrimitiveModby(longAtPointer(localSP + (1 * BytesPerWord)), longAtPointer(localSP + (0 * BytesPerWord)));
				if (GIV(primFailCode) == 0) {
					/* begin internalPop:thenPush: */
					longAtPointerput(localSP += (2 - 1) * BytesPerWord, ((mod << 1) | 1));
					/* begin fetchNextBytecode */
					currentBytecode = byteAtPointer(++localIP);
					goto l63;
				}
				GIV(messageSelector) = longAt(((longAt((GIV(specialObjectsOop) + BaseHeaderSize) + (SpecialSelectors << ShiftForWord))) + BaseHeaderSize) + ((10 * 2) << ShiftForWord));
				GIV(argumentCount) = 1;
				goto normalSend;
			}
;
		l63:	/* end case */;
			BREAK;
		CASE(187)
			/* bytecodePrimMakePoint */
			{
				sqInt argument;
				sqInt pt;
				sqInt rcvr;
				sqInt pointResult;
				sqInt pointResult1;
				sqInt pointResult2;
				char *sp;

				VM_LABEL(0bytecodePrimMakePoint);
								/* begin initPrimCall */
				GIV(primFailCode) = 0;
				/* begin externalizeIPandSP */
				assert((((usqInt)localIP)) != (ceReturnToInterpreterPC()));
				GIV(instructionPointer) = oopForPointer(localIP);
				GIV(stackPointer) = localSP;
				GIV(framePointer) = localFP;
				/* begin primitiveMakePoint */
				VM_LABEL(0primitiveMakePoint);
				argument = longAt(GIV(stackPointer));
				rcvr = longAt(GIV(stackPointer) + (1 * BytesPerWord));
				if ((rcvr & 1)) {
					if ((argument & 1)) {
						/* begin makePointwithxValue:yValue: */
						pointResult = eeInstantiateSmallClasssizeInBytes(longAt((GIV(specialObjectsOop) + BaseHeaderSize) + (ClassPoint << ShiftForWord)), 3 * BytesPerWord);
						longAtput((pointResult + BaseHeaderSize) + (XIndex << ShiftForWord), ((((rcvr >> 1)) << 1) | 1));
						longAtput((pointResult + BaseHeaderSize) + (YIndex << ShiftForWord), ((((argument >> 1)) << 1) | 1));
						pt = pointResult;
					}
					else {
						/* begin makePointwithxValue:yValue: */
						pointResult1 = eeInstantiateSmallClasssizeInBytes(longAt((GIV(specialObjectsOop) + BaseHeaderSize) + (ClassPoint << ShiftForWord)), 3 * BytesPerWord);
						longAtput((pointResult1 + BaseHeaderSize) + (XIndex << ShiftForWord), ((((rcvr >> 1)) << 1) | 1));
						longAtput((pointResult1 + BaseHeaderSize) + (YIndex << ShiftForWord), ((0 << 1) | 1));
						pt = pointResult1;
						/* begin storePointer:ofObject:withValue: */
						if ((((usqInt) pt)) < (((usqInt) GIV(youngStart)))) {
							possibleRootStoreIntovalue(pt, longAt(GIV(stackPointer) + (0 * BytesPerWord)));
						}
						longAtput((pt + BaseHeaderSize) + (1 << ShiftForWord), longAt(GIV(stackPointer) + (0 * BytesPerWord)));
					}
				}
				else {
					if (!(((rcvr & 1) == 0)
						 && ((ClassFloatCompactIndex != 0
	? ((((usqInt) (longAt(rcvr))) >> 12) & 31) == ClassFloatCompactIndex
	: (fetchClassOfNonInt(rcvr)) == (longAt((GIV(specialObjectsOop) + BaseHeaderSize) + (ClassFloat << ShiftForWord))))))) {
						/* begin success: */
						if (!(0)) {
							if (GIV(primFailCode) == 0) {

								/* Don't overwrite an error code that has already been set. */

								GIV(primFailCode) = 1;
							}
						}
						goto l65;
					}
					/* begin makePointwithxValue:yValue: */
					pointResult2 = eeInstantiateSmallClasssizeInBytes(longAt((GIV(specialObjectsOop) + BaseHeaderSize) + (ClassPoint << ShiftForWord)), 3 * BytesPerWord);
					longAtput((pointResult2 + BaseHeaderSize) + (XIndex << ShiftForWord), ((0 << 1) | 1));
					longAtput((pointResult2 + BaseHeaderSize) + (YIndex << ShiftForWord), ((0 << 1) | 1));
					pt = pointResult2;
					/* begin storePointer:ofObject:withValue: */
					if ((((usqInt) pt)) < (((usqInt) GIV(youngStart)))) {
						possibleRootStoreIntovalue(pt, longAt(GIV(stackPointer) + (1 * BytesPerWord)));
					}
					longAtput((pt + BaseHeaderSize) + (0 << ShiftForWord), longAt(GIV(stackPointer) + (1 * BytesPerWord)));
					/* begin storePointer:ofObject:withValue: */
					if ((((usqInt) pt)) < (((usqInt) GIV(youngStart)))) {
						possibleRootStoreIntovalue(pt, longAt(GIV(stackPointer) + (0 * BytesPerWord)));
					}
					longAtput((pt + BaseHeaderSize) + (1 << ShiftForWord), longAt(GIV(stackPointer) + (0 * BytesPerWord)));
				}
				/* begin pop:thenPush: */
				longAtput(sp = GIV(stackPointer) + ((2 - 1) * BytesPerWord), pt);
				GIV(stackPointer) = sp;
			l65:	/* end primitiveMakePoint */;
				/* begin internalizeIPandSP */
				assert(GIV(instructionPointer) != (ceReturnToInterpreterPC()));
				localIP = pointerForOop(GIV(instructionPointer));
				localSP = pointerForOop(GIV(stackPointer));
				localFP = pointerForOop(GIV(framePointer));
				if (GIV(primFailCode) == 0) {
					/* begin fetchNextBytecode */
					currentBytecode = byteAtPointer(++localIP);
					goto l64;
				}
				GIV(messageSelector) = longAt(((longAt((GIV(specialObjectsOop) + BaseHeaderSize) + (SpecialSelectors << ShiftForWord))) + BaseHeaderSize) + ((11 * 2) << ShiftForWord));
				GIV(argumentCount) = 1;
				goto normalSend;
			}
;
		l64:	/* end case */;
			BREAK;
		CASE(188)
			/* bytecodePrimBitShift */
			{
				sqInt integerArgument;
				sqInt integerReceiver;
				sqInt shifted;
				sqInt object;
				char *sp;
				sqInt top;
				sqInt top1;
				sqInt integerPointer;
				sqInt top2;

				VM_LABEL(0bytecodePrimBitShift);
								/* begin initPrimCall */
				GIV(primFailCode) = 0;
				/* begin externalizeIPandSP */
				assert((((usqInt)localIP)) != (ceReturnToInterpreterPC()));
				GIV(instructionPointer) = oopForPointer(localIP);
				GIV(stackPointer) = localSP;
				GIV(framePointer) = localFP;
				/* begin primitiveBitShift */
				VM_LABEL(0primitiveBitShift);
				/* begin popInteger */
				/* begin popStack */
				top2 = longAt(GIV(stackPointer));
				GIV(stackPointer) += BytesPerWord;
				integerPointer = top2;
				/* begin checkedIntegerValueOf: */
				if ((integerPointer & 1)) {
					integerArgument = (integerPointer >> 1);
					goto l67;
				}
				else {
					/* begin primitiveFail */
					if (GIV(primFailCode) == 0) {
						GIV(primFailCode) = 1;
					}
					integerArgument = 0;
					goto l67;
				}
			l67:	/* end popInteger */;
				/* begin popPos32BitInteger */
				/* begin popStack */
				top1 = longAt(GIV(stackPointer));
				GIV(stackPointer) += BytesPerWord;
				top = top1;
				integerReceiver = positive32BitValueOf(top);
				if (GIV(primFailCode) == 0) {
					if (integerArgument >= 0) {
						/* begin success: */
						if (!(integerArgument <= 31)) {
							if (GIV(primFailCode) == 0) {

								/* Don't overwrite an error code that has already been set. */

								GIV(primFailCode) = 1;
							}
						}
						shifted = integerReceiver << integerArgument;
						/* begin success: */
						if (!((((usqInt) shifted) >> integerArgument) == integerReceiver)) {
							if (GIV(primFailCode) == 0) {

								/* Don't overwrite an error code that has already been set. */

								GIV(primFailCode) = 1;
							}
						}
					}
					else {
						/* begin success: */
						if (!(integerArgument >= -31)) {
							if (GIV(primFailCode) == 0) {

								/* Don't overwrite an error code that has already been set. */

								GIV(primFailCode) = 1;
							}
						}
						shifted = ((integerArgument < 0) ? ((usqInt) integerReceiver >> -integerArgument) : ((usqInt) integerReceiver << integerArgument));
					}
				}
				if (GIV(primFailCode) == 0) {
					/* begin push: */
					object = positive32BitIntegerFor(shifted);
					longAtput(sp = GIV(stackPointer) - BytesPerWord, object);
					GIV(stackPointer) = sp;
				}
				else {
					/* begin unPop: */
					GIV(stackPointer) -= 2 * BytesPerWord;
				}
				/* begin internalizeIPandSP */
				assert(GIV(instructionPointer) != (ceReturnToInterpreterPC()));
				localIP = pointerForOop(GIV(instructionPointer));
				localSP = pointerForOop(GIV(stackPointer));
				localFP = pointerForOop(GIV(framePointer));
				if (GIV(primFailCode) == 0) {
					/* begin fetchNextBytecode */
					currentBytecode = byteAtPointer(++localIP);
					goto l66;
				}
				GIV(messageSelector) = longAt(((longAt((GIV(specialObjectsOop) + BaseHeaderSize) + (SpecialSelectors << ShiftForWord))) + BaseHeaderSize) + ((12 * 2) << ShiftForWord));
				GIV(argumentCount) = 1;
				goto normalSend;
			}
;
		l66:	/* end case */;
			BREAK;
		CASE(189)
			/* bytecodePrimDiv */
			{
				sqInt quotient;

				VM_LABEL(0bytecodePrimDiv);
								/* begin initPrimCall */
				GIV(primFailCode) = 0;
				quotient = doPrimitiveDivby(longAtPointer(localSP + (1 * BytesPerWord)), longAtPointer(localSP + (0 * BytesPerWord)));
				if (GIV(primFailCode) == 0) {
					/* begin internalPop:thenPush: */
					longAtPointerput(localSP += (2 - 1) * BytesPerWord, ((quotient << 1) | 1));
					/* begin fetchNextBytecode */
					currentBytecode = byteAtPointer(++localIP);
					goto l68;
				}
				GIV(messageSelector) = longAt(((longAt((GIV(specialObjectsOop) + BaseHeaderSize) + (SpecialSelectors << ShiftForWord))) + BaseHeaderSize) + ((13 * 2) << ShiftForWord));
				GIV(argumentCount) = 1;
				goto normalSend;
			}
;
		l68:	/* end case */;
			BREAK;
		CASE(190)
			/* bytecodePrimBitAnd */
			{
				sqInt integerArgument;
				sqInt integerReceiver;
				sqInt object;
				char *sp;
				sqInt top;
				sqInt top1;
				sqInt top2;
				sqInt top11;

				VM_LABEL(0bytecodePrimBitAnd);
								/* begin initPrimCall */
				GIV(primFailCode) = 0;
				/* begin externalizeIPandSP */
				assert((((usqInt)localIP)) != (ceReturnToInterpreterPC()));
				GIV(instructionPointer) = oopForPointer(localIP);
				GIV(stackPointer) = localSP;
				GIV(framePointer) = localFP;
				/* begin primitiveBitAnd */
				/* begin popPos32BitInteger */
				/* begin popStack */
				top1 = longAt(GIV(stackPointer));
				GIV(stackPointer) += BytesPerWord;
				top = top1;
				integerArgument = positive32BitValueOf(top);
				/* begin popPos32BitInteger */
				/* begin popStack */
				top11 = longAt(GIV(stackPointer));
				GIV(stackPointer) += BytesPerWord;
				top2 = top11;
				integerReceiver = positive32BitValueOf(top2);
				if (GIV(primFailCode) == 0) {
					/* begin push: */
					object = positive32BitIntegerFor(integerReceiver & integerArgument);
					longAtput(sp = GIV(stackPointer) - BytesPerWord, object);
					GIV(stackPointer) = sp;
				}
				else {
					/* begin unPop: */
					GIV(stackPointer) -= 2 * BytesPerWord;
				}
				/* begin internalizeIPandSP */
				assert(GIV(instructionPointer) != (ceReturnToInterpreterPC()));
				localIP = pointerForOop(GIV(instructionPointer));
				localSP = pointerForOop(GIV(stackPointer));
				localFP = pointerForOop(GIV(framePointer));
				if (GIV(primFailCode) == 0) {
					/* begin fetchNextBytecode */
					currentBytecode = byteAtPointer(++localIP);
					goto l69;
				}
				GIV(messageSelector) = longAt(((longAt((GIV(specialObjectsOop) + BaseHeaderSize) + (SpecialSelectors << ShiftForWord))) + BaseHeaderSize) + ((14 * 2) << ShiftForWord));
				GIV(argumentCount) = 1;
				goto normalSend;
			}
;
		l69:	/* end case */;
			BREAK;
		CASE(191)
			/* bytecodePrimBitOr */
			{
				sqInt integerArgument;
				sqInt integerReceiver;
				sqInt object;
				char *sp;
				sqInt top;
				sqInt top1;
				sqInt top2;
				sqInt top11;

				VM_LABEL(0bytecodePrimBitOr);
								/* begin initPrimCall */
				GIV(primFailCode) = 0;
				/* begin externalizeIPandSP */
				assert((((usqInt)localIP)) != (ceReturnToInterpreterPC()));
				GIV(instructionPointer) = oopForPointer(localIP);
				GIV(stackPointer) = localSP;
				GIV(framePointer) = localFP;
				/* begin primitiveBitOr */
				/* begin popPos32BitInteger */
				/* begin popStack */
				top1 = longAt(GIV(stackPointer));
				GIV(stackPointer) += BytesPerWord;
				top = top1;
				integerArgument = positive32BitValueOf(top);
				/* begin popPos32BitInteger */
				/* begin popStack */
				top11 = longAt(GIV(stackPointer));
				GIV(stackPointer) += BytesPerWord;
				top2 = top11;
				integerReceiver = positive32BitValueOf(top2);
				if (GIV(primFailCode) == 0) {
					/* begin push: */
					object = positive32BitIntegerFor(integerReceiver | integerArgument);
					longAtput(sp = GIV(stackPointer) - BytesPerWord, object);
					GIV(stackPointer) = sp;
				}
				else {
					/* begin unPop: */
					GIV(stackPointer) -= 2 * BytesPerWord;
				}
				/* begin internalizeIPandSP */
				assert(GIV(instructionPointer) != (ceReturnToInterpreterPC()));
				localIP = pointerForOop(GIV(instructionPointer));
				localSP = pointerForOop(GIV(stackPointer));
				localFP = pointerForOop(GIV(framePointer));
				if (GIV(primFailCode) == 0) {
					/* begin fetchNextBytecode */
					currentBytecode = byteAtPointer(++localIP);
					goto l70;
				}
				GIV(messageSelector) = longAt(((longAt((GIV(specialObjectsOop) + BaseHeaderSize) + (SpecialSelectors << ShiftForWord))) + BaseHeaderSize) + ((15 * 2) << ShiftForWord));
				GIV(argumentCount) = 1;
				goto normalSend;
			}
;
		l70:	/* end case */;
			BREAK;
		CASE(192)
			/* bytecodePrimAt */
			{
				sqInt atIx;
				sqInt index;
				sqInt rcvr;
				sqInt result;
				sqInt ccIndex;
				sqInt fixedFields;
				sqInt fmt;
				sqInt result1;
				sqInt stSize;

				VM_LABEL(0bytecodePrimAt);
								index = longAtPointer(localSP);
				rcvr = longAtPointer(localSP + (1 * BytesPerWord));
				if ((!((rcvr & 1)))
				 && ((index & 1))) {

					/* Index into atCache = 4N, for N = 0 ... 7 */

					atIx = rcvr & AtCacheMask;
					if ((GIV(atCache)[atIx + AtCacheOop]) != rcvr) {
						/* begin fetchClassOfNonInt: */
						if (((ccIndex = (((usqInt) (longAt(rcvr))) >> 12) & 31)) == 0) {
							GIV(lkupClass) = (longAt(rcvr - BaseHeaderSize)) & AllButTypeMask;
							goto l72;
						}
						else {
							GIV(lkupClass) = longAt(((longAt((GIV(specialObjectsOop) + BaseHeaderSize) + (CompactClasses << ShiftForWord))) + BaseHeaderSize) + ((ccIndex - 1) << ShiftForWord));
							goto l72;
						}
					l72:	/* end fetchClassOfNonInt: */;
						GIV(messageSelector) = longAt(((longAt((GIV(specialObjectsOop) + BaseHeaderSize) + (SpecialSelectors << ShiftForWord))) + BaseHeaderSize) + ((16 * 2) << ShiftForWord));
						if (!(lookupInMethodCacheSelclass(GIV(messageSelector), GIV(lkupClass)))) {
							GIV(argumentCount) = 1;
							goto commonSend;
							goto l71;
						}
						if (primitiveFunctionPointer == (primitiveAt)) {
							installinAtCacheatstring(rcvr, GIV(atCache), atIx, 0);
						}
						else {
							if (primitiveFunctionPointer == (primitiveStringAt)) {
								installinAtCacheatstring(rcvr, GIV(atCache), atIx, 1);
							}
							else {
								GIV(argumentCount) = 1;
								goto commonSend;
								goto l71;
							}
						}
					}
					/* begin commonVariable:at:cacheIndex: */
					VM_LABEL(0commonVariableatcacheIndex);
					stSize = GIV(atCache)[atIx + AtCacheSize];
					if (((((usqInt) ((index >> 1)))) >= (((usqInt) 1)))
					 && ((((usqInt) ((index >> 1)))) <= (((usqInt) stSize)))) {
						fmt = GIV(atCache)[atIx + AtCacheFmt];
						if (fmt <= 4) {
							fixedFields = GIV(atCache)[atIx + AtCacheFixedFields];
							result = longAt((rcvr + BaseHeaderSize) + (((((index >> 1)) + fixedFields) - 1) << ShiftForWord));
							goto l73;
						}
						if (fmt < 8) {

							/* Bitmap */

							result1 = long32At((rcvr + BaseHeaderSize) + ((((index >> 1)) - 1) << 2));
							result = positive32BitIntegerFor(result1);
							goto l73;
						}
						if (fmt >= 16) {
							result = longAt(((longAt((GIV(specialObjectsOop) + BaseHeaderSize) + (CharacterTable << ShiftForWord))) + BaseHeaderSize) + ((byteAt((rcvr + BaseHeaderSize) + (((index >> 1)) - 1))) << ShiftForWord));
							goto l73;
						}
						else {
							result = (((byteAt((rcvr + BaseHeaderSize) + (((index >> 1)) - 1))) << 1) | 1);
							goto l73;
						}
					}
					result = GIV(primFailCode) = PrimErrBadIndex;
				l73:	/* end commonVariable:at:cacheIndex: */;
					if (GIV(primFailCode) == 0) {
						/* begin fetchNextBytecode */
						currentBytecode = byteAtPointer(++localIP);
						/* begin internalPop:thenPush: */
						longAtPointerput(localSP += (2 - 1) * BytesPerWord, result);
						goto l71;
					}
				}
				GIV(messageSelector) = longAt(((longAt((GIV(specialObjectsOop) + BaseHeaderSize) + (SpecialSelectors << ShiftForWord))) + BaseHeaderSize) + ((16 * 2) << ShiftForWord));
				GIV(argumentCount) = 1;
				goto normalSend;
			}
;
		l71:	/* end case */;
			BREAK;
		CASE(193)
			/* bytecodePrimAtPut */
			{
				sqInt atIx;
				sqInt index;
				sqInt rcvr;
				sqInt value;
				sqInt ccIndex;
				sqInt fixedFields;
				sqInt fmt;
				sqInt stSize;
				sqInt valToPut;

				VM_LABEL(0bytecodePrimAtPut);
								value = longAtPointer(localSP);
				index = longAtPointer(localSP + (1 * BytesPerWord));
				rcvr = longAtPointer(localSP + (2 * BytesPerWord));
				if ((!((rcvr & 1)))
				 && ((index & 1))) {

					/* Index into atPutCache */

					atIx = (rcvr & AtCacheMask) + AtPutBase;
					if ((GIV(atCache)[atIx + AtCacheOop]) != rcvr) {
						/* begin fetchClassOfNonInt: */
						if (((ccIndex = (((usqInt) (longAt(rcvr))) >> 12) & 31)) == 0) {
							GIV(lkupClass) = (longAt(rcvr - BaseHeaderSize)) & AllButTypeMask;
							goto l75;
						}
						else {
							GIV(lkupClass) = longAt(((longAt((GIV(specialObjectsOop) + BaseHeaderSize) + (CompactClasses << ShiftForWord))) + BaseHeaderSize) + ((ccIndex - 1) << ShiftForWord));
							goto l75;
						}
					l75:	/* end fetchClassOfNonInt: */;
						GIV(messageSelector) = longAt(((longAt((GIV(specialObjectsOop) + BaseHeaderSize) + (SpecialSelectors << ShiftForWord))) + BaseHeaderSize) + ((17 * 2) << ShiftForWord));
						if (!(lookupInMethodCacheSelclass(GIV(messageSelector), GIV(lkupClass)))) {
							GIV(argumentCount) = 2;
							goto commonSend;
							goto l74;
						}
						if (primitiveFunctionPointer == (primitiveAtPut)) {
							installinAtCacheatstring(rcvr, GIV(atCache), atIx, 0);
						}
						else {
							if (primitiveFunctionPointer == (primitiveStringAtPut)) {
								installinAtCacheatstring(rcvr, GIV(atCache), atIx, 1);
							}
							else {
								GIV(argumentCount) = 2;
								goto commonSend;
								goto l74;
							}
						}
					}
					/* begin commonVariable:at:put:cacheIndex: */
					VM_LABEL(0commonVariableatputcacheIndex);
					stSize = GIV(atCache)[atIx + AtCacheSize];
					if (((((usqInt) ((index >> 1)))) >= (((usqInt) 1)))
					 && ((((usqInt) ((index >> 1)))) <= (((usqInt) stSize)))) {
						fmt = GIV(atCache)[atIx + AtCacheFmt];
						if (fmt <= 4) {
							fixedFields = GIV(atCache)[atIx + AtCacheFixedFields];
							/* begin storePointer:ofObject:withValue: */
							if ((((usqInt) rcvr)) < (((usqInt) GIV(youngStart)))) {
								possibleRootStoreIntovalue(rcvr, value);
							}
							longAtput((rcvr + BaseHeaderSize) + (((((index >> 1)) + fixedFields) - 1) << ShiftForWord), value);
							goto l76;
						}
						if (fmt < 8) {

							/* Bitmap */

							valToPut = positive32BitValueOf(value);
							if (GIV(primFailCode) == 0) {
								long32Atput((rcvr + BaseHeaderSize) + ((((index >> 1)) - 1) << 2), valToPut);
							}
							goto l76;
						}
						if (fmt >= 16) {

							/* Note fmt >= 16 is an artificial flag for strings */

							valToPut = asciiOfCharacter(value);
							if (!(GIV(primFailCode) == 0)) {
								goto l76;
							}
						}
						else {
							valToPut = value;
						}
						if ((valToPut & 1)) {
							valToPut = (valToPut >> 1);
							if (!((valToPut >= 0)
								 && (valToPut <= 255))) {
								/* begin primitiveFail */
								if (GIV(primFailCode) == 0) {
									GIV(primFailCode) = 1;
								}
								goto l76;
							}
							byteAtput((rcvr + BaseHeaderSize) + (((index >> 1)) - 1), valToPut);
							goto l76;
						}
					}
					GIV(primFailCode) = PrimErrBadIndex;
				l76:	/* end commonVariable:at:put:cacheIndex: */;
					if (GIV(primFailCode) == 0) {
						/* begin fetchNextBytecode */
						currentBytecode = byteAtPointer(++localIP);
						/* begin internalPop:thenPush: */
						longAtPointerput(localSP += (3 - 1) * BytesPerWord, value);
						goto l74;
					}
				}
				GIV(messageSelector) = longAt(((longAt((GIV(specialObjectsOop) + BaseHeaderSize) + (SpecialSelectors << ShiftForWord))) + BaseHeaderSize) + ((17 * 2) << ShiftForWord));
				GIV(argumentCount) = 2;
				goto normalSend;
			}
;
		l74:	/* end case */;
			BREAK;
		CASE(194)
			/* bytecodePrimSize */
			{
				sqInt isArray;
				sqInt isString;
				sqInt rcvr;
				sqInt sz;
				sqInt header;
				sqInt sz1;
				sqInt header1;
				sqInt sz2;
				sqInt ccIndex;
				sqInt ccIndex1;

				VM_LABEL(0bytecodePrimSize);
								/* begin initPrimCall */
				GIV(primFailCode) = 0;

				/* Shortcut the mega-lookup for ByteString and Array, the two big consumers of cycles
	 here. Both of these have compact class indices and neither has any added fields. */

				rcvr = longAtPointer(localSP);
				/* begin is:instanceOf:compactClassIndex: */
				if ((rcvr & 1)) {
					isString = 0;
					goto l80;
				}
				ccIndex = (((usqInt) (longAt(rcvr))) >> 12) & 31;
				if (ClassByteStringCompactIndex != 0) {
					isString = ClassByteStringCompactIndex == ccIndex;
					goto l80;
				}
				isString = (ccIndex == 0)
				 && (((longAt(rcvr - BaseHeaderSize)) & AllButTypeMask) == (longAt((GIV(specialObjectsOop) + BaseHeaderSize) + (ClassString << ShiftForWord))));
			l80:	/* end is:instanceOf:compactClassIndex: */;
				if (isString) {
					/* begin lengthOf: */
					header = longAt(rcvr);
					/* begin lengthOf:baseHeader:format: */
					if ((header & TypeMask) == HeaderTypeSizeAndClass) {
						sz1 = (longAt(rcvr - (BytesPerWord * 2))) & LongSizeMask;
					}
					else {
						sz1 = header & SizeMask;
					}
					sz1 -= header & Size4Bit;
					if (((((usqInt) header) >> 8) & 15) <= 4) {
						sz = ((usqInt) (sz1 - BaseHeaderSize)) >> ShiftForWord;
						goto l78;
					}
					if (((((usqInt) header) >> 8) & 15) < 8) {
						sz = ((usqInt) (sz1 - BaseHeaderSize)) >> 2;
						goto l78;
					}
					else {
						sz = (sz1 - BaseHeaderSize) - (((((usqInt) header) >> 8) & 15) & 3);
						goto l78;
					}
				l78:	/* end lengthOf: */;
					longAtPointerput(localSP, ((sz << 1) | 1));
					/* begin fetchNextBytecode */
					currentBytecode = byteAtPointer(++localIP);
					goto l77;
				}
				/* begin is:instanceOf:compactClassIndex: */
				if ((rcvr & 1)) {
					isArray = 0;
					goto l81;
				}
				ccIndex1 = (((usqInt) (longAt(rcvr))) >> 12) & 31;
				if (ClassArrayCompactIndex != 0) {
					isArray = ClassArrayCompactIndex == ccIndex1;
					goto l81;
				}
				isArray = (ccIndex1 == 0)
				 && (((longAt(rcvr - BaseHeaderSize)) & AllButTypeMask) == (longAt((GIV(specialObjectsOop) + BaseHeaderSize) + (ClassArray << ShiftForWord))));
			l81:	/* end is:instanceOf:compactClassIndex: */;
				if (isArray) {
					/* begin lengthOf: */
					header1 = longAt(rcvr);
					/* begin lengthOf:baseHeader:format: */
					if ((header1 & TypeMask) == HeaderTypeSizeAndClass) {
						sz2 = (longAt(rcvr - (BytesPerWord * 2))) & LongSizeMask;
					}
					else {
						sz2 = header1 & SizeMask;
					}
					sz2 -= header1 & Size4Bit;
					if (((((usqInt) header1) >> 8) & 15) <= 4) {
						sz = ((usqInt) (sz2 - BaseHeaderSize)) >> ShiftForWord;
						goto l79;
					}
					if (((((usqInt) header1) >> 8) & 15) < 8) {
						sz = ((usqInt) (sz2 - BaseHeaderSize)) >> 2;
						goto l79;
					}
					else {
						sz = (sz2 - BaseHeaderSize) - (((((usqInt) header1) >> 8) & 15) & 3);
						goto l79;
					}
				l79:	/* end lengthOf: */;
					longAtPointerput(localSP, ((sz << 1) | 1));
					/* begin fetchNextBytecode */
					currentBytecode = byteAtPointer(++localIP);
					goto l77;
				}
				GIV(messageSelector) = longAt(((longAt((GIV(specialObjectsOop) + BaseHeaderSize) + (SpecialSelectors << ShiftForWord))) + BaseHeaderSize) + ((18 * 2) << ShiftForWord));
				GIV(argumentCount) = 0;
				goto normalSend;
			}
;
		l77:	/* end case */;
			BREAK;
		CASE(195)
			/* bytecodePrimNext */
			{

				VM_LABEL(0bytecodePrimNext);
								GIV(messageSelector) = longAt(((longAt((GIV(specialObjectsOop) + BaseHeaderSize) + (SpecialSelectors << ShiftForWord))) + BaseHeaderSize) + ((19 * 2) << ShiftForWord));
				GIV(argumentCount) = 0;
				goto normalSend;
			}
;
			BREAK;
		CASE(196)
			/* bytecodePrimNextPut */
			{

				VM_LABEL(0bytecodePrimNextPut);
								GIV(messageSelector) = longAt(((longAt((GIV(specialObjectsOop) + BaseHeaderSize) + (SpecialSelectors << ShiftForWord))) + BaseHeaderSize) + ((20 * 2) << ShiftForWord));
				GIV(argumentCount) = 1;
				goto normalSend;
			}
;
			BREAK;
		CASE(197)
			/* bytecodePrimAtEnd */
			{

				VM_LABEL(0bytecodePrimAtEnd);
								GIV(messageSelector) = longAt(((longAt((GIV(specialObjectsOop) + BaseHeaderSize) + (SpecialSelectors << ShiftForWord))) + BaseHeaderSize) + ((21 * 2) << ShiftForWord));
				GIV(argumentCount) = 0;
				goto normalSend;
			}
;
			BREAK;
		CASE(198)
			/* bytecodePrimEquivalent */
			{
				sqInt arg;
				sqInt rcvr;

				VM_LABEL(0bytecodePrimEquivalent);
								rcvr = longAtPointer(localSP + (1 * BytesPerWord));
				arg = longAtPointer(localSP + (0 * BytesPerWord));
				/* begin booleanCheat: */
				if (rcvr == arg) {
					goto booleanCheatTrue;
				}
				else {
					goto booleanCheatFalse;
				}
			}
;
			BREAK;
		CASE(199)
			/* bytecodePrimClass */
			{
				sqInt rcvr;
				sqInt aValue;
				sqInt ccIndex;

				VM_LABEL(0bytecodePrimClass);
								rcvr = longAtPointer(localSP);
				/* begin internalStackTopPut: */
				/* begin fetchClassOf: */
				if ((rcvr & 1)) {
					aValue = longAt((GIV(specialObjectsOop) + BaseHeaderSize) + (ClassInteger << ShiftForWord));
					goto l82;
				}
				if (((ccIndex = (((usqInt) (longAt(rcvr))) >> 12) & 31)) == 0) {
					aValue = (longAt(rcvr - BaseHeaderSize)) & AllButTypeMask;
					goto l82;
				}
				else {
					aValue = longAt(((longAt((GIV(specialObjectsOop) + BaseHeaderSize) + (CompactClasses << ShiftForWord))) + BaseHeaderSize) + ((ccIndex - 1) << ShiftForWord));
					goto l82;
				}
			l82:	/* end fetchClassOf: */;
				longAtPointerput(localSP, aValue);
				/* begin fetchNextBytecode */
				currentBytecode = byteAtPointer(++localIP);
			}
;
			BREAK;
		CASE(200)
			/* bytecodePrimBlockCopy */
			{

				VM_LABEL(0bytecodePrimBlockCopy);
								GIV(messageSelector) = longAt(((longAt((GIV(specialObjectsOop) + BaseHeaderSize) + (SpecialSelectors << ShiftForWord))) + BaseHeaderSize) + ((24 * 2) << ShiftForWord));
				GIV(argumentCount) = 1;
				goto normalSend;
			}
;
			BREAK;
		CASE(201)
			/* bytecodePrimValue */
			{
				sqInt isBlock;
				sqInt rcvr;
				sqInt ccIndex;

				VM_LABEL(0bytecodePrimValue);
								rcvr = longAtPointer(localSP);
				GIV(argumentCount) = 0;
				/* begin is:instanceOf:compactClassIndex: */
				if ((rcvr & 1)) {
					isBlock = 0;
					goto l84;
				}
				ccIndex = (((usqInt) (longAt(rcvr))) >> 12) & 31;
				if (ClassBlockClosureCompactIndex != 0) {
					isBlock = ClassBlockClosureCompactIndex == ccIndex;
					goto l84;
				}
				isBlock = (ccIndex == 0)
				 && (((longAt(rcvr - BaseHeaderSize)) & AllButTypeMask) == (longAt((GIV(specialObjectsOop) + BaseHeaderSize) + (ClassBlockClosure << ShiftForWord))));
			l84:	/* end is:instanceOf:compactClassIndex: */;
				if (isBlock) {
					/* begin externalizeIPandSP */
					assert((((usqInt)localIP)) != (ceReturnToInterpreterPC()));
					GIV(instructionPointer) = oopForPointer(localIP);
					GIV(stackPointer) = localSP;
					GIV(framePointer) = localFP;
					/* begin initPrimCall */
					GIV(primFailCode) = 0;
					primitiveClosureValue();
					/* begin internalizeIPandSP */
					assert(GIV(instructionPointer) != (ceReturnToInterpreterPC()));
					localIP = pointerForOop(GIV(instructionPointer));
					localSP = pointerForOop(GIV(stackPointer));
					localFP = pointerForOop(GIV(framePointer));
					if (GIV(primFailCode) == 0) {
						/* begin fetchNextBytecode */
						currentBytecode = byteAtPointer(++localIP);
						goto l83;
					}
					GIV(primFailCode) = 0;
				}
				GIV(messageSelector) = longAt(((longAt((GIV(specialObjectsOop) + BaseHeaderSize) + (SpecialSelectors << ShiftForWord))) + BaseHeaderSize) + ((25 * 2) << ShiftForWord));
				goto normalSend;
			}
;
		l83:	/* end case */;
			BREAK;
		CASE(202)
			/* bytecodePrimValueWithArg */
			{
				sqInt isBlock;
				sqInt rcvr;
				sqInt ccIndex;

				VM_LABEL(0bytecodePrimValueWithArg);
								rcvr = longAtPointer(localSP + (1 * BytesPerWord));
				GIV(argumentCount) = 1;
				/* begin is:instanceOf:compactClassIndex: */
				if ((rcvr & 1)) {
					isBlock = 0;
					goto l86;
				}
				ccIndex = (((usqInt) (longAt(rcvr))) >> 12) & 31;
				if (ClassBlockClosureCompactIndex != 0) {
					isBlock = ClassBlockClosureCompactIndex == ccIndex;
					goto l86;
				}
				isBlock = (ccIndex == 0)
				 && (((longAt(rcvr - BaseHeaderSize)) & AllButTypeMask) == (longAt((GIV(specialObjectsOop) + BaseHeaderSize) + (ClassBlockClosure << ShiftForWord))));
			l86:	/* end is:instanceOf:compactClassIndex: */;
				if (isBlock) {
					/* begin externalizeIPandSP */
					assert((((usqInt)localIP)) != (ceReturnToInterpreterPC()));
					GIV(instructionPointer) = oopForPointer(localIP);
					GIV(stackPointer) = localSP;
					GIV(framePointer) = localFP;
					/* begin initPrimCall */
					GIV(primFailCode) = 0;
					primitiveClosureValue();
					/* begin internalizeIPandSP */
					assert(GIV(instructionPointer) != (ceReturnToInterpreterPC()));
					localIP = pointerForOop(GIV(instructionPointer));
					localSP = pointerForOop(GIV(stackPointer));
					localFP = pointerForOop(GIV(framePointer));
					if (GIV(primFailCode) == 0) {
						/* begin fetchNextBytecode */
						currentBytecode = byteAtPointer(++localIP);
						goto l85;
					}
					GIV(primFailCode) = 0;
				}
				GIV(messageSelector) = longAt(((longAt((GIV(specialObjectsOop) + BaseHeaderSize) + (SpecialSelectors << ShiftForWord))) + BaseHeaderSize) + ((26 * 2) << ShiftForWord));
				goto normalSend;
			}
;
		l85:	/* end case */;
			BREAK;
		CASE(203)
			/* bytecodePrimDo */
			{

				VM_LABEL(0bytecodePrimDo);
								GIV(messageSelector) = longAt(((longAt((GIV(specialObjectsOop) + BaseHeaderSize) + (SpecialSelectors << ShiftForWord))) + BaseHeaderSize) + ((27 * 2) << ShiftForWord));
				GIV(argumentCount) = 1;
				goto normalSend;
			}
;
			BREAK;
		CASE(204)
			/* bytecodePrimNew */
			{

				VM_LABEL(0bytecodePrimNew);
								GIV(messageSelector) = longAt(((longAt((GIV(specialObjectsOop) + BaseHeaderSize) + (SpecialSelectors << ShiftForWord))) + BaseHeaderSize) + ((28 * 2) << ShiftForWord));
				GIV(argumentCount) = 0;
				goto normalSend;
			}
;
			BREAK;
		CASE(205)
			/* bytecodePrimNewWithArg */
			{

				VM_LABEL(0bytecodePrimNewWithArg);
								GIV(messageSelector) = longAt(((longAt((GIV(specialObjectsOop) + BaseHeaderSize) + (SpecialSelectors << ShiftForWord))) + BaseHeaderSize) + ((29 * 2) << ShiftForWord));
				GIV(argumentCount) = 1;
				goto normalSend;
			}
;
			BREAK;
		CASE(206)
			/* bytecodePrimPointX */
			{
				sqInt rcvr;
				sqInt successBoolean;
				sqInt ccIndex;
				sqInt cl;

				VM_LABEL(0bytecodePrimPointX);
								/* begin initPrimCall */
				GIV(primFailCode) = 0;
				rcvr = longAtPointer(localSP);
				/* begin assertClassOf:is: */
				/* begin success: */
				/* begin isClassOfNonImm:equalTo: */
				if ((rcvr & 1)) {
					successBoolean = 0;
					goto l88;
				}
				cl = (((ccIndex = (((usqInt) (longAt(rcvr))) >> 12) & 31)) == 0
					? (longAt(rcvr - BaseHeaderSize)) & AllButTypeMask
					: longAt(((longAt((GIV(specialObjectsOop) + BaseHeaderSize) + (CompactClasses << ShiftForWord))) + BaseHeaderSize) + ((ccIndex - 1) << ShiftForWord)));
				successBoolean = cl == (longAt((GIV(specialObjectsOop) + BaseHeaderSize) + (ClassPoint << ShiftForWord)));
			l88:	/* end isClassOfNonImm:equalTo: */;
				if (!(successBoolean)) {
					if (GIV(primFailCode) == 0) {

						/* Don't overwrite an error code that has already been set. */

						GIV(primFailCode) = 1;
					}
				}
				if (GIV(primFailCode) == 0) {
					longAtPointerput(localSP, longAt((rcvr + BaseHeaderSize) + (XIndex << ShiftForWord)));
					/* begin fetchNextBytecode */
					currentBytecode = byteAtPointer(++localIP);
					goto l87;
				}
				GIV(primFailCode) = 0;
				GIV(messageSelector) = longAt(((longAt((GIV(specialObjectsOop) + BaseHeaderSize) + (SpecialSelectors << ShiftForWord))) + BaseHeaderSize) + ((30 * 2) << ShiftForWord));
				GIV(argumentCount) = 0;
				goto normalSend;
			}
;
		l87:	/* end case */;
			BREAK;
		CASE(207)
			/* bytecodePrimPointY */
			{
				sqInt rcvr;
				sqInt successBoolean;
				sqInt ccIndex;
				sqInt cl;

				VM_LABEL(0bytecodePrimPointY);
								/* begin initPrimCall */
				GIV(primFailCode) = 0;
				rcvr = longAtPointer(localSP);
				/* begin assertClassOf:is: */
				/* begin success: */
				/* begin isClassOfNonImm:equalTo: */
				if ((rcvr & 1)) {
					successBoolean = 0;
					goto l90;
				}
				cl = (((ccIndex = (((usqInt) (longAt(rcvr))) >> 12) & 31)) == 0
					? (longAt(rcvr - BaseHeaderSize)) & AllButTypeMask
					: longAt(((longAt((GIV(specialObjectsOop) + BaseHeaderSize) + (CompactClasses << ShiftForWord))) + BaseHeaderSize) + ((ccIndex - 1) << ShiftForWord)));
				successBoolean = cl == (longAt((GIV(specialObjectsOop) + BaseHeaderSize) + (ClassPoint << ShiftForWord)));
			l90:	/* end isClassOfNonImm:equalTo: */;
				if (!(successBoolean)) {
					if (GIV(primFailCode) == 0) {

						/* Don't overwrite an error code that has already been set. */

						GIV(primFailCode) = 1;
					}
				}
				if (GIV(primFailCode) == 0) {
					longAtPointerput(localSP, longAt((rcvr + BaseHeaderSize) + (YIndex << ShiftForWord)));
					/* begin fetchNextBytecode */
					currentBytecode = byteAtPointer(++localIP);
					goto l89;
				}
				GIV(primFailCode) = 0;
				GIV(messageSelector) = longAt(((longAt((GIV(specialObjectsOop) + BaseHeaderSize) + (SpecialSelectors << ShiftForWord))) + BaseHeaderSize) + ((31 * 2) << ShiftForWord));
				GIV(argumentCount) = 0;
				goto normalSend;
			}
;
		l89:	/* end case */;
			BREAK;
		CASE(208)
		CASE(209)
		CASE(210)
		CASE(211)
		CASE(212)
		CASE(213)
		CASE(214)
		CASE(215)
		CASE(216)
		CASE(217)
		CASE(218)
		CASE(219)
		CASE(220)
		CASE(221)
		CASE(222)
		CASE(223)
			/* sendLiteralSelector0ArgsBytecode */
			{
				sqInt rcvr;
				sqInt ccIndex;

				VM_LABEL(0sendLiteralSelector0ArgsBytecode);
								/* begin literal: */
				assert(GIV(method) == (iframeMethod(localFP)));
				GIV(messageSelector) = longAt((GIV(method) + BaseHeaderSize) + (((currentBytecode & 15) + LiteralStart) << ShiftForWord));
				GIV(argumentCount) = 0;
				rcvr = longAtPointer(localSP + (0 * BytesPerWord));
				/* begin fetchClassOf: */
				if ((rcvr & 1)) {
					GIV(lkupClass) = longAt((GIV(specialObjectsOop) + BaseHeaderSize) + (ClassInteger << ShiftForWord));
					goto l91;
				}
				if (((ccIndex = (((usqInt) (longAt(rcvr))) >> 12) & 31)) == 0) {
					GIV(lkupClass) = (longAt(rcvr - BaseHeaderSize)) & AllButTypeMask;
					goto l91;
				}
				else {
					GIV(lkupClass) = longAt(((longAt((GIV(specialObjectsOop) + BaseHeaderSize) + (CompactClasses << ShiftForWord))) + BaseHeaderSize) + ((ccIndex - 1) << ShiftForWord));
					goto l91;
				}
			l91:	/* end fetchClassOf: */;
				assert(GIV(lkupClass) != (nilObject()));
				goto commonSend;
			}
;
			BREAK;
		CASE(224)
		CASE(225)
		CASE(226)
		CASE(227)
		CASE(228)
		CASE(229)
		CASE(230)
		CASE(231)
		CASE(232)
		CASE(233)
		CASE(234)
		CASE(235)
		CASE(236)
		CASE(237)
		CASE(238)
		CASE(239)
			/* sendLiteralSelector1ArgBytecode */
			{
				sqInt rcvr;
				sqInt ccIndex;

				VM_LABEL(0sendLiteralSelector1ArgBytecode);
								/* begin literal: */
				assert(GIV(method) == (iframeMethod(localFP)));
				GIV(messageSelector) = longAt((GIV(method) + BaseHeaderSize) + (((currentBytecode & 15) + LiteralStart) << ShiftForWord));
				GIV(argumentCount) = 1;
				rcvr = longAtPointer(localSP + (1 * BytesPerWord));
				/* begin fetchClassOf: */
				if ((rcvr & 1)) {
					GIV(lkupClass) = longAt((GIV(specialObjectsOop) + BaseHeaderSize) + (ClassInteger << ShiftForWord));
					goto l92;
				}
				if (((ccIndex = (((usqInt) (longAt(rcvr))) >> 12) & 31)) == 0) {
					GIV(lkupClass) = (longAt(rcvr - BaseHeaderSize)) & AllButTypeMask;
					goto l92;
				}
				else {
					GIV(lkupClass) = longAt(((longAt((GIV(specialObjectsOop) + BaseHeaderSize) + (CompactClasses << ShiftForWord))) + BaseHeaderSize) + ((ccIndex - 1) << ShiftForWord));
					goto l92;
				}
			l92:	/* end fetchClassOf: */;
				assert(GIV(lkupClass) != (nilObject()));
				goto commonSend;
			}
;
			BREAK;
		CASE(240)
		CASE(241)
		CASE(242)
		CASE(243)
		CASE(244)
		CASE(245)
		CASE(246)
		CASE(247)
		CASE(248)
		CASE(249)
		CASE(250)
		CASE(251)
		CASE(252)
		CASE(253)
		CASE(254)
		CASE(255)
			/* sendLiteralSelector2ArgsBytecode */
			{
				sqInt rcvr;
				sqInt ccIndex;

				VM_LABEL(0sendLiteralSelector2ArgsBytecode);
								/* begin literal: */
				assert(GIV(method) == (iframeMethod(localFP)));
				GIV(messageSelector) = longAt((GIV(method) + BaseHeaderSize) + (((currentBytecode & 15) + LiteralStart) << ShiftForWord));
				GIV(argumentCount) = 2;
				rcvr = longAtPointer(localSP + (2 * BytesPerWord));
				/* begin fetchClassOf: */
				if ((rcvr & 1)) {
					GIV(lkupClass) = longAt((GIV(specialObjectsOop) + BaseHeaderSize) + (ClassInteger << ShiftForWord));
					goto l93;
				}
				if (((ccIndex = (((usqInt) (longAt(rcvr))) >> 12) & 31)) == 0) {
					GIV(lkupClass) = (longAt(rcvr - BaseHeaderSize)) & AllButTypeMask;
					goto l93;
				}
				else {
					GIV(lkupClass) = longAt(((longAt((GIV(specialObjectsOop) + BaseHeaderSize) + (CompactClasses << ShiftForWord))) + BaseHeaderSize) + ((ccIndex - 1) << ShiftForWord));
					goto l93;
				}
			l93:	/* end fetchClassOf: */;
				assert(GIV(lkupClass) != (nilObject()));
				goto commonSend;
			}
;
			BREAK;
		}
	}

	/* undo the pre-increment of IP before returning */

	localIP -= 1;
	/* begin externalizeIPandSP */
	assert((((usqInt)localIP)) != (ceReturnToInterpreterPC()));
	GIV(instructionPointer) = oopForPointer(localIP);
	GIV(stackPointer) = localSP;
	GIV(framePointer) = localFP;
	return null;
}


/*	Activate newMethod when newMethod has been cogged, i.e. create a
	machine-code frame and (re)enter machine-code.
 */

static void
activateCoggedNewMethod(sqInt inInterpreter)
{   DECL_MAYBE_SQ_GLOBAL_STRUCT
    CogMethod *cogMethod;
    sqInt errorCode;
    sqInt i;
    sqInt methodHeader;
    sqInt numTemps;
    sqInt object;
    sqInt object1;
    sqInt offset;
    sqInt rcvr;
    char *sp;
    char *sp1;
    char *sp2;
    char *sp3;
    char *sp4;
    char *sp5;
    char *sp6;
    char *sp7;
    char *sp8;
    char *sp9;
    sqInt switched;
    sqInt table;

	methodHeader = longAt((GIV(newMethod) + BaseHeaderSize) + (HeaderIndex << ShiftForWord));
	assert(isCogMethodReference(methodHeader));
	cogMethod = ((CogMethod *) methodHeader);
	methodHeader = (cogMethod->methodHeader);
	/* begin stackValue: */
	offset = (cogMethod->cmNumArgs);
	rcvr = longAt(GIV(stackPointer) + (offset * BytesPerWord));
	/* begin push: */
	longAtput(sp5 = GIV(stackPointer) - BytesPerWord, GIV(instructionPointer));
	GIV(stackPointer) = sp5;
	if (((cogMethod->stackCheckOffset)) == 0) {
		
#    if (numRegArgs()) > 0
		if (((cogMethod->cmNumArgs)) <= (numRegArgs())) {
			enterRegisterArgCogMethodatreceiver(cogMethod, noCheckEntryOffset(), rcvr);
		}

#    endif /* (numRegArgs()) > 0 */

		/* begin push: */
		object = (((sqInt)cogMethod)) + (noCheckEntryOffset());
		longAtput(sp = GIV(stackPointer) - BytesPerWord, object);
		GIV(stackPointer) = sp;
		/* begin push: */
		longAtput(sp1 = GIV(stackPointer) - BytesPerWord, rcvr);
		GIV(stackPointer) = sp1;
		ceEnterCogCodePopReceiverReg();
		error("should not be reached");
	}
	/* begin push: */
	longAtput(sp6 = GIV(stackPointer) - BytesPerWord, GIV(framePointer));
	GIV(stackPointer) = sp6;
	GIV(framePointer) = GIV(stackPointer);
	/* begin push: */
	longAtput(sp7 = GIV(stackPointer) - BytesPerWord, ((sqInt)cogMethod));
	GIV(stackPointer) = sp7;
	/* begin push: */
	longAtput(sp8 = GIV(stackPointer) - BytesPerWord, GIV(nilObj));
	GIV(stackPointer) = sp8;
	/* begin push: */
	longAtput(sp9 = GIV(stackPointer) - BytesPerWord, rcvr);
	GIV(stackPointer) = sp9;
	numTemps = (((usqInt) methodHeader) >> 19) & 63;
	for (i = (((cogMethod->cmNumArgs)) + 1); i <= numTemps; i += 1) {
		/* begin push: */
		longAtput(sp2 = GIV(stackPointer) - BytesPerWord, GIV(nilObj));
		GIV(stackPointer) = sp2;
	}
	if (GIV(primFailCode) != 0) {
		if ((byteAtPointer((GIV(newMethod) + ((LiteralStart + ((((usqInt) methodHeader) >> 10) & 255)) * BytesPerWord)) + BaseHeaderSize)) == 129) {
			/* begin getErrorObjectFromPrimFailCode */
			if (GIV(primFailCode) > 0) {
				table = longAt((GIV(specialObjectsOop) + BaseHeaderSize) + (PrimErrTableIndex << ShiftForWord));
				if (GIV(primFailCode) <= (((sqInt) (lastPointerOf(table)) >> 2))) {
					errorCode = longAt((table + BaseHeaderSize) + ((GIV(primFailCode) - 1) << ShiftForWord));
					goto l1;
				}
			}
			errorCode = ((GIV(primFailCode) << 1) | 1);
		l1:	/* end getErrorObjectFromPrimFailCode */;
			longAtPointerput(GIV(stackPointer), errorCode);
		}
		GIV(primFailCode) = 0;
	}
	if (GIV(stackPointer) >= GIV(stackLimit)) {
		assert(((cogMethod->stackCheckOffset)) > (noCheckEntryOffset()));
		/* begin push: */
		object1 = (((sqInt)cogMethod)) + ((cogMethod->stackCheckOffset));
		longAtput(sp3 = GIV(stackPointer) - BytesPerWord, object1);
		GIV(stackPointer) = sp3;
		/* begin push: */
		longAtput(sp4 = GIV(stackPointer) - BytesPerWord, rcvr);
		GIV(stackPointer) = sp4;
		ceEnterCogCodePopReceiverReg();
		error("should not be reached");
	}
	GIV(instructionPointer) = (((sqInt)cogMethod)) + ((cogMethod->stackCheckOffset));
	switched = handleStackOverflowOrEventAllowContextSwitch(canContextSwitchIfActivating(methodHeader));
	returnToExecutivepostContextSwitch(inInterpreter, switched);
}


/*	Execute an interpreted method from machine code. We assume (require) that
	newMethod messageSelector, primitiveFunctionPointer and argumentCount have
	been set in the caller.
	Once evaluated either continue in the interpreter via a jongjmp or in
	machine code via an
	enilopmart (a form of longjmp - a stinking rose by any other name). */

static sqInt
activateInterpreterMethodFromMachineCode(void)
{   DECL_MAYBE_SQ_GLOBAL_STRUCT
    sqInt nArgs;
    char *savedFramePointer;
    char *savedStackPointer;
    sqInt top;

	assertCStackWellAligned();
	assert(validInstructionPointerinFrame(stackTop(), GIV(framePointer)));
	/* begin popStack */
	top = longAt(GIV(stackPointer));
	GIV(stackPointer) += BytesPerWord;
	GIV(instructionPointer) = ((sqInt) top);
	if (primitiveFunctionPointer != 0) {
		if (primitiveFunctionPointer == (primitiveInvokeObjectAsMethod)) {
			assert(!(isOopCompiledMethod(GIV(newMethod))));
		}
		else {
			assert((isOopCompiledMethod(GIV(newMethod)))
			 && ((primitiveIndexOf(GIV(newMethod))) != 0));
		}
		(GIV(stackPage)->headFP = GIV(framePointer));
		if ((((unsigned long) primitiveFunctionPointer)) <= MaxQuickPrimitiveIndex) {
			externalQuickPrimitiveResponse();
			GIV(primFailCode) = 0;
		}
		else {
			/* begin slowPrimitiveResponse */
			if (recordPrimTrace()) {
				/* begin fastLogPrim: */
				GIV(primTraceLog)[GIV(primTraceLogIndex)] = GIV(messageSelector);
				primTraceLogIndex(GIV(primTraceLogIndex) + 1);
			}
			if (FailImbalancedPrimitives) {
				nArgs = GIV(argumentCount);
				savedStackPointer = GIV(stackPointer);
				savedFramePointer = GIV(framePointer);
			}
			/* begin initPrimCall */
			GIV(primFailCode) = 0;
			dispatchFunctionPointer(primitiveFunctionPointer);
			if (FailImbalancedPrimitives
			 && ((GIV(primFailCode) == 0)
 && ((GIV(framePointer) == savedFramePointer)
 && (!((((usqInt)(longAt(GIV(framePointer) + FoxMethod)))) < heapBase))))) {
				if (GIV(stackPointer) != (savedStackPointer + (nArgs * BytesPerWord))) {
					flag("Would be nice to make this a message send of e.g. unbalancedPrimitive to the current process or context");
					GIV(stackPointer) = savedStackPointer;
					failUnbalancedPrimitive();
				}
			}
			if (GIV(nextProfileTick) > 0) {
				checkProfileTick(GIV(newMethod));
			}
			GIV(primFailCode) == 0;
		}
		if (GIV(primFailCode) == 0) {
			returntoExecutive(popStack(), 0);
		}
	}
	else {
		assert(((primitiveIndexOf(GIV(newMethod))) == 0)
		 || ((functionPointerForinClass(primitiveIndexOf(GIV(newMethod)), nilObject())) == 0));
	}
	activateNewMethod();
	siglongjmp(reenterInterpreter, ReturnToInterpreter);
	return null;
}

static void
activateNewMethod(void)
{   DECL_MAYBE_SQ_GLOBAL_STRUCT
    sqInt errorCode;
    sqInt i;
    sqInt inInterpreter;
    sqInt methodHeader;
    sqInt methodHeader1;
    sqInt numArgs;
    sqInt numTemps;
    sqInt object;
    sqInt rcvr;
    char *sp;
    char *sp1;
    char *sp2;
    char *sp3;
    char *sp4;
    char *sp5;
    char *sp6;
    char *sp7;
    sqInt switched;
    sqInt table;

	/* begin headerOf: */
	methodHeader1 = longAt((GIV(newMethod) + BaseHeaderSize) + (HeaderIndex << ShiftForWord));
	methodHeader = (isCogMethodReference(methodHeader1)
		? (((CogMethod *) methodHeader1)->methodHeader)
		: methodHeader1);
	numTemps = (((usqInt) methodHeader) >> 19) & 63;
	numArgs = (((usqInt) methodHeader) >> 25) & 15;

	/* could new rcvr be set at point of send? */
	/* Because this is an uncogged method we need to continue via the interpreter.
	 We could have been reached either from the interpreter, in which case we
	 should simply return, or from a machine code frame or from a compiled
	 primitive.  In these latter two cases we must longjmp back to the interpreter.
	 The instructionPointer tells us which path we took.
	 If the sender was an interpreter frame but called through a (failing) primitive
	 then make sure we restore the saved instruction pointer and avoid pushing
	 ceReturnToInterpreterPC which is only valid between an interpreter caller
	 frame and a machine code callee frame. */

	rcvr = longAt(GIV(stackPointer) + (numArgs * BytesPerWord));
	if (!((inInterpreter = GIV(instructionPointer) >= heapBase))) {
		if (GIV(instructionPointer) == (ceReturnToInterpreterPC())) {
			GIV(instructionPointer) = longAt(GIV(framePointer) + FoxIFSavedIP);
		}
	}
	/* begin push: */
	longAtput(sp1 = GIV(stackPointer) - BytesPerWord, GIV(instructionPointer));
	GIV(stackPointer) = sp1;
	/* begin push: */
	longAtput(sp2 = GIV(stackPointer) - BytesPerWord, GIV(framePointer));
	GIV(stackPointer) = sp2;
	GIV(framePointer) = GIV(stackPointer);
	/* begin push: */
	longAtput(sp3 = GIV(stackPointer) - BytesPerWord, GIV(newMethod));
	GIV(stackPointer) = sp3;
	/* begin setMethod: */
	assert((((usqInt)GIV(newMethod))) >= (startOfMemory()));
	GIV(method) = GIV(newMethod);
	/* begin push: */
	longAtput(sp4 = GIV(stackPointer) - BytesPerWord, GIV(nilObj));
	GIV(stackPointer) = sp4;
	/* begin push: */
	object = (VMBIGENDIAN
		? ((1 + (numArgs << ((BytesPerWord * 8) - 8))) + ((0
	? 1 << ((BytesPerWord * 8) - 16)
	: 0))) + ((0
	? 1 << ((BytesPerWord * 8) - 24)
	: 0))
		: ((1 + (numArgs << 8)) + ((0
	? 1 << 16
	: 0))) + ((0
	? 1 << 24
	: 0)));
	longAtput(sp5 = GIV(stackPointer) - BytesPerWord, object);
	GIV(stackPointer) = sp5;
	/* begin push: */
	longAtput(sp6 = GIV(stackPointer) - BytesPerWord, 0);
	GIV(stackPointer) = sp6;
	/* begin push: */
	longAtput(sp7 = GIV(stackPointer) - BytesPerWord, rcvr);
	GIV(stackPointer) = sp7;
	for (i = (numArgs + 1); i <= numTemps; i += 1) {
		/* begin push: */
		longAtput(sp = GIV(stackPointer) - BytesPerWord, GIV(nilObj));
		GIV(stackPointer) = sp;
	}

	/* Pass primitive error code to last temp if method receives it (indicated by an
	 initial long store temp bytecode).  We don't need to check that newMethod
	 actually has a primitive because the initial 129 only occurs if there is one. */

	GIV(instructionPointer) = ((GIV(newMethod) + ((LiteralStart + ((((usqInt) methodHeader) >> 10) & 255)) * BytesPerWord)) + BaseHeaderSize) - 1;
	if (GIV(primFailCode) != 0) {
		if ((byteAtPointer(GIV(instructionPointer) + 1)) == 129) {
			/* begin getErrorObjectFromPrimFailCode */
			if (GIV(primFailCode) > 0) {
				table = longAt((GIV(specialObjectsOop) + BaseHeaderSize) + (PrimErrTableIndex << ShiftForWord));
				if (GIV(primFailCode) <= (((sqInt) (lastPointerOf(table)) >> 2))) {
					errorCode = longAt((table + BaseHeaderSize) + ((GIV(primFailCode) - 1) << ShiftForWord));
					goto l1;
				}
			}
			errorCode = ((GIV(primFailCode) << 1) | 1);
		l1:	/* end getErrorObjectFromPrimFailCode */;
			longAtPointerput(GIV(stackPointer), errorCode);
		}
		GIV(primFailCode) = 0;
	}
	switched = 1;
	if (GIV(stackPointer) < GIV(stackLimit)) {
		switched = handleStackOverflowOrEventAllowContextSwitch(canContextSwitchIfActivating(methodHeader));
	}
	returnToExecutivepostContextSwitch(inInterpreter, switched);
}


/*	Add the given variable location to the extra roots table */

EXPORT(sqInt)
addGCRoot(sqInt *varLoc)
{   DECL_MAYBE_SQ_GLOBAL_STRUCT
	if (GIV(extraRootCount) >= ExtraRootSize) {
		return 0;
	}
	GIV(extraRoots)[(GIV(extraRootCount) += 1)] = varLoc;
	return 1;
}


/*	Add the given process to the end of the given linked list
	and set the backpointer of process to its new list. */

static void
addLastLinktoList(sqInt proc, sqInt aList)
{   DECL_MAYBE_SQ_GLOBAL_STRUCT
    sqInt lastLink;

	assert((fetchPointerofObject(NextLinkIndex, proc)) == (nilObject()));
	if ((longAt((aList + BaseHeaderSize) + (FirstLinkIndex << ShiftForWord))) == GIV(nilObj)) {
		/* begin storePointer:ofObject:withValue: */
		if ((((usqInt) aList)) < (((usqInt) GIV(youngStart)))) {
			possibleRootStoreIntovalue(aList, proc);
		}
		longAtput((aList + BaseHeaderSize) + (FirstLinkIndex << ShiftForWord), proc);
	}
	else {
		lastLink = longAt((aList + BaseHeaderSize) + (LastLinkIndex << ShiftForWord));
		assert(lastLink != proc);
		/* begin storePointer:ofObject:withValue: */
		if ((((usqInt) lastLink)) < (((usqInt) GIV(youngStart)))) {
			possibleRootStoreIntovalue(lastLink, proc);
		}
		longAtput((lastLink + BaseHeaderSize) + (NextLinkIndex << ShiftForWord), proc);
	}
	/* begin storePointer:ofObject:withValue: */
	if ((((usqInt) aList)) < (((usqInt) GIV(youngStart)))) {
		possibleRootStoreIntovalue(aList, proc);
	}
	longAtput((aList + BaseHeaderSize) + (LastLinkIndex << ShiftForWord), proc);
	/* begin storePointer:ofObject:withValue: */
	if ((((usqInt) proc)) < (((usqInt) GIV(youngStart)))) {
		possibleRootStoreIntovalue(proc, aList);
	}
	longAtput((proc + BaseHeaderSize) + (MyListIndex << ShiftForWord), aList);
}


/*	Add the given entry to the method cache.
	The policy is as follows:
	Look for an empty entry anywhere in the reprobe chain.
	If found, install the new entry there.
	If not found, then install the new entry at the first probe position
	and delete the entries in the rest of the reprobe chain.
	This has two useful purposes:
	If there is active contention over the first slot, the second
	or third will likely be free for reentry after ejection.
	Also, flushing is good when reprobe chains are getting full. */
/*	Override to refuse to cache other than compiled methods.
	This protects open PICs against having to test for compiled methods. */

static void
addNewMethodToCache(sqInt class)
{   DECL_MAYBE_SQ_GLOBAL_STRUCT
    sqInt hash;
    sqInt p;
    sqInt primBits;
    sqInt primitiveIndex;
    sqInt probe;

	if (!(((GIV(newMethod) & 1) == 0)
		 && (((((usqInt) (longAt(GIV(newMethod)))) >> 8) & 15) >= 12))) {
		primitiveFunctionPointer = primitiveInvokeObjectAsMethod;
		return;
	}

	/* drop low-order zeros from addresses */

	hash = GIV(messageSelector) ^ class;
	if (((GIV(newMethod) & 1) == 0)
	 && (((((usqInt) (longAt(GIV(newMethod)))) >> 8) & 15) >= 12)) {
		/* begin primitiveIndexOf: */
		primBits = (((usqInt) (headerOf(GIV(newMethod)))) >> 1) & 268435967;
		primitiveIndex = (primBits & 511) + (((usqInt) primBits) >> 19);
		/* begin functionPointerFor:inClass: */
		primitiveFunctionPointer = ((void (*)(void)) ((primitiveIndex > MaxPrimitiveIndex
	? 0
	: primitiveTable[primitiveIndex])));
	}
	else {
		primitiveFunctionPointer = primitiveInvokeObjectAsMethod;
	}
	for (p = 0; p <= (CacheProbeMax - 1); p += 1) {
		probe = (((usqInt) hash) >> p) & MethodCacheMask;
		if ((GIV(methodCache)[probe + MethodCacheSelector]) == 0) {
			GIV(methodCache)[probe + MethodCacheSelector] = GIV(messageSelector);
			GIV(methodCache)[probe + MethodCacheClass] = class;
			GIV(methodCache)[probe + MethodCacheMethod] = GIV(newMethod);
			GIV(methodCache)[probe + MethodCachePrimFunction] = (((long) primitiveFunctionPointer));

			/* this for primitiveExternalMethod */

			GIV(lastMethodCacheProbeWrite) = probe;
			return;
		}
	}

	/* first probe */

	probe = hash & MethodCacheMask;
	GIV(methodCache)[probe + MethodCacheSelector] = GIV(messageSelector);
	GIV(methodCache)[probe + MethodCacheClass] = class;
	GIV(methodCache)[probe + MethodCacheMethod] = GIV(newMethod);
	GIV(methodCache)[probe + MethodCachePrimFunction] = (((long) primitiveFunctionPointer));

	/* this for primitiveExternalMethod */
	/* ...and zap the following entries */

	GIV(lastMethodCacheProbeWrite) = probe;
	for (p = 1; p <= (CacheProbeMax - 1); p += 1) {
		probe = (((usqInt) hash) >> p) & MethodCacheMask;
		GIV(methodCache)[probe + MethodCacheSelector] = 0;
	}
}


/*	Answer if address appears to be that of an object, which implies it is
	safe to fetch the class and size. For code disassembly and assertions. */

static sqInt
addressCouldBeObjWhileForwarding(sqInt address)
{
	return ((address & 3) == 0)
	 && (((((usqInt)address)) >= heapBase)
 && ((((usqInt)address)) < GIV(freeStart)));
}


/*	Answer if address appears to be that of an object, which implies it is
	safe to fetch the class and size. For code disassembly and assertions. */

sqInt
addressCouldBeObj(sqInt address)
{
	return ((address & 3) == 0)
	 && (((((usqInt)address)) >= heapBase)
 && (((((usqInt)address)) < GIV(freeStart))
 && (((longAt(address)) & TypeMask) != HeaderTypeGC)));
}


/*	Answer if address appears to be that of either a SmallInteger or an
	object. For code disassembly and assertions. */

sqInt
addressCouldBeOop(sqInt address)
{
	return ((address & 1))
	 || (((address & 3) == 0)
 && (((((usqInt)address)) >= heapBase)
 && (((((usqInt)address)) < GIV(freeStart))
 && (((longAt(address)) & TypeMask) != HeaderTypeGC))));
}


/*	For assert-checking */

static sqInt
addressIsInPage(StackPage * self_in_addressIsInPage, char *address)
{
	return (((self_in_addressIsInPage->lastAddress)) < address)
	 && (address < ((self_in_addressIsInPage->baseAddress)));
}


/*	Adjust all oop references by the given number of bytes. This 
	is done just after reading in an image when the new base 
	address of the object heap is different from the base address 
	in the image. */
/*	di 11/18/2000 - return number of objects found */

static sqInt
adjustAllOopsBy(sqInt bytesToShift)
{   DECL_MAYBE_SQ_GLOBAL_STRUCT
    sqInt classHeader;
    sqInt fieldAddr;
    sqInt fieldOop;
    sqInt header;
    sqInt newClassOop;
    sqInt oop;
    sqInt sz;
    sqInt totalObjects;

	if (bytesToShift == 0) {
		return 300000;
	}
	totalObjects = 0;
	oop = heapBase + (headerTypeBytes[(longAt(heapBase)) & TypeMask]);
	while ((((usqInt) oop)) < (((usqInt) GIV(endOfMemory)))) {
		if (!(((longAt(oop)) & TypeMask) == HeaderTypeFree)) {
			totalObjects += 1;
			/* begin adjustFieldsAndClassOf:by: */
			if (bytesToShift == 0) {
				goto l1;
			}
			fieldAddr = oop + (lastPointerOf(oop));
			while ((((usqInt) fieldAddr)) > (((usqInt) oop))) {
				fieldOop = longAt(fieldAddr);
				if (!((fieldOop & 1))) {
					longAtput(fieldAddr, fieldOop + bytesToShift);
				}
				fieldAddr -= BytesPerWord;
			}
			if (((longAt(oop)) & TypeMask) != HeaderTypeShort) {

				/* adjust class header if not a compact class */

				classHeader = longAt(oop - BytesPerWord);
				newClassOop = (classHeader & AllButTypeMask) + bytesToShift;
				longAtput(oop - BytesPerWord, newClassOop | (classHeader & TypeMask));
			}
		l1:	/* end adjustFieldsAndClassOf:by: */;
		}
		/* begin objectAfter: */
		if (DoAssertionChecks) {
			if ((((usqInt) oop)) >= (((usqInt) GIV(endOfMemory)))) {
				error("no objects after the end of memory");
			}
		}
		if (((longAt(oop)) & TypeMask) == HeaderTypeFree) {
			sz = (longAt(oop)) & AllButTypeMask;
		}
		else {
			/* begin sizeBitsOf: */
			header = longAt(oop);
			sz = ((header & TypeMask) == HeaderTypeSizeAndClass
				? (longAt(oop - (BytesPerWord * 2))) & LongSizeMask
				: header & SizeMask);
		}
		oop = (oop + sz) + (headerTypeBytes[(longAt(oop + sz)) & TypeMask]);
	}
	return totalObjects;
}


/*	Return true if all the oops in both arrays, and the arrays 
	themselves, are in the young object space. */

static sqInt
allYoungand(sqInt array1, sqInt array2)
{   DECL_MAYBE_SQ_GLOBAL_STRUCT
    sqInt contextSize;
    sqInt fieldOffset;
    sqInt fmt;
    sqInt header;
    sqInt methodHeader;
    sqInt sp;

	if ((((usqInt) array1)) < (((usqInt) GIV(youngStart)))) {
		return 0;
	}
	if ((((usqInt) array2)) < (((usqInt) GIV(youngStart)))) {
		return 0;
	}
	/* begin lastPointerOf: */
	header = longAt(array1);
	fmt = (((usqInt) header) >> 8) & 15;
	if (fmt <= 4) {
		if ((fmt == 3)
		 && (((((usqInt) header) >> 12) & 31) == ClassMethodContextCompactIndex)) {
			/* begin fetchStackPointerOf: */
			sp = longAt((array1 + BaseHeaderSize) + (StackPointerIndex << ShiftForWord));
			if (!((sp & 1))) {
				contextSize = 0;
				goto l1;
			}
			assert((ReceiverIndex + ((sp >> 1))) < (lengthOf(array1)));
			contextSize = (sp >> 1);
		l1:	/* end fetchStackPointerOf: */;
			fieldOffset = (CtxtTempFrameStart + contextSize) * BytesPerWord;
			goto l2;
		}
		fieldOffset = (sizeBitsOfSafe(array1)) - BaseHeaderSize;
		goto l2;
	}
	if (fmt < 12) {
		fieldOffset = 0;
		goto l2;
	}
	methodHeader = longAt(array1 + BaseHeaderSize);
	if (isCogMethodReference(methodHeader)) {
		assert(((((CogMethod *) methodHeader)->cmType)) == CMMethod);
		methodHeader = (((CogMethod *) methodHeader)->methodHeader);
	}
	fieldOffset = (((((usqInt) methodHeader) >> 10) & 255) * BytesPerWord) + BaseHeaderSize;
l2:	/* end lastPointerOf: */;
	while (fieldOffset >= BaseHeaderSize) {
		if ((((usqInt) (longAt(array1 + fieldOffset)))) < (((usqInt) GIV(youngStart)))) {
			return 0;
		}
		if ((((usqInt) (longAt(array2 + fieldOffset)))) < (((usqInt) GIV(youngStart)))) {
			return 0;
		}
		fieldOffset -= BytesPerWord;
	}
	return 1;
}

usqInt
argumentCountAddress(void)
{
	return ((usqInt)((&GIV(argumentCount))));
}

sqInt
argumentCountOfMethodHeader(sqInt header)
{
	return (((usqInt) header) >> 25) & 15;
}

sqInt
argumentCountOf(sqInt methodPointer)
{
    sqInt header;
    sqInt methodHeader;

	/* begin argumentCountOfMethodHeader: */
	/* begin headerOf: */
	methodHeader = longAt((methodPointer + BaseHeaderSize) + (HeaderIndex << ShiftForWord));
	header = (isCogMethodReference(methodHeader)
		? (((CogMethod *) methodHeader)->methodHeader)
		: methodHeader);
	return (((usqInt) header) >> 25) & 15;
}


/*	Return the address of first indexable field of resulting array object, or
	fail if the instance variable does not contain an indexable bytes or words
	object. 
 */
/*	Note: May be called by translated primitive code. */

void *
arrayValueOf(sqInt arrayOop)
{   DECL_MAYBE_SQ_GLOBAL_STRUCT
	if ((!((arrayOop & 1)))
	 && (((arrayOop & 1) == 0)
 && (isWordsOrBytesNonInt(arrayOop)))) {
		return (void *)pointerForOop(arrayOop + BaseHeaderSize);
	}
	/* begin primitiveFail */
	if (GIV(primFailCode) == 0) {
		GIV(primFailCode) = 1;
	}
}


/*	Coerce either a CMMethod or a CMBlock to the home CMMethod */

static CogMethod *
asCogHomeMethod(CogBlockMethod *aCogMethod)
{
	return (((aCogMethod->cmType)) == CMMethod
		? ((CogMethod *) aCogMethod)
		: cmHomeMethod(aCogMethod));
}


/*	Returns an integer object */

static sqInt
asciiOfCharacter(sqInt characterObj)
{   DECL_MAYBE_SQ_GLOBAL_STRUCT
    sqInt ccIndex;
    sqInt cl;
    sqInt successBoolean;

	/* begin assertClassOf:is: */
	/* begin success: */
	/* begin isClassOfNonImm:equalTo: */
	if ((characterObj & 1)) {
		successBoolean = 0;
		goto l1;
	}
	cl = (((ccIndex = (((usqInt) (longAt(characterObj))) >> 12) & 31)) == 0
		? (longAt(characterObj - BaseHeaderSize)) & AllButTypeMask
		: longAt(((longAt((GIV(specialObjectsOop) + BaseHeaderSize) + (CompactClasses << ShiftForWord))) + BaseHeaderSize) + ((ccIndex - 1) << ShiftForWord)));
	successBoolean = cl == (longAt((GIV(specialObjectsOop) + BaseHeaderSize) + (ClassCharacter << ShiftForWord)));
l1:	/* end isClassOfNonImm:equalTo: */;
	if (!(successBoolean)) {
		if (GIV(primFailCode) == 0) {

			/* Don't overwrite an error code that has already been set. */

			GIV(primFailCode) = 1;
		}
	}
	if (GIV(primFailCode) == 0) {
		return longAt((characterObj + BaseHeaderSize) + (CharacterValueIndex << ShiftForWord));
	}
	else {
		return ConstZero;
	}
}

void
assertValidExecutionPointers(usqInt lip, char *lifp, char *lisp)
{
	assertValidExecutionPointersimbar(lip, lifp, lisp, !((((usqInt)(longAt(lifp + FoxMethod)))) < heapBase));
}

static void
assertValidExecutionPointersimbar(usqInt lip, char *lifp, char *lisp, sqInt inInterpreter)
{   DECL_MAYBE_SQ_GLOBAL_STRUCT
    CogMethod *cogMethod;
    sqInt methodField;
    sqInt methodField1;

	assert(GIV(stackPage) == (stackPageFor(lifp)));
	assert(GIV(stackPage) == (mostRecentlyUsedPage()));
	deferStackLimitSmashAround(assertValidStackLimits);
	assert(lifp < ((GIV(stackPage)->baseAddress)));
	assert(lisp < lifp);
	assert(lifp > lisp);
	assert(lisp >= (((GIV(stackPage)->realStackLimit)) - (stackLimitOffset())));
	assert((lifp - lisp) < LargeContextSize);
	methodField = longAt(lifp + FoxMethod);
	if (inInterpreter) {
		assert(!(isMachineCodeFrame(lifp)));
		assert(GIV(method) == methodField);
		if ((asserta((((usqInt)methodField)) > heapBase))
		 && (asserta((((usqInt)methodField)) < GIV(freeStart)))) {
			if (lip != (ceReturnToInterpreterPC())) {
				assert((lip >= (((methodField + (lastPointerOf(methodField))) + BaseHeaderSize) - 1))
				 && (lip < ((methodField + (byteLengthOf(methodField))) + BaseHeaderSize)));
			}
		}
		assert((iframeIsBlockActivation(lifp))
		 || ((pushedReceiverOrClosureOfFrame(lifp)) == (iframeReceiver(lifp))));
	}
	else {
		assert(isMachineCodeFrame(lifp));
		if ((asserta((((usqInt)methodField)) >= (minCogMethodAddress())))
		 && (asserta((((usqInt)methodField)) < (maxCogMethodAddress())))) {
			/* begin mframeHomeMethod: */
			methodField1 = longAt(lifp + FoxMethod);
			if ((methodField1 & MFMethodFlagIsBlockFlag) != 0) {
				cogMethod = cmHomeMethod(((CogBlockMethod *) (methodField1 & MFMethodMask)));
				goto l1;
			}
			cogMethod = ((CogMethod *) (methodField1 & MFMethodMask));
		l1:	/* end mframeHomeMethod: */;
			assert((lip > (methodField + ((mframeIsBlockActivation(lifp)
	? sizeof(CogBlockMethod)
	: sizeof(CogMethod)))))
			 && (lip < (methodField + ((cogMethod->blockSize)))));
		}
		assert((mframeIsBlockActivation(lifp))
		 || ((pushedReceiverOrClosureOfFrame(lifp)) == (mframeReceiver(lifp))));
	}
	if ((longAt(lifp + FoxSavedFP)) == 0) {
		assert(frameHasContext(lifp));
		assert((frameContext(lifp)) == (longAt(((GIV(stackPage)->baseAddress)) - BytesPerWord)));
	}
}

void
assertValidMachineCodeFrame(sqInt instrPtr)
{   DECL_MAYBE_SQ_GLOBAL_STRUCT
    CogBlockMethod *cogMethod;
    CogMethod *homeMethod;

	assert(isMachineCodeFrame(GIV(framePointer)));
	/* begin mframeCogMethod: */
	cogMethod = ((CogBlockMethod *) ((longAt(GIV(framePointer) + FoxMethod)) & MFMethodMask));
	/* begin asCogHomeMethod: */
	homeMethod = (((cogMethod->cmType)) == CMMethod
		? ((CogMethod *) cogMethod)
		: cmHomeMethod(cogMethod));
	assert((methodFor(cogMethod)) == homeMethod);
	assert((instrPtr > (((sqInt)cogMethod)))
	 && (instrPtr < ((((sqInt)homeMethod)) + ((homeMethod->blockSize)))));
}


/*	Order in the stackLimit checks is important because stackLimit is smashed
	by interrupts. So always check for unsmashed value first to avoid race
	condition. 
 */

static void
assertValidStackLimits(void)
{   DECL_MAYBE_SQ_GLOBAL_STRUCT
	assert((GIV(stackLimit) == ((GIV(stackPage)->realStackLimit)))
	 || (GIV(stackLimit) == (((char *) (((usqInt) -1))))));
	assert((((GIV(stackPage)->stackLimit)) == ((GIV(stackPage)->realStackLimit)))
	 || (((GIV(stackPage)->stackLimit)) == (((char *) (((usqInt) -1))))));
}

static void
attemptToSwitchToMachineCode(sqInt bcpc)
{   DECL_MAYBE_SQ_GLOBAL_STRUCT
    sqInt aCompiledMethodHeader;
    sqInt closure;
    CogMethod *cogMethod;
    CogBlockMethod *cogMethod1;
    CogBlockMethod *cogMethod2;
    CogMethod *homeMethod;
    sqInt methodField;
    sqInt methodHeader;
    char *p;
    sqInt pc;
    sqInt pc1;
    sqInt savedIP;
    char *sp;
    char *sp1;
    sqInt startBcpc;
    char *theFP;

	if (!(methodHasCogMethod(GIV(method)))) {
		cogselector(GIV(method), GIV(nilObj));
	}
	if (methodHasCogMethod(GIV(method))) {
		/* begin cogMethodOf: */
		methodHeader = longAt((GIV(method) + BaseHeaderSize) + (HeaderIndex << ShiftForWord));
		assert((isNonIntegerObject(methodHeader))
		 && ((((usqInt)methodHeader)) < (startOfMemory())));
		cogMethod = ((CogMethod *) methodHeader);
		/* begin convertToMachineCodeFrame:bcpc: */
		VM_LABEL(0convertToMachineCodeFramebcpc);
		assert(!(isMachineCodeFrame(GIV(framePointer))));
		if ((longAt(GIV(framePointer) + FoxSavedFP)) == 0) {
			longAtput(GIV(framePointer) + FoxCallerSavedIP, ceBaseFrameReturnPC());
		}
		else {
			if (!(isMachineCodeFrame(frameCallerFP(GIV(framePointer))))) {
				/* begin iframeSavedIP:put: */
				/* begin frameCallerFP: */
				theFP = pointerForOop(longAt(GIV(framePointer) + FoxSavedFP));
				savedIP = ((sqInt)(frameCallerSavedIP(GIV(framePointer))));
				assert(!(isMachineCodeFrame(theFP)));
				longAtput(theFP + FoxIFSavedIP, savedIP);
				longAtput(GIV(framePointer) + FoxCallerSavedIP, ceReturnToInterpreterPC());
			}
		}
		if ((byteAt((GIV(framePointer) + FoxIFrameFlags) + 3)) != 0) {
			closure = longAt(GIV(framePointer) + ((FoxCallerSavedIP + BytesPerWord) + ((((((usqInt)(longAt(GIV(framePointer) + FoxMethod)))) < heapBase
	? (mframeCogMethod(GIV(framePointer))->cmNumArgs)
	: byteAt((GIV(framePointer) + FoxIFrameFlags) + 1))) << ShiftForWord)));
			startBcpc = (((longAt((closure + BaseHeaderSize) + (ClosureStartPCIndex << ShiftForWord))) >> 1)) - 1;
			cogMethod2 = findMethodForStartBcpcinHomeMethod(startBcpc, cogMethod);
			methodField = (((sqInt)cogMethod2)) + MFMethodFlagIsBlockFlag;
		}
		else {
			/* begin startPCOfMethodHeader: */
			aCompiledMethodHeader = (cogMethod->methodHeader);
			startBcpc = (((((usqInt) aCompiledMethodHeader) >> 10) & 255) * BytesPerWord) + BaseHeaderSize;
			cogMethod2 = ((CogBlockMethod *) cogMethod);
			methodField = ((sqInt)cogMethod);
		}
		longAtput(GIV(framePointer) + FoxMethod, methodField + (((byteAt((GIV(framePointer) + FoxIFrameFlags) + 2)) != 0
	? MFMethodFlagHasContextFlag
	: 0)));
		for (p = (GIV(framePointer) + FoxIFReceiver); p >= GIV(stackPointer); p += (-BytesPerWord)) {
			longAtput((p + FoxMFReceiver) - FoxIFReceiver, longAt(p));
		}
		GIV(stackPointer) = (GIV(stackPointer) + FoxMFReceiver) - FoxIFReceiver;
		pc1 = mcPCForstartBcpcin(bcpc, startBcpc, cogMethod2);
		assert(pc1 > (noCheckEntryOffset()));
		pc = (((sqInt)cogMethod2)) + pc1;
		/* begin assertValidMachineCodeFrame: */
		assert(isMachineCodeFrame(GIV(framePointer)));
		/* begin mframeCogMethod: */
		cogMethod1 = ((CogBlockMethod *) ((longAt(GIV(framePointer) + FoxMethod)) & MFMethodMask));
		/* begin asCogHomeMethod: */
		homeMethod = (((cogMethod1->cmType)) == CMMethod
			? ((CogMethod *) cogMethod1)
			: cmHomeMethod(cogMethod1));
		assert((methodFor(cogMethod1)) == homeMethod);
		assert((pc > (((sqInt)cogMethod1)))
		 && (pc < ((((sqInt)homeMethod)) + ((homeMethod->blockSize)))));
		/* begin push: */
		longAtput(sp = GIV(stackPointer) - BytesPerWord, pc);
		GIV(stackPointer) = sp;
		/* begin push: */
		longAtput(sp1 = GIV(stackPointer) - BytesPerWord, GIV(nilObj));
		GIV(stackPointer) = sp1;
		ceEnterCogCodePopReceiverReg();
	}
}

static sqInt
baseHeader(sqInt oop)
{
	return longAt(oop);
}

sqInt
becomewith(sqInt array1, sqInt array2)
{
	return becomewithtwoWaycopyHash(array1, array2, 1, 1);
}


/*	All references to each object in array1 are swapped with all references to
	the corresponding object in array2. That is, all pointers to one object
	are replaced with with pointers to the other. The arguments must be arrays
	of the same length. 
	Returns PrimNoErr if the primitive succeeds.
 */
/*	Implementation: Uses forwarding blocks to update references as done in
	compaction. 
 */

static sqInt
becomewithtwoWaycopyHash(sqInt array1, sqInt array2, sqInt twoWayFlag, sqInt copyHashFlag)
{   DECL_MAYBE_SQ_GLOBAL_STRUCT
    sqInt contextSize;
    sqInt fieldOffset;
    sqInt fmt;
    sqInt fwdBlock;
    sqInt fwdBlock1;
    sqInt fwdBlock11;
    sqInt fwdBlock2;
    sqInt fwdHeader;
    sqInt fwdHeader1;
    sqInt fwdHeader2;
    sqInt hdr1;
    sqInt hdr11;
    sqInt hdr2;
    sqInt hdr21;
    sqInt header;
    sqInt methodHeader;
    sqInt oop1;
    sqInt oop11;
    sqInt oop2;
    sqInt oop21;
    sqInt sp;
    sqInt start;

	if ((checkForLeaks & 4) != 0) {
		runLeakCheckerForFullGC(1);
	}
	if (!(((array1 & 1) == 0)
		 && (((((usqInt) (longAt(array1))) >> 8) & 15) == 2))) {
		return PrimErrBadReceiver;
	}
	if (!((((array2 & 1) == 0)
 && (((((usqInt) (longAt(array2))) >> 8) & 15) == 2))
		 && ((lastPointerOf(array1)) == (lastPointerOf(array2))))) {
		return PrimErrBadArgument;
	}
	if (twoWayFlag) {
		if (!(containOnlyOopsand(array1, array2))) {
			return PrimErrInappropriate;
		}
	}
	else {
		if (!(containOnlyOops(array1))) {
			return PrimErrInappropriate;
		}
	}
	if (!(prepareForwardingTableForBecomingwithtwoWay(array1, array2, twoWayFlag))) {
		return PrimErrNoMemory;
	}
	if (allYoungand(array1, array2)) {

		/* sweep only the young objects plus the roots */

		start = GIV(youngStart);
	}
	else {

		/* sweep all objects */

		start = heapBase;
	}
	mapPointersInObjectsFromto(start, GIV(endOfMemory));
	if (twoWayFlag) {
		/* begin restoreHeadersAfterBecoming:with: */
		VM_LABEL(0restoreHeadersAfterBecomingwith);
		/* begin lastPointerOf: */
		header = longAt(array1);
		fmt = (((usqInt) header) >> 8) & 15;
		if (fmt <= 4) {
			if ((fmt == 3)
			 && (((((usqInt) header) >> 12) & 31) == ClassMethodContextCompactIndex)) {
				/* begin fetchStackPointerOf: */
				sp = longAt((array1 + BaseHeaderSize) + (StackPointerIndex << ShiftForWord));
				if (!((sp & 1))) {
					contextSize = 0;
					goto l1;
				}
				assert((ReceiverIndex + ((sp >> 1))) < (lengthOf(array1)));
				contextSize = (sp >> 1);
			l1:	/* end fetchStackPointerOf: */;
				fieldOffset = (CtxtTempFrameStart + contextSize) * BytesPerWord;
				goto l2;
			}
			fieldOffset = (sizeBitsOfSafe(array1)) - BaseHeaderSize;
			goto l2;
		}
		if (fmt < 12) {
			fieldOffset = 0;
			goto l2;
		}
		methodHeader = longAt(array1 + BaseHeaderSize);
		if (isCogMethodReference(methodHeader)) {
			assert(((((CogMethod *) methodHeader)->cmType)) == CMMethod);
			methodHeader = (((CogMethod *) methodHeader)->methodHeader);
		}
		fieldOffset = (((((usqInt) methodHeader) >> 10) & 255) * BytesPerWord) + BaseHeaderSize;
	l2:	/* end lastPointerOf: */;
		while (fieldOffset >= BaseHeaderSize) {
			oop1 = longAt(array1 + fieldOffset);
			oop2 = longAt(array2 + fieldOffset);
			if (!(oop1 == oop2)) {
				/* begin restoreHeaderOf: */
				fwdHeader = longAt(oop1);
				fwdBlock = (fwdHeader & AllButMarkBitAndTypeMask) << 1;
				assert((fwdHeader & MarkBit) != 0);
				assert(fwdBlockValid(fwdBlock));
				longAtput(oop1, longAt(fwdBlock + BytesPerWord));
				/* begin restoreHeaderOf: */
				fwdHeader1 = longAt(oop2);
				fwdBlock1 = (fwdHeader1 & AllButMarkBitAndTypeMask) << 1;
				assert((fwdHeader1 & MarkBit) != 0);
				assert(fwdBlockValid(fwdBlock1));
				longAtput(oop2, longAt(fwdBlock1 + BytesPerWord));
				hdr1 = longAt(oop1);
				hdr2 = longAt(oop2);
				longAtput(oop1, (hdr1 & AllButHashBits) | (hdr2 & HashBits));
				longAtput(oop2, (hdr2 & AllButHashBits) | (hdr1 & HashBits));
			}
			fieldOffset -= BytesPerWord;
		}
	}
	else {
		/* begin restoreHeadersAfterForwardBecome: */
		VM_LABEL(0restoreHeadersAfterForwardBecome);
		fwdBlock2 = ((GIV(endOfMemory) + BaseHeaderSize) + 7) & (WordMask - 7);
		flag("Dan");

		/* fwdBlockGet: did a pre-increment */

		fwdBlock2 += BytesPerWord * 4;
		while ((((usqInt) fwdBlock2)) <= (((usqInt) GIV(fwdTableNext)))) {

			/* Backpointer to mutated object. */

			oop11 = longAt(fwdBlock2 + (BytesPerWord * 2));
			oop21 = longAt(fwdBlock2);
			/* begin restoreHeaderOf: */
			fwdHeader2 = longAt(oop11);
			fwdBlock11 = (fwdHeader2 & AllButMarkBitAndTypeMask) << 1;
			assert((fwdHeader2 & MarkBit) != 0);
			assert(fwdBlockValid(fwdBlock11));
			longAtput(oop11, longAt(fwdBlock11 + BytesPerWord));
			if (copyHashFlag) {

				/* Change the hash of the new oop (oop2) to be that of the old (oop1) 
					so mutated objects in hash structures will be 
					happy after the change. */

				hdr11 = longAt(oop11);
				hdr21 = longAt(oop21);
				longAtput(oop21, (hdr21 & AllButHashBits) | (hdr11 & HashBits));
			}
			fwdBlock2 += BytesPerWord * 4;
		}
	}
	initializeMemoryFirstFree(GIV(freeStart));
	if ((checkForLeaks & 4) != 0) {
		runLeakCheckerForFullGC(1);
	}
	forceInterruptCheck();
	return PrimNoErr;
}


/*	If this object is old, mark it as a root (because a new object 
	may be stored into it) */

void
beRootIfOld(sqInt oop)
{   DECL_MAYBE_SQ_GLOBAL_STRUCT
    sqInt header;

	if (((((usqInt) oop)) < (((usqInt) GIV(youngStart))))
	 && (!((oop & 1)))) {
		/* begin noteAsRoot:headerLoc: */
		header = longAt(oop);
		if ((header & RootBit) == 0) {
			if (GIV(rootTableCount) < RootTableSize) {

				/* record oop as root only if not already recorded */
				/* record root if there is enough room in the roots  table  */

				GIV(rootTableCount) += 1;
				GIV(rootTable)[GIV(rootTableCount)] = oop;
				longAtput(oop, header | RootBit);
				if (GIV(rootTableCount) > RootTableRedZone) {
					/* begin scheduleIncrementalGC */
					GIV(needGCFlag) = 1;
					forceInterruptCheck();
				}
			}
		}
	}
}


/*	convert true and false (Smalltalk) to true or false(C) */

sqInt
booleanValueOf(sqInt obj)
{   DECL_MAYBE_SQ_GLOBAL_STRUCT
	if (obj == GIV(trueObj)) {
		return 1;
	}
	if (obj == GIV(falseObj)) {
		return 0;
	}
	/* begin success: */
	if (!(0)) {
		if (GIV(primFailCode) == 0) {

			/* Don't overwrite an error code that has already been set. */

			GIV(primFailCode) = 1;
		}
	}
	return null;
}


/*	Return the number of indexable bytes in the given object. This is
	basically a special copy of lengthOf: for BitBlt.
 */

static sqInt
byteLengthOf(sqInt oop)
{
    sqInt fmt;
    sqInt header;
    sqInt sz;

	header = longAt(oop);
	sz = ((header & TypeMask) == HeaderTypeSizeAndClass
		? (longAt(oop - (BytesPerWord * 2))) & AllButTypeMask
		: header & SizeMask);
	fmt = (((usqInt) header) >> 8) & 15;
	return (fmt < 8
		? sz - BaseHeaderSize
		: (sz - BaseHeaderSize) - (fmt & 3));
}

sqInt
byteSizeOf(sqInt oop)
{
    sqInt format;
    sqInt header;
    sqInt size;

	if ((oop & 1)) {
		return 0;
	}
	header = longAt(oop);
	format = (((usqInt) header) >> 8) & 15;
	size = ((header & TypeMask) == HeaderTypeSizeAndClass
		? (longAt(oop - (BytesPerWord * 2))) & LongSizeMask
		: header & SizeMask);
	size -= header & Size4Bit;
	return (format < 8
		? size - BaseHeaderSize
		: (size - BaseHeaderSize) - (format & 3));
}


/*	Answer the given integer with its bytes in the reverse order. */

sqInt
byteSwapped(sqInt w)
{
	
#  if BytesPerWord == 4
	return ((((((usqInt) w >> 24)) & Byte0Mask) + ((((usqInt) w >> 8)) & Byte1Mask)) + ((((usqInt) w << 8)) & Byte2Mask)) + ((((usqInt) w << 24)) & Byte3Mask);

#  else /* BytesPerWord == 4 */
	return ((((((((((usqInt) w << 0)) & Byte0Mask) + ((((usqInt) w << 0)) & Byte1Mask)) + ((((usqInt) w >> 24)) & Byte2Mask)) + ((((usqInt) w >> 8)) & Byte3Mask)) + ((((usqInt) w << 8)) & Byte4Mask)) + ((((usqInt) w << 24)) & Byte5Mask)) + ((((usqInt) w << 0)) & Byte6Mask)) + ((((usqInt) w << 0)) & Byte7Mask);

#  endif /* BytesPerWord == 4 */

}


/*	Re-enter the interpreter for executing a callback */

EXPORT(sqInt)
callbackEnter(sqInt *callbackID)
{   DECL_MAYBE_VOLATILE_SQ_GLOBAL_STRUCT
    volatile sqInt calledFromMachineCode;
    volatile void *currentCFramePointer;
    volatile void *currentCStackPointer;
    volatile sqInt header;
    volatile sqInt methodHeader;
    volatile jmp_buf savedReenterInterpreter;
    volatile sqInt wasInMachineCode;
    volatile sqInt xArray;

	if (!(asserta(primitiveFunctionPointer != 0))) {
		return 0;
	}
	assert(GIV(primFailCode) == 0);
	if (!(asserta(GIV(jmpDepth) < MaxJumpBuf))) {
		return 0;
	}
	GIV(jmpDepth) += 1;
	wasInMachineCode = (((usqInt)(longAt(GIV(framePointer) + FoxMethod)))) < heapBase;

	/* Suspend the currently active process */

	calledFromMachineCode = GIV(instructionPointer) <= heapBase;
	GIV(suspendedCallbacks)[GIV(jmpDepth)] = (longAt(((longAt(((longAt((GIV(specialObjectsOop) + BaseHeaderSize) + (SchedulerAssociation << ShiftForWord))) + BaseHeaderSize) + (ValueIndex << ShiftForWord))) + BaseHeaderSize) + (ActiveProcessIndex << ShiftForWord)));
	GIV(suspendedMethods)[GIV(jmpDepth)] = GIV(newMethod);
	flag("need to debug this properly.  Conceptually it is the right thing to do but it crashes in practice");
	if (0) {
		/* begin signalExternalSemaphores */
		xArray = longAt((GIV(specialObjectsOop) + BaseHeaderSize) + (ExternalObjectsArray << ShiftForWord));
		doSignalExternalSemaphores(stSizeOf(xArray));
		if ((GIV(suspendedCallbacks)[GIV(jmpDepth)]) == (longAt(((longAt(((longAt((GIV(specialObjectsOop) + BaseHeaderSize) + (SchedulerAssociation << ShiftForWord))) + BaseHeaderSize) + (ValueIndex << ShiftForWord))) + BaseHeaderSize) + (ActiveProcessIndex << ShiftForWord)))) {
			transferTofrom(wakeHighestPriority(), CSCallbackLeave);
		}
	}
	else {
		transferTofrom(wakeHighestPriority(), CSCallbackLeave);
	}
	forceInterruptCheck();
	currentCStackPointer = getCStackPointer();
	currentCFramePointer = getCFramePointer();
	memcpy(((void *) savedReenterInterpreter), reenterInterpreter, sizeof(jmp_buf));
	assertCStackWellAligned();
	if ((setjmp(GIV(jmpBuf)[GIV(jmpDepth)])) == 0) {
		callbackID[0] = GIV(jmpDepth);
		enterSmalltalkExecutive();
		assert(0);
	}
	setCStackPointer(currentCStackPointer);
	setCFramePointer(currentCFramePointer);
	memcpy(reenterInterpreter, ((void *) savedReenterInterpreter), sizeof(jmp_buf));
	putToSleepyieldingIf(longAt(((longAt(((longAt((GIV(specialObjectsOop) + BaseHeaderSize) + (SchedulerAssociation << ShiftForWord))) + BaseHeaderSize) + (ValueIndex << ShiftForWord))) + BaseHeaderSize) + (ActiveProcessIndex << ShiftForWord)), GIV(preemptionYields));
	transferTofrom(GIV(suspendedCallbacks)[GIV(jmpDepth)], CSCallbackLeave);

	/* see comment above */

	GIV(newMethod) = GIV(suspendedMethods)[GIV(jmpDepth)];
	/* begin argumentCountOf: */
	/* begin argumentCountOfMethodHeader: */
	/* begin headerOf: */
	methodHeader = longAt((GIV(newMethod) + BaseHeaderSize) + (HeaderIndex << ShiftForWord));
	header = (isCogMethodReference(methodHeader)
		? (((CogMethod *) methodHeader)->methodHeader)
		: methodHeader);
	GIV(argumentCount) = (((usqInt) header) >> 25) & 15;
	assert(wasInMachineCode == (isMachineCodeFrame(GIV(framePointer))));
	if (calledFromMachineCode) {
		if (GIV(instructionPointer) >= heapBase) {
			/* begin iframeSavedIP:put: */
			assert(!(isMachineCodeFrame(GIV(framePointer))));
			longAtput(GIV(framePointer) + FoxIFSavedIP, GIV(instructionPointer));
			GIV(instructionPointer) = ceReturnToInterpreterPC();
		}
	}
	else {
		assert(!(isMachineCodeFrame(GIV(framePointer))));
		assert(GIV(instructionPointer) > (startOfMemory()));
	}
	assert(GIV(primFailCode) == 0);
	GIV(jmpDepth) -= 1;
	return 1;
}


/*	Leave from a previous callback */
/*	For now, do not allow a callback return unless we're in a
	primitiveResponse 
 */

EXPORT(sqInt)
callbackLeave(sqInt cbID)
{   DECL_MAYBE_SQ_GLOBAL_STRUCT
	if (!(asserta(primitiveFunctionPointer != 0))) {
		return 0;
	}
	if (!(cbID == GIV(jmpDepth))) {
		return 0;
	}
	if (cbID < 1) {
		return 0;
	}
	longjmp(GIV(jmpBuf)[GIV(jmpDepth)], 1);
	return null;
}


/*	Call the external plugin function identified. In the VM this is an
	address; see StackInterpreterSimulator for its version. */

static void
callExternalPrimitive(void (*functionID)())
{
	dispatchFunctionPointer(functionID);
}

void
callForCogCompiledCodeCompaction(void)
{
	GIV(cogCompiledCodeCompactionCalledFor) = 1;
	forceInterruptCheck();
}


/*	Context switch should not be allowed on every method activation. In
	particular the implementation of ensure: and ifCurtailed: depends on there
	being no
	suspension point on failing primitive 198 (primitiveMarkUnwindMethod).
	slowPrimitiveResponse states
	``N.B. This means there is no suspension point on primitive failure
	which methods such as ensure: and ifCurtailed: rely on.''
	Rather than prevent context switch on all primitives but the ones we
	really need
	to be suspension points (primitiveSignal et al) we choose to allow context
	switch for all but primitiveMarkUnwindMethod. */

sqInt
canContextSwitchIfActivating(sqInt methodHeader)
{
    sqInt primBits;
    sqInt primitiveIndex;

	/* begin primitiveIndexOfMethodHeader: */
	primBits = ((usqInt) methodHeader) >> 1;
	primitiveIndex = (primBits & 511) + ((((usqInt) primBits) >> 19) & 512);
	if (1) {
		return primitiveIndex != 198;
	}
	return (primitiveIndex == 0)
	 || ((((primitiveIndex >= 85) && (primitiveIndex <= 88)))
 || (primitiveIndex == 167));
}


/*	An external call or FFI primitive has failed. Build the frame and
	activate as appropriate. Enter either the interpreter or machine
	code depending on whether aPrimitiveMethod has been or is still
	cogged. Note that we could always interpret but want the efficiency
	of executing machine code if it is available. */

void
ceActivateFailingPrimitiveMethod(sqInt aPrimitiveMethod)
{
    sqInt methodHeader;

	assert(GIV(newMethod) == aPrimitiveMethod);
	methodHeader = longAt((aPrimitiveMethod + BaseHeaderSize) + (HeaderIndex << ShiftForWord));
	if (isCogMethodReference(methodHeader)) {
		activateCoggedNewMethod(0);
	}
	else {
		activateNewMethod();
	}
}


/*	Return across a page boundary. The context to return to (which may be
	married) is stored in the first word of the stack. We get here when a
	return instruction jumps
	to the ceBaseFrameReturn: address that is the return pc for base frames. A
	consequence of this is that the current frame is no longer valid since an
	interrupt may have overwritten
	its state as soon as the stack pointer has been cut-back beyond the return
	pc. So to have
	a context to send the cannotReturn: message to we also store the base
	frame's context
	in the second word of the stack page. */

sqInt
ceBaseFrameReturn(sqInt returnValue)
{   DECL_MAYBE_SQ_GLOBAL_STRUCT
    char *callerFP;
    sqInt contextToReturnFrom;
    sqInt contextToReturnTo;
    char *fp;
    char *frameAbove;
    sqInt index;
    sqInt isAContext;
    StackPage *lruOrFree;
    StackPage *newPage;
    char *sp;
    char *sp1;
    char *sp2;
    char *sp3;
    StackPage *thePage;
    sqInt value;

	assert((stackPageFor(GIV(stackPointer))) == GIV(stackPage));
	assert((mostRecentlyUsedPage()) == GIV(stackPage));
	assertCStackWellAligned();
	assert(GIV(framePointer) == 0);
	assert(GIV(stackPointer) <= (((GIV(stackPage)->baseAddress)) - BytesPerWord));
	assert((((GIV(stackPage)->baseFP)) + (2 * BytesPerWord)) < ((GIV(stackPage)->baseAddress)));
	assert((addressCouldBeObj(longAt(((GIV(stackPage)->baseAddress)) - BytesPerWord)))
	 && (isContext(longAt(((GIV(stackPage)->baseAddress)) - BytesPerWord))));
	assert((addressCouldBeObj(longAt((GIV(stackPage)->baseAddress))))
	 && (isContext(longAt((GIV(stackPage)->baseAddress)))));

	/* The stack page is effectively free now, so free it.  We must free it to be
	 correct in determining if contextToReturnTo is still married, and in case
	 makeBaseFrameFor: cogs a method, which may cause a code compaction,
	 in which case the frame must be free to avoid the relocation machinery
	 tracing the dead frame.  Since freeing now temporarily violates the page-list
	 ordering invariant, use the assert-free version. */

	contextToReturnTo = longAt((GIV(stackPage)->baseAddress));
	freeStackPageNoAssert(GIV(stackPage));
	isAContext = ((contextToReturnTo & 1) == 0)
	 && (((((usqInt) (longAt(contextToReturnTo))) >> 12) & 31) == ClassMethodContextCompactIndex);
	if (isAContext
	 && ((((longAt((contextToReturnTo + BaseHeaderSize) + (SenderIndex << ShiftForWord))) & 1))
 && (!(isWidowedContext(contextToReturnTo))))) {
		/* begin frameOfMarriedContext: */
		value = longAt((contextToReturnTo + BaseHeaderSize) + (SenderIndex << ShiftForWord));
		/* begin withoutSmallIntegerTags: */
		assert((value & 1));
		GIV(framePointer) = pointerForOop(value - 1);
		/* begin stackPageFor: */
		/* begin stackPageAt: */
		/* begin pageIndexFor: */
		assert((((((char *) GIV(framePointer))) >= (GIV(stackBasePlus1) - 1)) && ((((char *) GIV(framePointer))) <= (((char *) GIV(pages))))));
		index = pageIndexForstackBasePlus1bytesPerPage(GIV(framePointer), GIV(stackBasePlus1), GIV(bytesPerPage));
		thePage = stackPageAtpages(index, GIV(pages));
		if (GIV(framePointer) == ((thePage->headFP))) {
			GIV(stackPointer) = (thePage->headSP);
		}
		else {
			/* begin findFrameAbove:inPage: */
			fp = (thePage->headFP);
			if (fp == GIV(framePointer)) {
				frameAbove = 0;
				goto l1;
			}
			while (((callerFP = frameCallerFP(fp))) != 0) {
				if (callerFP == GIV(framePointer)) {
					frameAbove = fp;
					goto l1;
				}
				fp = callerFP;
			}
			error("did not find theFP in stack page");
			frameAbove = 0;
		l1:	/* end findFrameAbove:inPage: */;
			/* begin newStackPage */
			lruOrFree = (mostRecentlyUsedPage()->nextPage);
			if (isFree(lruOrFree)) {
				newPage = lruOrFree;
				goto l2;
			}
			divorceFramesIn(lruOrFree);
			newPage = lruOrFree;
		l2:	/* end newStackPage */;
			assert(newPage == GIV(stackPage));
			moveFramesInthroughtoPage(thePage, frameAbove, newPage);
			markStackPageMostRecentlyUsed(newPage);
			GIV(framePointer) = (thePage->headFP);
			GIV(stackPointer) = (thePage->headSP);
		}
	}
	else {
		if (!(isAContext
			 && (((longAt((contextToReturnTo + BaseHeaderSize) + (InstructionPointerIndex << ShiftForWord))) & 1)))) {
			contextToReturnFrom = longAt(((GIV(stackPage)->baseAddress)) - BytesPerWord);
			tearDownAndRebuildFrameForCannotReturnBaseFrameReturnFromtoreturnValue(contextToReturnFrom, contextToReturnTo, returnValue);
			/* begin externalCannotReturn:from: */
			/* begin push: */
			longAtput(sp3 = GIV(stackPointer) - BytesPerWord, contextToReturnFrom);
			GIV(stackPointer) = sp3;
			/* begin push: */
			longAtput(sp1 = GIV(stackPointer) - BytesPerWord, returnValue);
			GIV(stackPointer) = sp1;
			/* begin push: */
			longAtput(sp2 = GIV(stackPointer) - BytesPerWord, GIV(instructionPointer));
			GIV(stackPointer) = sp2;
			return ceSendsupertonumArgs(longAt((GIV(specialObjectsOop) + BaseHeaderSize) + (SelectorCannotReturn << ShiftForWord)), 0, contextToReturnFrom, -1 - 1);
		}
		GIV(instructionPointer) = 0;
		thePage = makeBaseFrameFor(contextToReturnTo);
		GIV(framePointer) = (thePage->headFP);
		GIV(stackPointer) = (thePage->headSP);
	}
	/* begin setStackPageAndLimit: */
	GIV(stackPage) = thePage;
	if (GIV(stackLimit) != (((char *) (((usqInt) -1))))) {
		GIV(stackLimit) = (GIV(stackPage)->stackLimit);
	}
	markStackPageMostRecentlyUsed(thePage);
	assert((stackPageFor(GIV(framePointer))) == GIV(stackPage));
	if ((((usqInt)(longAt(GIV(framePointer) + FoxMethod)))) < heapBase) {
		/* begin push: */
		longAtput(sp = GIV(stackPointer) - BytesPerWord, returnValue);
		GIV(stackPointer) = sp;
		ceEnterCogCodePopReceiverReg();
	}
	GIV(instructionPointer) = longAt(GIV(stackPointer));
	if (GIV(instructionPointer) == (ceReturnToInterpreterPC())) {
		GIV(instructionPointer) = longAt(GIV(framePointer) + FoxIFSavedIP);
	}
	/* begin setMethod: */
	assert((((usqInt)(longAt(GIV(framePointer) + FoxMethod)))) >= (startOfMemory()));
	GIV(method) = longAt(GIV(framePointer) + FoxMethod);
	longAtPointerput(GIV(stackPointer), returnValue);
	assert(checkIsStillMarriedContextcurrentFP(contextToReturnTo, GIV(framePointer)));
	siglongjmp(reenterInterpreter, ReturnToInterpreter);
	return null;
}


/*	A context that has been returned from, or otherwise has an invalid pc has
	been reentered.
	Until we have a cannotResume: selector, simply resend cannotReturn:. */

sqInt
ceCannotResume(void)
{   DECL_MAYBE_SQ_GLOBAL_STRUCT
    sqInt object;
    sqInt resultOop;
    char *sp;
    char *sp1;
    char *sp2;

	assert(isMachineCodeFrame(GIV(framePointer)));
	assert(frameHasContext(GIV(framePointer)));
	resultOop = longAt(GIV(stackPointer));
	/* begin push: */
	longAtput(sp = GIV(stackPointer) - BytesPerWord, longAt(GIV(framePointer) + FoxThisContext));
	GIV(stackPointer) = sp;
	/* begin push: */
	longAtput(sp1 = GIV(stackPointer) - BytesPerWord, resultOop);
	GIV(stackPointer) = sp1;
	/* begin push: */
	object = ceCannotResumePC();
	longAtput(sp2 = GIV(stackPointer) - BytesPerWord, object);
	GIV(stackPointer) = sp2;
	return ceSendsupertonumArgs(longAt((GIV(specialObjectsOop) + BaseHeaderSize) + (SelectorCannotReturn << ShiftForWord)), 0, longAt(GIV(framePointer) + FoxThisContext), -1 - 1);
}

void
ceCheckForInterrupts(void)
{
    sqInt switched;

	switched = checkForEventsMayContextSwitch(1);
	returnToExecutivepostContextSwitch(0, switched);
}


/*	Check if the profile timer has expired and if so take a sample.
	If the primitive has failed sample the profileMethod as nil.
	As a courtesy to compileInterpreterPrimitive: map NULL to nilObj. */

void
ceCheckProfileTick(void)
{   DECL_MAYBE_SQ_GLOBAL_STRUCT
	if (GIV(newMethod) == null) {
		GIV(newMethod) = GIV(nilObj);
	}
	null;
	checkProfileTick(GIV(newMethod));
}

sqInt
ceContextinstVar(sqInt maybeContext, sqInt slotIndex)
{   DECL_MAYBE_SQ_GLOBAL_STRUCT
    sqInt result;
    char *sp;
    sqInt top;

	if (((((usqInt) (longAt(maybeContext))) >> 12) & 31) == ClassMethodContextCompactIndex) {
		/* begin popStack */
		top = longAt(GIV(stackPointer));
		GIV(stackPointer) += BytesPerWord;
		GIV(instructionPointer) = ((sqInt) top);
		result = externalInstVarofContext(slotIndex, maybeContext);
		/* begin push: */
		longAtput(sp = GIV(stackPointer) - BytesPerWord, GIV(instructionPointer));
		GIV(stackPointer) = sp;
	}
	else {
		result = longAt((maybeContext + BaseHeaderSize) + (slotIndex << ShiftForWord));
	}
	return result;
}


/*	genStorePop:MaybeContextReceiverVariable: filters out unmarried contexts
	but not arbitrary objects in subclasses. It answers maybeMarriedContext so
	that the StackToRegisterMappingCogit can keep ReceiverResultReg live. */

sqInt
ceContextinstVarvalue(sqInt maybeMarriedContext, sqInt slotIndex, sqInt anOop)
{   DECL_MAYBE_SQ_GLOBAL_STRUCT
    char *sp;
    sqInt top;

	if (((((usqInt) (longAt(maybeMarriedContext))) >> 12) & 31) == ClassMethodContextCompactIndex) {
		assert(isMarriedOrWidowedContext(maybeMarriedContext));
		/* begin popStack */
		top = longAt(GIV(stackPointer));
		GIV(stackPointer) += BytesPerWord;
		GIV(instructionPointer) = ((sqInt) top);
		externalInstVarofContextput(slotIndex, maybeMarriedContext, anOop);
		/* begin push: */
		longAtput(sp = GIV(stackPointer) - BytesPerWord, GIV(instructionPointer));
		GIV(stackPointer) = sp;
	}
	else {
		/* begin storePointer:ofObject:withValue: */
		if ((((usqInt) maybeMarriedContext)) < (((usqInt) GIV(youngStart)))) {
			possibleRootStoreIntovalue(maybeMarriedContext, anOop);
		}
		longAtput((maybeMarriedContext + BaseHeaderSize) + (slotIndex << ShiftForWord), anOop);
	}
	return maybeMarriedContext;
}

sqInt
ceInterpretMethodFromPICreceiver(sqInt aMethodObj, sqInt rcvr)
{   DECL_MAYBE_SQ_GLOBAL_STRUCT
    CogMethod *pic;
    sqInt primBits;
    sqInt primitiveIndex;

	assert(!(methodHasCogMethod(aMethodObj)));
	pic = ((CogMethod *) ((popStack()) - (interpretOffset())));
	assert((((pic->cmType)) == CMOpenPIC)
	 || (((pic->cmType)) == CMClosedPIC));
	if (((pic->cmType)) == CMOpenPIC) {
		if (methodShouldBeCogged(aMethodObj)) {
			cogselector(aMethodObj, (pic->selector));
			if (methodHasCogMethod(aMethodObj)) {
				executeCogMethodFromUnlinkedSendwithReceiver(cogMethodOf(aMethodObj), rcvr);
			}
		}
	}
	else {
		assert(GIV(cogCompiledCodeCompactionCalledFor)
		 || (!(methodShouldBeCogged(aMethodObj))));
	}
	GIV(messageSelector) = (pic->selector);
	GIV(newMethod) = aMethodObj;
	/* begin primitiveIndexOf: */
	primBits = (((usqInt) (headerOf(aMethodObj))) >> 1) & 268435967;
	primitiveIndex = (primBits & 511) + (((usqInt) primBits) >> 19);
	/* begin functionPointerFor:inClass: */
	primitiveFunctionPointer = ((void (*)(void)) ((primitiveIndex > MaxPrimitiveIndex
	? 0
	: primitiveTable[primitiveIndex])));
	GIV(argumentCount) = (pic->cmNumArgs);
	return activateInterpreterMethodFromMachineCode();
}

void
ceMNUFromPICMNUMethodreceiver(sqInt aMethodObj, sqInt rcvr)
{   DECL_MAYBE_SQ_GLOBAL_STRUCT
    sqInt ccIndex;
    CogMethod *cPIC;

	assert(((rcvr & 1))
	 || (addressCouldBeObj(rcvr)));
	cPIC = ((CogMethod *) ((popStack()) - (mnuOffset())));
	assert(((cPIC->cmType)) == CMClosedPIC);
	GIV(argumentCount) = (cPIC->cmNumArgs);
	GIV(messageSelector) = (cPIC->selector);
	/* begin fetchClassOf: */
	if ((rcvr & 1)) {
		GIV(lkupClass) = longAt((GIV(specialObjectsOop) + BaseHeaderSize) + (ClassInteger << ShiftForWord));
		goto l1;
	}
	if (((ccIndex = (((usqInt) (longAt(rcvr))) >> 12) & 31)) == 0) {
		GIV(lkupClass) = (longAt(rcvr - BaseHeaderSize)) & AllButTypeMask;
		goto l1;
	}
	else {
		GIV(lkupClass) = longAt(((longAt((GIV(specialObjectsOop) + BaseHeaderSize) + (CompactClasses << ShiftForWord))) + BaseHeaderSize) + ((ccIndex - 1) << ShiftForWord));
		goto l1;
	}
l1:	/* end fetchClassOf: */;
	handleMNUInMachineCodeToclassForMessagemayLink(SelectorDoesNotUnderstand, rcvr, GIV(lkupClass), 0);
}

sqInt
ceNewArraySlotSize(sqInt slotSize)
{
	return eeInstantiateAndInitializeClassindexableSize(longAt((GIV(specialObjectsOop) + BaseHeaderSize) + (ClassArray << ShiftForWord)), slotSize);
}

sqInt
ceNonLocalReturn(sqInt returnValue)
{   DECL_MAYBE_SQ_GLOBAL_STRUCT
    StackPage *aPage;
    sqInt callerContextOrNil;
    sqInt callerContextOrNil1;
    sqInt callerContextOrNil2;
    char *callerFP;
    sqInt closure;
    sqInt contextToReturnTo;
    sqInt ctxtOrNilOrZero;
    sqInt currentCtx;
    char *frameToReturnTo;
    sqInt home;
    sqInt index;
    sqInt index1;
    sqInt index2;
    sqInt index3;
    sqInt index4;
    StackPage *newPage;
    sqInt nextCntx;
    sqInt ourContext;
    sqInt ourContext1;
    char *sp;
    char *sp1;
    char *sp11;
    char *sp12;
    char *sp2;
    char *sp21;
    char *sp22;
    char *sp3;
    char *sp31;
    char *sp4;
    char *theFP;
    char *theFP1;
    char *theFP2;
    char *theFP3;
    char *theFP4;
    sqInt theMethod;
    StackPage *thePage;
    StackPage *thePage1;
    StackPage *thePage2;
    StackPage *thePage3;
    char *theSP;
    char *theSP1;
    sqInt top;
    sqInt unwindContextOrNilOrZero;
    sqInt value;
    sqInt value1;

	assert(isMachineCodeFrame(GIV(framePointer)));
	assert(frameIsBlockActivation(GIV(framePointer)));
	closure = longAt(GIV(framePointer) + ((FoxCallerSavedIP + BytesPerWord) + ((((((usqInt)(longAt(GIV(framePointer) + FoxMethod)))) < heapBase
	? (mframeCogMethod(GIV(framePointer))->cmNumArgs)
	: byteAt((GIV(framePointer) + FoxIFrameFlags) + 1))) << ShiftForWord)));

	/* Walk the closure's lexical chain to find the context or frame to return from (home). */

	home = null;
	while (closure != GIV(nilObj)) {
		home = longAt((closure + BaseHeaderSize) + (ClosureOuterContextIndex << ShiftForWord));
		closure = longAt((home + BaseHeaderSize) + (ClosureIndex << ShiftForWord));
	}
	/* begin externalWriteBackHeadFramePointers */
	assert((GIV(framePointer) - GIV(stackPointer)) < LargeContextSize);
	assert(GIV(stackPage) == (mostRecentlyUsedPage()));
	/* begin setHeadFP:andSP:inPage: */
	assert(GIV(stackPointer) < GIV(framePointer));
	assert((GIV(stackPointer) < ((GIV(stackPage)->baseAddress)))
	 && (GIV(stackPointer) > (((GIV(stackPage)->realStackLimit)) - LargeContextSize)));
	assert((GIV(framePointer) < ((GIV(stackPage)->baseAddress)))
	 && (GIV(framePointer) > (((GIV(stackPage)->realStackLimit)) - (((sqInt) LargeContextSize >> 1)))));
	(GIV(stackPage)->headFP = GIV(framePointer));
	(GIV(stackPage)->headSP = GIV(stackPointer));
	assert(pageListIsWellFormed());
	/* begin findUnwindThroughContext: */
	ctxtOrNilOrZero = findMethodWithPrimitiveFromFPUpToContext(198, GIV(framePointer), home);
	if (ctxtOrNilOrZero == 0) {
		theMethod = longAt((home + BaseHeaderSize) + (MethodIndex << ShiftForWord));
		if ((primitiveIndexOf(theMethod)) == 198) {
			unwindContextOrNilOrZero = home;
			goto l1;
		}
	}
	unwindContextOrNilOrZero = ctxtOrNilOrZero;
l1:	/* end findUnwindThroughContext: */;
	if (unwindContextOrNilOrZero == GIV(nilObj)) {
		/* begin ensureFrameIsMarried:SP: */
		VM_LABEL(6ensureFrameIsMarriedSP);
		theFP3 = GIV(framePointer);
		theSP = GIV(stackPointer);
		if (((((usqInt)(longAt(theFP3 + FoxMethod)))) < heapBase
			? ((longAt(theFP3 + FoxMethod)) & MFMethodFlagHasContextFlag) != 0
			: (byteAt((theFP3 + FoxIFrameFlags) + 2)) != 0)) {
			assert(isContext(frameContext(theFP3)));
			ourContext = longAt(theFP3 + FoxThisContext);
			goto l2;
		}
		ourContext = marryFrameSP(theFP3, theSP);
	l2:	/* end ensureFrameIsMarried:SP: */;
		/* begin externalCannotReturn:from: */
		/* begin push: */
		longAtput(sp = GIV(stackPointer) - BytesPerWord, ourContext);
		GIV(stackPointer) = sp;
		/* begin push: */
		longAtput(sp1 = GIV(stackPointer) - BytesPerWord, returnValue);
		GIV(stackPointer) = sp1;
		/* begin push: */
		longAtput(sp2 = GIV(stackPointer) - BytesPerWord, GIV(instructionPointer));
		GIV(stackPointer) = sp2;
		return ceSendsupertonumArgs(longAt((GIV(specialObjectsOop) + BaseHeaderSize) + (SelectorCannotReturn << ShiftForWord)), 0, ourContext, -1 - 1);
	}
	if (unwindContextOrNilOrZero != 0) {
		/* begin externalAboutToReturn:through: */
		VM_LABEL(0externalAboutToReturnthrough);
		/* begin ensureFrameIsMarried:SP: */
		VM_LABEL(7ensureFrameIsMarriedSP);
		if (((((usqInt)(longAt(GIV(framePointer) + FoxMethod)))) < heapBase
			? ((longAt(GIV(framePointer) + FoxMethod)) & MFMethodFlagHasContextFlag) != 0
			: (byteAt((GIV(framePointer) + FoxIFrameFlags) + 2)) != 0)) {
			assert(isContext(frameContext(GIV(framePointer))));
			ourContext1 = longAt(GIV(framePointer) + FoxThisContext);
			goto l4;
		}
		ourContext1 = marryFrameSP(GIV(framePointer), GIV(stackPointer));
	l4:	/* end ensureFrameIsMarried:SP: */;
		/* begin push: */
		longAtput(sp4 = GIV(stackPointer) - BytesPerWord, ourContext1);
		GIV(stackPointer) = sp4;
		/* begin push: */
		longAtput(sp12 = GIV(stackPointer) - BytesPerWord, returnValue);
		GIV(stackPointer) = sp12;
		/* begin push: */
		longAtput(sp22 = GIV(stackPointer) - BytesPerWord, unwindContextOrNilOrZero);
		GIV(stackPointer) = sp22;
		/* begin push: */
		longAtput(sp31 = GIV(stackPointer) - BytesPerWord, GIV(instructionPointer));
		GIV(stackPointer) = sp31;
		return ceSendsupertonumArgs(longAt((GIV(specialObjectsOop) + BaseHeaderSize) + (SelectorAboutToReturn << ShiftForWord)), 0, ourContext1, -2 - 1);
	}
	contextToReturnTo = null;
	if (((longAt((home + BaseHeaderSize) + (SenderIndex << ShiftForWord))) & 1)) {
		assert(checkIsStillMarriedContextcurrentFP(home, GIV(framePointer)));
		/* begin frameOfMarriedContext: */
		value = longAt((home + BaseHeaderSize) + (SenderIndex << ShiftForWord));
		/* begin withoutSmallIntegerTags: */
		assert((value & 1));
		theFP = pointerForOop(value - 1);
		if ((longAt(theFP + FoxSavedFP)) == 0) {
			/* begin frameCallerContext: */
			assert(isBaseFrame(theFP));
			/* begin stackPageFor: */
			/* begin stackPageAt: */
			/* begin pageIndexFor: */
			assert((((((char *) theFP)) >= (GIV(stackBasePlus1) - 1)) && ((((char *) theFP)) <= (((char *) GIV(pages))))));
			index2 = pageIndexForstackBasePlus1bytesPerPage(theFP, GIV(stackBasePlus1), GIV(bytesPerPage));
			thePage1 = stackPageAtpages(index2, GIV(pages));
			callerContextOrNil = longAt((thePage1->baseAddress));
			assert(addressCouldBeObj(callerContextOrNil));
			assert((callerContextOrNil == (nilObject()))
			 || (isContext(callerContextOrNil)));
			contextToReturnTo = callerContextOrNil;
		}
		else {
			/* begin frameCallerFP: */
			frameToReturnTo = pointerForOop(longAt(theFP + FoxSavedFP));
		}
	}
	else {
		contextToReturnTo = longAt((home + BaseHeaderSize) + (SenderIndex << ShiftForWord));
		if ((((contextToReturnTo & 1) == 0)
 && (((((usqInt) (longAt(contextToReturnTo))) >> 12) & 31) == ClassMethodContextCompactIndex))
		 && (((longAt((contextToReturnTo + BaseHeaderSize) + (SenderIndex << ShiftForWord))) & 1))) {
			assert(checkIsStillMarriedContextcurrentFP(contextToReturnTo, GIV(framePointer)));
			/* begin frameOfMarriedContext: */
			value1 = longAt((contextToReturnTo + BaseHeaderSize) + (SenderIndex << ShiftForWord));
			/* begin withoutSmallIntegerTags: */
			assert((value1 & 1));
			frameToReturnTo = pointerForOop(value1 - 1);
			contextToReturnTo = null;
		}
	}
	if (contextToReturnTo != null) {
		frameToReturnTo = establishFrameForContextToReturnTo(contextToReturnTo);
		if (frameToReturnTo == 0) {
			/* begin ensureFrameIsMarried:SP: */
			VM_LABEL(8ensureFrameIsMarriedSP);
			theFP4 = GIV(framePointer);
			theSP1 = GIV(stackPointer);
			if (((((usqInt)(longAt(theFP4 + FoxMethod)))) < heapBase
				? ((longAt(theFP4 + FoxMethod)) & MFMethodFlagHasContextFlag) != 0
				: (byteAt((theFP4 + FoxIFrameFlags) + 2)) != 0)) {
				assert(isContext(frameContext(theFP4)));
				ourContext = longAt(theFP4 + FoxThisContext);
				goto l3;
			}
			ourContext = marryFrameSP(theFP4, theSP1);
		l3:	/* end ensureFrameIsMarried:SP: */;
			/* begin externalCannotReturn:from: */
			/* begin push: */
			longAtput(sp3 = GIV(stackPointer) - BytesPerWord, ourContext);
			GIV(stackPointer) = sp3;
			/* begin push: */
			longAtput(sp11 = GIV(stackPointer) - BytesPerWord, returnValue);
			GIV(stackPointer) = sp11;
			/* begin push: */
			longAtput(sp21 = GIV(stackPointer) - BytesPerWord, GIV(instructionPointer));
			GIV(stackPointer) = sp21;
			return ceSendsupertonumArgs(longAt((GIV(specialObjectsOop) + BaseHeaderSize) + (SelectorCannotReturn << ShiftForWord)), 0, ourContext, -1 - 1);
		}
	}
	assert(pageListIsWellFormed());
	/* begin stackPageFor: */
	/* begin stackPageAt: */
	/* begin pageIndexFor: */
	assert((((((char *) frameToReturnTo)) >= (GIV(stackBasePlus1) - 1)) && ((((char *) frameToReturnTo)) <= (((char *) GIV(pages))))));
	index1 = pageIndexForstackBasePlus1bytesPerPage(frameToReturnTo, GIV(stackBasePlus1), GIV(bytesPerPage));
	newPage = stackPageAtpages(index1, GIV(pages));
	if (newPage != GIV(stackPage)) {
		/* begin frameCallerContext: */
		theFP2 = (GIV(stackPage)->baseFP);
		assert(isBaseFrame(theFP2));
		/* begin stackPageFor: */
		/* begin stackPageAt: */
		/* begin pageIndexFor: */
		assert((((((char *) theFP2)) >= (GIV(stackBasePlus1) - 1)) && ((((char *) theFP2)) <= (((char *) GIV(pages))))));
		index4 = pageIndexForstackBasePlus1bytesPerPage(theFP2, GIV(stackBasePlus1), GIV(bytesPerPage));
		thePage3 = stackPageAtpages(index4, GIV(pages));
		callerContextOrNil2 = longAt((thePage3->baseAddress));
		assert(addressCouldBeObj(callerContextOrNil2));
		assert((callerContextOrNil2 == (nilObject()))
		 || (isContext(callerContextOrNil2)));
		currentCtx = callerContextOrNil2;
		assert(isContext(currentCtx));
		/* begin freeStackPage: */
		aPage = GIV(stackPage);
		freeStackPageNoAssert(aPage);
		assert(pageListIsWellFormed());
			while (1) {
			assert(isContext(currentCtx));
			if ((((longAt((currentCtx + BaseHeaderSize) + (SenderIndex << ShiftForWord))) & 1))
 && ((stackPageFor(theFP = frameOfMarriedContext(currentCtx))) == newPage)) break;
			if (((longAt((currentCtx + BaseHeaderSize) + (SenderIndex << ShiftForWord))) & 1)) {
				/* begin stackPageFor: */
				/* begin stackPageAt: */
				/* begin pageIndexFor: */
				assert((((((char *) theFP)) >= (GIV(stackBasePlus1) - 1)) && ((((char *) theFP)) <= (((char *) GIV(pages))))));
				index = pageIndexForstackBasePlus1bytesPerPage(theFP, GIV(stackBasePlus1), GIV(bytesPerPage));
				thePage = stackPageAtpages(index, GIV(pages));
				/* begin frameCallerContext: */
				theFP1 = (thePage->baseFP);
				assert(isBaseFrame(theFP1));
				/* begin stackPageFor: */
				/* begin stackPageAt: */
				/* begin pageIndexFor: */
				assert((((((char *) theFP1)) >= (GIV(stackBasePlus1) - 1)) && ((((char *) theFP1)) <= (((char *) GIV(pages))))));
				index3 = pageIndexForstackBasePlus1bytesPerPage(theFP1, GIV(stackBasePlus1), GIV(bytesPerPage));
				thePage2 = stackPageAtpages(index3, GIV(pages));
				callerContextOrNil1 = longAt((thePage2->baseAddress));
				assert(addressCouldBeObj(callerContextOrNil1));
				assert((callerContextOrNil1 == (nilObject()))
				 || (isContext(callerContextOrNil1)));
				currentCtx = callerContextOrNil1;
				/* begin freeStackPage: */
				freeStackPageNoAssert(thePage);
				assert(pageListIsWellFormed());
			}
			else {
				nextCntx = longAt((currentCtx + BaseHeaderSize) + (SenderIndex << ShiftForWord));
				/* begin markContextAsDead: */
				assert(isContext(currentCtx));
				longAtput((currentCtx + BaseHeaderSize) + (SenderIndex << ShiftForWord), GIV(nilObj));
				longAtput((currentCtx + BaseHeaderSize) + (InstructionPointerIndex << ShiftForWord), GIV(nilObj));
				currentCtx = nextCntx;
			}
		}
		/* begin setStackPageAndLimit: */
		GIV(stackPage) = newPage;
		if (GIV(stackLimit) != (((char *) (((usqInt) -1))))) {
			GIV(stackLimit) = (GIV(stackPage)->stackLimit);
		}
		markStackPageMostRecentlyUsed(newPage);
		GIV(stackPointer) = (GIV(stackPage)->headSP);
		GIV(framePointer) = (GIV(stackPage)->headFP);
	}
	flag("currently caller pushes result");
	if (GIV(framePointer) == frameToReturnTo) {
		/* begin popStack */
		top = longAt(GIV(stackPointer));
		GIV(stackPointer) += BytesPerWord;
		GIV(instructionPointer) = ((sqInt) top);
	}
	else {
		do {
			callerFP = GIV(framePointer);
			/* begin frameCallerFP: */
			GIV(framePointer) = pointerForOop(longAt(GIV(framePointer) + FoxSavedFP));
		} while(GIV(framePointer) != frameToReturnTo);
		GIV(instructionPointer) = ((usqInt)(frameCallerSavedIP(callerFP)));
		/* begin frameCallerSP: */
		assert(!(isBaseFrame(callerFP)));
		GIV(stackPointer) = (callerFP + ((FoxCallerSavedIP + BytesPerWord) + ((((((usqInt)(longAt(callerFP + FoxMethod)))) < heapBase
	? (mframeCogMethod(callerFP)->cmNumArgs)
	: byteAt((callerFP + FoxIFrameFlags) + 1))) << ShiftForWord))) + BytesPerWord;
	}
	return returntoExecutive(returnValue, 0);
}

sqInt
cePositive32BitIntegerFor(usqInt anInteger)
{
	return positive32BitIntegerFor(anInteger);
}


/*	Since the trampoline checks for marriage we should only be here for a
	single frame.
 */

sqInt
cePushActiveContext(void)
{   DECL_MAYBE_SQ_GLOBAL_STRUCT
	assert(isMachineCodeFrame(GIV(framePointer)));
	assert(!(frameHasContext(GIV(framePointer))));
	return marryFrameSP(GIV(framePointer), GIV(stackPointer) + BytesPerWord);
}

sqInt
ceReturnToInterpreter(sqInt anOop)
{   DECL_MAYBE_SQ_GLOBAL_STRUCT
    char *sp;
    StackPage *thePage;

	assert(((anOop & 1))
	 || (addressCouldBeObj(anOop)));
	flag("are you really sure setStackPageAndLimit: is needed?");
	/* begin setStackPageAndLimit: */
	thePage = GIV(stackPage);
	GIV(stackPage) = thePage;
	if (GIV(stackLimit) != (((char *) (((usqInt) -1))))) {
		GIV(stackLimit) = (GIV(stackPage)->stackLimit);
	}
	markStackPageMostRecentlyUsed(thePage);
	assert(!(isMachineCodeFrame(GIV(framePointer))));
	/* begin setMethod: */
	assert((((usqInt)(longAt(GIV(framePointer) + FoxMethod)))) >= (startOfMemory()));
	GIV(method) = longAt(GIV(framePointer) + FoxMethod);
	assertValidExecutionPointersimbar(longAt(GIV(framePointer) + FoxIFSavedIP), GIV(framePointer), GIV(stackPointer), 1);
	GIV(instructionPointer) = longAt(GIV(framePointer) + FoxIFSavedIP);
	/* begin push: */
	longAtput(sp = GIV(stackPointer) - BytesPerWord, anOop);
	GIV(stackPointer) = sp;
	siglongjmp(reenterInterpreter, ReturnToInterpreter);
	return null;
}


/*	Send from an Open PIC when the first-level method lookup probe has failed,
	or to continue when PIC creation has failed (e.g. because we're out of
	code space). */
/*	self printFrame: stackPage headFP WithSP: stackPage headSP */
/*	self printStringOf: selector */

sqInt
ceSendFromInLineCacheMiss(CogMethod *oPIC)
{   DECL_MAYBE_SQ_GLOBAL_STRUCT
    sqInt ccIndex;
    sqInt class;
    CogMethod *cogMethod;
    sqInt errSelIdx;
    sqInt methodHeader;
    sqInt numArgs;
    sqInt rcvr;
    sqInt selector;
    sqInt top;

	numArgs = (oPIC->cmNumArgs);

	/* skip return pc */

	rcvr = longAt(GIV(stackPointer) + ((numArgs + 1) * BytesPerWord));
	assert(((rcvr & 1))
	 || (addressCouldBeObj(rcvr)));
	/* begin fetchClassOf: */
	if ((rcvr & 1)) {
		class = longAt((GIV(specialObjectsOop) + BaseHeaderSize) + (ClassInteger << ShiftForWord));
		goto l1;
	}
	if (((ccIndex = (((usqInt) (longAt(rcvr))) >> 12) & 31)) == 0) {
		class = (longAt(rcvr - BaseHeaderSize)) & AllButTypeMask;
		goto l1;
	}
	else {
		class = longAt(((longAt((GIV(specialObjectsOop) + BaseHeaderSize) + (CompactClasses << ShiftForWord))) + BaseHeaderSize) + ((ccIndex - 1) << ShiftForWord));
		goto l1;
	}
l1:	/* end fetchClassOf: */;

	/* We set the messageSelector and lkupClass for executeMethod below since things
	 like the at cache read messageSelectorand lkupClass and so they cannot be left stale. */

	GIV(argumentCount) = numArgs;
	GIV(messageSelector) = (oPIC->selector);
	GIV(lkupClass) = class;
	if (lookupInMethodCacheSelclass((oPIC->selector), class)) {
		/* begin ifAppropriateCompileToNativeCode:selector: */
		selector = (oPIC->selector);
		methodHeader = longAt((GIV(newMethod) + BaseHeaderSize) + (HeaderIndex << ShiftForWord));
		if (isCogMethodReference(methodHeader)) {

			/* makeBaseFrame: can create cog methods with nil selectors. */

			cogMethod = ((CogMethod *) methodHeader);
			if (((cogMethod->selector)) == GIV(nilObj)) {
				setSelectorOfto(cogMethod, selector);
			}
		}
		else {
			if (((((usqInt) methodHeader) >> 10) & 255) <= maxLiteralCountForCompile) {
				cogselector(GIV(newMethod), selector);
			}
			else {
				maybeFlagMethodAsInterpreted(GIV(newMethod));
			}
		}
	}
	else {
		if (((errSelIdx = lookupMethodNoMNUEtcInClass(class))) != 0) {
			handleMNUInMachineCodeToclassForMessagemayLink(errSelIdx, rcvr, class, 0);
			assert(0);
		}
	}
	if (((GIV(newMethod) & 1) == 0)
	 && ((((((usqInt) (longAt(GIV(newMethod)))) >> 8) & 15) >= 12)
 && (isCogMethodReference(longAt((GIV(newMethod) + BaseHeaderSize) + (HeaderIndex << ShiftForWord)))))) {
		/* begin popStack */
		top = longAt(GIV(stackPointer));
		GIV(stackPointer) += BytesPerWord;
		GIV(instructionPointer) = ((sqInt) top);
		executeNewMethod();
		assert(0);
	}
	return activateInterpreterMethodFromMachineCode();
}

sqInt
ceSendMustBeBoolean(sqInt anObject)
{   DECL_MAYBE_SQ_GLOBAL_STRUCT
    char *sp;
    char *sp1;
    sqInt top;

	/* begin popStack */
	top = longAt(GIV(stackPointer));
	GIV(stackPointer) += BytesPerWord;
	GIV(instructionPointer) = ((sqInt) top);
	/* begin push: */
	longAtput(sp = GIV(stackPointer) - BytesPerWord, anObject);
	GIV(stackPointer) = sp;
	/* begin push: */
	longAtput(sp1 = GIV(stackPointer) - BytesPerWord, GIV(instructionPointer));
	GIV(stackPointer) = sp1;
	return ceSendsupertonumArgs(longAt((GIV(specialObjectsOop) + BaseHeaderSize) + (SelectorMustBeBoolean << ShiftForWord)), 0, anObject, 0 - 1);
}


/*	<Integer> */
/*	<Integer> */
/*	<Integer> */
/*	Entry-point for an unlinked send in a CogMethod, or, if numArgs < 0, a
	send of
	a return escape case (cannotReturn:, aboutToReturn:through:,
	mustBeBoolean) in machine-code. Smalltalk stack looks like
	receiver
	args
	head sp ->	sender return pc
	
	If a return escape then simply try and dispatch the send, but the send may
	turn into an MNU.
	If a normal send then try and link the send site as efficiently as
	possible. 
	If an MNU then defer to handleMNUInMachineCodeTo:... which will dispatch
	the MNU and
	may choose to allocate a closed PIC with a fast MNU dispatch for this
	send. 
	If not an MNU and the receiver's class is old then try to link to the
	target method.
	If not an MNU but the receiver's class is young then try and link to an
	Open PIC for
	this selector. All link attempts may fail; e.g. because we're out of code
	memory. 
	Continue execution via either
	executeCogMethodFromUnlinkedSend:withReceiver: or
	activateInterpreterMethodFromMachineCode: depending on whether the target
	method is cogged or not. Note it seems we can use executeNewMethod instead
	of 
	executeCogMethodFromUnlinkedSend:withReceiver: */

sqInt
ceSendsupertonumArgs(sqInt selector, sqInt superNormalBar, sqInt rcvr, sqInt numArgs)
{   DECL_MAYBE_SQ_GLOBAL_STRUCT
    sqInt canLinkCacheTag;
    sqInt ccIndex;
    sqInt class;
    sqInt classPointer;
    CogMethod *cogMethod;
    CogMethod *cogMethod1;
    sqInt errSelIdx;
    sqInt mayLink;
    sqInt methodHeader;
    sqInt methodHeader1;
    sqInt methodPointer;
    sqInt offset;
    sqInt oop;
    sqInt top;

	assertCStackWellAligned();
	assert(((rcvr & 1))
	 || (addressCouldBeObj(rcvr)));
	sendBreakpointreceiver(selector + BaseHeaderSize, lengthOf(selector), rcvr);
	if (superNormalBar == 0) {
		/* begin fetchClassOf: */
		if ((rcvr & 1)) {
			class = longAt((GIV(specialObjectsOop) + BaseHeaderSize) + (ClassInteger << ShiftForWord));
			goto l1;
		}
		if (((ccIndex = (((usqInt) (longAt(rcvr))) >> 12) & 31)) == 0) {
			class = (longAt(rcvr - BaseHeaderSize)) & AllButTypeMask;
			goto l1;
		}
		else {
			class = longAt(((longAt((GIV(specialObjectsOop) + BaseHeaderSize) + (CompactClasses << ShiftForWord))) + BaseHeaderSize) + ((ccIndex - 1) << ShiftForWord));
			goto l1;
		}
	l1:	/* end fetchClassOf: */;
	}
	else {
		/* begin superclassOf: */
		/* begin methodClassOf: */
		methodPointer = ((((usqInt)(longAt(GIV(framePointer) + FoxMethod)))) < heapBase
			? (mframeHomeMethod(GIV(framePointer))->methodObject)
			: longAt(GIV(framePointer) + FoxMethod));
		/* begin fetchPointer:ofObject: */
		/* begin literal:ofMethod: */
		offset = (literalCountOf(methodPointer)) - 1;
		oop = longAt((methodPointer + BaseHeaderSize) + ((offset + LiteralStart) << ShiftForWord));
		classPointer = longAt((oop + BaseHeaderSize) + (ValueIndex << ShiftForWord));
		class = longAt((classPointer + BaseHeaderSize) + (SuperclassIndex << ShiftForWord));
	}
	if (numArgs >= 0) {
		mayLink = GIV(linkSends);
		canLinkCacheTag = (!((((usqInt) class)) >= (((usqInt) GIV(youngStart)))))
		 || (canLinkToYoungClasses());
		GIV(argumentCount) = numArgs;
	}
	else {

		/* This is a cannotReturn:, nonLocalreturn:through: or mustBeBoolean send.  Must not link. */

		mayLink = 0;
		GIV(argumentCount) = -1 - numArgs;
	}
	GIV(messageSelector) = selector;
	GIV(lkupClass) = class;
	if (lookupInMethodCacheSelclass(selector, class)) {
		/* begin ifAppropriateCompileToNativeCode:selector: */
		methodHeader = longAt((GIV(newMethod) + BaseHeaderSize) + (HeaderIndex << ShiftForWord));
		if (isCogMethodReference(methodHeader)) {

			/* makeBaseFrame: can create cog methods with nil selectors. */

			cogMethod1 = ((CogMethod *) methodHeader);
			if (((cogMethod1->selector)) == GIV(nilObj)) {
				setSelectorOfto(cogMethod1, selector);
			}
		}
		else {
			if (((((usqInt) methodHeader) >> 10) & 255) <= maxLiteralCountForCompile) {
				cogselector(GIV(newMethod), selector);
			}
			else {
				maybeFlagMethodAsInterpreted(GIV(newMethod));
			}
		}
	}
	else {
		if (((errSelIdx = lookupMethodNoMNUEtcInClass(class))) != 0) {
			handleMNUInMachineCodeToclassForMessagemayLink(errSelIdx, rcvr, class, mayLink
			 && (canLinkCacheTag));
			assert(0);
		}
	}
	if (((GIV(newMethod) & 1) == 0)
	 && ((((((usqInt) (longAt(GIV(newMethod)))) >> 8) & 15) >= 12)
 && (isCogMethodReference(longAt((GIV(newMethod) + BaseHeaderSize) + (HeaderIndex << ShiftForWord)))))) {
		if (mayLink) {
			/* begin cogMethodOf: */
			methodHeader1 = longAt((GIV(newMethod) + BaseHeaderSize) + (HeaderIndex << ShiftForWord));
			assert((isNonIntegerObject(methodHeader1))
			 && ((((usqInt)methodHeader1)) < (startOfMemory())));
			cogMethod = ((CogMethod *) methodHeader1);
			if (((cogMethod->selector)) == GIV(nilObj)) {
				setSelectorOfto(cogMethod, selector);
			}
			if (canLinkCacheTag) {
				linkSendAtintocheckedreceiver(longAt(GIV(stackPointer)), mframeHomeMethod(GIV(framePointer)), cogMethod, superNormalBar == 0, rcvr);
			}
			else {
				patchToOpenPICFornumArgsreceiver(selector, numArgs, rcvr);
			}
		}
		/* begin popStack */
		top = longAt(GIV(stackPointer));
		GIV(stackPointer) += BytesPerWord;
		GIV(instructionPointer) = ((sqInt) top);
		executeNewMethod();
		assert(0);
	}
	return activateInterpreterMethodFromMachineCode();
}


/*	If contextSwitchIfNotNil is nil we can't context switch.
	contextSwitchIfNotNil is set to nil by
	- the special primitiveClosureValueNoContextSwitch entry-point in block
	dispatch - the stack check in methods with primitive 198.
	In a normal method contextSwitchIfNotNil will be the method (see e.g.
	SimpleStackBasedCogit>>compileFrameBuild). In a block it will be the
	closure (see e.g. SimpleStackBasedCogit>>compileMethodBody). */

void
ceStackOverflow(sqInt contextSwitchIfNotNil)
{   DECL_MAYBE_SQ_GLOBAL_STRUCT
    sqInt aMethodObj;
    sqInt cesoRetAddr;
    CogBlockMethod *cogMethod;
    sqInt switched;
    sqInt top;

	/* begin popStack */
	top = longAt(GIV(stackPointer));
	GIV(stackPointer) += BytesPerWord;
	cesoRetAddr = top;
	/* begin mframeCogMethod: */
	cogMethod = ((CogBlockMethod *) ((longAt(GIV(framePointer) + FoxMethod)) & MFMethodMask));
	assert((cesoRetAddr - (abortOffset())) == (((sqInt)(asCogHomeMethod(cogMethod)))));
	GIV(instructionPointer) = (((sqInt)cogMethod)) + ((cogMethod->stackCheckOffset));
	assertValidExecutionPointersimbar(GIV(instructionPointer), GIV(framePointer), GIV(stackPointer), 0);
	/* begin setMethod: */
	aMethodObj = GIV(newMethod) = GIV(messageSelector) = GIV(lkupClass) = GIV(nilObj);
	assert((((usqInt)aMethodObj)) >= (startOfMemory()));
	GIV(method) = aMethodObj;
	switched = handleStackOverflowOrEventAllowContextSwitch(contextSwitchIfNotNil != 0);
	returnToExecutivepostContextSwitch(0, switched);
	error("should not be reached");
}


/*	Do the store check. Answer the argument for the benefit of the code
	generator; ReceiverResultReg may be caller-saved and hence smashed by this
	call. Answering
	it allows the code generator to reload ReceiverResultReg cheaply. */

sqInt
ceStoreCheck(sqInt anOop)
{   DECL_MAYBE_SQ_GLOBAL_STRUCT
    sqInt header;

	assert(isNonIntegerObject(anOop));
	assert(oopisLessThan(anOop, youngStart()));
	assert(((baseHeader(anOop)) & RootBit) == 0);
	/* begin noteAsRoot:headerLoc: */
	header = longAt(anOop);
	if ((header & RootBit) == 0) {
		if (GIV(rootTableCount) < RootTableSize) {

			/* record oop as root only if not already recorded */
			/* record root if there is enough room in the roots  table  */

			GIV(rootTableCount) += 1;
			GIV(rootTable)[GIV(rootTableCount)] = anOop;
			longAtput(anOop, header | RootBit);
			if (GIV(rootTableCount) > RootTableRedZone) {
				/* begin scheduleIncrementalGC */
				GIV(needGCFlag) = 1;
				forceInterruptCheck();
			}
		}
	}
	return anOop;
}

void
ceTraceBlockActivation(void)
{   DECL_MAYBE_SQ_GLOBAL_STRUCT
    sqInt selector;

	if (recordSendTrace()) {
		/* begin recordTrace:thing:source: */
		selector = (mframeHomeMethod(GIV(framePointer))->methodObject);
		GIV(traceLog)[GIV(traceLogIndex)] = TraceBlockActivation;
		GIV(traceLog)[GIV(traceLogIndex) + 1] = selector;
		GIV(traceLog)[GIV(traceLogIndex) + 2] = TraceIsFromMachineCode;
		GIV(traceLogIndex) = (GIV(traceLogIndex) + 3) % TraceBufferSize;
	}
	if (printOnTrace()) {
		printActivationNameForreceiverisBlockfirstTemporary((mframeHomeMethod(GIV(framePointer))->methodObject), ((((usqInt)(longAt(GIV(framePointer) + FoxMethod)))) < heapBase
			? longAt(GIV(framePointer) + FoxMFReceiver)
			: longAt(GIV(framePointer) + FoxIFReceiver)), 1, null);
		/* begin cr */
		printf("\n");
	}
}

void
ceTraceLinkedSend(sqInt theReceiver)
{   DECL_MAYBE_SQ_GLOBAL_STRUCT
    sqInt ccIndex;
    sqInt classOrInteger;
    CogMethod *cogMethod;
    sqInt selector;

	cogMethod = ((CogMethod *) ((longAt(GIV(stackPointer))) - (traceLinkedSendOffset())));
	if (recordSendTrace()) {
		/* begin recordTrace:thing:source: */
		/* begin fetchClassOf: */
		if ((theReceiver & 1)) {
			classOrInteger = longAt((GIV(specialObjectsOop) + BaseHeaderSize) + (ClassInteger << ShiftForWord));
			goto l1;
		}
		if (((ccIndex = (((usqInt) (longAt(theReceiver))) >> 12) & 31)) == 0) {
			classOrInteger = (longAt(theReceiver - BaseHeaderSize)) & AllButTypeMask;
			goto l1;
		}
		else {
			classOrInteger = longAt(((longAt((GIV(specialObjectsOop) + BaseHeaderSize) + (CompactClasses << ShiftForWord))) + BaseHeaderSize) + ((ccIndex - 1) << ShiftForWord));
			goto l1;
		}
	l1:	/* end fetchClassOf: */;
		selector = (cogMethod->selector);
		GIV(traceLog)[GIV(traceLogIndex)] = classOrInteger;
		GIV(traceLog)[GIV(traceLogIndex) + 1] = selector;
		GIV(traceLog)[GIV(traceLogIndex) + 2] = TraceIsFromMachineCode;
		GIV(traceLogIndex) = (GIV(traceLogIndex) + 3) % TraceBufferSize;
	}
	if (printOnTrace()) {
		printActivationNameForreceiverisBlockfirstTemporary((cogMethod->methodObject), theReceiver, 0, null);
		/* begin cr */
		printf("\n");
	}
	sendBreakpointreceiver(((cogMethod->selector)) + BaseHeaderSize, lengthOf((cogMethod->selector)), theReceiver);
}


/*	For assertion checking. */

void
ceTraceStoreOfinto(sqInt aValue, sqInt anObject)
{
	assert(((aValue & 1))
	 || (addressCouldBeObj(aValue)));
	assert(addressCouldBeObj(anObject));
}


/*	Arg must lie in range 0-255! */

sqInt
characterForAscii(sqInt ascii)
{
	return longAt(((longAt((GIV(specialObjectsOop) + BaseHeaderSize) + (CharacterTable << ShiftForWord))) + BaseHeaderSize) + (ascii << ShiftForWord));
}

sqInt
characterTable(void)
{
	return longAt((GIV(specialObjectsOop) + BaseHeaderSize) + (CharacterTable << ShiftForWord));
}

void
checkAssertsEnabledInCoInterpreter(void)
{
    sqInt assertsAreEnabledInCoInterpreter;

	assertsAreEnabledInCoInterpreter = 0;
	assert(assertsAreEnabledInCoInterpreter);
}


/*	Perform an integrity/leak check using the heapMap. Assume
	clearLeakMapAndMapAccessibleObjects has set a bit at each
	object's header. Check that all object references in machine
	code are valid. Answer if all checks pass. */

static sqInt
checkCodeIntegrity(sqInt fullGCFlag)
{
	return checkIntegrityOfObjectReferencesInCode(fullGCFlag);
}


/*	Check for a hit of the longRunningPrimitive probe and if so attempt to
	signal the
	longRunningPrimitiveCheckSemaphore. Answer if a process switch occurred as
	a result. */

static sqInt
checkDeliveryOfLongRunningPrimitiveSignal(void)
{   DECL_MAYBE_SQ_GLOBAL_STRUCT
	if ((GIV(longRunningPrimitiveStopUsecs) > GIV(longRunningPrimitiveStartUsecs))
	 && ((GIV(longRunningPrimitiveCheckSemaphore) != null)
 && (GIV(longRunningPrimitiveSignalUndelivered)))) {

		/* but not yet delivered */

		GIV(longRunningPrimitiveSignalUndelivered) = 0;

		/* Signal the LRP check semaphore if it is present */

		GIV(longRunningPrimitiveGCUsecs) = ((GIV(gcStartUsecs) < GIV(longRunningPrimitiveStopUsecs))
		 && (GIV(statGCEndUsecs) > GIV(longRunningPrimitiveStartUsecs))
			? GIV(statGCEndUsecs) - GIV(gcStartUsecs)
			: 0);
		return synchronousSignal(GIV(longRunningPrimitiveCheckSemaphore));
	}
	return 0;
}


/*	Note: May be called by translated primitive code. */

sqInt
checkedIntegerValueOf(sqInt intOop)
{   DECL_MAYBE_SQ_GLOBAL_STRUCT
	if ((intOop & 1)) {
		return (intOop >> 1);
	}
	else {
		/* begin primitiveFail */
		if (GIV(primFailCode) == 0) {
			GIV(primFailCode) = 1;
		}
		return 0;
	}
}


/*	Assumes zero-based array indexing. For testing in Smalltalk, this method
	should be overridden in a subclass.
 */

sqInt
checkedLongAt(sqInt byteAddress)
{   DECL_MAYBE_SQ_GLOBAL_STRUCT
	/* begin checkAddress: */
	if ((((usqInt) byteAddress)) < (((usqInt) heapBase))) {
		error("bad address: negative");
	}
	if ((((usqInt) byteAddress)) >= (((usqInt) GIV(memoryLimit)))) {
		error("bad address: past end of heap");
	}
	/* begin checkAddress: */
	if ((((usqInt) (byteAddress + 3))) < (((usqInt) heapBase))) {
		error("bad address: negative");
	}
	if ((((usqInt) (byteAddress + 3))) >= (((usqInt) GIV(memoryLimit)))) {
		error("bad address: past end of heap");
	}
	return longAt(byteAddress);
}


/*	Check for possible interrupts and handle one if necessary.
	Answer if a context switch has occurred. */

static sqInt
checkForEventsMayContextSwitch(sqInt mayContextSwitch)
{   DECL_MAYBE_SQ_GLOBAL_STRUCT
    usqLong now;
    sqInt sema;
    sqInt switched;


	/* restore the stackLimit if it has been smashed. */

	GIV(statCheckForEvents) += 1;
	/* begin restoreStackLimit */
	(GIV(stackPage)->stackLimit = (GIV(stackPage)->realStackLimit));
	GIV(stackLimit) = (GIV(stackPage)->stackLimit);
	/* begin externalWriteBackHeadFramePointers */
	assert((GIV(framePointer) - GIV(stackPointer)) < LargeContextSize);
	assert(GIV(stackPage) == (mostRecentlyUsedPage()));
	/* begin setHeadFP:andSP:inPage: */
	assert(GIV(stackPointer) < GIV(framePointer));
	assert((GIV(stackPointer) < ((GIV(stackPage)->baseAddress)))
	 && (GIV(stackPointer) > (((GIV(stackPage)->realStackLimit)) - LargeContextSize)));
	assert((GIV(framePointer) < ((GIV(stackPage)->baseAddress)))
	 && (GIV(framePointer) > (((GIV(stackPage)->realStackLimit)) - (((sqInt) LargeContextSize >> 1)))));
	(GIV(stackPage)->headFP = GIV(framePointer));
	(GIV(stackPage)->headSP = GIV(stackPointer));
	assert(pageListIsWellFormed());
	assert(GIV(stackPage) == (mostRecentlyUsedPage()));
	ioSynchronousCheckForEvents();
	/* begin checkCogCompiledCodeCompactionCalledFor */
	if (GIV(cogCompiledCodeCompactionCalledFor)) {
		commenceCogCompiledCodeCompaction();
	}
	if (GIV(needGCFlag)) {
		GIV(needGCFlag) = 0;
		if (!(sufficientSpaceAfterGC(0))) {
			setSignalLowSpaceFlagAndSaveProcess();
		}
	}
	if (!(mayContextSwitch)) {
		return 0;
	}
	switched = 0;
	if ((GIV(profileProcess) != GIV(nilObj))
	 || ((GIV(nextProfileTick) > 0)
 && ((ioHighResClock()) >= GIV(nextProfileTick)))) {
		if (GIV(profileProcess) == GIV(nilObj)) {

			/* Take a sample (if not already done so) for the profiler if it is active.  This
		  must be done before any of the synchronousSignals below or else we will
		  attribute a pause in ioRelinquishProcessor to the newly activated process. */

			GIV(profileProcess) = longAt(((longAt(((longAt((GIV(specialObjectsOop) + BaseHeaderSize) + (SchedulerAssociation << ShiftForWord))) + BaseHeaderSize) + (ValueIndex << ShiftForWord))) + BaseHeaderSize) + (ActiveProcessIndex << ShiftForWord));
			GIV(profileMethod) = GIV(nilObj);
		}
		if ((GIV(profileSemaphore) != GIV(nilObj))
		 && (synchronousSignal(GIV(profileSemaphore)))) {
			switched = 1;
		}
		GIV(nextProfileTick) = 0;
	}
	if (checkDeliveryOfLongRunningPrimitiveSignal()) {
		switched = 1;
	}
	if (GIV(signalLowSpace)) {
		GIV(signalLowSpace) = 0;
		sema = longAt((GIV(specialObjectsOop) + BaseHeaderSize) + (TheLowSpaceSemaphore << ShiftForWord));
		if ((sema != GIV(nilObj))
		 && (synchronousSignal(sema))) {
			switched = 1;
		}
	}
	if ((((now = ioUTCMicroseconds())) >= GIV(nextPollUsecs))
	 && (inIOProcessEvents == 0)) {
		GIV(statIOProcessEvents) += 1;
		inIOProcessEvents += 1;
		ioProcessEvents();
		if (inIOProcessEvents > 0) {
			inIOProcessEvents -= 1;
		}

		/* msecs to wait before next call to ioProcessEvents.  Note that strictly
		  speaking we might need to update 'now' at this point since
		  ioProcessEvents could take a very long time on some platforms */

		GIV(nextPollUsecs) = now + 20000;
	}
	if (GIV(interruptPending)) {

		/* reset interrupt flag */

		GIV(interruptPending) = 0;
		sema = longAt((GIV(specialObjectsOop) + BaseHeaderSize) + (TheInterruptSemaphore << ShiftForWord));
		if ((sema != GIV(nilObj))
		 && (synchronousSignal(sema))) {
			switched = 1;
		}
	}
	if (GIV(nextWakeupUsecs) != 0) {
		if (now >= GIV(nextWakeupUsecs)) {

			/* set timer interrupt to 0 for 'no timer' */

			GIV(nextWakeupUsecs) = 0;
			sema = longAt((GIV(specialObjectsOop) + BaseHeaderSize) + (TheTimerSemaphore << ShiftForWord));
			if ((sema != GIV(nilObj))
			 && (synchronousSignal(sema))) {
				switched = 1;
			}
		}
	}
	if (GIV(pendingFinalizationSignals) > 0) {
		sema = longAt((GIV(specialObjectsOop) + BaseHeaderSize) + (TheFinalizationSemaphore << ShiftForWord));
		if ((isClassOfNonImmequalTo(sema, longAt((GIV(specialObjectsOop) + BaseHeaderSize) + (ClassSemaphore << ShiftForWord))))
		 && (synchronousSignal(sema))) {
			switched = 1;
		}
		GIV(pendingFinalizationSignals) = 0;
	}
	if (signalExternalSemaphores()) {
		switched = 1;
	}
	return switched;
}


/*	Perform an integrity/leak check using the heapMap. Assume
	clearLeakMapAndMapAccessibleObjects has set a bit at each
	object's header. Scan all objects in the heap checking that every
	pointer points to a header. Scan the rootTable, remapBuffer and
	extraRootTable checking that every entry is a pointer to a header.
	Check that the number of roots is correct and that all rootTable
	entries have their rootBit set. Answer if all checks pass. */

static sqInt
checkHeapIntegrity(void)
{   DECL_MAYBE_SQ_GLOBAL_STRUCT
    sqInt fi;
    sqInt fieldOop;
    sqInt fmt;
    sqInt hdr;
    sqInt header;
    sqInt header1;
    sqInt numRootsInHeap;
    sqInt obj;
    sqInt ok;
    sqInt ri;
    sqInt sz;
    sqInt sz1;

	ok = 1;
	numRootsInHeap = 0;
	obj = heapBase + (headerTypeBytes[(longAt(heapBase)) & TypeMask]);
	while ((((usqInt) obj)) < (((usqInt) GIV(freeStart)))) {
		if (((longAt(obj)) & TypeMask) == HeaderTypeFree) {
			sz = (longAt(obj)) & AllButTypeMask;
		}
		else {
			hdr = longAt(obj);
			if ((hdr & RootBit) != 0) {
				numRootsInHeap += 1;
			}
			if (((((usqInt) hdr) >> 12) & 31) == 0) {
				fieldOop = (longAt(obj - BaseHeaderSize)) & AllButTypeMask;
				if (((fieldOop & 1))
				 || ((heapMapAtWord(pointerForOop(fieldOop))) == 0)) {
					print("object leak in ");
					printHex(obj);
					print(" class ");
					printHex(fieldOop);
					/* begin cr */
					printf("\n");
					ok = 0;
				}
			}
			fmt = (((usqInt) hdr) >> 8) & 15;
			if ((fmt <= 4)
			 || (fmt >= 12)) {
				if (fmt >= 12) {

					/* + 1 = methodHeader slot */

					fi = (literalCountOfHeader(headerOf(obj))) + 1;
				}
				else {
					if ((fmt == 3)
					 && (((((usqInt) hdr) >> 12) & 31) == ClassMethodContextCompactIndex)) {
						fi = CtxtTempFrameStart + (fetchStackPointerOf(obj));
					}
					else {
						/* begin lengthOf: */
						header = longAt(obj);
						/* begin lengthOf:baseHeader:format: */
						if ((header & TypeMask) == HeaderTypeSizeAndClass) {
							sz1 = (longAt(obj - (BytesPerWord * 2))) & LongSizeMask;
						}
						else {
							sz1 = header & SizeMask;
						}
						sz1 -= header & Size4Bit;
						if (((((usqInt) header) >> 8) & 15) <= 4) {
							fi = ((usqInt) (sz1 - BaseHeaderSize)) >> ShiftForWord;
							goto l1;
						}
						if (((((usqInt) header) >> 8) & 15) < 8) {
							fi = ((usqInt) (sz1 - BaseHeaderSize)) >> 2;
							goto l1;
						}
						else {
							fi = (sz1 - BaseHeaderSize) - (((((usqInt) header) >> 8) & 15) & 3);
							goto l1;
						}
					l1:	/* end lengthOf: */;
					}
				}
				while (((fi -= 1)) >= 0) {
					fieldOop = longAt((obj + BaseHeaderSize) + (fi << ShiftForWord));
					if ((fieldOop & 1) == 0) {
						if ((fieldOop & (BytesPerWord - 1)) != 0) {
							print("misaligned oop in ");
							printHex(obj);
							print(" @ ");
							printNum(fi);
							print(" = ");
							printHex(fieldOop);
							/* begin cr */
							printf("\n");
							ok = 0;
						}
						else {
							if ((heapMapAtWord(pointerForOop(fieldOop))) == 0) {
								print("object leak in ");
								printHex(obj);
								print(" @ ");
								printNum(fi);
								/* begin cr */
								printf("\n");
								ok = 0;
							}
						}
					}
				}
			}
			/* begin sizeBitsOf: */
			header1 = longAt(obj);
			sz = ((header1 & TypeMask) == HeaderTypeSizeAndClass
				? (longAt(obj - (BytesPerWord * 2))) & LongSizeMask
				: header1 & SizeMask);
		}
		obj = (obj + sz) + (headerTypeBytes[(longAt(obj + sz)) & TypeMask]);
	}
	if (numRootsInHeap != GIV(rootTableCount)) {
		print("root count mismatch. #heap roots ");
		printNum(numRootsInHeap);
		print("; #roots ");
		printNum(GIV(rootTableCount));
		/* begin cr */
		printf("\n");
		ok = 0;
	}
	for (ri = 1; ri <= GIV(rootTableCount); ri += 1) {
		obj = GIV(rootTable)[ri];
		if ((obj & (BytesPerWord - 1)) != 0) {
			print("misaligned oop in rootTable @ ");
			printNum(ri);
			print(" = ");
			printHex(obj);
			/* begin cr */
			printf("\n");
			ok = 0;
		}
		else {
			if ((heapMapAtWord(pointerForOop(obj))) == 0) {
				print("object leak in rootTable @ ");
				printNum(ri);
				print(" = ");
				printHex(obj);
				/* begin cr */
				printf("\n");
				ok = 0;
			}
			else {
				hdr = longAt(obj);
				if ((hdr & RootBit) == 0) {
					print("non-root in rootTable @ ");
					printNum(ri);
					print(" = ");
					printHex(obj);
					/* begin cr */
					printf("\n");
					ok = 0;
				}
			}
		}
	}
	for (ri = 1; ri <= GIV(remapBufferCount); ri += 1) {
		obj = GIV(remapBuffer)[ri];
		if ((obj & (BytesPerWord - 1)) != 0) {
			print("misaligned remapRoot @ ");
			printNum(ri);
			print(" = ");
			printHex(obj);
			/* begin cr */
			printf("\n");
			ok = 0;
		}
		else {
			if ((heapMapAtWord(pointerForOop(obj))) == 0) {
				print("object leak in remapRoots @ ");
				printNum(ri);
				print(" = ");
				printHex(obj);
				/* begin cr */
				printf("\n");
				ok = 0;
			}
		}
	}
	for (ri = 1; ri <= GIV(extraRootCount); ri += 1) {
		obj = (GIV(extraRoots)[ri])[0];
		if ((obj & (BytesPerWord - 1)) != 0) {
			print("misaligned extraRoot @ ");
			printNum(ri);
			print(" => ");
			printHex(obj);
			/* begin cr */
			printf("\n");
			ok = 0;
		}
		else {
			if ((heapMapAtWord(pointerForOop(obj))) == 0) {
				print("object leak in extraRoots @ ");
				printNum(ri);
				print(" => ");
				printHex(obj);
				/* begin cr */
				printf("\n");
				ok = 0;
			}
		}
	}
	return ok;
}


/*	Perform an integrity/leak check using the heapMap. Assume
	clearLeakMapAndMapAccessibleObjects has set a bit at each
	object's header. Check that all oops in the interpreter's state
	points to a header. Answer if all checks pass. */

static sqInt
checkInterpreterIntegrity(void)
{   DECL_MAYBE_SQ_GLOBAL_STRUCT
    sqInt i;
    sqInt ok;

	ok = 1;
	if (!(checkOopIntegritynamed(GIV(specialObjectsOop), "specialObjectsOop"))) {
		ok = 0;
	}
	if (!((GIV(messageSelector) & 1))) {
		if (!(checkOopIntegritynamed(GIV(messageSelector), "messageSelector"))) {
			ok = 0;
		}
	}
	if (!(checkOopIntegritynamed(GIV(newMethod), "newMethod"))) {
		ok = 0;
	}
	if (!(checkOopIntegritynamed(GIV(lkupClass), "lkupClass"))) {
		ok = 0;
	}
	if (!(checkOopIntegritynamed(GIV(profileProcess), "profileProcess"))) {
		ok = 0;
	}
	if (!(checkOopIntegritynamed(GIV(profileMethod), "profileMethod"))) {
		ok = 0;
	}
	if (!(checkOopIntegritynamed(GIV(profileSemaphore), "profileSemaphore"))) {
		ok = 0;
	}
	if (!(GIV(tempOop) == 0)) {
		if (!(checkOopIntegritynamed(GIV(tempOop), "tempOop"))) {
			ok = 0;
		}
	}
	for (i = 1; i <= GIV(jmpDepth); i += 1) {
		if (!(checkOopIntegritynamedindex(GIV(suspendedCallbacks)[i], "suspendedCallbacks", i))) {
			ok = 0;
		}
		if (!(checkOopIntegritynamedindex(GIV(suspendedMethods)[i], "suspendedMethods", i))) {
			ok = 0;
		}
	}
	if (!(checkLogIntegrity())) {
		ok = 0;
	}
	return ok;
}


/*	Another version of isWidowedContext:currentFP: for debugging.
	This will not bereave a widowed context. */

static sqInt
checkIsStillMarriedContextcurrentFP(sqInt aContext, char *currentFP)
{   DECL_MAYBE_SQ_GLOBAL_STRUCT
    sqInt index;
    char *limitFP;
    char *theFP;
    StackPage *thePage;
    sqInt value;

	if (!(((longAt((aContext + BaseHeaderSize) + (SenderIndex << ShiftForWord))) & 1))) {
		return 0;
	}
	/* begin frameOfMarriedContext: */
	value = longAt((aContext + BaseHeaderSize) + (SenderIndex << ShiftForWord));
	/* begin withoutSmallIntegerTags: */
	assert((value & 1));
	theFP = pointerForOop(value - 1);
	/* begin stackPageFor: */
	/* begin stackPageAt: */
	/* begin pageIndexFor: */
	assert((((((char *) theFP)) >= (GIV(stackBasePlus1) - 1)) && ((((char *) theFP)) <= (((char *) GIV(pages))))));
	index = pageIndexForstackBasePlus1bytesPerPage(theFP, GIV(stackBasePlus1), GIV(bytesPerPage));
	thePage = stackPageAtpages(index, GIV(pages));
	limitFP = ((thePage == GIV(stackPage))
	 && (currentFP != null)
		? currentFP
		: (thePage->headFP));
	return (theFP >= limitFP)
	 && ((isNonIntegerObject(((sqInt)(frameCallerFP(theFP)))))
 && (((withSmallIntegerTags(frameCallerFP(theFP))) == (longAt((aContext + BaseHeaderSize) + (InstructionPointerIndex << ShiftForWord))))
 && (((((((usqInt)(longAt(theFP + FoxMethod)))) < heapBase
	? (mframeHomeMethod(theFP)->methodObject)
	: longAt(theFP + FoxMethod))) == (longAt((aContext + BaseHeaderSize) + (MethodIndex << ShiftForWord))))
 && ((((((usqInt)(longAt(theFP + FoxMethod)))) < heapBase
	? ((longAt(theFP + FoxMethod)) & MFMethodFlagHasContextFlag) != 0
	: (byteAt((theFP + FoxIFrameFlags) + 2)) != 0))
 && (((longAt(theFP + FoxThisContext)) == aContext)
 && (((aContext & 1) == 0)
 && (((((usqInt) (longAt(aContext))) >> 12) & 31) == ClassMethodContextCompactIndex)))))));
}


/*	Check the log for leaks. The trace log is a circular buffer of pairs of
	entries. If there is an entry at traceLogIndex - 3 \\ TraceBufferSize it
	has entries. If
	there is something at traceLogIndex it has wrapped. */

static sqInt
checkLogIntegrity(void)
{   DECL_MAYBE_SQ_GLOBAL_STRUCT
    sqInt i;
    sqInt limit;
    sqInt ok;
    sqInt oop;
    sqInt remainder;

	limit = (((remainder = (GIV(traceLogIndex) - 3) % TraceBufferSize)) < 0
		? remainder + TraceBufferSize
		: remainder);
	if ((GIV(traceLog)[limit]) == 0) {
		return 1;
	}
	if ((GIV(traceLog)[GIV(traceLogIndex)]) != 0) {
		limit = TraceBufferSize - 3;
	}
	ok = 1;
	for (i = 0; i <= limit; i += 3) {
		oop = GIV(traceLog)[i];
		if (!((oop & 1))) {
			if (!(checkOopIntegritynamedindex(oop, "traceLog", i))) {
				ok = 0;
			}
		}
		oop = GIV(traceLog)[i + 1];
		if (!((oop & 1))) {
			if (!(checkOopIntegritynamedindex(oop, "traceLog", i + 1))) {
				ok = 0;
			}
		}
	}
	return ok;
}

static sqInt
checkOopIntegritynamed(sqInt obj, char *name)
{
	if ((heapMapAtWord(pointerForOop(obj))) != 0) {
		return 1;
	}
	print(name);
	print(" leak ");
	printHex(obj);
	/* begin cr */
	printf("\n");
	return 0;
}

static sqInt
checkOopIntegritynamedindex(sqInt obj, char *name, sqInt i)
{
	if ((heapMapAtWord(pointerForOop(obj))) != 0) {
		return 1;
	}
	print(name);
	print(" leak @ ");
	printNum(i);
	print(" = ");
	printHex(obj);
	/* begin cr */
	printf("\n");
	return 0;
}


/*	Check if the profile timer has expired and if so take a sample.
	If the primitive has failed sample the profileMethod as nil. */

static void
checkProfileTick(sqInt aPrimitiveMethod)
{   DECL_MAYBE_SQ_GLOBAL_STRUCT
	assert(GIV(nextProfileTick) != 0);
	if ((ioHighResClock()) >= GIV(nextProfileTick)) {
		GIV(profileProcess) = longAt(((longAt(((longAt((GIV(specialObjectsOop) + BaseHeaderSize) + (SchedulerAssociation << ShiftForWord))) + BaseHeaderSize) + (ValueIndex << ShiftForWord))) + BaseHeaderSize) + (ActiveProcessIndex << ShiftForWord));
		GIV(profileMethod) = (GIV(primFailCode) == 0
			? aPrimitiveMethod
			: GIV(nilObj));
		forceInterruptCheck();
		GIV(nextProfileTick) = 0;
	}
}


/*	Perform an integrity/leak check using the heapMap. Assume
	clearLeakMapAndMapAccesibleObjects has set a bit at each
	object's header. Scan all objects accessible from the stack
	checking that every pointer points to a header. Answer if no
	dangling pointers were detected. */

static sqInt
checkStackIntegrity(void)
{   DECL_MAYBE_SQ_GLOBAL_STRUCT
    char *callerFP;
    CogMethod *cogMethod;
    char *frameRcvrOffset;
    sqInt i;
    sqInt methodField;
    sqInt ok;
    sqInt oop;
    char *theFP;
    StackPage *thePage;
    char *theSP;

	ok = 1;
	for (i = 0; i <= (GIV(numStackPages) - 1); i += 1) {
		/* begin stackPageAt: */
		thePage = stackPageAtpages(i, GIV(pages));
		if (!(isFree(thePage))) {
			if (thePage == GIV(stackPage)) {
				theSP = GIV(stackPointer);
				theFP = GIV(framePointer);
			}
			else {
				theSP = (thePage->headSP);
				theFP = (thePage->headFP);
			}
			if (!(thePage == GIV(stackPage))) {
				theSP += BytesPerWord;
			}
					while (1) {
				frameRcvrOffset = ((((usqInt)(longAt(theFP + FoxMethod)))) < heapBase
					? theFP + FoxMFReceiver
					: theFP + FoxIFReceiver);
				while (theSP <= frameRcvrOffset) {
					oop = longAt(theSP);
					if (((oop & 1) == 0)
					 && ((heapMapAtWord(pointerForOop(oop))) == 0)) {
						printFrameThingat("object leak in frame temp", theSP);
						/* begin cr */
						printf("\n");
						ok = 0;
					}
					theSP += BytesPerWord;
				}
				if (((((usqInt)(longAt(theFP + FoxMethod)))) < heapBase
					? ((longAt(theFP + FoxMethod)) & MFMethodFlagHasContextFlag) != 0
					: (byteAt((theFP + FoxIFrameFlags) + 2)) != 0)) {
					oop = longAt(theFP + FoxThisContext);
					if (((oop & 1))
					 || ((heapMapAtWord(pointerForOop(oop))) == 0)) {
						printFrameThingat("object leak in frame ctxt", theFP + FoxThisContext);
						/* begin cr */
						printf("\n");
						ok = 0;
					}
					if (!((oop == GIV(nilObj))
						 || (((oop & 1) == 0)
 && (((((usqInt) (longAt(oop))) >> 12) & 31) == ClassMethodContextCompactIndex)))) {
						printFrameThingat("frame ctxt should be context", theFP + FoxThisContext);
						/* begin cr */
						printf("\n");
						ok = 0;
					}
				}
				if ((((usqInt)(longAt(theFP + FoxMethod)))) < heapBase) {
					/* begin mframeHomeMethod: */
					methodField = longAt(theFP + FoxMethod);
					if ((methodField & MFMethodFlagIsBlockFlag) != 0) {
						cogMethod = cmHomeMethod(((CogBlockMethod *) (methodField & MFMethodMask)));
						goto l1;
					}
					cogMethod = ((CogMethod *) (methodField & MFMethodMask));
				l1:	/* end mframeHomeMethod: */;
					if ((heapMapAtWord(pointerForOop(cogMethod))) == 0) {
						printFrameThingat("object leak in mframe mthd", theFP + FoxMethod);
						/* begin cr */
						printf("\n");
						ok = 0;
					}
				}
				else {
					oop = longAt(theFP + FoxMethod);
					if (((oop & 1))
					 || ((heapMapAtWord(pointerForOop(oop))) == 0)) {
						printFrameThingat("object leak in iframe mthd", theFP + FoxMethod);
						/* begin cr */
						printf("\n");
						ok = 0;
					}
				}
				if (!(((callerFP = frameCallerFP(theFP))) != 0)) break;
				theSP = (theFP + FoxCallerSavedIP) + BytesPerWord;
				theFP = callerFP;
			}
			theSP = (theFP + FoxCallerSavedIP) + BytesPerWord;
			while (theSP <= ((thePage->baseAddress))) {
				oop = longAt(theSP);
				if (((oop & 1) == 0)
				 && ((heapMapAtWord(pointerForOop(oop))) == 0)) {
					printFrameThingat("object leak in frame arg", theSP);
					/* begin cr */
					printf("\n");
					ok = 0;
				}
				theSP += BytesPerWord;
			}
		}
	}
	return ok;
}

sqInt
classAlien(void)
{
	return longAt((GIV(specialObjectsOop) + BaseHeaderSize) + (ClassAlien << ShiftForWord));
}

sqInt
classArray(void)
{
	return longAt((GIV(specialObjectsOop) + BaseHeaderSize) + (ClassArray << ShiftForWord));
}

sqInt
classBitmap(void)
{
	return longAt((GIV(specialObjectsOop) + BaseHeaderSize) + (ClassBitmap << ShiftForWord));
}

sqInt
classByteArray(void)
{
	return longAt((GIV(specialObjectsOop) + BaseHeaderSize) + (ClassByteArray << ShiftForWord));
}

sqInt
classCharacter(void)
{
	return longAt((GIV(specialObjectsOop) + BaseHeaderSize) + (ClassCharacter << ShiftForWord));
}

sqInt
classExternalAddress(void)
{
	return longAt((GIV(specialObjectsOop) + BaseHeaderSize) + (ClassExternalAddress << ShiftForWord));
}

sqInt
classExternalData(void)
{
	return longAt((GIV(specialObjectsOop) + BaseHeaderSize) + (ClassExternalData << ShiftForWord));
}

sqInt
classExternalFunction(void)
{
	return longAt((GIV(specialObjectsOop) + BaseHeaderSize) + (ClassExternalFunction << ShiftForWord));
}

sqInt
classExternalLibrary(void)
{
	return longAt((GIV(specialObjectsOop) + BaseHeaderSize) + (ClassExternalLibrary << ShiftForWord));
}

sqInt
classExternalStructure(void)
{
	return longAt((GIV(specialObjectsOop) + BaseHeaderSize) + (ClassExternalStructure << ShiftForWord));
}

sqInt
classFieldOffset(void)
{
	return 0 - BaseHeaderSize;
}

sqInt
classFloat(void)
{
	return longAt((GIV(specialObjectsOop) + BaseHeaderSize) + (ClassFloat << ShiftForWord));
}

sqInt
classFloatCompactIndex(void)
{
	return ClassFloatCompactIndex;
}

sqInt
classHeader(sqInt oop)
{
	return longAt(oop - BaseHeaderSize);
}

sqInt
classLargeNegativeInteger(void)
{
	return longAt((GIV(specialObjectsOop) + BaseHeaderSize) + (ClassLargeNegativeInteger << ShiftForWord));
}

sqInt
classLargePositiveInteger(void)
{
	return longAt((GIV(specialObjectsOop) + BaseHeaderSize) + (ClassLargePositiveInteger << ShiftForWord));
}


/*	Check if aClass's name is className */

static sqInt
classNameOfIs(sqInt aClass, char *className)
{   DECL_MAYBE_SQ_GLOBAL_STRUCT
    sqInt i;
    sqInt length;
    sqInt name;
    char *srcName;

	if ((lengthOf(aClass)) <= GIV(classNameIndex)) {
		return 0;
	}
	name = longAt((aClass + BaseHeaderSize) + (GIV(classNameIndex) << ShiftForWord));
	if (!(((name & 1) == 0)
		 && (((((usqInt) (longAt(name))) >> 8) & 15) >= 8))) {
		return 0;
	}
	length = stSizeOf(name);
	srcName = ((char *) (arrayValueOf(name)));
	for (i = 0; i <= (length - 1); i += 1) {
		if (!((srcName[i]) == (className[i]))) {
			return 0;
		}
	}
	return (className[length]) == 0;
}

sqInt
classPoint(void)
{
	return longAt((GIV(specialObjectsOop) + BaseHeaderSize) + (ClassPoint << ShiftForWord));
}

sqInt
classSemaphore(void)
{
	return longAt((GIV(specialObjectsOop) + BaseHeaderSize) + (ClassSemaphore << ShiftForWord));
}

sqInt
classSmallInteger(void)
{
	return longAt((GIV(specialObjectsOop) + BaseHeaderSize) + (ClassInteger << ShiftForWord));
}

sqInt
classString(void)
{
	return longAt((GIV(specialObjectsOop) + BaseHeaderSize) + (ClassString << ShiftForWord));
}

sqInt
classUnsafeAlien(void)
{
	return longAt((GIV(specialObjectsOop) + BaseHeaderSize) + (ClassUnsafeAlien << ShiftForWord));
}


/*	Perform an integrity/leak check using the heapMap. Set a bit at each
	object's header.
	Override to set a bit at each Cog method */

static void
clearLeakMapAndMapAccessibleObjects(void)
{
    sqInt header;
    usqInt nextHeader;
    usqInt obj;
    usqInt sz;

	clearHeapMap();
	obj = heapBase + (headerTypeBytes[(longAt(heapBase)) & TypeMask]);
	while (obj < GIV(freeStart)) {
		if (((longAt(obj)) & TypeMask) == HeaderTypeFree) {
			sz = (longAt(obj)) & AllButTypeMask;
		}
		else {
			heapMapAtWordPut(pointerForOop(obj), 1);
			/* begin sizeBitsOf: */
			header = longAt(obj);
			sz = ((sqInt) (((header & TypeMask) == HeaderTypeSizeAndClass
	? (longAt(obj - (BytesPerWord * 2))) & LongSizeMask
	: header & SizeMask)));
		}
		nextHeader = obj + sz;
		obj = nextHeader + (headerTypeBytes[(longAt(nextHeader)) & TypeMask]);
	}
	addCogMethodsToHeapMap();
}

void
clearTraceLog(void)
{   DECL_MAYBE_SQ_GLOBAL_STRUCT
    sqInt i;

	GIV(traceLogIndex) = 0;
	for (i = 0; i <= (TraceBufferSize - 1); i += 1) {
		GIV(traceLog)[i] = 0;
	}
}


/*	Return a shallow copy of the given object. May cause GC */
/*	Assume: Oop is a real object, not a small integer. */

sqInt
clone(sqInt oop)
{   DECL_MAYBE_SQ_GLOBAL_STRUCT
    sqInt bytes;
    sqInt extraHdrBytes;
    usqInt fromIndex;
    sqInt hash;
    sqInt header;
    sqInt header1;
    usqInt lastFrom;
    sqInt newChunk;
    usqInt newChunk1;
    usqInt newFreeStart;
    sqInt newOop;
    sqInt oop1;
    sqInt remappedOop;
    sqInt toIndex;

	extraHdrBytes = headerTypeBytes[(longAt(oop)) & TypeMask];
	/* begin sizeBitsOf: */
	header1 = longAt(oop);
	bytes = ((header1 & TypeMask) == HeaderTypeSizeAndClass
		? (longAt(oop - (BytesPerWord * 2))) & LongSizeMask
		: header1 & SizeMask);

	/* allocate space for the copy, remapping oop in case of a GC */

	bytes += extraHdrBytes;
	/* begin pushRemappableOop: */
	assert(addressCouldBeOop(oop));
	GIV(remapBuffer)[(GIV(remapBufferCount) += 1)] = oop;
	if (!(sufficientSpaceToAllocate(2500 + bytes))) {
		return 0;
	}
	/* begin allocateChunk: */
	newChunk1 = GIV(freeStart);
	newFreeStart = GIV(freeStart) + bytes;
	if (newFreeStart < GIV(scavengeThreshold)) {
		if ((AllocationCheckFiller != 0)
		 && ((longAt(newChunk1)) != ((AllocationCheckFiller == 182275669
	? newChunk1
	: AllocationCheckFiller)))) {
			error("last object overwritten");
		}
		GIV(freeStart) = newFreeStart;
		newChunk = oopForPointer(newChunk1);
		goto l1;
	}
	/* begin scheduleIncrementalGC */
	GIV(needGCFlag) = 1;
	forceInterruptCheck();
	if (GIV(freeStart) <= GIV(reserveStart)) {
		GIV(freeStart) = newFreeStart;
		newChunk = oopForPointer(newChunk1);
		goto l1;
	}
	newChunk = 0;
l1:	/* end allocateChunk: */;
	/* begin popRemappableOop */
	oop1 = GIV(remapBuffer)[GIV(remapBufferCount)];
	GIV(remapBufferCount) -= 1;
	remappedOop = oop1;

	/* loop below uses pre-increment */

	toIndex = newChunk - BytesPerWord;
	fromIndex = (remappedOop - extraHdrBytes) - BytesPerWord;
	lastFrom = fromIndex + bytes;
	while (fromIndex < lastFrom) {
		longAtput(toIndex += BytesPerWord, longAt(fromIndex += BytesPerWord));
	}

	/* convert from chunk to oop */
	/* fix base header: compute new hash and clear Mark and Root bits */

	newOop = newChunk + extraHdrBytes;
	hash = ((usqInt) GIV(freeStart)) >> BytesPerWord;

	/* use old ccIndex, format, size, and header-type fields */

	header = (longAt(newOop)) & 131071;
	header = header | ((hash << HashBitsOffset) & HashBits);
	longAtput(newOop, header);
	return newOop;
}

static CogMethod *
cmHomeMethod(CogBlockMethod * self_in_cmHomeMethod)
{
	return ((CogMethod *) ((((usqInt)self_in_cmHomeMethod)) - ((self_in_cmHomeMethod->homeOffset))));
}

CogMethod *
cogMethodOf(sqInt aMethodOop)
{
    sqInt methodHeader;

	methodHeader = longAt((aMethodOop + BaseHeaderSize) + (HeaderIndex << ShiftForWord));
	assert((isNonIntegerObject(methodHeader))
	 && ((((usqInt)methodHeader)) < (startOfMemory())));
	return ((CogMethod *) methodHeader);
}

static void
commenceCogCompiledCodeCompaction(void)
{   DECL_MAYBE_SQ_GLOBAL_STRUCT
    char *sp;
    usqLong startTime;
    sqInt top;

	GIV(cogCompiledCodeCompactionCalledFor) = 0;
	if (recordEventTrace()) {
		/* begin recordTrace:thing:source: */
		GIV(traceLog)[GIV(traceLogIndex)] = TraceCodeCompaction;
		GIV(traceLog)[GIV(traceLogIndex) + 1] = TraceCodeCompaction;
		GIV(traceLog)[GIV(traceLogIndex) + 2] = 0;
		GIV(traceLogIndex) = (GIV(traceLogIndex) + 3) % TraceBufferSize;
	}

	/* This can be called in a number of circumstances.  The instructionPointer
	 may contain a native pc that must be relocated.  There may already be a
	 pushed instructionPointer on stack.  Clients ensure that instructionPointer
	 is 0 if it should not be pushed and/or relocated.  Pushing twice is a mistake
	 because only the top one will be relocated. */

	startTime = ioUTCMicrosecondsNow();
	if (GIV(instructionPointer) != 0) {
		/* begin push: */
		longAtput(sp = GIV(stackPointer) - BytesPerWord, GIV(instructionPointer));
		GIV(stackPointer) = sp;
		/* begin externalWriteBackHeadStackPointer */
		assert((GIV(stackPointer) < ((GIV(stackPage)->baseAddress)))
		 && (GIV(stackPointer) > (((GIV(stackPage)->realStackLimit)) - LargeContextSize)));
		(GIV(stackPage)->headSP = GIV(stackPointer));
	}
	compactCogCompiledCode();
	if (GIV(instructionPointer) != 0) {
		/* begin popStack */
		top = longAt(GIV(stackPointer));
		GIV(stackPointer) += BytesPerWord;
		GIV(instructionPointer) = ((sqInt) top);
		/* begin externalWriteBackHeadStackPointer */
		assert((GIV(stackPointer) < ((GIV(stackPage)->baseAddress)))
		 && (GIV(stackPointer) > (((GIV(stackPage)->realStackLimit)) - LargeContextSize)));
		(GIV(stackPage)->headSP = GIV(stackPointer));
	}
	GIV(statCodeCompactionCount) += 1;
	GIV(statCodeCompactionUsecs) += (ioUTCMicrosecondsNow()) - startTime;
	if (checkForLeaks != 0) {
		clearLeakMapAndMapAccessibleObjects();
		assert(checkCodeIntegrity(0));
	}
}


/*	This code is called if the receiver responds primitively to at:Put:.
	If this is so, it will be installed in the atPutCache so that subsequent
	calls of at:
	or next may be handled immediately in bytecode primitive routines. */

static void
commonAtPut(sqInt stringy)
{   DECL_MAYBE_SQ_GLOBAL_STRUCT
    sqInt atIx;
    sqInt fixedFields;
    sqInt fmt;
    sqInt index;
    sqInt rcvr;
    char *sp;
    char *sp1;
    sqInt stSize;
    sqInt valToPut;
    sqInt value;

	value = longAt(GIV(stackPointer));
	/* begin initPrimCall */
	GIV(primFailCode) = 0;
	rcvr = longAt(GIV(stackPointer) + (2 * BytesPerWord));
	if (!((rcvr & 1) == 0)) {
		GIV(primFailCode) = PrimErrInappropriate; return;
	}

	/* No need to test for large positive integers here.  No object has 1g elements */

	index = longAt(GIV(stackPointer) + (1 * BytesPerWord));
	if (!((index & 1))) {
		GIV(primFailCode) = PrimErrBadArgument; return;
	}

	/* NOTE:  The atPut-cache, since it is specific to the non-super response to #at:Put:.
	Therefore we must determine that the message is #at:Put: (not, eg, #basicAt:Put:),
	and that the send is not a super-send, before using the at-cache. */

	index = (index >> 1);
	if ((GIV(messageSelector) == (longAt(((longAt((GIV(specialObjectsOop) + BaseHeaderSize) + (SpecialSelectors << ShiftForWord))) + BaseHeaderSize) + ((17 * 2) << ShiftForWord))))
	 && (GIV(lkupClass) == (fetchClassOfNonInt(rcvr)))) {

		/* OK -- look in the at-cache */
		/* Index into atPutCache */

		atIx = (rcvr & AtCacheMask) + AtPutBase;
		if (!((GIV(atCache)[atIx + AtCacheOop]) == rcvr)) {
			installinAtCacheatstring(rcvr, GIV(atCache), atIx, stringy);
		}
		if (GIV(primFailCode) == 0) {
			/* begin commonVariable:at:put:cacheIndex: */
			VM_LABEL(1commonVariableatputcacheIndex);
			stSize = GIV(atCache)[atIx + AtCacheSize];
			if (((((usqInt) index)) >= (((usqInt) 1)))
			 && ((((usqInt) index)) <= (((usqInt) stSize)))) {
				fmt = GIV(atCache)[atIx + AtCacheFmt];
				if (fmt <= 4) {
					fixedFields = GIV(atCache)[atIx + AtCacheFixedFields];
					/* begin storePointer:ofObject:withValue: */
					if ((((usqInt) rcvr)) < (((usqInt) GIV(youngStart)))) {
						possibleRootStoreIntovalue(rcvr, value);
					}
					longAtput((rcvr + BaseHeaderSize) + (((index + fixedFields) - 1) << ShiftForWord), value);
					goto l1;
				}
				if (fmt < 8) {

					/* Bitmap */

					valToPut = positive32BitValueOf(value);
					if (GIV(primFailCode) == 0) {
						long32Atput((rcvr + BaseHeaderSize) + ((index - 1) << 2), valToPut);
					}
					goto l1;
				}
				if (fmt >= 16) {

					/* Note fmt >= 16 is an artificial flag for strings */

					valToPut = asciiOfCharacter(value);
					if (!(GIV(primFailCode) == 0)) {
						goto l1;
					}
				}
				else {
					valToPut = value;
				}
				if ((valToPut & 1)) {
					valToPut = (valToPut >> 1);
					if (!((valToPut >= 0)
						 && (valToPut <= 255))) {
						/* begin primitiveFail */
						if (GIV(primFailCode) == 0) {
							GIV(primFailCode) = 1;
						}
						goto l1;
					}
					byteAtput((rcvr + BaseHeaderSize) + (index - 1), valToPut);
					goto l1;
				}
			}
			GIV(primFailCode) = PrimErrBadIndex;
		l1:	/* end commonVariable:at:put:cacheIndex: */;
		}
		if (GIV(primFailCode) == 0) {
			/* begin pop:thenPush: */
			longAtput(sp = GIV(stackPointer) + (((GIV(argumentCount) + 1) - 1) * BytesPerWord), value);
			GIV(stackPointer) = sp;
			return;
		}
	}
	/* begin initPrimCall */
	GIV(primFailCode) = 0;
	if (stringy) {
		stObjectatput(rcvr, index, asciiOfCharacter(value));
	}
	else {
		stObjectatput(rcvr, index, value);
	}
	if (GIV(primFailCode) == 0) {
		/* begin pop:thenPush: */
		longAtput(sp1 = GIV(stackPointer) + (((GIV(argumentCount) + 1) - 1) * BytesPerWord), value);
		GIV(stackPointer) = sp1;
		return;
	}
}


/*	This code is called if the receiver responds primitively to at:.
	If this is so, it will be installed in the atCache so that subsequent
	calls of at:
	or next may be handled immediately in bytecode primitive routines. */

static void
commonAt(sqInt stringy)
{   DECL_MAYBE_SQ_GLOBAL_STRUCT
    sqInt atIx;
    sqInt fixedFields;
    sqInt fmt;
    sqInt index;
    sqInt rcvr;
    sqInt result;
    sqInt result1;
    char *sp;
    char *sp1;
    sqInt stSize;

	/* begin initPrimCall */
	GIV(primFailCode) = 0;
	rcvr = longAt(GIV(stackPointer) + (1 * BytesPerWord));
	if (!((rcvr & 1) == 0)) {
		GIV(primFailCode) = PrimErrInappropriate; return;
	}

	/* No need to test for large positive integers here.  No object has 1g elements */

	index = longAt(GIV(stackPointer));
	if (!((index & 1))) {
		GIV(primFailCode) = PrimErrBadArgument; return;
	}

	/* NOTE:  The at-cache, since it is specific to the non-super response to #at:.
	Therefore we must determine that the message is #at: (not, eg, #basicAt:),
	and that the send is not a super-send, before using the at-cache. */

	index = (index >> 1);
	if ((GIV(messageSelector) == (longAt(((longAt((GIV(specialObjectsOop) + BaseHeaderSize) + (SpecialSelectors << ShiftForWord))) + BaseHeaderSize) + ((16 * 2) << ShiftForWord))))
	 && (GIV(lkupClass) == (fetchClassOfNonInt(rcvr)))) {

		/* OK -- look in the at-cache */
		/* Index into atCache = 4N, for N = 0 ... 7 */

		atIx = rcvr & AtCacheMask;
		if (!((GIV(atCache)[atIx + AtCacheOop]) == rcvr)) {
			installinAtCacheatstring(rcvr, GIV(atCache), atIx, stringy);
		}
		if (GIV(primFailCode) == 0) {
			/* begin commonVariable:at:cacheIndex: */
			VM_LABEL(1commonVariableatcacheIndex);
			stSize = GIV(atCache)[atIx + AtCacheSize];
			if (((((usqInt) index)) >= (((usqInt) 1)))
			 && ((((usqInt) index)) <= (((usqInt) stSize)))) {
				fmt = GIV(atCache)[atIx + AtCacheFmt];
				if (fmt <= 4) {
					fixedFields = GIV(atCache)[atIx + AtCacheFixedFields];
					result = longAt((rcvr + BaseHeaderSize) + (((index + fixedFields) - 1) << ShiftForWord));
					goto l1;
				}
				if (fmt < 8) {

					/* Bitmap */

					result1 = long32At((rcvr + BaseHeaderSize) + ((index - 1) << 2));
					result = positive32BitIntegerFor(result1);
					goto l1;
				}
				if (fmt >= 16) {
					result = longAt(((longAt((GIV(specialObjectsOop) + BaseHeaderSize) + (CharacterTable << ShiftForWord))) + BaseHeaderSize) + ((byteAt((rcvr + BaseHeaderSize) + (index - 1))) << ShiftForWord));
					goto l1;
				}
				else {
					result = (((byteAt((rcvr + BaseHeaderSize) + (index - 1))) << 1) | 1);
					goto l1;
				}
			}
			result = GIV(primFailCode) = PrimErrBadIndex;
		l1:	/* end commonVariable:at:cacheIndex: */;
		}
		if (GIV(primFailCode) == 0) {
			/* begin pop:thenPush: */
			longAtput(sp = GIV(stackPointer) + (((GIV(argumentCount) + 1) - 1) * BytesPerWord), result);
			GIV(stackPointer) = sp;
			return;
		}
	}
	/* begin initPrimCall */
	GIV(primFailCode) = 0;
	result = stObjectat(rcvr, index);
	if (GIV(primFailCode) == 0) {
		if (stringy) {
			result = longAt(((longAt((GIV(specialObjectsOop) + BaseHeaderSize) + (CharacterTable << ShiftForWord))) + BaseHeaderSize) + (((result >> 1)) << ShiftForWord));
		}
		/* begin pop:thenPush: */
		longAtput(sp1 = GIV(stackPointer) + (((GIV(argumentCount) + 1) - 1) * BytesPerWord), result);
		GIV(stackPointer) = sp1;
		return;
	}
}


/*	Index must be between 1 and compactClassArray size. (A zero compact class
	index in the base header indicate that the class is in the class header
	word.) 
 */

sqInt
compactClassAt(sqInt ccIndex)
{
    sqInt classArray;

	classArray = longAt((GIV(specialObjectsOop) + BaseHeaderSize) + (CompactClasses << ShiftForWord));
	return longAt((classArray + BaseHeaderSize) + ((ccIndex - 1) << ShiftForWord));
}

sqInt
compactClassFieldLSB(void)
{
	return 12;
}

sqInt
compactClassFieldWidth(void)
{
	return 5;
}

sqInt
compactClassIndexOfHeader(sqInt header)
{
	return (((usqInt) header) >> 12) & 31;
}

sqInt
compactClassIndexOf(sqInt oop)
{
	return (((usqInt) (longAt(oop))) >> 12) & 31;
}

sqInt
compactClassTable(void)
{
	return longAt((GIV(specialObjectsOop) + BaseHeaderSize) + (CompactClasses << ShiftForWord));
}


/*	May set success to false */
/*	First compare two ST integers... */

static sqInt
compare31or32Bitsequal(sqInt obj1, sqInt obj2)
{
	if (((obj1 & 1))
	 && ((obj2 & 1))) {
		return obj1 == obj2;
	}
	return (positive32BitValueOf(obj1)) == (positive32BitValueOf(obj2));
}

void
compilationBreakpointFor(sqInt selectorOop)
{
	suppressHeartbeatFlag = 1;
	warning("compilation send break (heartbeat suppressed)");
}


/*	Return true if the array contains a small integer. You 
	can't become: SmallIntegers! */

static sqInt
containOnlyOops(sqInt array)
{
    sqInt contextSize;
    sqInt fieldOffset;
    sqInt fmt;
    sqInt header;
    sqInt methodHeader;
    sqInt sp;

	/* begin lastPointerOf: */
	header = longAt(array);
	fmt = (((usqInt) header) >> 8) & 15;
	if (fmt <= 4) {
		if ((fmt == 3)
		 && (((((usqInt) header) >> 12) & 31) == ClassMethodContextCompactIndex)) {
			/* begin fetchStackPointerOf: */
			sp = longAt((array + BaseHeaderSize) + (StackPointerIndex << ShiftForWord));
			if (!((sp & 1))) {
				contextSize = 0;
				goto l1;
			}
			assert((ReceiverIndex + ((sp >> 1))) < (lengthOf(array)));
			contextSize = (sp >> 1);
		l1:	/* end fetchStackPointerOf: */;
			fieldOffset = (CtxtTempFrameStart + contextSize) * BytesPerWord;
			goto l2;
		}
		fieldOffset = (sizeBitsOfSafe(array)) - BaseHeaderSize;
		goto l2;
	}
	if (fmt < 12) {
		fieldOffset = 0;
		goto l2;
	}
	methodHeader = longAt(array + BaseHeaderSize);
	if (isCogMethodReference(methodHeader)) {
		assert(((((CogMethod *) methodHeader)->cmType)) == CMMethod);
		methodHeader = (((CogMethod *) methodHeader)->methodHeader);
	}
	fieldOffset = (((((usqInt) methodHeader) >> 10) & 255) * BytesPerWord) + BaseHeaderSize;
l2:	/* end lastPointerOf: */;
	while (fieldOffset >= BaseHeaderSize) {
		if (((longAt(array + fieldOffset)) & 1)) {
			return 0;
		}
		fieldOffset -= BytesPerWord;
	}
	return 1;
}


/*	Return true if neither array contains a small integer. You 
	can't become: integers! */

static sqInt
containOnlyOopsand(sqInt array1, sqInt array2)
{
    sqInt contextSize;
    sqInt fieldOffset;
    sqInt fmt;
    sqInt header;
    sqInt methodHeader;
    sqInt sp;

	/* begin lastPointerOf: */
	header = longAt(array1);
	fmt = (((usqInt) header) >> 8) & 15;
	if (fmt <= 4) {
		if ((fmt == 3)
		 && (((((usqInt) header) >> 12) & 31) == ClassMethodContextCompactIndex)) {
			/* begin fetchStackPointerOf: */
			sp = longAt((array1 + BaseHeaderSize) + (StackPointerIndex << ShiftForWord));
			if (!((sp & 1))) {
				contextSize = 0;
				goto l1;
			}
			assert((ReceiverIndex + ((sp >> 1))) < (lengthOf(array1)));
			contextSize = (sp >> 1);
		l1:	/* end fetchStackPointerOf: */;
			fieldOffset = (CtxtTempFrameStart + contextSize) * BytesPerWord;
			goto l2;
		}
		fieldOffset = (sizeBitsOfSafe(array1)) - BaseHeaderSize;
		goto l2;
	}
	if (fmt < 12) {
		fieldOffset = 0;
		goto l2;
	}
	methodHeader = longAt(array1 + BaseHeaderSize);
	if (isCogMethodReference(methodHeader)) {
		assert(((((CogMethod *) methodHeader)->cmType)) == CMMethod);
		methodHeader = (((CogMethod *) methodHeader)->methodHeader);
	}
	fieldOffset = (((((usqInt) methodHeader) >> 10) & 255) * BytesPerWord) + BaseHeaderSize;
l2:	/* end lastPointerOf: */;
	while (fieldOffset >= BaseHeaderSize) {
		if (((longAt(array1 + fieldOffset)) & 1)) {
			return 0;
		}
		if (((longAt(array2 + fieldOffset)) & 1)) {
			return 0;
		}
		fieldOffset -= BytesPerWord;
	}
	return 1;
}


/*	Answer a value to store in the InstructionPointer index of a context
	object for theIP and theFP.
	Mapping native pcs to bytecode pcs is quite expensive, requiring a search
	through the method
	map. We mitigate this cost by deferring mapping until we really have to,
	which is when a context's
	instruction pointer is accessed by Smalltalk code (either direct inst var
	access or through the
	instVarAt: primitive). But to defer mapping we have to be able to
	distinguish machine code from
	bytecode pcs, which we do by using negative values for machine code pcs.
	So if the frame is a
	machine code one answer the negation of the offset in the cog method.
	
	As a whorish performance hack we also include the block method offset in
	the pc of a block.
	The least significant 16 bits are the native pc and the most significant
	14 bits are the block
	start, in block alignment units. So when mapping back we can find the
	start of the block.
	
	See mustMapMachineCodePC:context: for the code that does the actual
	mapping.  */

static sqInt
contextInstructionPointerframe(sqInt theIP, char *theFP)
{
	assert(validInstructionPointerinFrame(theIP, theFP));
	if ((((usqInt)(longAt(theFP + FoxMethod)))) < heapBase) {
		return encodedNativePCOfcogMethod(theIP, mframeCogMethod(theFP));
	}
	return (((((((theIP == (ceReturnToInterpreterPC())
	? longAt(theFP + FoxIFSavedIP)
	: theIP)) - (longAt(theFP + FoxMethod))) - BaseHeaderSize) + 2) << 1) | 1);
}


/*	Does thisCntx have aContext in its sender chain?
	Cheapo implementation above extant machinery. */

static sqInt
contexthasSender(sqInt thisCntx, sqInt aContext)
{
    sqInt handlerOrNilOrZero;

	handlerOrNilOrZero = findMethodWithPrimitiveFromContextUpToContext(-1, thisCntx, aContext);
	return handlerOrNilOrZero == 0;
}


/*	This entry point needs to be implemented for the interpreter proxy.
	Since BitBlt is now a plugin we need to look up BitBltPlugin:=copyBits
	and call it. This entire mechanism should eventually go away and be
	replaced with a dynamic lookup from BitBltPlugin itself but for backward
	compatibility this stub is provided */

sqInt
copyBits(void)
{   DECL_MAYBE_SQ_GLOBAL_STRUCT
    void *fn;

	fn = ioLoadFunctionFrom("copyBits", "BitBltPlugin");
	if (fn == 0) {
		/* begin primitiveFail */
		if (GIV(primFailCode) == 0) {
			GIV(primFailCode) = 1;
		}
		return null;
	}
	return ((sqInt (*)(void))fn)();
}


/*	This entry point needs to be implemented for the interpreter proxy.
	Since BitBlt is now a plugin we need to look up
	BitBltPlugin:=copyBitsFrom:to:at: and call it. This entire mechanism
	should eventually go away and be
	replaced with a dynamic lookup from BitBltPlugin itself but for backward
	compatibility this stub is provided
 */

sqInt
copyBitsFromtoat(sqInt x0, sqInt x1, sqInt y)
{   DECL_MAYBE_SQ_GLOBAL_STRUCT
    void *fn;

	fn = ioLoadFunctionFrom("copyBitsFromtoat", "BitBltPlugin");
	if (fn == 0) {
		/* begin primitiveFail */
		if (GIV(primFailCode) == 0) {
			GIV(primFailCode) = 1;
		}
		return null;
	}
	return ((sqInt (*)(sqInt, sqInt, sqInt))fn)(x0, x1, y);
}


/*	Copy this object into the segment beginning at lastSeg.
	Install a forwarding pointer, and save oop and header.
	Fail if out of space. Return the next segmentAddr if successful. */
/*	Copy the object... */

static sqInt
copyObjtoSegmentaddrstopAtsaveOopAtheaderAt(sqInt oop, sqInt segmentWordArray, sqInt lastSeg, sqInt stopAddr, sqInt oopPtr, sqInt hdrPtr)
{
    sqInt bodySize;
    sqInt extraSize;
    sqInt hdrAddr;
    sqInt header;
    sqInt in;
    sqInt lastIn;
    sqInt out;

	flag("Dan");
	extraSize = headerTypeBytes[(longAt(oop)) & TypeMask];
	/* begin sizeBitsOf: */
	header = longAt(oop);
	bodySize = ((header & TypeMask) == HeaderTypeSizeAndClass
		? (longAt(oop - (BytesPerWord * 2))) & LongSizeMask
		: header & SizeMask);
	if ((((usqInt) ((lastSeg + extraSize) + bodySize))) >= (((usqInt) stopAddr))) {
		return 0;
	}
	/* begin transfer:from:to: */
	flag("Dan");
	in = (oop - extraSize) - BytesPerWord;
	lastIn = in + ((((sqInt) (extraSize + bodySize) >> 2)) * BytesPerWord);
	out = (lastSeg + BytesPerWord) - BytesPerWord;
	while ((((usqInt) in)) < (((usqInt) lastIn))) {
		longAtput(out += BytesPerWord, longAt(in += BytesPerWord));
	}
	hdrAddr = (lastSeg + BytesPerWord) + extraSize;
	longAtput(hdrAddr, (longAt(hdrAddr)) & (AllButRootBit - MarkBit));
	if ((((((usqInt) (longAt(oop))) >> 8) & 15) >= 12)
	 && (methodHasCogMethod(oop))) {
		longAtput(hdrAddr + BaseHeaderSize, headerOf(oop));
	}
	/* begin forward:to:savingOopAt:andHeaderAt: */
	longAtput(oopPtr, oop);
	longAtput(hdrPtr, longAt(oop));
	longAtput(oop, (((lastSeg + BytesPerWord) + extraSize) - segmentWordArray) + HeaderTypeFree);
	return (lastSeg + extraSize) + bodySize;
}


/*	For testing in Smalltalk, this method should be overridden in a subclass. */

static void
cr(void)
{
	printf("\n");
}


/*	Bundle up the selector, arguments and lookupClass into a Message object. 
	In the process it pops the arguments off the stack, and pushes the message
	object. 
	This can then be presented as the argument of e.g. #doesNotUnderstand: */

static void
createActualMessageTo(sqInt lookupClass)
{   DECL_MAYBE_SQ_GLOBAL_STRUCT
    sqInt argumentArray;
    sqInt i;
    sqInt message;
    char *sp;

	assert(((GIV(messageSelector) & 1))
	 || (addressCouldBeObj(GIV(messageSelector))));
	argumentArray = eeInstantiateClassindexableSize(longAt((GIV(specialObjectsOop) + BaseHeaderSize) + (ClassArray << ShiftForWord)), GIV(argumentCount));

	/* Since the array is new can use unchecked stores. */

	message = eeInstantiateClassindexableSize(longAt((GIV(specialObjectsOop) + BaseHeaderSize) + (ClassMessage << ShiftForWord)), 0);
	for (i = ((GIV(argumentCount) - 1) * BytesPerWord); i >= 0; i += (-BytesPerWord)) {
		longAtput((argumentArray + BaseHeaderSize) + i, popStack());
	}
	longAtput((message + BaseHeaderSize) + (MessageSelectorIndex << ShiftForWord), GIV(messageSelector));
	longAtput((message + BaseHeaderSize) + (MessageArgumentsIndex << ShiftForWord), argumentArray);
	longAtput((message + BaseHeaderSize) + (MessageLookupClassIndex << ShiftForWord), lookupClass);
	/* begin push: */
	longAtput(sp = GIV(stackPointer) - BytesPerWord, message);
	GIV(stackPointer) = sp;
	GIV(argumentCount) = 1;
}

sqInt
createClosureNumArgsnumCopiedstartpc(sqInt numArgs, sqInt numCopied, sqInt initialIP)
{   DECL_MAYBE_SQ_GLOBAL_STRUCT
    sqInt context;
    sqInt i;
    sqInt newClosure;
    sqInt newClosure1;
    char *theFP;
    char *theSP;

	assert(isMachineCodeFrame(GIV(framePointer)));
	/* begin ensureFrameIsMarried:SP: */
	VM_LABEL(9ensureFrameIsMarriedSP);
	theFP = GIV(framePointer);
	theSP = GIV(stackPointer) + ((1 + numCopied) * BytesPerWord);
	if (((((usqInt)(longAt(theFP + FoxMethod)))) < heapBase
		? ((longAt(theFP + FoxMethod)) & MFMethodFlagHasContextFlag) != 0
		: (byteAt((theFP + FoxIFrameFlags) + 2)) != 0)) {
		assert(isContext(frameContext(theFP)));
		context = longAt(theFP + FoxThisContext);
		goto l1;
	}
	context = marryFrameSP(theFP, theSP);
l1:	/* end ensureFrameIsMarried:SP: */;
	/* begin closureIn:numArgs:instructionPointer:numCopiedValues: */
	VM_LABEL(1closureInnumArgsinstructionPointernumCopiedValues);
	assert(((BytesPerWord * (ClosureFirstCopiedValueIndex + numCopied)) + BaseHeaderSize) <= 252);

	/* Assume: have just allocated a new closure; it must be young. Thus, can use unchecked stores. */

	newClosure1 = eeInstantiateSmallClasssizeInBytes(longAt((GIV(specialObjectsOop) + BaseHeaderSize) + (ClassBlockClosure << ShiftForWord)), (BytesPerWord * (ClosureFirstCopiedValueIndex + numCopied)) + BaseHeaderSize);
	longAtput((newClosure1 + BaseHeaderSize) + (ClosureOuterContextIndex << ShiftForWord), context);
	longAtput((newClosure1 + BaseHeaderSize) + (ClosureStartPCIndex << ShiftForWord), ((initialIP << 1) | 1));
	longAtput((newClosure1 + BaseHeaderSize) + (ClosureNumArgsIndex << ShiftForWord), ((numArgs << 1) | 1));
	newClosure = newClosure1;
	if (recordSendTrace()) {
		/* begin recordTrace:thing:source: */
		GIV(traceLog)[GIV(traceLogIndex)] = TraceBlockCreation;
		GIV(traceLog)[GIV(traceLogIndex) + 1] = newClosure;
		GIV(traceLog)[GIV(traceLogIndex) + 2] = TraceIsFromMachineCode;
		GIV(traceLogIndex) = (GIV(traceLogIndex) + 3) % TraceBufferSize;
	}
	if (numCopied > 0) {
		for (i = 0; i <= (numCopied - 1); i += 1) {
			longAtput((newClosure + BaseHeaderSize) + ((i + ClosureFirstCopiedValueIndex) << ShiftForWord), longAt(GIV(stackPointer) + ((numCopied - i) * BytesPerWord)));
		}
	}
	return newClosure;
}


/*	Answer either a malloced string with the null-terminated contents of oop
	if oop is a string,
	or the null pointer if oop is nil, or fail. It is the client's
	responsibility to free the string later. */

char *
cStringOrNullFor(sqInt oop)
{   DECL_MAYBE_SQ_GLOBAL_STRUCT
    sqInt ccIndex;
    char *cString;
    sqInt header;
    sqInt isString;
    sqInt len;
    sqInt sz;

	/* begin isClassOfNonImm:equalTo:compactClassIndex: */
	assert(!((oop & 1)));
	ccIndex = (((usqInt) (longAt(oop))) >> 12) & 31;
	isString = (ClassByteStringCompactIndex == 0
		? (ccIndex == 0
	? ((longAt(oop - BaseHeaderSize)) & AllButTypeMask) == (longAt((GIV(specialObjectsOop) + BaseHeaderSize) + (ClassByteString << ShiftForWord)))
	: 0)
		: ClassByteStringCompactIndex == ccIndex);
	if (!(isString)) {
		if (oop != GIV(nilObj)) {
			GIV(primFailCode) = PrimErrBadArgument;
		}
		return 0;
	}
	/* begin lengthOf: */
	header = longAt(oop);
	/* begin lengthOf:baseHeader:format: */
	if ((header & TypeMask) == HeaderTypeSizeAndClass) {
		sz = (longAt(oop - (BytesPerWord * 2))) & LongSizeMask;
	}
	else {
		sz = header & SizeMask;
	}
	sz -= header & Size4Bit;
	if (((((usqInt) header) >> 8) & 15) <= 4) {
		len = ((usqInt) (sz - BaseHeaderSize)) >> ShiftForWord;
		goto l1;
	}
	if (((((usqInt) header) >> 8) & 15) < 8) {
		len = ((usqInt) (sz - BaseHeaderSize)) >> 2;
		goto l1;
	}
	else {
		len = (sz - BaseHeaderSize) - (((((usqInt) header) >> 8) & 15) & 3);
		goto l1;
	}
l1:	/* end lengthOf:baseHeader:format: */;
	if (len == 0) {
		return 0;
	}
	cString = malloc(len + 1);
	if (!(cString)) {
		GIV(primFailCode) = PrimErrNoCMemory;
		return 0;
	}
	memcpy(cString, firstIndexableField(oop), len);
	cString[len] = 0;
	return cString;
}


/*	This version answers the value of a float or nil if not a flat *WITHOUT*
	setting successFlag or any other such nonsense. It is hence safe for use
	in debug printing. Sheesh. */

static double
dbgFloatValueOf(sqInt oop)
{
    double result;

	flag("Dan");
	if (((oop & 1) == 0)
	 && ((fetchClassOfNonInt(oop)) == (longAt((GIV(specialObjectsOop) + BaseHeaderSize) + (ClassFloat << ShiftForWord))))) {
		;
		fetchFloatAtinto(oop + BaseHeaderSize, result);
		return result;
	}
	return null;
}


/*	Return the default number of bytes to allocate for native code at startup.
	The actual value can be set via vmParameterAt: and/or a preference in the
	ini file. */

static sqInt
defaultCogCodeSize(void)
{
	return 1024 * 1024;
}


/*	Return the default amount of memory to allocate before doing a scavenge
	(incremental GC).
	This default suits Qwaq Forums (specifically loading). The actual value
	can be set via
	vmParameterAt: and/or a preference in the ini file. */

static sqInt
defaultEdenBytes(void)
{
	return (2 * 1024) * 1024;
}


/*	Return the default number of stack pages allocate at startup.
	This default suits Qwaq Forums (specifically general rendering).
	It is probably a bit high for normal use but QF is profligate with
	processes. The actual value can be set via vmParameterAt: and/or a
	preference in the ini file. */

static sqInt
defaultNumStackPages(void)
{
	return 160;
}


/*	Defer smashes of the stackLimit around the call of functionSymbol (for
	assert checks)
 */

static void
deferStackLimitSmashAround(void (*functionSymbol)(void))
{   DECL_MAYBE_SQ_GLOBAL_STRUCT
	GIV(deferSmash) = 1;
	functionSymbol();
	GIV(deferSmash) = 0;
	if (GIV(deferredSmash)) {
		GIV(deferredSmash) = 0;
		forceInterruptCheck();
	}
}


/*	Repaint the portion of the Smalltalk screen bounded by the affected
	rectangle. Used to synchronize the screen after a Bitblt to the Smalltalk
	Display object.
 */

static void
displayBitsOfLeftTopRightBottom(sqInt aForm, sqInt l, sqInt t, sqInt r, sqInt b)
{   DECL_MAYBE_SQ_GLOBAL_STRUCT
    sqInt bottom;
    sqInt d;
    sqInt dispBits;
    sqInt dispBitsIndex;
    sqInt displayObj;
    sqInt h;
    sqInt left;
    sqInt right;
    sqInt successBoolean;
    sqInt surfaceHandle;
    sqInt top;
    sqInt w;

	displayObj = longAt((GIV(specialObjectsOop) + BaseHeaderSize) + (TheDisplay << ShiftForWord));
	if (!(aForm == displayObj)) {
		return;
	}
	/* begin success: */
	successBoolean = (((displayObj & 1) == 0)
 && (((((usqInt) (longAt(displayObj))) >> 8) & 15) <= 4))
	 && ((lengthOf(displayObj)) >= 4);
	if (!(successBoolean)) {
		if (GIV(primFailCode) == 0) {

			/* Don't overwrite an error code that has already been set. */

			GIV(primFailCode) = 1;
		}
	}
	if (GIV(primFailCode) == 0) {
		dispBits = longAt((displayObj + BaseHeaderSize) + (0 << ShiftForWord));
		w = fetchIntegerofObject(1, displayObj);
		h = fetchIntegerofObject(2, displayObj);
		d = fetchIntegerofObject(3, displayObj);
	}
	if (l < 0) {
		left = 0;
	}
	else {
		left = l;
	}
	if (r > w) {
		right = w;
	}
	else {
		right = r;
	}
	if (t < 0) {
		top = 0;
	}
	else {
		top = t;
	}
	if (b > h) {
		bottom = h;
	}
	else {
		bottom = b;
	}
	if (!((left <= right)
		 && (top <= bottom))) {
		return;
	}
	if (GIV(primFailCode) == 0) {
		if ((dispBits & 1)) {
			surfaceHandle = (dispBits >> 1);
			if (showSurfaceFn == 0) {
				showSurfaceFn = ioLoadFunctionFrom("ioShowSurface", "SurfacePlugin");
				if (showSurfaceFn == 0) {
					/* begin success: */
					if (!(0)) {
						if (GIV(primFailCode) == 0) {

							/* Don't overwrite an error code that has already been set. */

							GIV(primFailCode) = 1;
						}
					}
					return;
				}
			}
			((sqInt (*)(sqInt, sqInt, sqInt, sqInt, sqInt))showSurfaceFn)(surfaceHandle, left, top, right-left, bottom-top);
		}
		else {

			/* index in memory byte array */

			dispBitsIndex = dispBits + BaseHeaderSize;
			ioShowDisplay(dispBitsIndex, w, h, d, left, right, top, bottom);
		}
	}
}

sqInt
displayObject(void)
{
	return longAt((GIV(specialObjectsOop) + BaseHeaderSize) + (TheDisplay << ShiftForWord));
}

static sqInt
divorceAllFrames(void)
{   DECL_MAYBE_SQ_GLOBAL_STRUCT
    sqInt activeContext;
    StackPage *aPage;
    sqInt i;
    char *theFP;
    char *theSP;

	/* begin externalWriteBackHeadFramePointers */
	assert((GIV(framePointer) - GIV(stackPointer)) < LargeContextSize);
	assert(GIV(stackPage) == (mostRecentlyUsedPage()));
	/* begin setHeadFP:andSP:inPage: */
	assert(GIV(stackPointer) < GIV(framePointer));
	assert((GIV(stackPointer) < ((GIV(stackPage)->baseAddress)))
	 && (GIV(stackPointer) > (((GIV(stackPage)->realStackLimit)) - LargeContextSize)));
	assert((GIV(framePointer) < ((GIV(stackPage)->baseAddress)))
	 && (GIV(framePointer) > (((GIV(stackPage)->realStackLimit)) - (((sqInt) LargeContextSize >> 1)))));
	(GIV(stackPage)->headFP = GIV(framePointer));
	(GIV(stackPage)->headSP = GIV(stackPointer));
	assert(pageListIsWellFormed());
	/* begin ensureFrameIsMarried:SP: */
	VM_LABEL(10ensureFrameIsMarriedSP);
	theFP = GIV(framePointer);
	theSP = GIV(stackPointer);
	if (((((usqInt)(longAt(theFP + FoxMethod)))) < heapBase
		? ((longAt(theFP + FoxMethod)) & MFMethodFlagHasContextFlag) != 0
		: (byteAt((theFP + FoxIFrameFlags) + 2)) != 0)) {
		assert(isContext(frameContext(theFP)));
		activeContext = longAt(theFP + FoxThisContext);
		goto l1;
	}
	activeContext = marryFrameSP(theFP, theSP);
l1:	/* end ensureFrameIsMarried:SP: */;
	for (i = 0; i <= (GIV(numStackPages) - 1); i += 1) {
		/* begin stackPageAt: */
		aPage = stackPageAtpages(i, GIV(pages));
		if (!(isFree(aPage))) {
			divorceFramesIn(aPage);
		}
	}
	GIV(stackPage) = 0;
	return activeContext;
}

static void
divorceFramesIn(StackPage *aStackPage)
{   DECL_MAYBE_SQ_GLOBAL_STRUCT
    sqInt calleeContext;
    char *calleeFP;
    sqInt callerContextOrNil;
    sqInt index;
    sqInt theContext;
    char *theFP;
    sqInt theIP;
    StackPage *thePage;
    char *theSP;
    sqInt valuePointer;
    sqInt valuePointer1;

	GIV(statStackPageDivorce) += 1;
	theFP = (aStackPage->headFP);
	theSP = (aStackPage->headSP);
	theIP = longAt(theSP);

	/* theSP points at hottest item on frame's stack */

	theSP += BytesPerWord;
	calleeContext = null;
	while (1) {
		/* begin ensureFrameIsMarried:SP: */
		VM_LABEL(11ensureFrameIsMarriedSP);
		if (((((usqInt)(longAt(theFP + FoxMethod)))) < heapBase
			? ((longAt(theFP + FoxMethod)) & MFMethodFlagHasContextFlag) != 0
			: (byteAt((theFP + FoxIFrameFlags) + 2)) != 0)) {
			assert(isContext(frameContext(theFP)));
			theContext = longAt(theFP + FoxThisContext);
			goto l1;
		}
		theContext = marryFrameSP(theFP, theSP);
	l1:	/* end ensureFrameIsMarried:SP: */;
		updateStateOfSpouseContextForFrameWithSP(theFP, theSP);
		/* begin storePointerUnchecked:ofObject:withValue: */
		valuePointer = contextInstructionPointerframe(theIP, theFP);
		longAtput((theContext + BaseHeaderSize) + (InstructionPointerIndex << ShiftForWord), valuePointer);
		assert((frameReceiver(theFP)) == (fetchPointerofObject(ReceiverIndex, theContext)));
		if (calleeContext != null) {
			/* begin storePointer:ofObject:withValue: */
			if ((((usqInt) calleeContext)) < (((usqInt) GIV(youngStart)))) {
				possibleRootStoreIntovalue(calleeContext, theContext);
			}
			longAtput((calleeContext + BaseHeaderSize) + (SenderIndex << ShiftForWord), theContext);
		}
		calleeContext = theContext;
		calleeFP = theFP;
		theIP = ((sqInt)(frameCallerSavedIP(theFP)));
		/* begin frameCallerFP: */
		theFP = pointerForOop(longAt(theFP + FoxSavedFP));
		if (!(theFP != 0)) break;
		/* begin frameCallerSP: */
		assert(!(isBaseFrame(calleeFP)));
		theSP = (calleeFP + ((FoxCallerSavedIP + BytesPerWord) + ((((((usqInt)(longAt(calleeFP + FoxMethod)))) < heapBase
	? (mframeCogMethod(calleeFP)->cmNumArgs)
	: byteAt((calleeFP + FoxIFrameFlags) + 1))) << ShiftForWord))) + BytesPerWord;
	}
	/* begin storePointer:ofObject:withValue: */
	/* begin frameCallerContext: */
	assert(isBaseFrame(calleeFP));
	/* begin stackPageFor: */
	/* begin stackPageAt: */
	/* begin pageIndexFor: */
	assert((((((char *) calleeFP)) >= (GIV(stackBasePlus1) - 1)) && ((((char *) calleeFP)) <= (((char *) GIV(pages))))));
	index = pageIndexForstackBasePlus1bytesPerPage(calleeFP, GIV(stackBasePlus1), GIV(bytesPerPage));
	thePage = stackPageAtpages(index, GIV(pages));
	callerContextOrNil = longAt((thePage->baseAddress));
	assert(addressCouldBeObj(callerContextOrNil));
	assert((callerContextOrNil == (nilObject()))
	 || (isContext(callerContextOrNil)));
	valuePointer1 = callerContextOrNil;
	if ((((usqInt) theContext)) < (((usqInt) GIV(youngStart)))) {
		possibleRootStoreIntovalue(theContext, valuePointer1);
	}
	longAtput((theContext + BaseHeaderSize) + (SenderIndex << ShiftForWord), valuePointer1);
	(aStackPage->baseFP = 0);
}


/*	Rounds negative results towards negative infinity, rather than zero. */

static sqInt
doPrimitiveDivby(sqInt rcvr, sqInt arg)
{   DECL_MAYBE_SQ_GLOBAL_STRUCT
    sqInt integerArg;
    sqInt integerRcvr;
    sqInt posArg;
    sqInt posRcvr;
    sqInt result;

	if (((rcvr & arg) & 1) != 0) {
		integerRcvr = (rcvr >> 1);
		integerArg = (arg >> 1);
		/* begin success: */
		if (!(integerArg != 0)) {
			if (GIV(primFailCode) == 0) {

				/* Don't overwrite an error code that has already been set. */

				GIV(primFailCode) = 1;
			}
		}
	}
	else {
		/* begin primitiveFail */
		if (GIV(primFailCode) == 0) {
			GIV(primFailCode) = 1;
		}
	}
	if (!(GIV(primFailCode) == 0)) {
		return 1;
	}
	if (integerRcvr > 0) {
		if (integerArg > 0) {
			result = integerRcvr / integerArg;
		}
		else {

			/* round negative result toward negative infinity */

			posArg = 0 - integerArg;
			result = 0 - ((integerRcvr + (posArg - 1)) / posArg);
		}
	}
	else {
		posRcvr = 0 - integerRcvr;
		if (integerArg > 0) {

			/* round negative result toward negative infinity */

			result = 0 - ((posRcvr + (integerArg - 1)) / integerArg);
		}
		else {
			posArg = 0 - integerArg;
			result = posRcvr / posArg;
		}
	}
	/* begin success: */
	if (!((result ^ (result << 1)) >= 0)) {
		if (GIV(primFailCode) == 0) {

			/* Don't overwrite an error code that has already been set. */

			GIV(primFailCode) = 1;
		}
	}
	return result;
}

static sqInt
doPrimitiveModby(sqInt rcvr, sqInt arg)
{   DECL_MAYBE_SQ_GLOBAL_STRUCT
    sqInt integerArg;
    sqInt integerRcvr;
    sqInt integerResult;

	if (((rcvr & arg) & 1) != 0) {
		integerRcvr = (rcvr >> 1);
		integerArg = (arg >> 1);
		/* begin success: */
		if (!(integerArg != 0)) {
			if (GIV(primFailCode) == 0) {

				/* Don't overwrite an error code that has already been set. */

				GIV(primFailCode) = 1;
			}
		}
	}
	else {
		/* begin primitiveFail */
		if (GIV(primFailCode) == 0) {
			GIV(primFailCode) = 1;
		}
	}
	if (!(GIV(primFailCode) == 0)) {
		return 1;
	}

	/* ensure that the result has the same sign as the integerArg */

	integerResult = integerRcvr % integerArg;
	if (integerArg < 0) {
		if (integerResult > 0) {
			integerResult += integerArg;
		}
	}
	else {
		if (integerResult < 0) {
			integerResult += integerArg;
		}
	}
	/* begin success: */
	if (!((integerResult ^ (integerResult << 1)) >= 0)) {
		if (GIV(primFailCode) == 0) {

			/* Don't overwrite an error code that has already been set. */

			GIV(primFailCode) = 1;
		}
	}
	return integerResult;
}


/*	Signal the external semaphore with the given index. Answer if a context
	switch occurs as a result. Do not bounds check. This has been done in the
	caller.  */

sqInt
doSignalSemaphoreWithIndex(sqInt index)
{   DECL_MAYBE_SQ_GLOBAL_STRUCT
    sqInt sema;
    sqInt semaphoreClass;
    sqInt xArray;

	xArray = longAt((GIV(specialObjectsOop) + BaseHeaderSize) + (ExternalObjectsArray << ShiftForWord));
	semaphoreClass = longAt((GIV(specialObjectsOop) + BaseHeaderSize) + (ClassSemaphore << ShiftForWord));

	/* Note: semaphore indices are 1-based */

	sema = longAt((xArray + BaseHeaderSize) + ((index - 1) << ShiftForWord));
	return ((sema & 1) == 0)
	 && (((fetchClassOfNonInt(sema)) == semaphoreClass)
 && (synchronousSignal(sema)));
}

static void
dummyReferToProxy(void)
{
	interpreterProxy = interpreterProxy;
}


/*	Dump the entire image out to the given file. Intended for debugging only. */

EXPORT(sqInt)
dumpImage(sqInt fileName)
{
    sqInt dataSize;
    sqImageFile f;
    sqInt result;

	f = sqImageFileOpen(pointerForOop(fileName), "wb");
	if (f == null) {
		return -1;
	}
	dataSize = GIV(endOfMemory) - heapBase;
	result = sqImageFileWrite(pointerForOop(memory), sizeof(unsigned char), dataSize, f);
	sqImageFileClose(f);
	return result;
}


/*	The prim trace log is a circular buffer of entries. If there is
	an entry at primTraceLogIndex \\ PrimTraceLogSize it has entries.
	If there is something at primTraceLogIndex it has wrapped. */

void
dumpPrimTraceLog(void)
{   DECL_MAYBE_SQ_GLOBAL_STRUCT
    sqInt i;
    sqInt remainder;

	if ((GIV(primTraceLog)[(((remainder = (GIV(primTraceLogIndex) - 1) % PrimTraceLogSize)) < 0
		? remainder + PrimTraceLogSize
		: remainder)]) == 0) {
		return;
	}
	if ((GIV(primTraceLog)[GIV(primTraceLogIndex)]) != 0) {
		for (i = GIV(primTraceLogIndex); i <= (PrimTraceLogSize - 1); i += 1) {
			safePrintStringOf(GIV(primTraceLog)[i]);
			/* begin cr */
			printf("\n");
		}
	}
	for (i = 0; i <= (GIV(primTraceLogIndex) - 1); i += 1) {
		safePrintStringOf(GIV(primTraceLog)[i]);
		/* begin cr */
		printf("\n");
	}
}


/*	The trace log is a circular buffer of pairs of entries. If there is
	an entry at traceLogIndex - 3 \\ TraceBufferSize it has entries.
	If there is something at traceLogIndex it has wrapped. */

void
dumpTraceLog(void)
{   DECL_MAYBE_SQ_GLOBAL_STRUCT
    sqInt i;
    sqInt remainder;

	if ((GIV(traceLog)[(((remainder = (GIV(traceLogIndex) - 3) % TraceBufferSize)) < 0
		? remainder + TraceBufferSize
		: remainder)]) == 0) {
		return;
	}
	if ((GIV(traceLog)[GIV(traceLogIndex)]) != 0) {
		for (i = GIV(traceLogIndex); i <= (TraceBufferSize - 3); i += 3) {
			printLogEntryAt(i);
		}
	}
	for (i = 0; i <= (GIV(traceLogIndex) - 3); i += 3) {
		printLogEntryAt(i);
	}
}


/*	NOTE: This method supports the backward-compatible split instSize field of
	the 
	class format word. The sizeHiBits will go away and other shifts change by
	2 
	when the split fields get merged in an (incompatible) image change.
	Will *not* cause a GC. The instantiated object is initialized. */

static sqInt
eeInstantiateAndInitializeClassindexableSize(sqInt classPointer, sqInt size)
{   DECL_MAYBE_SQ_GLOBAL_STRUCT
    sqInt binc;
    sqInt bm1;
    sqInt byteSize;
    sqInt cClass;
    sqInt classFormat;
    usqInt end;
    sqInt fillWord;
    sqInt format;
    sqInt hash;
    sqInt hdrSize;
    sqInt header1;
    sqInt header2;
    sqInt header3;
    usqInt i;
    usqInt newChunk;
    usqInt newFreeStart;
    sqInt newObj;
    sqInt sizeHiBits;

	assert(size >= 0);
	hash = ((usqInt) GIV(freeStart)) >> BytesPerWord;

	/* Low 2 bits are 0 */

	classFormat = (longAt((classPointer + BaseHeaderSize) + (InstanceSpecificationIndex << ShiftForWord))) - 1;
	header1 = (classFormat & 130816) | ((hash & HashMaskUnshifted) << HashBitsOffset);
	header2 = classPointer;
	header3 = 0;
	sizeHiBits = ((usqInt) (classFormat & 393216)) >> 9;

	/* compact class field from format word */

	cClass = header1 & CompactClassMask;

	/* size in bytes -- low 2 bits are 0 */
	/* Note this byteSize comes from the format word of the class which is pre-shifted
		to 4 bytes per field.  Need another shift for 8 bytes per word... */

	byteSize = (classFormat & (SizeMask + Size4Bit)) + sizeHiBits;
	byteSize = byteSize << (ShiftForWord - 2);
	format = (((usqInt) classFormat) >> 8) & 15;
	flag("sizeLowBits");
	if (format < 8) {
		if (format == 6) {

			/* long32 bitmaps */

			bm1 = BytesPerWord - 1;

			/* round up */

			byteSize = ((byteSize + (size * 4)) + bm1) & LongSizeMask;

			/* odd bytes */
			/* extra low bit (4) for 64-bit VM goes in 4-bit (betw hdr bits and sizeBits) */

			binc = bm1 - (((size * 4) + bm1) & bm1);
			header1 = header1 | (binc & 4);
		}
		else {

			/* Arrays and 64-bit bitmaps */

			byteSize += size * BytesPerWord;
		}
	}
	else {

		/* Strings and Methods */

		bm1 = BytesPerWord - 1;

		/* round up */

		byteSize = ((byteSize + size) + bm1) & LongSizeMask;

		/* odd bytes */
		/* low bits of byte size go in format field */

		binc = bm1 - ((size + bm1) & bm1);

		/* extra low bit (4) for 64-bit VM goes in 4-bit (betw hdr bits and sizeBits) */

		header1 = header1 | ((binc & 3) << 8);
		header1 = header1 | (binc & 4);
	}
	if (byteSize > 255) {

		/* requires size header word */

		header3 = byteSize;
		header1 = header1;
	}
	else {
		header1 = header1 | byteSize;
	}
	if (header3 > 0) {

		/* requires full header */

		hdrSize = 3;
	}
	else {
		if (cClass == 0) {
			hdrSize = 2;
		}
		else {
			hdrSize = 1;
		}
	}
	/* begin eeAllocate:headerSize:h1:h2:h3:doFill:format: */
	/* begin allocateInterpreterChunk: */
	newChunk = GIV(freeStart);
	newFreeStart = GIV(freeStart) + (byteSize + ((hdrSize - 1) * BytesPerWord));
	if (newFreeStart < GIV(scavengeThreshold)) {
		if ((AllocationCheckFiller != 0)
		 && ((longAt(newChunk)) != ((AllocationCheckFiller == 182275669
	? newChunk
	: AllocationCheckFiller)))) {
			error("last object overwritten");
		}
		GIV(freeStart) = newFreeStart;
		newObj = oopForPointer(newChunk);
		goto l1;
	}
	if (GIV(freeStart) < GIV(scavengeThreshold)) {
		/* begin scheduleIncrementalGC */
		GIV(needGCFlag) = 1;
		forceInterruptCheck();
	}
	if (newFreeStart < GIV(reserveStart)) {
		GIV(freeStart) = newFreeStart;
		newObj = oopForPointer(newChunk);
		goto l1;
	}
	/* begin scheduleIncrementalGC */
	GIV(needGCFlag) = 1;
	forceInterruptCheck();
	if (GIV(freeStart) <= GIV(endOfMemory)) {
		GIV(freeStart) = newFreeStart;
		newObj = oopForPointer(newChunk);
		goto l1;
	}
	error("out of memory");
	newObj = null;
l1:	/* end allocateInterpreterChunk: */;
	if (newObj == 0) {
		return newObj;
	}
	if (hdrSize == 3) {
		longAtput(newObj, header3 | HeaderTypeSizeAndClass);
		longAtput(newObj + BytesPerWord, header2 | HeaderTypeSizeAndClass);
		longAtput(newObj + (BytesPerWord * 2), header1 | HeaderTypeSizeAndClass);
		newObj += BytesPerWord * 2;
	}
	if (hdrSize == 2) {
		longAtput(newObj, header2 | HeaderTypeClass);
		longAtput(newObj + BytesPerWord, header1 | HeaderTypeClass);
		newObj += BytesPerWord;
	}
	if (hdrSize == 1) {
		longAtput(newObj, header1 | HeaderTypeShort);
	}
	if (1) {
		fillWord = (format <= 4
			? GIV(nilObj)
			: 0);
		end = newObj + byteSize;
		i = newObj + BytesPerWord;
		while (i < end) {
			longAtput(i, fillWord);
			i += BytesPerWord;
		}
	}
	if (DoExpensiveAssertionChecks) {
		okayOop(newObj);
		oopHasOkayClass(newObj);
		if (!((safeObjectAfter(newObj)) == GIV(freeStart))) {
			error("allocate bug: did not set header of new oop correctly");
		}
	}
	return newObj;
}


/*	NOTE: This method supports the backward-compatible split instSize field of
	the 
	class format word. The sizeHiBits will go away and other shifts change by
	2 
	when the split fields get merged in an (incompatible) image change.
	Will *not* cause a GC.
	Note that the instantiated object IS NOT FILLED and must be completed
	before returning it to Smalltalk. Since this call is used in routines that
	do just that we are
	safe. Break this rule and die. */

sqInt
eeInstantiateClassindexableSize(sqInt classPointer, sqInt size)
{   DECL_MAYBE_SQ_GLOBAL_STRUCT
    sqInt binc;
    sqInt bm1;
    sqInt byteSize;
    sqInt cClass;
    sqInt classFormat;
    sqInt format;
    sqInt hash;
    sqInt hdrSize;
    sqInt header1;
    sqInt header2;
    sqInt header3;
    usqInt newChunk;
    usqInt newFreeStart;
    sqInt newObj;
    sqInt sizeHiBits;

	assert(size >= 0);
	hash = ((usqInt) GIV(freeStart)) >> BytesPerWord;

	/* Low 2 bits are 0 */

	classFormat = (longAt((classPointer + BaseHeaderSize) + (InstanceSpecificationIndex << ShiftForWord))) - 1;
	header1 = (classFormat & 130816) | ((hash & HashMaskUnshifted) << HashBitsOffset);
	header2 = classPointer;
	header3 = 0;
	sizeHiBits = ((usqInt) (classFormat & 393216)) >> 9;

	/* compact class field from format word */

	cClass = header1 & CompactClassMask;

	/* size in bytes -- low 2 bits are 0 */
	/* Note this byteSize comes from the format word of the class which is pre-shifted
		to 4 bytes per field.  Need another shift for 8 bytes per word... */

	byteSize = (classFormat & (SizeMask + Size4Bit)) + sizeHiBits;
	byteSize = byteSize << (ShiftForWord - 2);
	format = (((usqInt) classFormat) >> 8) & 15;
	flag("sizeLowBits");
	if (format < 8) {
		if (format == 6) {

			/* long32 bitmaps */

			bm1 = BytesPerWord - 1;

			/* round up */

			byteSize = ((byteSize + (size * 4)) + bm1) & LongSizeMask;

			/* odd bytes */
			/* extra low bit (4) for 64-bit VM goes in 4-bit (betw hdr bits and sizeBits) */

			binc = bm1 - (((size * 4) + bm1) & bm1);
			header1 = header1 | (binc & 4);
		}
		else {

			/* Arrays and 64-bit bitmaps */

			byteSize += size * BytesPerWord;
		}
	}
	else {

		/* Strings and Methods */

		bm1 = BytesPerWord - 1;

		/* round up */

		byteSize = ((byteSize + size) + bm1) & LongSizeMask;

		/* odd bytes */
		/* low bits of byte size go in format field */

		binc = bm1 - ((size + bm1) & bm1);

		/* extra low bit (4) for 64-bit VM goes in 4-bit (betw hdr bits and sizeBits) */

		header1 = header1 | ((binc & 3) << 8);
		header1 = header1 | (binc & 4);
	}
	if (byteSize > 255) {

		/* requires size header word */

		header3 = byteSize;
		header1 = header1;
	}
	else {
		header1 = header1 | byteSize;
	}
	if (header3 > 0) {

		/* requires full header */

		hdrSize = 3;
	}
	else {
		if (cClass == 0) {
			hdrSize = 2;
		}
		else {
			hdrSize = 1;
		}
	}
	/* begin eeAllocate:headerSize:h1:h2:h3: */
	/* begin allocateInterpreterChunk: */
	newChunk = GIV(freeStart);
	newFreeStart = GIV(freeStart) + (byteSize + ((hdrSize - 1) * BytesPerWord));
	if (newFreeStart < GIV(scavengeThreshold)) {
		if ((AllocationCheckFiller != 0)
		 && ((longAt(newChunk)) != ((AllocationCheckFiller == 182275669
	? newChunk
	: AllocationCheckFiller)))) {
			error("last object overwritten");
		}
		GIV(freeStart) = newFreeStart;
		newObj = oopForPointer(newChunk);
		goto l1;
	}
	if (GIV(freeStart) < GIV(scavengeThreshold)) {
		/* begin scheduleIncrementalGC */
		GIV(needGCFlag) = 1;
		forceInterruptCheck();
	}
	if (newFreeStart < GIV(reserveStart)) {
		GIV(freeStart) = newFreeStart;
		newObj = oopForPointer(newChunk);
		goto l1;
	}
	/* begin scheduleIncrementalGC */
	GIV(needGCFlag) = 1;
	forceInterruptCheck();
	if (GIV(freeStart) <= GIV(endOfMemory)) {
		GIV(freeStart) = newFreeStart;
		newObj = oopForPointer(newChunk);
		goto l1;
	}
	error("out of memory");
	newObj = null;
l1:	/* end allocateInterpreterChunk: */;
	if (newObj == 0) {
		return newObj;
	}
	if (hdrSize == 3) {
		longAtput(newObj, header3 | HeaderTypeSizeAndClass);
		longAtput(newObj + BytesPerWord, header2 | HeaderTypeSizeAndClass);
		longAtput(newObj + (BytesPerWord * 2), header1 | HeaderTypeSizeAndClass);
		newObj += BytesPerWord * 2;
	}
	if (hdrSize == 2) {
		longAtput(newObj, header2 | HeaderTypeClass);
		longAtput(newObj + BytesPerWord, header1 | HeaderTypeClass);
		newObj += BytesPerWord;
	}
	if (hdrSize == 1) {
		longAtput(newObj, header1 | HeaderTypeShort);
	}
	if (DoExpensiveAssertionChecks) {
		okayOop(newObj);
		oopHasOkayClass(newObj);
		if (!((safeObjectAfter(newObj)) == GIV(freeStart))) {
			error("allocate bug: did not set header of new oop correctly");
		}
	}
	return newObj;
}


/*	This version of instantiateClass assumes that the total object
	size is under 256 bytes, the limit for objects with only one or
	two header words. Note that the size is specified in bytes
	and should include 4 or 8 bytes for the base header word.
	NOTE this code will only work for sizes that are an integral number of
	words (like not a 32-bit LargeInteger in a 64-bit system).
	Will *not* cause a GC.
	Note that the created small object IS NOT FILLED and must be completed
	before returning it to Squeak.
	Since this call is used in routines that do just that we are safe. Break
	this rule and die. */
/*	size must be integral number of words */

static sqInt
eeInstantiateSmallClasssizeInBytes(sqInt classPointer, sqInt sizeInBytes)
{   DECL_MAYBE_SQ_GLOBAL_STRUCT
    sqInt hash;
    sqInt hdrSize;
    sqInt header1;
    sqInt header2;
    usqInt newChunk;
    usqInt newFreeStart;
    sqInt newObj;

	assert((sizeInBytes & (BytesPerWord - 1)) == 0);
	hash = ((usqInt) GIV(freeStart)) >> BytesPerWord;
	header1 = ((hash & HashMaskUnshifted) << HashBitsOffset) | ((longAt((classPointer + BaseHeaderSize) + (InstanceSpecificationIndex << ShiftForWord))) - 1);
	header2 = classPointer;
	hdrSize = ((header1 & CompactClassMask) > 0
		? 1
		: 2);
	header1 += sizeInBytes - (header1 & (SizeMask + Size4Bit));
	/* begin eeAllocate:headerSize:h1:h2:h3: */
	/* begin allocateInterpreterChunk: */
	newChunk = GIV(freeStart);
	newFreeStart = GIV(freeStart) + (sizeInBytes + ((hdrSize - 1) * BytesPerWord));
	if (newFreeStart < GIV(scavengeThreshold)) {
		if ((AllocationCheckFiller != 0)
		 && ((longAt(newChunk)) != ((AllocationCheckFiller == 182275669
	? newChunk
	: AllocationCheckFiller)))) {
			error("last object overwritten");
		}
		GIV(freeStart) = newFreeStart;
		newObj = oopForPointer(newChunk);
		goto l1;
	}
	if (GIV(freeStart) < GIV(scavengeThreshold)) {
		/* begin scheduleIncrementalGC */
		GIV(needGCFlag) = 1;
		forceInterruptCheck();
	}
	if (newFreeStart < GIV(reserveStart)) {
		GIV(freeStart) = newFreeStart;
		newObj = oopForPointer(newChunk);
		goto l1;
	}
	/* begin scheduleIncrementalGC */
	GIV(needGCFlag) = 1;
	forceInterruptCheck();
	if (GIV(freeStart) <= GIV(endOfMemory)) {
		GIV(freeStart) = newFreeStart;
		newObj = oopForPointer(newChunk);
		goto l1;
	}
	error("out of memory");
	newObj = null;
l1:	/* end allocateInterpreterChunk: */;
	if (newObj == 0) {
		return newObj;
	}
	if (hdrSize == 3) {
		longAtput(newObj, 0 | HeaderTypeSizeAndClass);
		longAtput(newObj + BytesPerWord, header2 | HeaderTypeSizeAndClass);
		longAtput(newObj + (BytesPerWord * 2), header1 | HeaderTypeSizeAndClass);
		newObj += BytesPerWord * 2;
	}
	if (hdrSize == 2) {
		longAtput(newObj, header2 | HeaderTypeClass);
		longAtput(newObj + BytesPerWord, header1 | HeaderTypeClass);
		newObj += BytesPerWord;
	}
	if (hdrSize == 1) {
		longAtput(newObj, header1 | HeaderTypeShort);
	}
	if (DoExpensiveAssertionChecks) {
		okayOop(newObj);
		oopHasOkayClass(newObj);
		if (!((safeObjectAfter(newObj)) == GIV(freeStart))) {
			error("allocate bug: did not set header of new oop correctly");
		}
	}
	return newObj;
}


/*	Encode the mcpc in cogMethod as a value that can be stashed in a context.
	Mapping native pcs to bytecode pcs is quite expensive, requiring a search
	through the method map. We mitigate this cost by deferring mapping until
	we really have to, which is when a context's instruction pointer is
	accessed by Smalltalk code. But to defer mapping we have to be able to
	distinguish machine code from bytecode pcs, which we do by using negative
	values for
	machine code pcs.
	
	As a whorish performance hack we also include the block method offset in
	the pc of a block. The least significant 16 bits are the native pc and the
	most significant 15 bits are the block start, in block alignment units. So
	when mapping back we can find the start of the block.
	
	See mustMapMachineCodePC:context: for the code that does the actual
	mapping.  */

static sqInt
encodedNativePCOfcogMethod(sqInt mcpc, CogBlockMethod *cogMethod)
{
    sqInt blockOffset;
    CogMethod *homeMethod;

	if (mcpc == (ceCannotResumePC())) {
		return HasBeenReturnedFromMCPC;
	}
	if (((cogMethod->cmType)) == CMMethod) {
		return ((((((sqInt)cogMethod)) - mcpc) << 1) | 1);
	}
	homeMethod = cmHomeMethod(cogMethod);
	blockOffset = ((((sqInt)homeMethod)) - (((sqInt)cogMethod))) / (sizeof(CogBlockMethod));
	return ((((((usqInt) blockOffset << 16)) | (((((sqInt)cogMethod)) - mcpc) & 65535)) << 1) | 1);
}


/*	Answerr the caller context for a frame. If the frame has a caller
	frame that doesn't have a context, then marry the caller frame. */

static sqInt
ensureCallerContext(char *theFP)
{   DECL_MAYBE_SQ_GLOBAL_STRUCT
    sqInt callerContextOrNil;
    char *callerFP;
    sqInt index;
    StackPage *thePage;
    char *theSP;

	/* begin frameCallerFP: */
	callerFP = pointerForOop(longAt(theFP + FoxSavedFP));
	if (callerFP == 0) {
		/* begin frameCallerContext: */
		assert(isBaseFrame(theFP));
		/* begin stackPageFor: */
		/* begin stackPageAt: */
		/* begin pageIndexFor: */
		assert((((((char *) theFP)) >= (GIV(stackBasePlus1) - 1)) && ((((char *) theFP)) <= (((char *) GIV(pages))))));
		index = pageIndexForstackBasePlus1bytesPerPage(theFP, GIV(stackBasePlus1), GIV(bytesPerPage));
		thePage = stackPageAtpages(index, GIV(pages));
		callerContextOrNil = longAt((thePage->baseAddress));
		assert(addressCouldBeObj(callerContextOrNil));
		assert((callerContextOrNil == (nilObject()))
		 || (isContext(callerContextOrNil)));
		return callerContextOrNil;
	}
	/* begin ensureFrameIsMarried:SP: */
	VM_LABEL(12ensureFrameIsMarriedSP);
	/* begin frameCallerStackPointer: */
	assert(!(isBaseFrame(theFP)));
	theSP = (theFP + ((FoxCallerSavedIP + BytesPerWord) + ((((((usqInt)(longAt(theFP + FoxMethod)))) < heapBase
	? (mframeCogMethod(theFP)->cmNumArgs)
	: byteAt((theFP + FoxIFrameFlags) + 1))) << ShiftForWord))) + BytesPerWord;
	if (((((usqInt)(longAt(callerFP + FoxMethod)))) < heapBase
		? ((longAt(callerFP + FoxMethod)) & MFMethodFlagHasContextFlag) != 0
		: (byteAt((callerFP + FoxIFrameFlags) + 2)) != 0)) {
		assert(isContext(frameContext(callerFP)));
		return longAt(callerFP + FoxThisContext);
	}
	return marryFrameSP(callerFP, theSP);
}


/*	Safety to give the JIT lattitude in calling convention. Conceptually,
	returning a value to a context involves pushing that value onto the stack.
	This is used
	in Squeak methods such as ContextPart>>jump
	jump
	| top |
	thisContext sender push: nil.
	stackp = 0 ifTrue: [self stepToSendOrReturn].
	stackp = 0 ifTrue: [self push: nil].
	top := self pop.
	thisContext privSender: self.
	^top
	Here jump may pop the value of a temporary variable off the stack which
	will, conceptually and, in the interpreter, actually, get pushed back on
	return. But
	if the JIT is mapping the stack to registers disaster may ensue since the
	value may not get pushed to the stack and code may access an invalid value
	(e.g. a pc).
	
	The solution is to fall back on the interpreter. If the stack pointer is
	changed we
	also ensure the pc is a bytecode pc (+ive) which will cause
	makeBaseFrameFor: to create an interpreter frame if the context is
	executed again. */

static void
ensureContextIsExecutionSafeAfterAssignToStackPointer(sqInt aContext)
{
    sqInt pc;

	assert(!(isMarriedOrWidowedContext(aContext)));
	pc = longAt((aContext + BaseHeaderSize) + (InstructionPointerIndex << ShiftForWord));
	if (((pc & 1))
	 && (((pc = (pc >> 1))) < 0)) {
		pc = mustMapMachineCodePCcontext(pc, aContext);
		longAtput((aContext + BaseHeaderSize) + (InstructionPointerIndex << ShiftForWord), pc);
	}
}


/*	Ensure the image data has been updayed to suit the current VM. */

static void
ensureImageFormatIsUpToDate(sqInt swapBytes)
{   DECL_MAYBE_SQ_GLOBAL_STRUCT
    sqInt addr;
    sqInt addr1;
    sqInt addr2;
    sqInt fmt;
    sqInt header;
    sqInt header1;
    sqInt methodHeader;
    sqInt oop;
    sqInt oop1;
    sqInt stopAddr1;
    sqInt stopAddr2;
    sqInt swapFloatWords;
    sqInt sz;
    sqInt sz1;
    sqInt temp;
    sqInt temp1;
    sqInt wordAddr;

	if (swapBytes) {
		/* begin reverseBytesInImage */
		VM_LABEL(0reverseBytesInImage);
		/* begin reverseBytesFrom:to: */
		flag("Dan");
		addr = heapBase;
		while ((((usqInt) addr)) < (((usqInt) GIV(endOfMemory)))) {
			longAtput(addr, byteSwapped(longAt(addr)));
			addr += BytesPerWord;
		}
		/* begin updateObjectsPostByteSwapFrom:to: */
		VM_LABEL(0updateObjectsPostByteSwapFromto);
		swapFloatWords = ((VMBIGENDIAN
	? 1
	: 0)) != GIV(imageFloatsBigEndian);
		assert(ClassFloatCompactIndex != 0);
		oop1 = heapBase + (headerTypeBytes[(longAt(heapBase)) & TypeMask]);
		while ((((usqInt) oop1)) < (((usqInt) GIV(endOfMemory)))) {
			if (!(((longAt(oop1)) & TypeMask) == HeaderTypeFree)) {
				fmt = (((usqInt) (longAt(oop1))) >> 8) & 15;
				if (fmt >= 8) {

					/* oop contains bytes */

					wordAddr = oop1 + BaseHeaderSize;
					if (fmt >= 12) {

						/* compiled method; start after methodHeader and literals */

						methodHeader = longAt(oop1 + BaseHeaderSize);
						wordAddr = (wordAddr + BytesPerWord) + (((((usqInt) methodHeader) >> 10) & 255) * BytesPerWord);
					}
					/* begin reverseBytesFrom:to: */
					stopAddr1 = oop1 + (sizeBitsOf(oop1));
					flag("Dan");
					addr2 = wordAddr;
					while ((((usqInt) addr2)) < (((usqInt) stopAddr1))) {
						longAtput(addr2, byteSwapped(longAt(addr2)));
						addr2 += BytesPerWord;
					}
				}
				if (fmt == 6) {
					if (swapFloatWords
					 && (((((usqInt) (longAt(oop1))) >> 12) & 31) == ClassFloatCompactIndex)) {
						temp1 = longAt(oop1 + BaseHeaderSize);
						longAtput(oop1 + BaseHeaderSize, longAt((oop1 + BaseHeaderSize) + 4));
						longAtput((oop1 + BaseHeaderSize) + 4, temp1);
					}
					else {
						if (BytesPerWord == 8) {

							/* Object contains 32-bit half-words packed into 64-bit machine words. */

							wordAddr = oop1 + BaseHeaderSize;
							/* begin reverseWordsFrom:to: */
							stopAddr2 = oop1 + (sizeBitsOf(oop1));
							addr1 = wordAddr;
							while ((((usqInt) addr1)) < (((usqInt) stopAddr2))) {
								longAtput(addr1, wordSwapped(longAt(addr1)));
								addr1 += BytesPerWord;
							}
						}
					}
				}
			}
			/* begin objectAfter: */
			if (DoAssertionChecks) {
				if ((((usqInt) oop1)) >= (((usqInt) GIV(endOfMemory)))) {
					error("no objects after the end of memory");
				}
			}
			if (((longAt(oop1)) & TypeMask) == HeaderTypeFree) {
				sz1 = (longAt(oop1)) & AllButTypeMask;
			}
			else {
				/* begin sizeBitsOf: */
				header1 = longAt(oop1);
				sz1 = ((header1 & TypeMask) == HeaderTypeSizeAndClass
					? (longAt(oop1 - (BytesPerWord * 2))) & LongSizeMask
					: header1 & SizeMask);
			}
			oop1 = (oop1 + sz1) + (headerTypeBytes[(longAt(oop1 + sz1)) & TypeMask]);
		}
	}
	else {
		/* begin convertFloatsToPlatformOrderFrom:to: */
		VM_LABEL(0convertFloatsToPlatformOrderFromto);
		if (((VMBIGENDIAN
	? 1
	: 0)) == GIV(imageFloatsBigEndian)) {
			goto l1;
		}
		assert(ClassFloatCompactIndex != 0);
		oop = heapBase + (headerTypeBytes[(longAt(heapBase)) & TypeMask]);
		while ((((usqInt) oop)) < (((usqInt) GIV(endOfMemory)))) {
			if (!(((longAt(oop)) & TypeMask) == HeaderTypeFree)) {
				if (((((usqInt) (longAt(oop))) >> 12) & 31) == ClassFloatCompactIndex) {
					temp = longAt(oop + BaseHeaderSize);
					longAtput(oop + BaseHeaderSize, longAt((oop + BaseHeaderSize) + 4));
					longAtput((oop + BaseHeaderSize) + 4, temp);
				}
			}
			/* begin objectAfter: */
			if (DoAssertionChecks) {
				if ((((usqInt) oop)) >= (((usqInt) GIV(endOfMemory)))) {
					error("no objects after the end of memory");
				}
			}
			if (((longAt(oop)) & TypeMask) == HeaderTypeFree) {
				sz = (longAt(oop)) & AllButTypeMask;
			}
			else {
				/* begin sizeBitsOf: */
				header = longAt(oop);
				sz = ((header & TypeMask) == HeaderTypeSizeAndClass
					? (longAt(oop - (BytesPerWord * 2))) & LongSizeMask
					: header & SizeMask);
			}
			oop = (oop + sz) + (headerTypeBytes[(longAt(oop + sz)) & TypeMask]);
		}
	l1:	/* end convertFloatsToPlatformOrderFrom:to: */;
	}
}


/*	convert
	rcvr	base
	arg(s)
	retpc	<- sp
	to
	retpc	base
	entrypc
	rcvr
	arg(s)	<- sp
	and then enter at either the checked or the unchecked entry-point. */

static void
enterRegisterArgCogMethodatreceiver(CogMethod *cogMethod, sqInt entryOffset, sqInt rcvr)
{   DECL_MAYBE_SQ_GLOBAL_STRUCT
    sqInt object;
    sqInt object1;
    char *sp;
    char *sp1;
    char *sp2;

	
#  if (numRegArgs()) > 0
	assert(((numRegArgs()) > 0)
	 && ((numRegArgs()) <= 2));
	if (((cogMethod->cmNumArgs)) == 2) {
		longAtput(GIV(stackPointer) + (3 * BytesPerWord), longAt(GIV(stackPointer)));
		/* begin push: */
		object = longAt(GIV(stackPointer) + (1 * BytesPerWord));
		longAtput(sp = GIV(stackPointer) - BytesPerWord, object);
		GIV(stackPointer) = sp;
		longAtput(GIV(stackPointer) + (1 * BytesPerWord), longAt(GIV(stackPointer) + (3 * BytesPerWord)));
		longAtput(GIV(stackPointer) + (2 * BytesPerWord), rcvr);
		longAtput(GIV(stackPointer) + (3 * BytesPerWord), (((sqInt)cogMethod)) + entryOffset);
		ceEnterCogCodePopReceiverArg1Arg0Regs();
	}
	if (((cogMethod->cmNumArgs)) == 1) {
		longAtput(GIV(stackPointer) + (2 * BytesPerWord), longAt(GIV(stackPointer)));
		/* begin push: */
		object1 = longAt(GIV(stackPointer) + (1 * BytesPerWord));
		longAtput(sp1 = GIV(stackPointer) - BytesPerWord, object1);
		GIV(stackPointer) = sp1;
		longAtput(GIV(stackPointer) + (1 * BytesPerWord), rcvr);
		longAtput(GIV(stackPointer) + (2 * BytesPerWord), (((sqInt)cogMethod)) + entryOffset);
		ceEnterCogCodePopReceiverArg0Regs();
	}
	assert(((cogMethod->cmNumArgs)) == 0);
	longAtput(GIV(stackPointer) + (1 * BytesPerWord), longAt(GIV(stackPointer)));
	longAtput(GIV(stackPointer) + (0 * BytesPerWord), (((sqInt)cogMethod)) + entryOffset);
	/* begin push: */
	longAtput(sp2 = GIV(stackPointer) - BytesPerWord, rcvr);
	GIV(stackPointer) = sp2;
	ceEnterCogCodePopReceiverReg();

#  else /* (numRegArgs()) > 0 */
	assert(0);

#  endif /* (numRegArgs()) > 0 */

}


/*	Main entry-point into the interpreter at each execution level, where an
	execution level is either the start of execution or reentry for a
	callback. Capture the C stack
	pointers so that calls from machine-code into the C run-time occur at this
	level. This is the actual implementation, separated from
	enterSmalltalkExecutive so the
	simulator can wrap it in an exception handler and hence simulate the
	setjmp/longjmp.  */

static sqInt
enterSmalltalkExecutiveImplementation(void)
{   DECL_MAYBE_SQ_GLOBAL_STRUCT
	assertCStackWellAligned();
	ceCaptureCStackPointers();
	sigsetjmp(reenterInterpreter, 0);
	if ((((usqInt)(longAt(GIV(framePointer) + FoxMethod)))) < heapBase) {
		returnToExecutivepostContextSwitch(0, 1);
	}
	/* begin setMethod: */
	assert((((usqInt)(longAt(GIV(framePointer) + FoxMethod)))) >= (startOfMemory()));
	GIV(method) = longAt(GIV(framePointer) + FoxMethod);
	if (GIV(instructionPointer) == (ceReturnToInterpreterPC())) {
		GIV(instructionPointer) = longAt(GIV(framePointer) + FoxIFSavedIP);
	}
	assertValidExecutionPointersimbar(GIV(instructionPointer), GIV(framePointer), GIV(stackPointer), 1);
	interpret();
	return 0;
}

static char *
establishFrameForContextToReturnTo(sqInt contextToReturnTo)
{
    StackPage *thePage;
    sqInt value;

	if (!(((contextToReturnTo & 1) == 0)
		 && (((((usqInt) (longAt(contextToReturnTo))) >> 12) & 31) == ClassMethodContextCompactIndex))) {
		return 0;
	}
	if (((longAt((contextToReturnTo + BaseHeaderSize) + (SenderIndex << ShiftForWord))) & 1)) {
		if (isWidowedContext(contextToReturnTo)) {
			return 0;
		}
		/* begin frameOfMarriedContext: */
		value = longAt((contextToReturnTo + BaseHeaderSize) + (SenderIndex << ShiftForWord));
		/* begin withoutSmallIntegerTags: */
		assert((value & 1));
		return pointerForOop(value - 1);
	}
	if (!(((longAt((contextToReturnTo + BaseHeaderSize) + (InstructionPointerIndex << ShiftForWord))) & 1))) {
		return 0;
	}
	thePage = makeBaseFrameFor(contextToReturnTo);
	markStackPageMostRecentlyUsed(thePage);
	return (thePage->baseFP);
}


/*	Execute a CogMethod from a linked send. The receiver,
	arguments and return address are on the Smalltalk stack. First
	push the entry-point and finally the register argument(s). Then write
	back the frame pointers and call the routine that will pop off the
	register argument(s) and jump to the entry by executing a return
	instruction. 
	In the simple jit only the receiver gets passed in registers, so only the
	receiver gets pushed. */

void
executeCogMethodFromLinkedSendwithReceiver(CogMethod *cogMethod, sqInt rcvr)
{   DECL_MAYBE_SQ_GLOBAL_STRUCT
    sqInt object;
    char *sp;
    char *sp1;

	assertCStackWellAligned();
	assert(isMachineCodeFrame(GIV(framePointer)));
	assertValidExecutionPointersimbar(longAt(GIV(stackPointer)), GIV(framePointer), GIV(stackPointer), 0);
	
#  if (numRegArgs()) > 0
	if (((cogMethod->cmNumArgs)) <= (numRegArgs())) {
		enterRegisterArgCogMethodatreceiver(cogMethod, entryOffset(), rcvr);
	}

#  endif /* (numRegArgs()) > 0 */

	/* begin push: */
	object = (((sqInt)cogMethod)) + (entryOffset());
	longAtput(sp = GIV(stackPointer) - BytesPerWord, object);
	GIV(stackPointer) = sp;
	/* begin push: */
	longAtput(sp1 = GIV(stackPointer) - BytesPerWord, rcvr);
	GIV(stackPointer) = sp1;
	ceEnterCogCodePopReceiverReg();
}


/*	Execute a CogMethod from a linked send. The receiver,
	arguments and return address are on the Smalltalk stack. First
	push the entry-point and finally the register argument(s). Then write
	back the frame pointers and call the routine that will pop off the
	register argument(s) and jump to the entry by executing a return
	instruction. 
	In the simple jit only the receiver gets passed in registers, so only the
	receiver gets pushed. */

void
executeCogMethodFromLinkedSendwithReceiverandCacheTag(CogMethod *cogMethod, sqInt rcvr, sqInt cacheTag)
{   DECL_MAYBE_SQ_GLOBAL_STRUCT
    sqInt object;
    char *sp;
    char *sp1;
    char *sp2;
    char *sp3;

	assertCStackWellAligned();
	assert(isMachineCodeFrame(GIV(framePointer)));
	assertValidExecutionPointersimbar(longAt(GIV(stackPointer)), GIV(framePointer), GIV(stackPointer), 0);
	/* begin push: */
	object = (((sqInt)cogMethod)) + (entryOffset());
	longAtput(sp1 = GIV(stackPointer) - BytesPerWord, object);
	GIV(stackPointer) = sp1;
	
#  if (numRegArgs()) > 0
	if (((cogMethod->cmNumArgs)) <= (numRegArgs())) {
		assert((numRegArgs()) <= 2);
		/* begin push: */
		longAtput(sp = GIV(stackPointer) - BytesPerWord, cacheTag);
		GIV(stackPointer) = sp;
		if (((cogMethod->cmNumArgs)) == 0) {
			ceEnter0ArgsPIC();
		}
		if (((cogMethod->cmNumArgs)) == 1) {
			ceEnter1ArgsPIC();
		}
		if (((cogMethod->cmNumArgs)) == 2) {
			ceEnter2ArgsPIC();
		}
		error("not reached");
	}

#  endif /* (numRegArgs()) > 0 */

	/* begin push: */
	longAtput(sp2 = GIV(stackPointer) - BytesPerWord, rcvr);
	GIV(stackPointer) = sp2;
	/* begin push: */
	longAtput(sp3 = GIV(stackPointer) - BytesPerWord, cacheTag);
	GIV(stackPointer) = sp3;
	ceEnterCogCodePopReceiverAndClassRegs();
}


/*	Execute a CogMethod from an unlinked send. The receiver,
	arguments and return address are on the Smalltalk stack. First
	push the entry-point and finally the register argument(s). Then write
	back the frame pointers and call the routine that will pop off the
	register argument(s) and jump to the entry by executing a return
	instruction. 
	In the simple jit only the receiver gets passed in registers, so only the
	receiver gets pushed. */

static void
executeCogMethodFromUnlinkedSendwithReceiver(CogMethod *cogMethod, sqInt rcvr)
{   DECL_MAYBE_SQ_GLOBAL_STRUCT
    sqInt object;
    char *sp;
    char *sp1;

	assertCStackWellAligned();
	assert(isMachineCodeFrame(GIV(framePointer)));
	assertValidExecutionPointersimbar(longAt(GIV(stackPointer)), GIV(framePointer), GIV(stackPointer), 0);
	
#  if (numRegArgs()) > 0
	if (((cogMethod->cmNumArgs)) <= (numRegArgs())) {
		enterRegisterArgCogMethodatreceiver(cogMethod, noCheckEntryOffset(), rcvr);
	}

#  endif /* (numRegArgs()) > 0 */

	/* begin push: */
	object = (((sqInt)cogMethod)) + (noCheckEntryOffset());
	longAtput(sp = GIV(stackPointer) - BytesPerWord, object);
	GIV(stackPointer) = sp;
	/* begin push: */
	longAtput(sp1 = GIV(stackPointer) - BytesPerWord, rcvr);
	GIV(stackPointer) = sp1;
	ceEnterCogCodePopReceiverReg();
}


/*	Execute newMethod - either primitiveFunctionPointer must be set directly
	(i.e. from primitiveExecuteMethod et al), or it would have been set
	probing the method cache (i.e. primitivePerform et al).
	Eagerly compile it if appropriate so that doits are fast. */

static void
executeNewMethod(void)
{   DECL_MAYBE_SQ_GLOBAL_STRUCT
    sqInt inInterpreter;
    sqInt methodHeader;

	inInterpreter = GIV(instructionPointer) >= heapBase;
	if (primitiveFunctionPointer != 0) {
		if ((((unsigned long) primitiveFunctionPointer)) <= MaxQuickPrimitiveIndex) {
			externalQuickPrimitiveResponse();
			returntoExecutive(popStack(), inInterpreter);
			return;
		}
		if (slowPrimitiveResponse()) {
			returntoExecutive(popStack(), inInterpreter);
			return;
		}
	}
	methodHeader = longAt((GIV(newMethod) + BaseHeaderSize) + (HeaderIndex << ShiftForWord));
	if (!(isCogMethodReference(methodHeader))) {
		if (((((usqInt) methodHeader) >> 10) & 255) <= maxLiteralCountForCompile) {
			cogselector(GIV(newMethod), GIV(nilObj));
			methodHeader = longAt((GIV(newMethod) + BaseHeaderSize) + (HeaderIndex << ShiftForWord));
		}
		else {
			maybeFlagMethodAsInterpreted(GIV(newMethod));
		}
	}
	if (isCogMethodReference(methodHeader)) {
		if ((((usqInt)GIV(instructionPointer))) >= heapBase) {
			/* begin iframeSavedIP:put: */
			assert(!(isMachineCodeFrame(GIV(framePointer))));
			longAtput(GIV(framePointer) + FoxIFSavedIP, ((sqInt)GIV(instructionPointer)));
			GIV(instructionPointer) = ceReturnToInterpreterPC();
		}
		activateCoggedNewMethod(inInterpreter);
	}
	else {
		activateNewMethod();
	}
}


/*	Divorce a single frame and its context. If it is not the top frame of a
	stack this means splitting its stack. */

static void
externalDivorceFrameandContext(char *theFP, sqInt ctxt)
{   DECL_MAYBE_SQ_GLOBAL_STRUCT
    sqInt callerContextOrNil;
    sqInt callerCtx;
    char *callerFP;
    char *callerFP1;
    sqInt callerIP;
    char *callerSP;
    char *frameAbove;
    sqInt index;
    sqInt index1;
    StackPage *lruOrFree;
    StackPage *newPage;
    sqInt onCurrent;
    sqInt theIP;
    StackPage *thePage;
    StackPage *thePage1;
    char *theSP;
    char *theSP1;
    sqInt valuePointer;

	assert(theFP != GIV(framePointer));
	assert((GIV(stackPage) == 0)
	 || (GIV(stackPage) == (mostRecentlyUsedPage())));
	/* begin stackPageFor: */
	/* begin stackPageAt: */
	/* begin pageIndexFor: */
	assert((((((char *) theFP)) >= (GIV(stackBasePlus1) - 1)) && ((((char *) theFP)) <= (((char *) GIV(pages))))));
	index1 = pageIndexForstackBasePlus1bytesPerPage(theFP, GIV(stackBasePlus1), GIV(bytesPerPage));
	thePage = stackPageAtpages(index1, GIV(pages));
	if (!((onCurrent = thePage == GIV(stackPage)))) {
		markStackPageNextMostRecentlyUsed(thePage);
	}
	theSP = findSPOfon(theFP, thePage);
	updateStateOfSpouseContextForFrameWithSP(theFP, theSP);
	/* begin ensureCallerContext: */
	/* begin frameCallerFP: */
	callerFP1 = pointerForOop(longAt(theFP + FoxSavedFP));
	if (callerFP1 == 0) {
		/* begin frameCallerContext: */
		assert(isBaseFrame(theFP));
		/* begin stackPageFor: */
		/* begin stackPageAt: */
		/* begin pageIndexFor: */
		assert((((((char *) theFP)) >= (GIV(stackBasePlus1) - 1)) && ((((char *) theFP)) <= (((char *) GIV(pages))))));
		index = pageIndexForstackBasePlus1bytesPerPage(theFP, GIV(stackBasePlus1), GIV(bytesPerPage));
		thePage1 = stackPageAtpages(index, GIV(pages));
		callerContextOrNil = longAt((thePage1->baseAddress));
		assert(addressCouldBeObj(callerContextOrNil));
		assert((callerContextOrNil == (nilObject()))
		 || (isContext(callerContextOrNil)));
		callerCtx = callerContextOrNil;
		goto l1;
	}
	/* begin ensureFrameIsMarried:SP: */
	VM_LABEL(13ensureFrameIsMarriedSP);
	/* begin frameCallerStackPointer: */
	assert(!(isBaseFrame(theFP)));
	theSP1 = (theFP + ((FoxCallerSavedIP + BytesPerWord) + ((((((usqInt)(longAt(theFP + FoxMethod)))) < heapBase
	? (mframeCogMethod(theFP)->cmNumArgs)
	: byteAt((theFP + FoxIFrameFlags) + 1))) << ShiftForWord))) + BytesPerWord;
	if (((((usqInt)(longAt(callerFP1 + FoxMethod)))) < heapBase
		? ((longAt(callerFP1 + FoxMethod)) & MFMethodFlagHasContextFlag) != 0
		: (byteAt((callerFP1 + FoxIFrameFlags) + 2)) != 0)) {
		assert(isContext(frameContext(callerFP1)));
		callerCtx = longAt(callerFP1 + FoxThisContext);
		goto l3;
	}
	callerCtx = marryFrameSP(callerFP1, theSP1);
l3:	/* end ensureFrameIsMarried:SP: */;
l1:	/* end ensureCallerContext: */;
	if (((frameAbove = findFrameAboveinPage(theFP, thePage))) == 0) {

		/* If we're divorcing the top frame we can simply peel it off. */

		theIP = longAt((thePage->headSP));
	}
	else {
		/* begin newStackPage */
		lruOrFree = (mostRecentlyUsedPage()->nextPage);
		if (isFree(lruOrFree)) {
			newPage = lruOrFree;
			goto l2;
		}
		divorceFramesIn(lruOrFree);
		newPage = lruOrFree;
	l2:	/* end newStackPage */;
		theIP = oopForPointer(frameCallerSavedIP(frameAbove));
		frameAbove = moveFramesInthroughtoPage(thePage, frameAbove, newPage);
		if (onCurrent) {
			/* begin setStackPageAndLimit: */
			GIV(stackPage) = newPage;
			if (GIV(stackLimit) != (((char *) (((usqInt) -1))))) {
				GIV(stackLimit) = (GIV(stackPage)->stackLimit);
			}
			markStackPageMostRecentlyUsed(newPage);
			GIV(framePointer) = (GIV(stackPage)->headFP);
			GIV(stackPointer) = (GIV(stackPage)->headSP);
		}
		else {
			markStackPageMostRecentlyUsed(newPage);
		}
		assert((frameCallerContext(frameAbove)) == ctxt);
	}
	/* begin storePointerUnchecked:ofObject:withValue: */
	valuePointer = contextInstructionPointerframe(theIP, theFP);
	longAtput((ctxt + BaseHeaderSize) + (InstructionPointerIndex << ShiftForWord), valuePointer);
	/* begin storePointer:ofObject:withValue: */
	if ((((usqInt) ctxt)) < (((usqInt) GIV(youngStart)))) {
		possibleRootStoreIntovalue(ctxt, callerCtx);
	}
	longAtput((ctxt + BaseHeaderSize) + (SenderIndex << ShiftForWord), callerCtx);
	/* begin frameCallerFP: */
	callerFP = pointerForOop(longAt(theFP + FoxSavedFP));
	if (callerFP == 0) {
		/* begin freeStackPage: */
		freeStackPageNoAssert(thePage);
		assert(pageListIsWellFormed());
	}
	else {
		callerIP = oopForPointer(frameCallerSavedIP(theFP));
		callerSP = (frameCallerSP(theFP)) - BytesPerWord;
		longAtput(callerSP, callerIP);
		/* begin setHeadFP:andSP:inPage: */
		assert(callerSP < callerFP);
		assert((callerSP < ((thePage->baseAddress)))
		 && (callerSP > (((thePage->realStackLimit)) - LargeContextSize)));
		assert((callerFP < ((thePage->baseAddress)))
		 && (callerFP > (((thePage->realStackLimit)) - (((sqInt) LargeContextSize >> 1)))));
		(thePage->headFP = callerFP);
		(thePage->headSP = callerSP);
	}
}


/*	Ensure aFramePtr is a base frame. Then we can assign its sender.
	Answer the possibly moved location of the frame. */

static char *
externalEnsureIsBaseFrame(char *aFramePtr)
{   DECL_MAYBE_SQ_GLOBAL_STRUCT
    sqInt index;
    sqInt onCurrent;
    char *theFP;
    StackPage *thePage;

	if ((longAt(aFramePtr + FoxSavedFP)) == 0) {
		return aFramePtr;
	}
	theFP = aFramePtr;
	/* begin stackPageFor: */
	/* begin stackPageAt: */
	/* begin pageIndexFor: */
	assert((((((char *) theFP)) >= (GIV(stackBasePlus1) - 1)) && ((((char *) theFP)) <= (((char *) GIV(pages))))));
	index = pageIndexForstackBasePlus1bytesPerPage(theFP, GIV(stackBasePlus1), GIV(bytesPerPage));
	thePage = stackPageAtpages(index, GIV(pages));

	/* Storing the frame's sender with its caller's context
	 has the side effect of making theFP a base frame. */

	onCurrent = thePage == GIV(stackPage);
	theFP = storeSenderOfFramewithValue(theFP, ensureCallerContext(theFP));
	if (onCurrent) {
		assert(GIV(stackPage) != thePage);
		GIV(framePointer) = (GIV(stackPage)->headFP);
		GIV(stackPointer) = (GIV(stackPage)->headSP);
	}
	else {
		markStackPageMostRecentlyUsed(GIV(stackPage));
	}
	assert(pageListIsWellFormed());
	assert(GIV(stackPage) == (mostRecentlyUsedPage()));
	return theFP;
}


/*	Fetch an instance variable from a maybe married context.
	If the context is still married compute the value of the
	relevant inst var from the spouse frame's state.
	
	If the context is single but has a negative instruction pointer
	recognise that the instruction pointer is actually into machine
	code and convert it to the corresponding bytecode pc. */

static sqInt
externalInstVarofContext(sqInt offset, sqInt aContext)
{   DECL_MAYBE_SQ_GLOBAL_STRUCT
    sqInt callerContextOrNil;
    char *callerFP;
    char *callerFP1;
    char *fp;
    sqInt index;
    sqInt index1;
    char *spouseFP;
    char *theFPAbove;
    sqInt theIP;
    StackPage *thePage;
    StackPage *thePage1;
    char *theSP;
    sqInt value;
    sqInt value1;

	assert(isContext(aContext));
	/* begin externalWriteBackHeadFramePointers */
	assert((GIV(framePointer) - GIV(stackPointer)) < LargeContextSize);
	assert(GIV(stackPage) == (mostRecentlyUsedPage()));
	/* begin setHeadFP:andSP:inPage: */
	assert(GIV(stackPointer) < GIV(framePointer));
	assert((GIV(stackPointer) < ((GIV(stackPage)->baseAddress)))
	 && (GIV(stackPointer) > (((GIV(stackPage)->realStackLimit)) - LargeContextSize)));
	assert((GIV(framePointer) < ((GIV(stackPage)->baseAddress)))
	 && (GIV(framePointer) > (((GIV(stackPage)->realStackLimit)) - (((sqInt) LargeContextSize >> 1)))));
	(GIV(stackPage)->headFP = GIV(framePointer));
	(GIV(stackPage)->headSP = GIV(stackPointer));
	assert(pageListIsWellFormed());
	if (!((offset < MethodIndex)
		 && (((longAt((aContext + BaseHeaderSize) + (SenderIndex << ShiftForWord))) & 1)))) {
		value = longAt((aContext + BaseHeaderSize) + (offset << ShiftForWord));
		return ((offset == InstructionPointerIndex)
		 && (((value & 1))
 && ((((sqInt) value)) < 0))
			? mustMapMachineCodePCcontext((value >> 1), aContext)
			: value);
	}
	if (isWidowedContext(aContext)) {
		return longAt((aContext + BaseHeaderSize) + (offset << ShiftForWord));
	}
	/* begin frameOfMarriedContext: */
	value1 = longAt((aContext + BaseHeaderSize) + (SenderIndex << ShiftForWord));
	/* begin withoutSmallIntegerTags: */
	assert((value1 & 1));
	spouseFP = pointerForOop(value1 - 1);
	if (offset == SenderIndex) {
		/* begin ensureCallerContext: */
		/* begin frameCallerFP: */
		callerFP = pointerForOop(longAt(spouseFP + FoxSavedFP));
		if (callerFP == 0) {
			/* begin frameCallerContext: */
			assert(isBaseFrame(spouseFP));
			/* begin stackPageFor: */
			/* begin stackPageAt: */
			/* begin pageIndexFor: */
			assert((((((char *) spouseFP)) >= (GIV(stackBasePlus1) - 1)) && ((((char *) spouseFP)) <= (((char *) GIV(pages))))));
			index = pageIndexForstackBasePlus1bytesPerPage(spouseFP, GIV(stackBasePlus1), GIV(bytesPerPage));
			thePage1 = stackPageAtpages(index, GIV(pages));
			callerContextOrNil = longAt((thePage1->baseAddress));
			assert(addressCouldBeObj(callerContextOrNil));
			assert((callerContextOrNil == (nilObject()))
			 || (isContext(callerContextOrNil)));
			return callerContextOrNil;
		}
		/* begin ensureFrameIsMarried:SP: */
		VM_LABEL(14ensureFrameIsMarriedSP);
		/* begin frameCallerStackPointer: */
		assert(!(isBaseFrame(spouseFP)));
		theSP = (spouseFP + ((FoxCallerSavedIP + BytesPerWord) + ((((((usqInt)(longAt(spouseFP + FoxMethod)))) < heapBase
	? (mframeCogMethod(spouseFP)->cmNumArgs)
	: byteAt((spouseFP + FoxIFrameFlags) + 1))) << ShiftForWord))) + BytesPerWord;
		if (((((usqInt)(longAt(callerFP + FoxMethod)))) < heapBase
			? ((longAt(callerFP + FoxMethod)) & MFMethodFlagHasContextFlag) != 0
			: (byteAt((callerFP + FoxIFrameFlags) + 2)) != 0)) {
			assert(isContext(frameContext(callerFP)));
			return longAt(callerFP + FoxThisContext);
		}
		return marryFrameSP(callerFP, theSP);
	}
	if (offset == StackPointerIndex) {
		assert((ReceiverIndex + (stackPointerIndexForFrame(spouseFP))) < (lengthOf(aContext)));
		return (((stackPointerIndexForFrame(spouseFP)) << 1) | 1);
	}
	if (offset == InstructionPointerIndex) {
		if (spouseFP == GIV(framePointer)) {
			theIP = oopForPointer(GIV(instructionPointer));
		}
		else {
			/* begin stackPageFor: */
			/* begin stackPageAt: */
			/* begin pageIndexFor: */
			assert((((((char *) spouseFP)) >= (GIV(stackBasePlus1) - 1)) && ((((char *) spouseFP)) <= (((char *) GIV(pages))))));
			index1 = pageIndexForstackBasePlus1bytesPerPage(spouseFP, GIV(stackBasePlus1), GIV(bytesPerPage));
			thePage = stackPageAtpages(index1, GIV(pages));
			/* begin findFrameAbove:inPage: */
			fp = (thePage->headFP);
			if (fp == spouseFP) {
				theFPAbove = 0;
				goto l1;
			}
			while (((callerFP1 = frameCallerFP(fp))) != 0) {
				if (callerFP1 == spouseFP) {
					theFPAbove = fp;
					goto l1;
				}
				fp = callerFP1;
			}
			error("did not find theFP in stack page");
			theFPAbove = 0;
		l1:	/* end findFrameAbove:inPage: */;
			theIP = (theFPAbove == 0
				? longAt((thePage->headSP))
				: oopForPointer(frameCallerSavedIP(theFPAbove)));
		}
		value = contextInstructionPointerframe(theIP, spouseFP);
		return ((((sqInt) value)) < 0
			? mustMapMachineCodePCcontext((value >> 1), aContext)
			: value);
	}
	error("bad index");
	return 0;
}

static void
externalInstVarofContextput(sqInt index, sqInt maybeMarriedContext, sqInt anOop)
{   DECL_MAYBE_SQ_GLOBAL_STRUCT
    sqInt index1;
    sqInt onCurrentPage;
    char *theFP;
    StackPage *thePage;
    sqInt value;

	assert(isContext(maybeMarriedContext));
	/* begin externalWriteBackHeadFramePointers */
	assert((GIV(framePointer) - GIV(stackPointer)) < LargeContextSize);
	assert(GIV(stackPage) == (mostRecentlyUsedPage()));
	/* begin setHeadFP:andSP:inPage: */
	assert(GIV(stackPointer) < GIV(framePointer));
	assert((GIV(stackPointer) < ((GIV(stackPage)->baseAddress)))
	 && (GIV(stackPointer) > (((GIV(stackPage)->realStackLimit)) - LargeContextSize)));
	assert((GIV(framePointer) < ((GIV(stackPage)->baseAddress)))
	 && (GIV(framePointer) > (((GIV(stackPage)->realStackLimit)) - (((sqInt) LargeContextSize >> 1)))));
	(GIV(stackPage)->headFP = GIV(framePointer));
	(GIV(stackPage)->headSP = GIV(stackPointer));
	assert(pageListIsWellFormed());
	if (!((((longAt((maybeMarriedContext + BaseHeaderSize) + (SenderIndex << ShiftForWord))) & 1))
		 && (!(isWidowedContext(maybeMarriedContext))))) {
		/* begin storePointer:ofObject:withValue: */
		if ((((usqInt) maybeMarriedContext)) < (((usqInt) GIV(youngStart)))) {
			possibleRootStoreIntovalue(maybeMarriedContext, anOop);
		}
		longAtput((maybeMarriedContext + BaseHeaderSize) + (index << ShiftForWord), anOop);
		if (index == StackPointerIndex) {
			ensureContextIsExecutionSafeAfterAssignToStackPointer(maybeMarriedContext);
		}
		return;
	}
	/* begin frameOfMarriedContext: */
	value = longAt((maybeMarriedContext + BaseHeaderSize) + (SenderIndex << ShiftForWord));
	/* begin withoutSmallIntegerTags: */
	assert((value & 1));
	theFP = pointerForOop(value - 1);
	/* begin stackPageFor: */
	/* begin stackPageAt: */
	/* begin pageIndexFor: */
	assert((((((char *) theFP)) >= (GIV(stackBasePlus1) - 1)) && ((((char *) theFP)) <= (((char *) GIV(pages))))));
	index1 = pageIndexForstackBasePlus1bytesPerPage(theFP, GIV(stackBasePlus1), GIV(bytesPerPage));
	thePage = stackPageAtpages(index1, GIV(pages));
	assert(GIV(stackPage) == (mostRecentlyUsedPage()));
	onCurrentPage = thePage == GIV(stackPage);
	if (index == SenderIndex) {
		storeSenderOfFramewithValue(theFP, anOop);
	}
	else {
		externalDivorceFrameandContext(theFP, maybeMarriedContext);
		/* begin storePointer:ofObject:withValue: */
		if ((((usqInt) maybeMarriedContext)) < (((usqInt) GIV(youngStart)))) {
			possibleRootStoreIntovalue(maybeMarriedContext, anOop);
		}
		longAtput((maybeMarriedContext + BaseHeaderSize) + (index << ShiftForWord), anOop);
		if (index == StackPointerIndex) {
			ensureContextIsExecutionSafeAfterAssignToStackPointer(maybeMarriedContext);
		}
	}
	if (onCurrentPage) {
		GIV(framePointer) = (GIV(stackPage)->headFP);
		GIV(stackPointer) = (GIV(stackPage)->headSP);
	}
	else {
		markStackPageMostRecentlyUsed(GIV(stackPage));
	}
	assert(GIV(stackPage) == (mostRecentlyUsedPage()));
	assert(pageListIsWellFormed());
	assert(validStackPageBaseFrames());
}


/*	Called under the assumption that primFunctionPtr has been preloaded */

static sqInt
externalQuickPrimitiveResponse(void)
{   DECL_MAYBE_SQ_GLOBAL_STRUCT
    sqInt localPrimIndex;
    sqInt oop;
    char *sp;
    char *sp1;
    char *sp2;
    char *sp3;
    char *sp4;

	assert(isPrimitiveFunctionPointerAnIndex());
	localPrimIndex = ((sqInt) primitiveFunctionPointer);
	assert((localPrimIndex > 255)
	 && (localPrimIndex < 520));
	if (localPrimIndex >= 264) {
		/* begin pop:thenPush: */
		oop = longAt(((longAt(GIV(stackPointer))) + BaseHeaderSize) + ((localPrimIndex - 264) << ShiftForWord));
		longAtput(sp = GIV(stackPointer) + ((1 - 1) * BytesPerWord), oop);
		GIV(stackPointer) = sp;
		return 1;
	}
	if (localPrimIndex == 256) {
		return 1;
	}
	if (localPrimIndex == 257) {
		/* begin pop:thenPush: */
		longAtput(sp1 = GIV(stackPointer) + ((1 - 1) * BytesPerWord), GIV(trueObj));
		GIV(stackPointer) = sp1;
		return 1;
	}
	if (localPrimIndex == 258) {
		/* begin pop:thenPush: */
		longAtput(sp2 = GIV(stackPointer) + ((1 - 1) * BytesPerWord), GIV(falseObj));
		GIV(stackPointer) = sp2;
		return 1;
	}
	if (localPrimIndex == 259) {
		/* begin pop:thenPush: */
		longAtput(sp3 = GIV(stackPointer) + ((1 - 1) * BytesPerWord), GIV(nilObj));
		GIV(stackPointer) = sp3;
		return 1;
	}
	/* begin pop:thenPush: */
	longAtput(sp4 = GIV(stackPointer) + ((1 - 1) * BytesPerWord), (((localPrimIndex - 261) << 1) | 1));
	GIV(stackPointer) = sp4;
	return 1;
}

sqInt
failed(void)
{
	return GIV(primFailCode) != 0;
}


/*	not inlined for breakpoint value... */

static void
failUnbalancedPrimitive(void)
{
	GIV(primFailCode) = PrimErrBadNumArgs;
}

sqInt
falseObject(void)
{
	return GIV(falseObj);
}


/*	Fetch the instance variable at the given index of the given object. Return
	the address of first indexable field of resulting array object, or fail if
	the instance variable does not contain an indexable bytes or words object.
 */
/*	Note: May be called by translated primitive code. */

void *
fetchArrayofObject(sqInt fieldIndex, sqInt objectPointer)
{
    sqInt arrayOop;

	arrayOop = longAt((objectPointer + BaseHeaderSize) + (fieldIndex << ShiftForWord));
	return arrayValueOf(arrayOop);
}

sqInt
fetchByteofObject(sqInt byteIndex, sqInt oop)
{
	return byteAt((oop + BaseHeaderSize) + byteIndex);
}

static sqInt
fetchClassOfNonInt(sqInt oop)
{
    sqInt ccIndex;

	if (((ccIndex = (((usqInt) (longAt(oop))) >> 12) & 31)) == 0) {
		return (longAt(oop - BaseHeaderSize)) & AllButTypeMask;
	}
	else {
		return longAt(((longAt((GIV(specialObjectsOop) + BaseHeaderSize) + (CompactClasses << ShiftForWord))) + BaseHeaderSize) + ((ccIndex - 1) << ShiftForWord));
	}
}

sqInt
fetchClassOf(sqInt oop)
{   DECL_MAYBE_SQ_GLOBAL_STRUCT
    sqInt ccIndex;

	if ((oop & 1)) {
		return longAt((GIV(specialObjectsOop) + BaseHeaderSize) + (ClassInteger << ShiftForWord));
	}
	if (((ccIndex = (((usqInt) (longAt(oop))) >> 12) & 31)) == 0) {
		return (longAt(oop - BaseHeaderSize)) & AllButTypeMask;
	}
	else {
		return longAt(((longAt((GIV(specialObjectsOop) + BaseHeaderSize) + (CompactClasses << ShiftForWord))) + BaseHeaderSize) + ((ccIndex - 1) << ShiftForWord));
	}
}


/*	Fetch the instance variable at the given index of the given object. Return
	the C double precision floating point value of that instance variable, or
	fail if it is not a Float.
 */
/*	Note: May be called by translated primitive code. */

double
fetchFloatofObject(sqInt fieldIndex, sqInt objectPointer)
{   DECL_MAYBE_SQ_GLOBAL_STRUCT
    sqInt ccIndex;
    sqInt floatOop;
    double result;
    sqInt successBoolean;

	floatOop = longAt((objectPointer + BaseHeaderSize) + (fieldIndex << ShiftForWord));
	/* begin floatValueOf: */
	VM_LABEL(0floatValueOf);
	flag("Dan");
	/* begin assertClassOf:is:compactClassIndex: */
	VM_LABEL(20assertClassOfiscompactClassIndex);
	/* begin success: */
	/* begin is:instanceOf:compactClassIndex: */
	if ((floatOop & 1)) {
		successBoolean = 0;
		goto l1;
	}
	ccIndex = (((usqInt) (longAt(floatOop))) >> 12) & 31;
	if (ClassFloatCompactIndex != 0) {
		successBoolean = ClassFloatCompactIndex == ccIndex;
		goto l1;
	}
	successBoolean = (ccIndex == 0)
	 && (((longAt(floatOop - BaseHeaderSize)) & AllButTypeMask) == (longAt((GIV(specialObjectsOop) + BaseHeaderSize) + (ClassFloat << ShiftForWord))));
l1:	/* end is:instanceOf:compactClassIndex: */;
	if (!(successBoolean)) {
		if (GIV(primFailCode) == 0) {

			/* Don't overwrite an error code that has already been set. */

			GIV(primFailCode) = 1;
		}
	}
	if (GIV(primFailCode) == 0) {
		;
		fetchFloatAtinto(floatOop + BaseHeaderSize, result);
		return result;
	}
	else {
		return 0.0;
	}
}


/*	Note: May be called by translated primitive code. */

sqInt
fetchIntegerofObject(sqInt fieldIndex, sqInt objectPointer)
{   DECL_MAYBE_SQ_GLOBAL_STRUCT
    sqInt intOop;

	intOop = longAt((objectPointer + BaseHeaderSize) + (fieldIndex << ShiftForWord));
	/* begin checkedIntegerValueOf: */
	if ((intOop & 1)) {
		return (intOop >> 1);
	}
	else {
		/* begin primitiveFail */
		if (GIV(primFailCode) == 0) {
			GIV(primFailCode) = 1;
		}
		return 0;
	}
}


/*	index by 32-bit units, and return a 32-bit value. Intended to replace
	fetchWord:ofObject: 
 */

sqInt
fetchLong32ofObject(sqInt fieldIndex, sqInt oop)
{
	return long32At((oop + BaseHeaderSize) + (fieldIndex << 2));
}


/*	index by word size, and return a pointer as long as the word size */

sqInt
fetchPointerofObject(sqInt fieldIndex, sqInt oop)
{
	return longAt((oop + BaseHeaderSize) + (fieldIndex << ShiftForWord));
}


/*	Return the stackPointer of a Context or BlockContext.
	Does not deal with married contexts. Use only for debug
	printing or object tracing functions. To obtain an accurate
	stack pointer use stackPointerForMaybeMarriedContext: */

static sqInt
fetchStackPointerOf(sqInt aContext)
{
    sqInt sp;

	sp = longAt((aContext + BaseHeaderSize) + (StackPointerIndex << ShiftForWord));
	if (!((sp & 1))) {
		return 0;
	}
	assert((ReceiverIndex + ((sp >> 1))) < (lengthOf(aContext)));
	return (sp >> 1);
}


/*	NOTE: this gives size appropriate for fetchPointer: n, but not in general
	for, eg, fetchLong32, etc.
 */

static sqInt
fetchWordLengthOf(sqInt objectPointer)
{
    sqInt header;
    sqInt sz;

	/* begin sizeBitsOf: */
	header = longAt(objectPointer);
	sz = ((header & TypeMask) == HeaderTypeSizeAndClass
		? (longAt(objectPointer - (BytesPerWord * 2))) & LongSizeMask
		: header & SizeMask);
	return ((usqInt) (sz - BaseHeaderSize)) >> ShiftForWord;
}


/*	During sweep phase we have encountered a weak reference. 
	Check if its object has gone away (or is about to) and if so, signal a 
	semaphore. */
/*	Do *not* inline this in sweepPhase - it is quite an unlikely 
	case to run into a weak reference */

static void
finalizeReference(usqInt oop)
{   DECL_MAYBE_SQ_GLOBAL_STRUCT
    sqInt chunk;
    sqInt contextSize;
    sqInt firstField;
    sqInt fmt;
    sqInt header;
    sqInt i;
    sqInt lastField;
    sqInt methodHeader;
    sqInt oopGone;
    sqInt sp;
    usqInt weakOop;

	firstField = BaseHeaderSize + ((nonWeakFieldsOf(oop)) << ShiftForWord);
	/* begin lastPointerOf: */
	header = longAt(oop);
	fmt = (((usqInt) header) >> 8) & 15;
	if (fmt <= 4) {
		if ((fmt == 3)
		 && (((((usqInt) header) >> 12) & 31) == ClassMethodContextCompactIndex)) {
			/* begin fetchStackPointerOf: */
			sp = longAt((oop + BaseHeaderSize) + (StackPointerIndex << ShiftForWord));
			if (!((sp & 1))) {
				contextSize = 0;
				goto l1;
			}
			assert((ReceiverIndex + ((sp >> 1))) < (lengthOf(oop)));
			contextSize = (sp >> 1);
		l1:	/* end fetchStackPointerOf: */;
			lastField = (CtxtTempFrameStart + contextSize) * BytesPerWord;
			goto l2;
		}
		lastField = (sizeBitsOfSafe(oop)) - BaseHeaderSize;
		goto l2;
	}
	if (fmt < 12) {
		lastField = 0;
		goto l2;
	}
	methodHeader = longAt(oop + BaseHeaderSize);
	if (isCogMethodReference(methodHeader)) {
		assert(((((CogMethod *) methodHeader)->cmType)) == CMMethod);
		methodHeader = (((CogMethod *) methodHeader)->methodHeader);
	}
	lastField = (((((usqInt) methodHeader) >> 10) & 255) * BytesPerWord) + BaseHeaderSize;
l2:	/* end lastPointerOf: */;
	for (i = firstField; i <= lastField; i += BytesPerWord) {

		/* ar 1/18/2005: Added oop < youngStart test to make sure we're not testing
			objects in non-GCable region. This could lead to a forward reference in
			old space with the oop pointed to not being marked and thus treated as free. */

		weakOop = longAt(oop + i);
		if (!((weakOop == GIV(nilObj))
			 || (((weakOop & 1))
 || (weakOop < GIV(youngStart))))) {
			if (weakOop < oop) {

				/* Check if the object is being collected. 
					If the weak reference points  
					* backward: check if the weakOops chunk is free
					* forward: check if the weakOoop has been marked by GC */

				chunk = weakOop - (headerTypeBytes[(longAt(weakOop)) & TypeMask]);
				oopGone = ((longAt(chunk)) & TypeMask) == HeaderTypeFree;
			}
			else {
				oopGone = !(((longAt(weakOop)) & MarkBit) != 0);
			}
			if (oopGone) {
				longAtput(oop + i, GIV(nilObj));
				/* begin signalFinalization: */
				forceInterruptCheck();
				GIV(pendingFinalizationSignals) += 1;
			}
		}
	}
}

sqInt
findClassOfMethodforReceiver(sqInt meth, sqInt rcvr)
{   DECL_MAYBE_SQ_GLOBAL_STRUCT
    sqInt ccIndex;
    sqInt ccIndex1;
    sqInt classDict;
    sqInt classDictSize;
    sqInt currClass;
    sqInt header;
    sqInt i;
    sqInt methodArray;
    sqInt sz;

	/* begin fetchClassOf: */
	if ((rcvr & 1)) {
		currClass = longAt((GIV(specialObjectsOop) + BaseHeaderSize) + (ClassInteger << ShiftForWord));
		goto l1;
	}
	if (((ccIndex = (((usqInt) (longAt(rcvr))) >> 12) & 31)) == 0) {
		currClass = (longAt(rcvr - BaseHeaderSize)) & AllButTypeMask;
		goto l1;
	}
	else {
		currClass = longAt(((longAt((GIV(specialObjectsOop) + BaseHeaderSize) + (CompactClasses << ShiftForWord))) + BaseHeaderSize) + ((ccIndex - 1) << ShiftForWord));
		goto l1;
	}
l1:	/* end fetchClassOf: */;
	do {
		classDict = longAt((currClass + BaseHeaderSize) + (MethodDictionaryIndex << ShiftForWord));
		/* begin fetchWordLengthOf: */
		/* begin sizeBitsOf: */
		header = longAt(classDict);
		sz = ((header & TypeMask) == HeaderTypeSizeAndClass
			? (longAt(classDict - (BytesPerWord * 2))) & LongSizeMask
			: header & SizeMask);
		classDictSize = ((usqInt) (sz - BaseHeaderSize)) >> ShiftForWord;
		methodArray = longAt((classDict + BaseHeaderSize) + (MethodArrayIndex << ShiftForWord));
		i = 0;
		while (i < (classDictSize - SelectorStart)) {
			if (meth == (longAt((methodArray + BaseHeaderSize) + (i << ShiftForWord)))) {
				return currClass;
			}
			i += 1;
		}
		currClass = longAt((currClass + BaseHeaderSize) + (SuperclassIndex << ShiftForWord));
	} while(!(currClass == GIV(nilObj)));
	/* begin fetchClassOf: */
	if ((rcvr & 1)) {
		return longAt((GIV(specialObjectsOop) + BaseHeaderSize) + (ClassInteger << ShiftForWord));
	}
	if (((ccIndex1 = (((usqInt) (longAt(rcvr))) >> 12) & 31)) == 0) {
		return (longAt(rcvr - BaseHeaderSize)) & AllButTypeMask;
	}
	else {
		return longAt(((longAt((GIV(specialObjectsOop) + BaseHeaderSize) + (CompactClasses << ShiftForWord))) + BaseHeaderSize) + ((ccIndex1 - 1) << ShiftForWord));
	}
}


/*	Answer the frame above theFP (adjacent frame nearest head end).
	If theFP is the head frame answer 0. */

static char *
findFrameAboveinPage(char *theFP, StackPage *thePage)
{
    char *callerFP;
    char *fp;

	fp = (thePage->headFP);
	if (fp == theFP) {
		return 0;
	}
	while (((callerFP = frameCallerFP(fp))) != 0) {
		if (callerFP == theFP) {
			return fp;
		}
		fp = callerFP;
	}
	error("did not find theFP in stack page");
	return 0;
}

static sqInt
findHomeForContext(sqInt aContext)
{
    sqInt closureOrNil;

	closureOrNil = longAt((aContext + BaseHeaderSize) + (ClosureIndex << ShiftForWord));
	if (closureOrNil == GIV(nilObj)) {
		return aContext;
	}
	return findHomeForContext(longAt((closureOrNil + BaseHeaderSize) + (ClosureOuterContextIndex << ShiftForWord)));
}


/*	See findUnwindThroughContext:. Alas this is mutually recursive with
	findMethodWithPrimitive:FromFP:SP:ThroughContext: instead of iterative.
	We're doing the simplest thing that could possibly work. Niceties can
	wait.  */

static sqInt
findMethodWithPrimitiveFromContextUpToContext(sqInt primitive, sqInt senderContext, sqInt homeContext)
{   DECL_MAYBE_SQ_GLOBAL_STRUCT
    sqInt theContext;
    sqInt theMethod;

	assert((senderContext == (nilObject()))
	 || (isContext(senderContext)));
	assert((homeContext == (nilObject()))
	 || (isContext(homeContext)));
	theContext = senderContext;
	while (1) {
		if (theContext == GIV(nilObj)) {
			return theContext;
		}
		if (((longAt((theContext + BaseHeaderSize) + (SenderIndex << ShiftForWord))) & 1)) break;
		if (theContext == homeContext) {
			return 0;
		}
		if ((longAt((theContext + BaseHeaderSize) + (ClosureIndex << ShiftForWord))) == GIV(nilObj)) {
			theMethod = longAt((theContext + BaseHeaderSize) + (MethodIndex << ShiftForWord));
			if ((primitiveIndexOf(theMethod)) == primitive) {
				return theContext;
			}
		}
		theContext = longAt((theContext + BaseHeaderSize) + (SenderIndex << ShiftForWord));
	}
	if (isWidowedContext(theContext)) {
		return GIV(nilObj);
	}
	return findMethodWithPrimitiveFromFPUpToContext(primitive, frameOfMarriedContext(theContext), homeContext);
}


/*	See findUnwindThroughContext:. Alas this is mutually recursive with
	findMethodWithPrimitive:FromContext:ThroughContext: instead of iterative.
	We're doing the simplest thing that could possibly work. Niceties can
	wait.  */

static sqInt
findMethodWithPrimitiveFromFPUpToContext(sqInt primitive, char *startFP, sqInt homeContext)
{   DECL_MAYBE_SQ_GLOBAL_STRUCT
    sqInt callerContextOrNil;
    sqInt index;
    sqInt senderContext;
    char *theFP;
    char *theFPAbove;
    sqInt theMethod;
    StackPage *thePage;
    char *theSP;

	theFP = startFP;
	theFPAbove = startFP;
	do {
		if ((((((usqInt)(longAt(theFP + FoxMethod)))) < heapBase
	? ((longAt(theFP + FoxMethod)) & MFMethodFlagHasContextFlag) != 0
	: (byteAt((theFP + FoxIFrameFlags) + 2)) != 0))
		 && (homeContext == (longAt(theFP + FoxThisContext)))) {
			return 0;
		}
		if (!(((((usqInt)(longAt(theFP + FoxMethod)))) < heapBase
				? ((longAt(theFP + FoxMethod)) & MFMethodFlagIsBlockFlag) != 0
				: (byteAt((theFP + FoxIFrameFlags) + 3)) != 0))) {
			theMethod = ((((usqInt)(longAt(theFP + FoxMethod)))) < heapBase
				? (mframeHomeMethod(theFP)->methodObject)
				: longAt(theFP + FoxMethod));
			if ((primitiveIndexOf(theMethod)) == primitive) {
				if (theFP == theFPAbove) {
					theSP = findSPOfon(theFP, stackPageFor(theFP));
				}
				else {
					/* begin frameCallerStackPointer: */
					assert(!(isBaseFrame(theFPAbove)));
					theSP = (theFPAbove + ((FoxCallerSavedIP + BytesPerWord) + ((((((usqInt)(longAt(theFPAbove + FoxMethod)))) < heapBase
	? (mframeCogMethod(theFPAbove)->cmNumArgs)
	: byteAt((theFPAbove + FoxIFrameFlags) + 1))) << ShiftForWord))) + BytesPerWord;
				}
				/* begin ensureFrameIsMarried:SP: */
				VM_LABEL(15ensureFrameIsMarriedSP);
				if (((((usqInt)(longAt(theFP + FoxMethod)))) < heapBase
					? ((longAt(theFP + FoxMethod)) & MFMethodFlagHasContextFlag) != 0
					: (byteAt((theFP + FoxIFrameFlags) + 2)) != 0)) {
					assert(isContext(frameContext(theFP)));
					return longAt(theFP + FoxThisContext);
				}
				return marryFrameSP(theFP, theSP);
			}
		}
		theFPAbove = theFP;
		/* begin frameCallerFP: */
		theFP = pointerForOop(longAt(theFP + FoxSavedFP));
	} while(theFP != 0);
	/* begin frameCallerContext: */
	assert(isBaseFrame(theFPAbove));
	/* begin stackPageFor: */
	/* begin stackPageAt: */
	/* begin pageIndexFor: */
	assert((((((char *) theFPAbove)) >= (GIV(stackBasePlus1) - 1)) && ((((char *) theFPAbove)) <= (((char *) GIV(pages))))));
	index = pageIndexForstackBasePlus1bytesPerPage(theFPAbove, GIV(stackBasePlus1), GIV(bytesPerPage));
	thePage = stackPageAtpages(index, GIV(pages));
	callerContextOrNil = longAt((thePage->baseAddress));
	assert(addressCouldBeObj(callerContextOrNil));
	assert((callerContextOrNil == (nilObject()))
	 || (isContext(callerContextOrNil)));
	senderContext = callerContextOrNil;
	if (!(((senderContext & 1) == 0)
		 && (((((usqInt) (longAt(senderContext))) >> 12) & 31) == ClassMethodContextCompactIndex))) {
		return GIV(nilObj);
	}
	return findMethodWithPrimitiveFromContextUpToContext(primitive, senderContext, homeContext);
}


/*	Find the compiled method to be run when the current messageSelector is
	sent to the given class, setting the values of newMethod and
	primitiveIndex. 
 */

static void
findNewMethodInClass(sqInt class)
{   DECL_MAYBE_SQ_GLOBAL_STRUCT
    CogMethod *cogMethod;
    sqInt hash;
    sqInt methodHeader;
    sqInt ok;
    sqInt probe;

	/* begin lookupInMethodCacheSel:class: */

	/* shift drops two low-order zeros from addresses */

	hash = GIV(messageSelector) ^ class;

	/* first probe */

	probe = hash & MethodCacheMask;
	if (((GIV(methodCache)[probe + MethodCacheSelector]) == GIV(messageSelector))
	 && ((GIV(methodCache)[probe + MethodCacheClass]) == class)) {
		GIV(newMethod) = GIV(methodCache)[probe + MethodCacheMethod];
		primitiveFunctionPointer = ((void (*)()) (GIV(methodCache)[probe + MethodCachePrimFunction]));
		ok = 1;
		goto l1;
	}

	/* second probe */

	probe = (((usqInt) hash) >> 1) & MethodCacheMask;
	if (((GIV(methodCache)[probe + MethodCacheSelector]) == GIV(messageSelector))
	 && ((GIV(methodCache)[probe + MethodCacheClass]) == class)) {
		GIV(newMethod) = GIV(methodCache)[probe + MethodCacheMethod];
		primitiveFunctionPointer = ((void (*)()) (GIV(methodCache)[probe + MethodCachePrimFunction]));
		ok = 1;
		goto l1;
	}
	probe = (((usqInt) hash) >> 2) & MethodCacheMask;
	if (((GIV(methodCache)[probe + MethodCacheSelector]) == GIV(messageSelector))
	 && ((GIV(methodCache)[probe + MethodCacheClass]) == class)) {
		GIV(newMethod) = GIV(methodCache)[probe + MethodCacheMethod];
		primitiveFunctionPointer = ((void (*)()) (GIV(methodCache)[probe + MethodCachePrimFunction]));
		ok = 1;
		goto l1;
	}
	ok = 0;
l1:	/* end lookupInMethodCacheSel:class: */;
	if (ok) {
		/* begin ifAppropriateCompileToNativeCode:selector: */
		methodHeader = longAt((GIV(newMethod) + BaseHeaderSize) + (HeaderIndex << ShiftForWord));
		if (isCogMethodReference(methodHeader)) {

			/* makeBaseFrame: can create cog methods with nil selectors. */

			cogMethod = ((CogMethod *) methodHeader);
			if (((cogMethod->selector)) == GIV(nilObj)) {
				setSelectorOfto(cogMethod, GIV(messageSelector));
			}
		}
		else {
			if (((((usqInt) methodHeader) >> 10) & 255) <= maxLiteralCountForCompile) {
				cogselector(GIV(newMethod), GIV(messageSelector));
			}
			else {
				maybeFlagMethodAsInterpreted(GIV(newMethod));
			}
		}
	}
	else {
		lookupMethodInClass(class);
		addNewMethodToCache(class);
	}
}

sqInt
findSelectorOfMethodforReceiver(sqInt meth, sqInt rcvr)
{   DECL_MAYBE_SQ_GLOBAL_STRUCT
    sqInt ccIndex;
    sqInt classDict;
    sqInt classDictSize;
    sqInt currClass;
    sqInt header;
    sqInt i;
    sqInt methodArray;
    sqInt sz;

	/* begin fetchClassOf: */
	if ((rcvr & 1)) {
		currClass = longAt((GIV(specialObjectsOop) + BaseHeaderSize) + (ClassInteger << ShiftForWord));
		goto l1;
	}
	if (((ccIndex = (((usqInt) (longAt(rcvr))) >> 12) & 31)) == 0) {
		currClass = (longAt(rcvr - BaseHeaderSize)) & AllButTypeMask;
		goto l1;
	}
	else {
		currClass = longAt(((longAt((GIV(specialObjectsOop) + BaseHeaderSize) + (CompactClasses << ShiftForWord))) + BaseHeaderSize) + ((ccIndex - 1) << ShiftForWord));
		goto l1;
	}
l1:	/* end fetchClassOf: */;
	do {
		classDict = longAt((currClass + BaseHeaderSize) + (MethodDictionaryIndex << ShiftForWord));
		/* begin fetchWordLengthOf: */
		/* begin sizeBitsOf: */
		header = longAt(classDict);
		sz = ((header & TypeMask) == HeaderTypeSizeAndClass
			? (longAt(classDict - (BytesPerWord * 2))) & LongSizeMask
			: header & SizeMask);
		classDictSize = ((usqInt) (sz - BaseHeaderSize)) >> ShiftForWord;
		methodArray = longAt((classDict + BaseHeaderSize) + (MethodArrayIndex << ShiftForWord));
		i = 0;
		while (i <= (classDictSize - SelectorStart)) {
			if (meth == (longAt((methodArray + BaseHeaderSize) + (i << ShiftForWord)))) {
				return longAt((classDict + BaseHeaderSize) + ((i + SelectorStart) << ShiftForWord));
			}
			i += 1;
		}
		currClass = longAt((currClass + BaseHeaderSize) + (SuperclassIndex << ShiftForWord));
	} while(!(currClass == GIV(nilObj)));
	return currClass;
}


/*	Search for the stack pointer for theFP. This points to the hottest item on
	the frame's stack.
	DO NOT CALL THIS WITH theFP == localFP OR theFP == framePointer! */

static char *
findSPOfon(char *theFP, StackPage *thePage)
{
    char *aFrame;
    char *startFrame;
    char *theSP;
    char *theSP1;

	/* begin findSPOrNilOf:on:startingFrom: */
	startFrame = (thePage->headFP);
	assert(!(isFree(thePage)));
	aFrame = startFrame;
	theSP1 = (thePage->headSP);
	if (aFrame == theFP) {
		if (theSP1 >= aFrame) {
			theSP = ((((usqInt)(longAt(aFrame + FoxMethod)))) < heapBase
				? aFrame + FoxMFReceiver
				: aFrame + FoxIFReceiver);
			goto l1;
		}
		theSP = (thePage == GIV(stackPage)
			? theSP1
			: theSP1 + BytesPerWord);
		goto l1;
	}
	while (1) {
		/* begin frameCallerSP: */
		assert(!(isBaseFrame(aFrame)));
		theSP1 = (aFrame + ((FoxCallerSavedIP + BytesPerWord) + ((((((usqInt)(longAt(aFrame + FoxMethod)))) < heapBase
	? (mframeCogMethod(aFrame)->cmNumArgs)
	: byteAt((aFrame + FoxIFrameFlags) + 1))) << ShiftForWord))) + BytesPerWord;
		/* begin frameCallerFP: */
		aFrame = pointerForOop(longAt(aFrame + FoxSavedFP));
		if (!(aFrame != 0)) break;
		if (theFP == aFrame) {
			theSP = theSP1;
			goto l1;
		}
	}
	theSP = null;
l1:	/* end findSPOrNilOf:on:startingFrom: */;
	if (theSP != null) {
		return theSP;
	}
	error("did not find theFP in stack page");
	return 0;
}


/*	Print the oops of all string-like things that have the same characters as
	aCString 
 */

void
findString(char *aCString)
{
    sqInt cssz;
    sqInt header;
    sqInt obj;
    sqInt sz;

	cssz = strlen(aCString);
	obj = heapBase + (headerTypeBytes[(longAt(heapBase)) & TypeMask]);
	while ((((usqInt) obj)) < (((usqInt) GIV(freeStart)))) {
		if (((longAt(obj)) & TypeMask) == HeaderTypeFree) {
			sz = (longAt(obj)) & AllButTypeMask;
		}
		else {
			if ((((((usqInt) (longAt(obj))) >> 8) & 15) >= 8)
			 && (((lengthOf(obj)) == cssz)
 && ((strncmp(aCString, pointerForOop(obj + BaseHeaderSize), cssz)) == 0))) {
				printHex(obj);
				/* begin cr */
				printf("\n");
			}
			/* begin sizeBitsOf: */
			header = longAt(obj);
			sz = ((header & TypeMask) == HeaderTypeSizeAndClass
				? (longAt(obj - (BytesPerWord * 2))) & LongSizeMask
				: header & SizeMask);
		}
		obj = (obj + sz) + (headerTypeBytes[(longAt(obj + sz)) & TypeMask]);
	}
}

void *
firstFixedField(sqInt oop)
{
	return pointerForOop(oop + BaseHeaderSize);
}


/*	NOTE: overridden in various simulator subclasses to add coercion to
	CArray, so please duplicate any changes
 */

void *
firstIndexableField(sqInt oop)
{
    sqInt ccIndex;
    sqInt class;
    sqInt classFormat;
    sqInt fixedFields;
    sqInt fmt;
    sqInt hdr;
    sqInt sz;
    sqInt totalLength;

	hdr = longAt(oop);
	fmt = (((usqInt) hdr) >> 8) & 15;
	if (fmt <= 4) {
		/* begin lengthOf:baseHeader:format: */
		if ((hdr & TypeMask) == HeaderTypeSizeAndClass) {
			sz = (longAt(oop - (BytesPerWord * 2))) & LongSizeMask;
		}
		else {
			sz = hdr & SizeMask;
		}
		sz -= hdr & Size4Bit;
		if (fmt <= 4) {
			totalLength = ((usqInt) (sz - BaseHeaderSize)) >> ShiftForWord;
			goto l1;
		}
		if (fmt < 8) {
			totalLength = ((usqInt) (sz - BaseHeaderSize)) >> 2;
			goto l1;
		}
		else {
			totalLength = (sz - BaseHeaderSize) - (fmt & 3);
			goto l1;
		}
	l1:	/* end lengthOf:baseHeader:format: */;
		/* begin fixedFieldsOf:format:length: */
		if ((fmt > 4)
		 || (fmt == 2)) {
			fixedFields = 0;
			goto l3;
		}
		if (fmt < 2) {
			fixedFields = totalLength;
			goto l3;
		}
		/* begin fetchClassOfNonInt: */
		if (((ccIndex = (((usqInt) (longAt(oop))) >> 12) & 31)) == 0) {
			class = (longAt(oop - BaseHeaderSize)) & AllButTypeMask;
			goto l2;
		}
		else {
			class = longAt(((longAt((GIV(specialObjectsOop) + BaseHeaderSize) + (CompactClasses << ShiftForWord))) + BaseHeaderSize) + ((ccIndex - 1) << ShiftForWord));
			goto l2;
		}
	l2:	/* end fetchClassOfNonInt: */;
		classFormat = (longAt((class + BaseHeaderSize) + (InstanceSpecificationIndex << ShiftForWord))) - 1;
		fixedFields = (((((usqInt) classFormat) >> 11) & 192) + ((((usqInt) classFormat) >> 2) & 63)) - 1;
	l3:	/* end fixedFieldsOf:format:length: */;
		return pointerForOop((oop + BaseHeaderSize) + (fixedFields << ShiftForWord));
	}
	return pointerForOop(oop + BaseHeaderSize);
}


/*	Like #stackFloatValue: but access method arguments left-to-right */

double
floatArg(sqInt index)
{   DECL_MAYBE_SQ_GLOBAL_STRUCT
    sqInt ccIndex;
    sqInt oop;
    double result;
    sqInt successBoolean;

	oop = methodArg(index);
	if (oop == 0) {
		return 0.0;
	}
	/* begin assertClassOf:is:compactClassIndex: */
	VM_LABEL(21assertClassOfiscompactClassIndex);
	/* begin success: */
	/* begin is:instanceOf:compactClassIndex: */
	if ((oop & 1)) {
		successBoolean = 0;
		goto l1;
	}
	ccIndex = (((usqInt) (longAt(oop))) >> 12) & 31;
	if (ClassFloatCompactIndex != 0) {
		successBoolean = ClassFloatCompactIndex == ccIndex;
		goto l1;
	}
	successBoolean = (ccIndex == 0)
	 && (((longAt(oop - BaseHeaderSize)) & AllButTypeMask) == (longAt((GIV(specialObjectsOop) + BaseHeaderSize) + (ClassFloat << ShiftForWord))));
l1:	/* end is:instanceOf:compactClassIndex: */;
	if (!(successBoolean)) {
		if (GIV(primFailCode) == 0) {

			/* Don't overwrite an error code that has already been set. */

			GIV(primFailCode) = 1;
		}
	}
	if (GIV(primFailCode) == 0) {
		;
		fetchFloatAtinto(oop + BaseHeaderSize, result);
		return result;
	}
	else {
		return 0.0;
	}
}

sqInt
floatObjectOf(double aFloat)
{
    sqInt newFloatObj;

	flag("Dan");
	newFloatObj = eeInstantiateSmallClasssizeInBytes(longAt((GIV(specialObjectsOop) + BaseHeaderSize) + (ClassFloat << ShiftForWord)), 8 + BaseHeaderSize);
	storeFloatAtfrom(newFloatObj + BaseHeaderSize, aFloat);
	return newFloatObj;
}


/*	Fetch the instance variable at the given index of the given object. Return
	the C double precision floating point value of that instance variable, or
	fail if it is not a Float.
 */
/*	Note: May be called by translated primitive code. */

double
floatValueOf(sqInt oop)
{   DECL_MAYBE_SQ_GLOBAL_STRUCT
    sqInt ccIndex;
    double result;
    sqInt successBoolean;

	flag("Dan");
	/* begin assertClassOf:is:compactClassIndex: */
	VM_LABEL(22assertClassOfiscompactClassIndex);
	/* begin success: */
	/* begin is:instanceOf:compactClassIndex: */
	if ((oop & 1)) {
		successBoolean = 0;
		goto l1;
	}
	ccIndex = (((usqInt) (longAt(oop))) >> 12) & 31;
	if (ClassFloatCompactIndex != 0) {
		successBoolean = ClassFloatCompactIndex == ccIndex;
		goto l1;
	}
	successBoolean = (ccIndex == 0)
	 && (((longAt(oop - BaseHeaderSize)) & AllButTypeMask) == (longAt((GIV(specialObjectsOop) + BaseHeaderSize) + (ClassFloat << ShiftForWord))));
l1:	/* end is:instanceOf:compactClassIndex: */;
	if (!(successBoolean)) {
		if (GIV(primFailCode) == 0) {

			/* Don't overwrite an error code that has already been set. */

			GIV(primFailCode) = 1;
		}
	}
	if (GIV(primFailCode) == 0) {
		;
		fetchFloatAtinto(oop + BaseHeaderSize, result);
		return result;
	}
	else {
		return 0.0;
	}
}


/*	methodObj is a CompiledMethod containing an external primitive.
	Flush the function address and session ID of the CM. Override
	to also flush the machine code call if one exists. */

static void
flushExternalPrimitiveOf(sqInt methodObj)
{
    sqInt lit;

	if (!((literalCountOfHeader(headerOf(methodObj))) > 0)) {
		return;
	}
	lit = longAt((methodObj + BaseHeaderSize) + ((0 + LiteralStart) << ShiftForWord));
	if (!((((lit & 1) == 0)
 && (((((usqInt) (longAt(lit))) >> 8) & 15) == 2))
		 && ((lengthOf(lit)) == 4))) {
		return;
	}
	longAtput((lit + BaseHeaderSize) + (2 << ShiftForWord), ConstZero);
	longAtput((lit + BaseHeaderSize) + (3 << ShiftForWord), ConstZero);
	if (methodHasCogMethod(methodObj)) {
		rewritePrimInvocationInto(cogMethodOf(methodObj), primitiveExternalCall);
	}
}


/*	Flush the references to external functions from plugin 
	primitives. This will force a reload of those primitives when 
	accessed next. 
	Note: We must flush the method cache here so that any 
	failed primitives are looked up again. */

static void
flushExternalPrimitives(void)
{   DECL_MAYBE_SQ_GLOBAL_STRUCT
    sqInt header;
    sqInt i;
    sqInt i1;
    sqInt i2;
    sqInt oop;
    sqInt primBits;
    sqInt primIdx;
    sqInt sz;

	oop = heapBase + (headerTypeBytes[(longAt(heapBase)) & TypeMask]);
	while ((((usqInt) oop)) < (((usqInt) GIV(freeStart)))) {
		if (!(((longAt(oop)) & TypeMask) == HeaderTypeFree)) {
			if (((((usqInt) (longAt(oop))) >> 8) & 15) >= 12) {
				/* begin primitiveIndexOf: */
				primBits = (((usqInt) (headerOf(oop))) >> 1) & 268435967;
				primIdx = (primBits & 511) + (((usqInt) primBits) >> 19);
				if (primIdx == PrimitiveExternalCallIndex) {
					flushExternalPrimitiveOf(oop);
				}
			}
		}
		/* begin objectAfter: */
		if (DoAssertionChecks) {
			if ((((usqInt) oop)) >= (((usqInt) GIV(endOfMemory)))) {
				error("no objects after the end of memory");
			}
		}
		if (((longAt(oop)) & TypeMask) == HeaderTypeFree) {
			sz = (longAt(oop)) & AllButTypeMask;
		}
		else {
			/* begin sizeBitsOf: */
			header = longAt(oop);
			sz = ((header & TypeMask) == HeaderTypeSizeAndClass
				? (longAt(oop - (BytesPerWord * 2))) & LongSizeMask
				: header & SizeMask);
		}
		oop = (oop + sz) + (headerTypeBytes[(longAt(oop + sz)) & TypeMask]);
	}
	/* begin flushMethodCache */
	for (i = 1; i <= MethodCacheSize; i += 1) {
		GIV(methodCache)[i] = 0;
	}

	/* this for primitiveExternalMethod */

	GIV(lastMethodCacheProbeWrite) = 0;
	unlinkAllSends();
	/* begin flushAtCache */
	for (i1 = 1; i1 <= AtCacheTotalSize; i1 += 1) {
		GIV(atCache)[i1] = 0;
	}
	/* begin flushExternalPrimitiveTable */
	for (i2 = 0; i2 <= (MaxExternalPrimitiveTableSize - 1); i2 += 1) {
		externalPrimitiveTable[i2] = 0;
	}
	GIV(externalPrimitiveTableFirstFreeIndex) = 0;
}


/*	Force an interrupt check ASAP.
	Must set the stack page's limit before stackLimit to avoid
	a race condition if this is called from an interrupt handler. */

void
forceInterruptCheck(void)
{   DECL_MAYBE_SQ_GLOBAL_STRUCT
    void (*iccFunc)();
    StackPage *thePage;

	if (GIV(stackLimit) == 0) {
		return;
	}
	thePage = GIV(stackPage);
	if (thePage != null) {
		(thePage->stackLimit = ((char *) (((usqInt) -1))));
	}
	GIV(stackLimit) = ((char *) (((usqInt) -1)));
	sqLowLevelMFence();
	if (((iccFunc = interruptCheckChain)) != null) {
		iccFunc();
	}
	GIV(statForceInterruptCheck) += 1;
}


/*	Force an interrupt check ASAP. This version is the
	entry-point to forceInterruptCheck for the heartbeat
	timer to allow for repeatable debugging. */

void
forceInterruptCheckFromHeartbeat(void)
{   DECL_MAYBE_SQ_GLOBAL_STRUCT
	if (!(suppressHeartbeatFlag)) {
		/* begin checkForLongRunningPrimitive */
		if (GIV(longRunningPrimitiveCheckSemaphore) == null) {
			goto l1;
		}
		if ((GIV(longRunningPrimitiveStartUsecs) > 0)
		 && ((GIV(longRunningPrimitiveCheckMethod) == GIV(newMethod))
 && (GIV(longRunningPrimitiveCheckSequenceNumber) == GIV(statCheckForEvents)))) {
			GIV(longRunningPrimitiveStopUsecs) = ioUTCMicroseconds();
			assert(GIV(longRunningPrimitiveStopUsecs) > GIV(longRunningPrimitiveStartUsecs));
			goto l1;
		}
		if (GIV(longRunningPrimitiveStopUsecs) == 0) {
			GIV(longRunningPrimitiveCheckSequenceNumber) = GIV(statCheckForEvents);
			GIV(longRunningPrimitiveCheckMethod) = GIV(newMethod);
			GIV(longRunningPrimitiveStartUsecs) = ioUTCMicroseconds();
			sqLowLevelMFence();
		}
	l1:	/* end checkForLongRunningPrimitive */;
		if (GIV(deferSmash)) {
			GIV(deferredSmash) = 1;
		}
		else {
			forceInterruptCheck();
		}
	}
}


/*	**should be in-lined** */
/*	Note that, in Smalltalk, the instSpec will be equal to the inst spec
	part of the base header of an instance (without hdr type) shifted left 1.
	In this way, apart from the smallInt bit, the bits
	are just where you want them for the first header word. */
/*	Callers (must) expect low 2 bits (header type) to be zero! */

sqInt
formatOfClass(sqInt classPointer)
{
	return (longAt((classPointer + BaseHeaderSize) + (InstanceSpecificationIndex << ShiftForWord))) - 1;
}


/*	In the StackInterpreter the saved ip field of a base frame holds the
	base frame's caller context. But in the Cog VM the first word on the
	stack holds the base frame's caller context, which is immediately
	above the stacked receiver. */

static sqInt
frameCallerContext(char *theFP)
{   DECL_MAYBE_SQ_GLOBAL_STRUCT
    sqInt callerContextOrNil;
    sqInt index;
    StackPage *thePage;

	assert(isBaseFrame(theFP));
	/* begin stackPageFor: */
	/* begin stackPageAt: */
	/* begin pageIndexFor: */
	assert((((((char *) theFP)) >= (GIV(stackBasePlus1) - 1)) && ((((char *) theFP)) <= (((char *) GIV(pages))))));
	index = pageIndexForstackBasePlus1bytesPerPage(theFP, GIV(stackBasePlus1), GIV(bytesPerPage));
	thePage = stackPageAtpages(index, GIV(pages));
	callerContextOrNil = longAt((thePage->baseAddress));
	assert(addressCouldBeObj(callerContextOrNil));
	assert((callerContextOrNil == (nilObject()))
	 || (isContext(callerContextOrNil)));
	return callerContextOrNil;
}


/*	In the StackInterpreter the saved ip field of a base frame holds the
	base frame's caller context. But in the Cog VM the first word on the
	stack holds the base frame's caller context, which is immediately
	above the stacked receiver. */

static sqInt
frameCallerContextput(char *theFP, sqInt aValue)
{
	assert(isBaseFrame(theFP));
	assert(((theFP + (frameStackedReceiverOffset(theFP))) + (2 * BytesPerWord)) == ((stackPageFor(theFP)->baseAddress)));
	assert((longAt((theFP + (frameStackedReceiverOffset(theFP))) + BytesPerWord)) == (frameContext(theFP)));
	return longAtput((theFP + ((FoxCallerSavedIP + BytesPerWord) + ((((((usqInt)(longAt(theFP + FoxMethod)))) < heapBase
	? (mframeCogMethod(theFP)->cmNumArgs)
	: byteAt((theFP + FoxIFrameFlags) + 1))) << ShiftForWord))) + (2 * BytesPerWord), aValue);
}

static char *
frameCallerFP(char *theFP)
{
	return pointerForOop(longAt(theFP + FoxSavedFP));
}

static char *
frameCallerSavedIP(char *theFP)
{
	return pointerForOop(longAt(theFP + FoxCallerSavedIP));
}


/*	Answer the SP of the caller provided theFP is not a base frame.
	This points to the hottest item on the caller frame's stack. */

static char *
frameCallerSP(char *theFP)
{
	assert(!(isBaseFrame(theFP)));
	return (theFP + ((FoxCallerSavedIP + BytesPerWord) + ((((((usqInt)(longAt(theFP + FoxMethod)))) < heapBase
	? (mframeCogMethod(theFP)->cmNumArgs)
	: byteAt((theFP + FoxIFrameFlags) + 1))) << ShiftForWord))) + BytesPerWord;
}

static sqInt
frameContext(char *theFP)
{
	return longAt(theFP + FoxThisContext);
}

static sqInt
frameHasContext(char *theFP)
{
	return ((((usqInt)(longAt(theFP + FoxMethod)))) < heapBase
		? ((longAt(theFP + FoxMethod)) & MFMethodFlagHasContextFlag) != 0
		: (byteAt((theFP + FoxIFrameFlags) + 2)) != 0);
}


/*	<Integer> */

static sqInt
frameIsBlockActivation(char *theFP)
{
	return ((((usqInt)(longAt(theFP + FoxMethod)))) < heapBase
		? ((longAt(theFP + FoxMethod)) & MFMethodFlagIsBlockFlag) != 0
		: (byteAt((theFP + FoxIFrameFlags) + 3)) != 0);
}


/*	See encodeFrameFieldHasContext:numArgs: */

static sqInt
frameNumArgs(char *theFP)
{
	return ((((usqInt)(longAt(theFP + FoxMethod)))) < heapBase
		? (mframeCogMethod(theFP)->cmNumArgs)
		: byteAt((theFP + FoxIFrameFlags) + 1));
}

static char *
frameOfMarriedContext(sqInt aContext)
{
    sqInt value;

	value = longAt((aContext + BaseHeaderSize) + (SenderIndex << ShiftForWord));
	/* begin withoutSmallIntegerTags: */
	assert((value & 1));
	return pointerForOop(value - 1);
}

usqInt
framePointerAddress(void)
{
	return ((usqInt)((&GIV(framePointer))));
}

static sqInt
frameReceiver(char *theFP)
{
	return ((((usqInt)(longAt(theFP + FoxMethod)))) < heapBase
		? longAt(theFP + FoxMFReceiver)
		: longAt(theFP + FoxIFReceiver));
}


/*	Answer the offset in bytes from the a frame pointer to its stacked
	receiver. The receiver of a message send or the closure of a block
	activation is
	always on the stack above any arguments and the frame itself. See the
	diagram in StackInterpreter class>>initializeFrameIndices. */

static sqInt
frameStackedReceiverOffset(char *theFP)
{
	return (FoxCallerSavedIP + BytesPerWord) + ((((((usqInt)(longAt(theFP + FoxMethod)))) < heapBase
	? (mframeCogMethod(theFP)->cmNumArgs)
	: byteAt((theFP + FoxIFrameFlags) + 1))) << ShiftForWord);
}


/*	<InterpreterStackPage> */
/*	MRUP-->used page<->used page<->used page<->used page<--LRUP
	^ <-next-prev-> ^
	| |
	v <-prev-next-> v
	free page<->free page<->free page<->free page */

static void
freeStackPageNoAssert(StackPage *aPage)
{   DECL_MAYBE_SQ_GLOBAL_STRUCT
    StackPage *prev;

	(aPage->baseFP = 0);
	if (aPage == GIV(mostRecentlyUsedPage)) {
		GIV(mostRecentlyUsedPage) = (GIV(mostRecentlyUsedPage)->prevPage);
		return;
	}
	if ((((prev = (aPage->prevPage))->baseFP)) == 0) {
		return;
	}
	(prev->nextPage = (aPage->nextPage));
	((aPage->nextPage)->prevPage = prev);
	(aPage->nextPage = (GIV(mostRecentlyUsedPage)->nextPage));
	((GIV(mostRecentlyUsedPage)->nextPage)->prevPage = aPage);
	(aPage->prevPage = GIV(mostRecentlyUsedPage));
	(GIV(mostRecentlyUsedPage)->nextPage = aPage);
}

usqInt
freeStartAddress(void)
{
	return ((usqInt)((&GIV(freeStart))));
}


/*	Repaint the entire smalltalk screen, ignoring the affected rectangle. Used
	in some platform's code when the Smalltalk window is brought to the front
	or uncovered.
 */

sqInt
fullDisplayUpdate(void)
{
    sqInt displayObj;
    sqInt h;
    sqInt w;

	displayObj = longAt((GIV(specialObjectsOop) + BaseHeaderSize) + (TheDisplay << ShiftForWord));
	if ((((displayObj & 1) == 0)
 && (((((usqInt) (longAt(displayObj))) >> 8) & 15) <= 4))
	 && ((lengthOf(displayObj)) >= 4)) {
		w = fetchIntegerofObject(1, displayObj);
		h = fetchIntegerofObject(2, displayObj);
		displayBitsOfLeftTopRightBottom(displayObj, 0, 0, w, h);
		ioForceDisplayUpdate();
	}
	return null;
}


/*	Do a mark/sweep garbage collection of the entire object memory. Free
	inaccessible objects but do not move them.
 */

void
fullGC(void)
{   DECL_MAYBE_SQ_GLOBAL_STRUCT
    sqInt delta;
    sqInt freeSizeNow;
    sqInt i;
    sqInt limit;
    sqInt limit1;
    sqInt oop;
    sqInt sz;
    sqInt traceType;

	if (GIV(fullGCLock) > 0) {
		warning("aborting fullGC because fullGCLock > 0");
		return;
	}
	/* begin initializeFreeBlocksPreSweep */
	/* begin setSizeOfFree:to: */
	longAtput(GIV(freeStart), ((GIV(endOfMemory) - GIV(freeStart)) & AllButTypeMask) | HeaderTypeFree);
	assert(isFreeObject(GIV(freeStart)));
	assert((GIV(freeStart) + (sizeOfFree(GIV(freeStart)))) == GIV(endOfMemory));
	assert((GIV(freeStart) < GIV(endOfMemory))
	 && (GIV(endOfMemory) < GIV(memoryLimit)));
	runLeakCheckerForFullGC(1);
	/* begin preGCAction: */
	VM_LABEL(0preGCAction);
	if (GIV(stackPage) != 0) {
		/* begin externalWriteBackHeadFramePointers */
		assert((GIV(framePointer) - GIV(stackPointer)) < LargeContextSize);
		assert(GIV(stackPage) == (mostRecentlyUsedPage()));
		/* begin setHeadFP:andSP:inPage: */
		assert(GIV(stackPointer) < GIV(framePointer));
		assert((GIV(stackPointer) < ((GIV(stackPage)->baseAddress)))
		 && (GIV(stackPointer) > (((GIV(stackPage)->realStackLimit)) - LargeContextSize)));
		assert((GIV(framePointer) < ((GIV(stackPage)->baseAddress)))
		 && (GIV(framePointer) > (((GIV(stackPage)->realStackLimit)) - (((sqInt) LargeContextSize >> 1)))));
		(GIV(stackPage)->headFP = GIV(framePointer));
		(GIV(stackPage)->headSP = GIV(stackPointer));
		assert(pageListIsWellFormed());
	}
	GIV(inFullGC) = 1;
	if (recordEventTrace()) {
		traceType = (1
			? TraceFullGC
			: TraceIncrementalGC);
		/* begin recordTrace:thing:source: */
		GIV(traceLog)[GIV(traceLogIndex)] = traceType;
		GIV(traceLog)[GIV(traceLogIndex) + 1] = traceType;
		GIV(traceLog)[GIV(traceLogIndex) + 2] = 0;
		GIV(traceLogIndex) = (GIV(traceLogIndex) + 3) % TraceBufferSize;
	}
	GIV(gcStartUsecs) = ioUTCMicrosecondsNow();
	GIV(statSweepCount) = GIV(statMarkCount) = GIV(statMkFwdCount) = GIV(statCompMoveCount) = 0;
	/* begin clearRootsTable */
	for (i = 1; i <= GIV(rootTableCount); i += 1) {

		/* clear root bits of current root table entries */

		oop = GIV(rootTable)[i];
		longAtput(oop, (longAt(oop)) & AllButRootBit);
		GIV(rootTable)[i] = 0;
	}
	GIV(rootTableCount) = 0;

	/* process all of memory */

	GIV(youngStart) = heapBase;
	markPhase(1);
	GIV(totalObjectCount) = sweepPhaseForFullGC();
	runLeakCheckerForFullGC(1);
	/* begin fullCompaction */
	assert(GIV(compStart) == (lowestFreeAfter(startOfMemory())));
	if (GIV(compStart) == GIV(freeStart)) {
		initializeMemoryFirstFree(GIV(freeStart));
		goto l1;
	}
	if (((sz = fwdTableSize(8))) < GIV(totalObjectCount)) {
		/* begin growObjectMemory: */
		delta = ((GIV(totalObjectCount) - sz) + 10000) * 8;
		GIV(statGrowMemory) += 1;
		limit1 = sqGrowMemoryBy(GIV(memoryLimit), delta);
		if (!(limit1 == GIV(memoryLimit))) {
			/* begin setMemoryLimit: */
			assert(((limit1 - 24) & (BytesPerWord - 1)) == 0);
			GIV(memoryLimit) = limit1 - 24;
			initializeMemoryFirstFree(GIV(freeStart));
			sqMakeMemoryNotExecutableFromTo(heapBase, GIV(memoryLimit));
		}
	}
	while (GIV(compStart) < GIV(freeStart)) {

		/* free chunk returned by incCompBody becomes start of next compaction */

		GIV(compStart) = incCompBody();
	}
l1:	/* end fullCompaction */;
	GIV(statFullGCs) += 1;
	GIV(statGCEndUsecs) = ioUTCMicrosecondsNow();
	GIV(statFullGCUsecs) += GIV(statGCEndUsecs) - GIV(gcStartUsecs);
	/* begin capturePendingFinalizationSignals */
	GIV(statPendingFinalizationSignals) = GIV(pendingFinalizationSignals);

	/* reset the young object boundary */

	GIV(youngStart) = GIV(freeStart);
	/* begin postGCAction: */
	freeSizeNow = ((((usqInt) GIV(freeStart))) < (((usqInt) GIV(reserveStart)))
		? (((usqInt) GIV(reserveStart))) - (((usqInt) GIV(freeStart)))
		: 0);
	if ((freeSizeNow > GIV(shrinkThreshold))
	 && (freeSizeNow > GIV(growHeadroom))) {
		/* begin shrinkObjectMemory: */
		GIV(statShrinkMemory) += 1;
		limit = sqShrinkMemoryBy(GIV(memoryLimit), freeSizeNow - GIV(growHeadroom));
		if (!(limit == GIV(memoryLimit))) {
			/* begin setMemoryLimit: */
			assert(((limit - 24) & (BytesPerWord - 1)) == 0);
			GIV(memoryLimit) = limit - 24;
			initializeMemoryFirstFree(GIV(freeStart));
		}
	}
	cogitPostGCAction();
	signalSemaphoreWithIndex(GIV(gcSemaphoreIndex));
	GIV(lastCoggableInterpretedBlockMethod) = GIV(lastUncoggableInterpretedBlockMethod) = null;
	GIV(inFullGC) = 0;
	runLeakCheckerForFullGC(1);
}


/*	Answer the function primitiveCallout from the FFI plugin or nil if it
	can't be found. Cache it for performance. We use this circumlocution so
	that Squeak can be deployed without the FFI plugin for security reasons. */

static void (*functionForPrimitiveCallout())(void)

{
    static void *function = (void *)-1;

	;
	if ((((sqInt)function)) == -1) {
		function = ioLoadFunctionFrom("primitiveCallout", "SqueakFFIPrims");
	}
	return ((void (*)(void)) function);
}


/*	Arrange to call the external primitive directly. The complication is
	arranging that the call can be flushed, given that it is embedded in
	machine code. */

static void (*functionForPrimitiveExternalCall(sqInt methodObj))(void)

{
    void (*functionPointer)(void);
    sqInt index;
    sqInt lit;

	setPostCompileHook(recordCallOffsetInof);
	if (!((literalCountOfHeader(headerOf(methodObj))) > 0)) {
		return primitiveExternalCall;
	}

	/* Check if it's an array of length 4 */

	lit = longAt((methodObj + BaseHeaderSize) + ((0 + LiteralStart) << ShiftForWord));
	if (!((((lit & 1) == 0)
 && (((((usqInt) (longAt(lit))) >> 8) & 15) == 2))
		 && ((lengthOf(lit)) == 4))) {
		return primitiveExternalCall;
	}
	index = longAt((lit + BaseHeaderSize) + (3 << ShiftForWord));
	if (!(((index & 1))
		 && ((((index = (index >> 1))) > 0)
 && (index <= MaxExternalPrimitiveTableSize)))) {
		return primitiveExternalCall;
	}
	functionPointer = externalPrimitiveTable[index - 1];
	if (functionPointer == 0) {
		return primitiveExternalCall;
	}
	return functionPointer;
}

void (*functionPointerForCompiledMethodprimitiveIndex(sqInt methodObj, sqInt primIndex))(void)

{
    void (*functionPointer)(void);

	/* begin functionPointerFor:inClass: */
	functionPointer = ((void (*)(void)) ((primIndex > MaxPrimitiveIndex
	? 0
	: primitiveTable[primIndex])));
	if (functionPointer == (primitiveAt)) {
		return primitiveNoAtCacheAt;
	}
	if (functionPointer == (primitiveAtPut)) {
		return primitiveNoAtCacheAtPut;
	}
	if (functionPointer == (primitiveStringAt)) {
		return primitiveNoAtCacheStringAt;
	}
	if (functionPointer == (primitiveStringAtPut)) {
		return primitiveNoAtCacheStringAtPut;
	}
	if (functionPointer == (primitiveCalloutToFFI)) {
		return functionForPrimitiveCallout();
	}
	if (functionPointer == (primitiveExternalCall)) {
		return functionForPrimitiveExternalCall(methodObj);
	}
	return functionPointer;
}


/*	Find an actual function pointer for this primitiveIndex. This is an
	opportunity to specialise the prim for the relevant class (format for
	example). Default for now is simply the entry in the base primitiveTable. */

void (*functionPointerForinClass(sqInt primIdx,sqInt theClass))(void)

{
	return (primIdx > MaxPrimitiveIndex
		? 0
		: primitiveTable[primIdx]);
}


/*	Answer if the given address is a valid forward table entry. */

static sqInt
fwdBlockValid(sqInt addr)
{   DECL_MAYBE_SQ_GLOBAL_STRUCT
	return ((((usqInt) addr)) > (((usqInt) GIV(endOfMemory))))
	 && (((((usqInt) addr)) <= (((usqInt) GIV(fwdTableNext))))
 && ((addr & 3) == 0));
}


/*	Set the limits for a table of two- or three-word forwarding blocks above
	the last used oop. The pointer fwdTableNext moves up to fwdTableLast. Used
	for compaction of memory and become-ing objects. Returns the number of
	forwarding blocks available.
 */
/*	set endOfMemory to just after a minimum-sized free block */

static sqInt
fwdTableInit(sqInt blkSize)
{   DECL_MAYBE_SQ_GLOBAL_STRUCT
	/* begin setSizeOfFree:to: */
	longAtput(GIV(freeStart), (BaseHeaderSize & AllButTypeMask) | HeaderTypeFree);
	/* begin setEndOfMemory: */
	assert(((GIV(freeStart) + BaseHeaderSize) & (BytesPerWord - 1)) == 0);
	GIV(endOfMemory) = GIV(freeStart) + BaseHeaderSize;
	/* begin setSizeOfFree:to: */
	longAtput(GIV(endOfMemory), (BaseHeaderSize & AllButTypeMask) | HeaderTypeFree);
	GIV(fwdTableNext) = ((GIV(endOfMemory) + BaseHeaderSize) + 7) & (WordMask - 7);
	flag("Dan");

	/* last forwarding table entry */
	/* return the number of forwarding blocks available */

	GIV(fwdTableLast) = GIV(memoryLimit) - blkSize;
	return (GIV(fwdTableLast) - GIV(fwdTableNext)) / blkSize;
}


/*	Estimate the number of forwarding blocks available for compaction */

static sqInt
fwdTableSize(sqInt blkSize)
{   DECL_MAYBE_SQ_GLOBAL_STRUCT
    sqInt eom;
    sqInt fwdFirst;
    sqInt fwdLast;


	/* use all memory free between freeStart and memoryLimit for forwarding table */
	/* Note: Forward blocks must be quadword aligned. */

	eom = GIV(freeStart) + BaseHeaderSize;
	fwdFirst = ((eom + BaseHeaderSize) + 7) & (WordMask - 7);
	flag("Dan");

	/* last forwarding table entry */
	/* return the number of forwarding blocks available */

	fwdLast = GIV(memoryLimit) - blkSize;
	return (fwdLast - fwdFirst) / blkSize;
}


/*	currentBytecode will be private to the main dispatch loop in the generated
	code. This method allows the currentBytecode to be retrieved from global
	variables. Override to answer -1 if we're not in an interpreter frame. */

sqInt
getCurrentBytecode(void)
{   DECL_MAYBE_SQ_GLOBAL_STRUCT
	return (((((((usqInt)GIV(framePointer))) & (BytesPerWord - 1)) == 0)
 && ((((((usqInt)GIV(framePointer))) >= (((usqInt)(GIV(stackBasePlus1) - 1)))) && ((((usqInt)GIV(framePointer))) <= (((usqInt)GIV(pages)))))))
	 && (!((((usqInt)(longAt(GIV(framePointer) + FoxMethod)))) < heapBase))
		? byteAt(GIV(instructionPointer))
		: -1);
}

sqInt
getFullScreenFlag(void)
{
	return GIV(fullScreenFlag);
}

sqInt
getInterruptKeycode(void)
{
	return GIV(interruptKeycode);
}

sqInt
getInterruptPending(void)
{
	return GIV(interruptPending);
}


/*	Answer the next word read from aFile, byte-swapped according to the
	swapFlag. 
 */

static sqInt
getLongFromFileswap(sqImageFile  aFile, sqInt swapFlag)
{
    sqInt w;

	w = 0;
	sqImageFileRead(&w, sizeof(w), 1, aFile);
	if (swapFlag) {
		return byteSwapped(w);
	}
	else {
		return w;
	}
}

usqLong
getNextWakeupUsecs(void)
{
	return GIV(nextWakeupUsecs);
}

sqInt
getSavedWindowSize(void)
{
	return GIV(savedWindowSize);
}


/*	Answer the next half-word read from aFile, byte-swapped according to the
	swapFlag. 
 */

static sqInt
getShortFromFileswap(sqImageFile aFile, sqInt swapFlag)
{
    sqInt w;

	w = 0;
	sqImageFileRead(&w, sizeof(unsigned short), 1, aFile);
	return (swapFlag
		? (((usqInt) w >> 8)) + (((usqInt) (w & 255) << 8))
		: w);
}


/*	return the global session ID value */

sqInt
getThisSessionID(void)
{
	return GIV(globalSessionID);
}


/*	A message send from either an open PIC or an unlinked send has not
	been understood. Load newMethod with the MNU method. If linking
	is allowed and the target MNU method is in the cache then create a
	closed PIC with an mnu-entry and link the send to it. messageSelector,
	argumentCount and lkupClass have already been set by the caller. */

static sqInt
handleMNUInMachineCodeToclassForMessagemayLink(sqInt selectorIndex, sqInt rcvr, sqInt classForMessage, sqInt mayLinkBoolean)
{   DECL_MAYBE_SQ_GLOBAL_STRUCT
    sqInt class;
    sqInt classForThisMessage;
    CogMethod *cogMethod;
    sqInt currentClass;
    sqInt dictionary;
    sqInt errSelIdx;
    sqInt methodHeader;
    char *sp;
    char *sp1;
    char *sp2;
    sqInt top;

	assert(((rcvr & 1))
	 || (addressCouldBeObj(rcvr)));
	/* begin popStack */
	top = longAt(GIV(stackPointer));
	GIV(stackPointer) += BytesPerWord;
	GIV(instructionPointer) = ((sqInt) top);
	createActualMessageTo(classForMessage);
	GIV(messageSelector) = longAt((GIV(specialObjectsOop) + BaseHeaderSize) + (selectorIndex << ShiftForWord));
	if (lookupInMethodCacheSelclass(GIV(messageSelector), GIV(lkupClass))) {
		/* begin ifAppropriateCompileToNativeCode:selector: */
		methodHeader = longAt((GIV(newMethod) + BaseHeaderSize) + (HeaderIndex << ShiftForWord));
		if (isCogMethodReference(methodHeader)) {

			/* makeBaseFrame: can create cog methods with nil selectors. */

			cogMethod = ((CogMethod *) methodHeader);
			if (((cogMethod->selector)) == GIV(nilObj)) {
				setSelectorOfto(cogMethod, GIV(messageSelector));
			}
		}
		else {
			if (((((usqInt) methodHeader) >> 10) & 255) <= maxLiteralCountForCompile) {
				cogselector(GIV(newMethod), GIV(messageSelector));
			}
			else {
				maybeFlagMethodAsInterpreted(GIV(newMethod));
			}
		}
	}
	else {
		/* begin lookupMethodNoMNUEtcInClass: */
		class = classForThisMessage = GIV(lkupClass);
		currentClass = class;
		while (currentClass != GIV(nilObj)) {
			dictionary = longAt((currentClass + BaseHeaderSize) + (MethodDictionaryIndex << ShiftForWord));
			if (dictionary == GIV(nilObj)) {
				GIV(lkupClass) = longAt((currentClass + BaseHeaderSize) + (SuperclassIndex << ShiftForWord));
				errSelIdx = SelectorCannotInterpret;
				goto l1;
			}
			if (lookupMethodInDictionary(dictionary)) {
				addNewMethodToCache(class);
				errSelIdx = 0;
				goto l1;
			}
			currentClass = longAt((currentClass + BaseHeaderSize) + (SuperclassIndex << ShiftForWord));
		}
		GIV(lkupClass) = class;
		errSelIdx = SelectorDoesNotUnderstand;
	l1:	/* end lookupMethodNoMNUEtcInClass: */;
		if (errSelIdx != 0) {
			if (errSelIdx == SelectorDoesNotUnderstand) {
				error("Recursive not understood error encountered");
			}
			/* begin push: */
			longAtput(sp = GIV(stackPointer) - BytesPerWord, GIV(instructionPointer));
			GIV(stackPointer) = sp;
			return handleMNUInMachineCodeToclassForMessagemayLink(errSelIdx, rcvr, classForThisMessage, 0);
		}
	}
	if (((GIV(newMethod) & 1) == 0)
	 && ((((((usqInt) (longAt(GIV(newMethod)))) >> 8) & 15) >= 12)
 && (isCogMethodReference(longAt((GIV(newMethod) + BaseHeaderSize) + (HeaderIndex << ShiftForWord)))))) {
		if (mayLinkBoolean) {
			flag("implement creating an MNU PIC sometime");
			if (0) {
				error("shouldBeImplemented");
			}
		}
		/* begin push: */
		longAtput(sp1 = GIV(stackPointer) - BytesPerWord, GIV(instructionPointer));
		GIV(stackPointer) = sp1;
		executeCogMethodFromUnlinkedSendwithReceiver(cogMethodOf(GIV(newMethod)), rcvr);
		assert(0);
	}
	/* begin push: */
	longAtput(sp2 = GIV(stackPointer) - BytesPerWord, GIV(instructionPointer));
	GIV(stackPointer) = sp2;
	return activateInterpreterMethodFromMachineCode();
}


/*	Check for stack overflow, moving frames to another stack if so. */

static void
handleStackOverflow(void)
{   DECL_MAYBE_SQ_GLOBAL_STRUCT
    sqInt callerContextOrNil;
    char *callerFP;
    char *callerFP1;
    sqInt index;
    StackPage *lruOrFree;
    StackPage *newPage;
    sqInt overflowCount;
    char *overflowLimitAddress;
    char *theFP;
    StackPage *thePage;
    char *theSP;

	if (!(GIV(stackPointer) < ((GIV(stackPage)->realStackLimit)))) {
		return;
	}

	/* The stack has overflowed this page.  If the system is executing some recursive algorithm,
	 e.g. fibonacci, then the system could thrash overflowing the stack if the call soon returns
	 back to the current page.  To avoid thrashing, since overflow is quite slow, we can move
	 more than one frame.  The idea is to record which page has overflowed, and the first
	 time it overflows move one frame, the second time two frames, and so on.  We move no
	 more frames than would leave the page half occupied. */

	GIV(statStackOverflow) += 1;
	theFP = GIV(framePointer);
	if (GIV(stackPage) == GIV(overflowedPage)) {
		overflowLimitAddress = ((GIV(stackPage)->baseAddress)) - GIV(overflowLimit);
		overflowCount = GIV(extraFramesToMoveOnOverflow) += 1;
		while ((((overflowCount -= 1)) >= 0)
 && ((((callerFP = frameCallerFP(theFP))) < overflowLimitAddress)
 && (!((longAt(callerFP + FoxSavedFP)) == 0)))) {
			theFP = callerFP;
		}
	}
	else {
		GIV(overflowedPage) = GIV(stackPage);
		GIV(extraFramesToMoveOnOverflow) = 0;
	}
	/* begin ensureCallerContext: */
	/* begin frameCallerFP: */
	callerFP1 = pointerForOop(longAt(theFP + FoxSavedFP));
	if (callerFP1 == 0) {
		/* begin frameCallerContext: */
		assert(isBaseFrame(theFP));
		/* begin stackPageFor: */
		/* begin stackPageAt: */
		/* begin pageIndexFor: */
		assert((((((char *) theFP)) >= (GIV(stackBasePlus1) - 1)) && ((((char *) theFP)) <= (((char *) GIV(pages))))));
		index = pageIndexForstackBasePlus1bytesPerPage(theFP, GIV(stackBasePlus1), GIV(bytesPerPage));
		thePage = stackPageAtpages(index, GIV(pages));
		callerContextOrNil = longAt((thePage->baseAddress));
		assert(addressCouldBeObj(callerContextOrNil));
		assert((callerContextOrNil == (nilObject()))
		 || (isContext(callerContextOrNil)));
		goto l1;
	}
	/* begin ensureFrameIsMarried:SP: */
	VM_LABEL(16ensureFrameIsMarriedSP);
	/* begin frameCallerStackPointer: */
	assert(!(isBaseFrame(theFP)));
	theSP = (theFP + ((FoxCallerSavedIP + BytesPerWord) + ((((((usqInt)(longAt(theFP + FoxMethod)))) < heapBase
	? (mframeCogMethod(theFP)->cmNumArgs)
	: byteAt((theFP + FoxIFrameFlags) + 1))) << ShiftForWord))) + BytesPerWord;
	if (((((usqInt)(longAt(callerFP1 + FoxMethod)))) < heapBase
		? ((longAt(callerFP1 + FoxMethod)) & MFMethodFlagHasContextFlag) != 0
		: (byteAt((callerFP1 + FoxIFrameFlags) + 2)) != 0)) {
		assert(isContext(frameContext(callerFP1)));
		longAt(callerFP1 + FoxThisContext);
		goto l3;
	}
	marryFrameSP(callerFP1, theSP);
l3:	/* end ensureFrameIsMarried:SP: */;
l1:	/* end ensureCallerContext: */;
	/* begin newStackPage */
	lruOrFree = (mostRecentlyUsedPage()->nextPage);
	if (isFree(lruOrFree)) {
		newPage = lruOrFree;
		goto l2;
	}
	divorceFramesIn(lruOrFree);
	newPage = lruOrFree;
l2:	/* end newStackPage */;
	moveFramesInthroughtoPage(GIV(stackPage), theFP, newPage);
	/* begin setStackPageAndLimit: */
	GIV(stackPage) = newPage;
	if (GIV(stackLimit) != (((char *) (((usqInt) -1))))) {
		GIV(stackLimit) = (GIV(stackPage)->stackLimit);
	}
	markStackPageMostRecentlyUsed(newPage);
	GIV(framePointer) = (GIV(stackPage)->headFP);
	GIV(stackPointer) = (GIV(stackPage)->headSP);
	if (1) {
		assert(validInstructionPointerinFrame(GIV(instructionPointer), GIV(framePointer)));
		assert((!(frameHasContext(GIV(framePointer))))
		 || (isContext(frameContext(GIV(framePointer)))));
	}
	else {
		assert(!(frameHasContext(GIV(framePointer))));
		assert(validInstructionPointerinMethodframePointer(GIV(instructionPointer), GIV(method), GIV(framePointer)));
	}
}


/*	The stackPointer is below the stackLimit. This is either because of a
	stack overflow or the setting of stackLimit to indicate a possible
	interrupt. Check for interrupts and stackOverflow and deal with each
	appropriately. Answer if a context switch occurred. */

static sqInt
handleStackOverflowOrEventAllowContextSwitch(sqInt mayContextSwitch)
{   DECL_MAYBE_SQ_GLOBAL_STRUCT
    sqInt switched;

	if (GIV(stackLimit) == ((GIV(stackPage)->realStackLimit))) {
		/* begin externalWriteBackHeadFramePointers */
		assert((GIV(framePointer) - GIV(stackPointer)) < LargeContextSize);
		assert(GIV(stackPage) == (mostRecentlyUsedPage()));
		/* begin setHeadFP:andSP:inPage: */
		assert(GIV(stackPointer) < GIV(framePointer));
		assert((GIV(stackPointer) < ((GIV(stackPage)->baseAddress)))
		 && (GIV(stackPointer) > (((GIV(stackPage)->realStackLimit)) - LargeContextSize)));
		assert((GIV(framePointer) < ((GIV(stackPage)->baseAddress)))
		 && (GIV(framePointer) > (((GIV(stackPage)->realStackLimit)) - (((sqInt) LargeContextSize >> 1)))));
		(GIV(stackPage)->headFP = GIV(framePointer));
		(GIV(stackPage)->headSP = GIV(stackPointer));
		assert(pageListIsWellFormed());
		switched = 0;
	}
	else {
		switched = checkForEventsMayContextSwitch(mayContextSwitch);
	}
	handleStackOverflow();
	return switched;
}

static sqInt
headerOf(sqInt methodPointer)
{
    sqInt methodHeader;

	methodHeader = longAt((methodPointer + BaseHeaderSize) + (HeaderIndex << ShiftForWord));
	return (isCogMethodReference(methodHeader)
		? (((CogMethod *) methodHeader)->methodHeader)
		: methodHeader);
}


/*	This is a C implementation needed by stackPageByteSize when translated. */

sqInt
highBit(usqInt anUnsignedValue)
{
    sqInt bitNo;
    usqInt shifted;

	shifted = anUnsignedValue;
	bitNo = 0;
	
#  if BytesPerWord > 4
	if (!(shifted < (1 << 32))) {
		shifted = ((usqInt) shifted) >> 32;
		bitNo += 32;
	}

#  endif /* BytesPerWord > 4 */

	if (!(shifted < (1 << 16))) {
		shifted = ((usqInt) shifted) >> 16;
		bitNo += 16;
	}
	if (!(shifted < (1 << 8))) {
		shifted = ((usqInt) shifted) >> 8;
		bitNo += 8;
	}
	if (!(shifted < (1 << 4))) {
		shifted = ((usqInt) shifted) >> 4;
		bitNo += 4;
	}
	if (!(shifted < (1 << 2))) {
		shifted = ((usqInt) shifted) >> 2;
		bitNo += 2;
	}
	if (!(shifted < (1 << 1))) {
		shifted = ((usqInt) shifted) >> 1;
		bitNo += 1;
	}
	return bitNo + shifted;
}


/*	<Integer> */

static sqInt
iframeIsBlockActivation(char *theFP)
{
	return (byteAt((theFP + FoxIFrameFlags) + 3)) != 0;
}

static sqInt
iframeMethod(char *theFP)
{
	return longAt(theFP + FoxMethod);
}

static sqInt
iframeReceiver(char *theFP)
{
	return longAt(theFP + FoxIFReceiver);
}

static sqInt
iframeSavedIP(char *theFP)
{
	return longAt(theFP + FoxIFSavedIP);
}


/*	This is for low-level error reporting. If either of the C stack pointers
	are pointing into the stack zone then write them back to framePointer
	and/or stackPointer so that the stack backtrace will be up to date. Write
	their original values through savedFPP & savedSPP if non-null. */

void
ifValidWriteBackStackPointersSaveTo(void *theCFP, void *theCSP, char **savedFPP, char **savedSPP)
{   DECL_MAYBE_SQ_GLOBAL_STRUCT
	if (savedFPP != 0) {
		savedFPP[0] = GIV(framePointer);
	}
	if (savedSPP != 0) {
		savedSPP[0] = GIV(stackPointer);
	}
	if ((((((usqInt)theCFP)) & (BytesPerWord - 1)) == 0)
	 && ((((((usqInt)theCFP)) >= (((usqInt)(GIV(stackBasePlus1) - 1)))) && ((((usqInt)theCFP)) <= (((usqInt)GIV(pages))))))) {
		GIV(framePointer) = theCFP;
	}
	if ((((((usqInt)theCSP)) & (BytesPerWord - 1)) == 0)
	 && ((((((usqInt)theCSP)) >= (((usqInt)(GIV(stackBasePlus1) - 1)))) && ((((usqInt)theCSP)) <= (((usqInt)GIV(pages))))))) {
		GIV(stackPointer) = theCSP;
	}
}


/*	a more complex version that tells both the word reversal and the
	endianness of the machine it came from. Low half of word is 6502. Top byte
	is top byte of #doesNotUnderstand: on this machine. ($d on the Mac or $s
	on the PC)
 */

static sqInt
imageSegmentVersion(void)
{
    sqInt wholeWord;


	/* first data word, 'does'  */

	wholeWord = longAt((longAt((GIV(specialObjectsOop) + BaseHeaderSize) + (SelectorDoesNotUnderstand << ShiftForWord))) + BaseHeaderSize);
	return ((BytesPerWord == 4
	? 6505
	: 68003)) | (wholeWord & 4278190080UL);
}


/*	Move objects to consolidate free space into one big chunk. Return the
	newly created free chunk.
 */

static sqInt
incCompBody(void)
{   DECL_MAYBE_SQ_GLOBAL_STRUCT
    sqInt bytesToBeFreed;

	fwdTableInit(BytesPerWord * 2);

	/* update pointers to point at new oops */

	bytesToBeFreed = incCompMakeFwd();
	mapPointersInObjectsFromto(GIV(youngStart), GIV(freeStart));
	return incCompMove(bytesToBeFreed);
}


/*	Create and initialize forwarding blocks for all non-free objects 
	following compStart. If the supply of forwarding blocks is exhausted, 
	set compEnd to the first chunk above the area to be compacted;
	otherwise, set it to endOfMemory. Return the number of bytes to be freed. */

static sqInt
incCompMakeFwd(void)
{   DECL_MAYBE_SQ_GLOBAL_STRUCT
    sqInt bytesToBeFreed;
    sqInt fwdBlock;
    sqInt fwdBlock1;
    sqInt header;
    sqInt header1;
    sqInt newOop;
    sqInt oop;
    sqInt originalHeader;
    sqInt originalHeaderType;
    sqInt realHeader;
    sqInt sz;
    sqInt sz1;

	bytesToBeFreed = 0;
	oop = GIV(compStart) + (headerTypeBytes[(longAt(GIV(compStart))) & TypeMask]);
	assert(oopisGreaterThanandLessThan(oop, startOfMemory(), GIV(freeStart)));
	while ((((usqInt) oop)) < (((usqInt) GIV(freeStart)))) {
		GIV(statMkFwdCount) += 1;
		assert(oopisGreaterThanandLessThan(oop, startOfMemory(), GIV(freeStart)));
		if (((longAt(oop)) & TypeMask) == HeaderTypeFree) {
			bytesToBeFreed += (longAt(oop)) & AllButTypeMask;
		}
		else {
			/* begin fwdBlockGet: */
			GIV(fwdTableNext) += BytesPerWord * 2;
			if (GIV(fwdTableNext) <= GIV(fwdTableLast)) {
				fwdBlock = GIV(fwdTableNext);
				goto l1;
			}
			else {
				fwdBlock = null;
				goto l1;
			}
		l1:	/* end fwdBlockGet: */;
			if (fwdBlock == null) {

				/* stop; we have used all available forwarding blocks */

				GIV(compEnd) = oop - (headerTypeBytes[(longAt(oop)) & TypeMask]);
				return bytesToBeFreed;
			}
			newOop = oop - bytesToBeFreed;
			assert(oopisGreaterThanandLessThan(newOop, startOfMemory(), GIV(freeStart)));
			/* begin initForwardBlock:mapping:to:withBackPtr: */
			originalHeader = longAt(oop);
			assert(fwdBlock != null);
			assert((originalHeader & MarkBit) == 0);
			originalHeaderType = originalHeader & TypeMask;
			longAtput(fwdBlock, newOop);
			longAtput(fwdBlock + BytesPerWord, originalHeader);
			if (0) {
				longAtput(fwdBlock + (BytesPerWord * 2), oop);
			}
			longAtput(oop, (((usqInt) fwdBlock) >> 1) | (MarkBit | originalHeaderType));
		}
		/* begin objectAfterWhileForwarding: */
		header = longAt(oop);
		if ((header & MarkBit) == 0) {
			/* begin objectAfter: */
			if (DoAssertionChecks) {
				if ((((usqInt) oop)) >= (((usqInt) GIV(endOfMemory)))) {
					error("no objects after the end of memory");
				}
			}
			if (((longAt(oop)) & TypeMask) == HeaderTypeFree) {
				sz1 = (longAt(oop)) & AllButTypeMask;
			}
			else {
				/* begin sizeBitsOf: */
				header1 = longAt(oop);
				sz1 = ((header1 & TypeMask) == HeaderTypeSizeAndClass
					? (longAt(oop - (BytesPerWord * 2))) & LongSizeMask
					: header1 & SizeMask);
			}
			oop = (oop + sz1) + (headerTypeBytes[(longAt(oop + sz1)) & TypeMask]);
			goto l2;
		}
		fwdBlock1 = (header & AllButMarkBitAndTypeMask) << 1;
		assert(fwdBlockValid(fwdBlock1));

		/* following code is like sizeBitsOf: */

		realHeader = longAt(fwdBlock1 + BytesPerWord);
		if ((realHeader & TypeMask) == HeaderTypeSizeAndClass) {
			sz = (longAt(oop - (BytesPerWord * 2))) & LongSizeMask;
		}
		else {
			sz = realHeader & SizeMask;
		}
		oop = (oop + sz) + (headerTypeBytes[(longAt(oop + sz)) & TypeMask]);
	l2:	/* end objectAfterWhileForwarding: */;
	}
	GIV(compEnd) = GIV(endOfMemory);
	return bytesToBeFreed;
}


/*	Move all non-free objects between compStart and compEnd to their new 
	locations, restoring their headers in the process. Create a new free 
	block at the end of memory. Return the newly created free chunk. */
/*	Note: The free block used by the allocator always must be the last free 
	block in memory. It may take several compaction passes to make all 
	free space bubble up to the end of memory. */

static sqInt
incCompMove(sqInt bytesFreed)
{   DECL_MAYBE_SQ_GLOBAL_STRUCT
    sqInt bytesToMove;
    usqInt firstWord;
    sqInt fwdBlock;
    sqInt fwdBlock1;
    sqInt header;
    sqInt header1;
    sqInt header2;
    sqInt header3;
    sqInt header4;
    usqInt lastWord;
    sqInt newFreeChunk;
    sqInt newOop;
    sqInt next;
    sqInt oop;
    sqInt realHeader;
    sqInt sz;
    sqInt sz1;
    sqInt sz2;
    sqInt sz3;
    sqInt target;
    usqInt w;

	newOop = null;
	oop = GIV(compStart) + (headerTypeBytes[(longAt(GIV(compStart))) & TypeMask]);
	while ((((usqInt) oop)) < (((usqInt) GIV(compEnd)))) {
		GIV(statCompMoveCount) += 1;
		/* begin objectAfterWhileForwarding: */
		header2 = longAt(oop);
		if ((header2 & MarkBit) == 0) {
			/* begin objectAfter: */
			if (DoAssertionChecks) {
				if ((((usqInt) oop)) >= (((usqInt) GIV(endOfMemory)))) {
					error("no objects after the end of memory");
				}
			}
			if (((longAt(oop)) & TypeMask) == HeaderTypeFree) {
				sz3 = (longAt(oop)) & AllButTypeMask;
			}
			else {
				/* begin sizeBitsOf: */
				header4 = longAt(oop);
				sz3 = ((header4 & TypeMask) == HeaderTypeSizeAndClass
					? (longAt(oop - (BytesPerWord * 2))) & LongSizeMask
					: header4 & SizeMask);
			}
			next = (oop + sz3) + (headerTypeBytes[(longAt(oop + sz3)) & TypeMask]);
			goto l1;
		}
		fwdBlock1 = (header2 & AllButMarkBitAndTypeMask) << 1;
		assert(fwdBlockValid(fwdBlock1));

		/* following code is like sizeBitsOf: */

		realHeader = longAt(fwdBlock1 + BytesPerWord);
		if ((realHeader & TypeMask) == HeaderTypeSizeAndClass) {
			sz2 = (longAt(oop - (BytesPerWord * 2))) & LongSizeMask;
		}
		else {
			sz2 = realHeader & SizeMask;
		}
		next = (oop + sz2) + (headerTypeBytes[(longAt(oop + sz2)) & TypeMask]);
	l1:	/* end objectAfterWhileForwarding: */;
		if (!(((longAt(oop)) & TypeMask) == HeaderTypeFree)) {

			/* a moving object; unwind its forwarding block */

			fwdBlock = ((longAt(oop)) & AllButMarkBitAndTypeMask) << 1;
			assert(fwdBlockValid(fwdBlock));
			newOop = longAt(fwdBlock);
			header = longAt(fwdBlock + BytesPerWord);
			longAtput(oop, header);

			/* move the oop (including any extra header words)  */

			bytesToMove = oop - newOop;
			/* begin sizeBitsOf: */
			header1 = longAt(oop);
			sz = ((header1 & TypeMask) == HeaderTypeSizeAndClass
				? (longAt(oop - (BytesPerWord * 2))) & LongSizeMask
				: header1 & SizeMask);
			firstWord = oop - (headerTypeBytes[(longAt(oop)) & TypeMask]);
			lastWord = (oop + sz) - BaseHeaderSize;
			target = firstWord - bytesToMove;
			for (w = firstWord; w <= lastWord; w += BytesPerWord) {
				longAtput(target, longAt(w));
				target += BytesPerWord;
			}
		}
		oop = next;
	}
	if (newOop == null) {

		/* no objects moved */

		oop = GIV(compStart) + (headerTypeBytes[(longAt(GIV(compStart))) & TypeMask]);
		if ((((longAt(oop)) & TypeMask) == HeaderTypeFree)
		 && ((objectAfter(oop)) == (GIV(compEnd) + (headerTypeBytes[(longAt(GIV(compEnd))) & TypeMask])))) {
			newFreeChunk = oop;
		}
		else {
			newFreeChunk = GIV(freeStart);
		}
	}
	else {

		/* initialize the newly freed memory chunk */
		/* newOop is the last object moved; free chunk starts right after it */

		newFreeChunk = newOop + (sizeBitsOf(newOop));
		/* begin setSizeOfFree:to: */
		longAtput(newFreeChunk, (bytesFreed & AllButTypeMask) | HeaderTypeFree);
	}
	/* begin safeObjectAfter: */
	if (((longAt(newFreeChunk)) & TypeMask) == HeaderTypeFree) {
		sz1 = (longAt(newFreeChunk)) & AllButTypeMask;
	}
	else {
		/* begin sizeBitsOf: */
		header3 = longAt(newFreeChunk);
		sz1 = ((header3 & TypeMask) == HeaderTypeSizeAndClass
			? (longAt(newFreeChunk - (BytesPerWord * 2))) & LongSizeMask
			: header3 & SizeMask);
	}
	next = ((newFreeChunk + sz1) >= GIV(freeStart)
		? GIV(freeStart)
		: (newFreeChunk + sz1) + (headerTypeBytes[(longAt(newFreeChunk + sz1)) & TypeMask]));
	assert((next == GIV(freeStart))
	 || (next == (oopFromChunk(GIV(compEnd)))));
	if (next == GIV(freeStart)) {
		initializeMemoryFirstFree(newFreeChunk);
	}
	else {
		initializeMemoryFirstFree(GIV(freeStart));
	}
	return newFreeChunk;
}


/*	Return the equivalent of 
	aClass includesBehavior: aSuperclass.
	Note: written for efficiency and better inlining (only 1 temp) */

sqInt
includesBehaviorThatOf(sqInt aClass, sqInt aSuperclass)
{   DECL_MAYBE_SQ_GLOBAL_STRUCT
    sqInt theClass;

	if ((((theClass = aClass)) == aSuperclass)
	 || (aSuperclass == GIV(nilObj))) {
		return 1;
	}
	do {
		if (((theClass = longAt((theClass + BaseHeaderSize) + (SuperclassIndex << ShiftForWord)))) == aSuperclass) {
			return 1;
		}
	} while(theClass != GIV(nilObj));
	return 0;
}


/*	Do a mark/sweep garbage collection of just the young object
	area of object memory (i.e., objects above youngStart), using
	the root table to identify objects containing pointers to
	young objects from the old object area. */

void
incrementalGC(void)
{   DECL_MAYBE_SQ_GLOBAL_STRUCT
    sqInt delta;
    sqInt freeSizeNow;
    sqInt growth;
    sqInt i;
    sqInt i1;
    sqInt limit;
    sqInt limit1;
    sqInt oop;
    sqInt survivorCount;
    sqInt traceType;
    sqInt weDidGrow;

	if (GIV(rootTableCount) >= RootTableSize) {

		/* root table overflow; cannot do an incremental GC (this should be very rare) */

		GIV(statRootTableOverflows) += 1;
		fullGC(); return;
	}
	/* begin initializeFreeBlocksPreSweep */
	/* begin setSizeOfFree:to: */
	longAtput(GIV(freeStart), ((GIV(endOfMemory) - GIV(freeStart)) & AllButTypeMask) | HeaderTypeFree);
	assert(isFreeObject(GIV(freeStart)));
	assert((GIV(freeStart) + (sizeOfFree(GIV(freeStart)))) == GIV(endOfMemory));
	assert((GIV(freeStart) < GIV(endOfMemory))
	 && (GIV(endOfMemory) < GIV(memoryLimit)));
	runLeakCheckerForFullGC(0);
	/* begin preGCAction: */
	VM_LABEL(1preGCAction);
	if (GIV(stackPage) != 0) {
		/* begin externalWriteBackHeadFramePointers */
		assert((GIV(framePointer) - GIV(stackPointer)) < LargeContextSize);
		assert(GIV(stackPage) == (mostRecentlyUsedPage()));
		/* begin setHeadFP:andSP:inPage: */
		assert(GIV(stackPointer) < GIV(framePointer));
		assert((GIV(stackPointer) < ((GIV(stackPage)->baseAddress)))
		 && (GIV(stackPointer) > (((GIV(stackPage)->realStackLimit)) - LargeContextSize)));
		assert((GIV(framePointer) < ((GIV(stackPage)->baseAddress)))
		 && (GIV(framePointer) > (((GIV(stackPage)->realStackLimit)) - (((sqInt) LargeContextSize >> 1)))));
		(GIV(stackPage)->headFP = GIV(framePointer));
		(GIV(stackPage)->headSP = GIV(stackPointer));
		assert(pageListIsWellFormed());
	}
	GIV(inFullGC) = 0;
	if (recordEventTrace()) {
		traceType = (0
			? TraceFullGC
			: TraceIncrementalGC);
		/* begin recordTrace:thing:source: */
		GIV(traceLog)[GIV(traceLogIndex)] = traceType;
		GIV(traceLog)[GIV(traceLogIndex) + 1] = traceType;
		GIV(traceLog)[GIV(traceLogIndex) + 2] = 0;
		GIV(traceLogIndex) = (GIV(traceLogIndex) + 3) % TraceBufferSize;
	}
	GIV(gcStartUsecs) = ioUTCMicrosecondsNow();
	GIV(weakRootCount) = 0;
	GIV(statSweepCount) = GIV(statMarkCount) = GIV(statMkFwdCount) = GIV(statCompMoveCount) = 0;
	markPhase(0);
	assert(GIV(weakRootCount) <= WeakRootTableSize);
	for (i = 1; i <= GIV(weakRootCount); i += 1) {
		finalizeReference(GIV(weakRoots)[i]);
	}
	survivorCount = sweepPhase();
	runLeakCheckerForFullGC(0);
	/* begin incrementalCompaction */
	if (GIV(compStart) == GIV(freeStart)) {
		initializeMemoryFirstFree(GIV(freeStart));
	}
	else {
		incCompBody();
	}
	GIV(statIncrGCs) += 1;
	GIV(statGCEndUsecs) = ioUTCMicrosecondsNow();
	GIV(statIGCDeltaUsecs) = GIV(statGCEndUsecs) - GIV(gcStartUsecs);
	GIV(statIncrGCUsecs) += GIV(statIGCDeltaUsecs);
	/* begin capturePendingFinalizationSignals */
	GIV(statPendingFinalizationSignals) = GIV(pendingFinalizationSignals);
	GIV(statRootTableCount) = GIV(rootTableCount);
	GIV(statSurvivorCount) = survivorCount;
	weDidGrow = 0;
	if (((survivorCount > GIV(tenuringThreshold))
 || (GIV(rootTableCount) >= RootTableRedZone))
	 || (GIV(forceTenureFlag) == 1)) {

		/* move up the young space boundary if
		  * there are too many survivors:
			this limits the number of objects that must be
			processed on future incremental GC's
		  * we're about to overflow the roots table:
			this limits the number of full GCs that may be caused
			by root table overflows in the near future */

		GIV(forceTenureFlag) = 0;
		GIV(statTenures) += 1;
		/* begin clearRootsTable */
		for (i1 = 1; i1 <= GIV(rootTableCount); i1 += 1) {

			/* clear root bits of current root table entries */

			oop = GIV(rootTable)[i1];
			longAtput(oop, (longAt(oop)) & AllButRootBit);
			GIV(rootTable)[i1] = 0;
		}
		GIV(rootTableCount) = 0;
		if (((((((usqInt) GIV(freeStart))) < (((usqInt) GIV(reserveStart)))
	? (((usqInt) GIV(reserveStart))) - (((usqInt) GIV(freeStart)))
	: 0)) < GIV(growHeadroom))
		 && (GIV(gcBiasToGrow) > 0)) {
			/* begin biasToGrow */
			/* begin growObjectMemory: */
			delta = (((sqInt) (GIV(growHeadroom) * 3) >> 1)) - (((((usqInt) GIV(freeStart))) < (((usqInt) GIV(reserveStart)))
	? (((usqInt) GIV(reserveStart))) - (((usqInt) GIV(freeStart)))
	: 0));
			GIV(statGrowMemory) += 1;
			limit = sqGrowMemoryBy(GIV(memoryLimit), delta);
			if (!(limit == GIV(memoryLimit))) {
				/* begin setMemoryLimit: */
				assert(((limit - 24) & (BytesPerWord - 1)) == 0);
				GIV(memoryLimit) = limit - 24;
				initializeMemoryFirstFree(GIV(freeStart));
				sqMakeMemoryNotExecutableFromTo(heapBase, GIV(memoryLimit));
			}
			weDidGrow = 1;
		}
		GIV(youngStart) = GIV(freeStart);
	}
	/* begin postGCAction: */
	freeSizeNow = ((((usqInt) GIV(freeStart))) < (((usqInt) GIV(reserveStart)))
		? (((usqInt) GIV(reserveStart))) - (((usqInt) GIV(freeStart)))
		: 0);
	if ((freeSizeNow > GIV(shrinkThreshold))
	 && (freeSizeNow > GIV(growHeadroom))) {
		/* begin shrinkObjectMemory: */
		GIV(statShrinkMemory) += 1;
		limit1 = sqShrinkMemoryBy(GIV(memoryLimit), freeSizeNow - GIV(growHeadroom));
		if (!(limit1 == GIV(memoryLimit))) {
			/* begin setMemoryLimit: */
			assert(((limit1 - 24) & (BytesPerWord - 1)) == 0);
			GIV(memoryLimit) = limit1 - 24;
			initializeMemoryFirstFree(GIV(freeStart));
		}
	}
	cogitPostGCAction();
	signalSemaphoreWithIndex(GIV(gcSemaphoreIndex));
	GIV(lastCoggableInterpretedBlockMethod) = GIV(lastUncoggableInterpretedBlockMethod) = null;
	GIV(inFullGC) = 0;
	runLeakCheckerForFullGC(0);
	if (weDidGrow) {
		/* begin biasToGrowCheckGCLimit */
		growth = (GIV(youngStart) - heapBase) - GIV(gcBiasToGrowThreshold);
		if (growth < 0) {
			GIV(gcBiasToGrowThreshold) = GIV(youngStart) - memory;
		}
		if (growth > GIV(gcBiasToGrowGCLimit)) {
			fullGC();
			GIV(gcBiasToGrowThreshold) = GIV(youngStart) - memory;
		}
	}
}


/*	Initialize Interpreter state before starting execution of a new image. */

static void
initializeInterpreter(sqInt bytesToShift)
{   DECL_MAYBE_SQ_GLOBAL_STRUCT
    sqInt ccIndex;
    sqInt cct;
    sqInt classArrayClass;
    sqInt classArrayObj;
    sqInt header;
    sqInt i;
    sqInt i1;
    sqInt i11;
    sqInt i2;
    sqInt i3;
    sqInt i4;
    sqInt index;
    sqInt oop;

	interpreterProxy = sqGetInterpreterProxy();
	dummyReferToProxy();
	initializeObjectMemory(bytesToShift);
	/* begin checkAssumedCompactClasses */
	/* begin checkCompactIndex:isClass:named: */
	if ((ClassArrayCompactIndex != 0)
	 && ((longAt((GIV(specialObjectsOop) + BaseHeaderSize) + (ClassArray << ShiftForWord))) != (longAt(((longAt((GIV(specialObjectsOop) + BaseHeaderSize) + (CompactClasses << ShiftForWord))) + BaseHeaderSize) + ((ClassArrayCompactIndex - 1) << ShiftForWord))))) {
		invalidCompactClassError("Array");
	}
	/* begin checkCompactIndex:isClass:named: */
	if ((ClassLargeNegativeIntegerCompactIndex != 0)
	 && ((longAt((GIV(specialObjectsOop) + BaseHeaderSize) + (ClassLargeNegativeInteger << ShiftForWord))) != (longAt(((longAt((GIV(specialObjectsOop) + BaseHeaderSize) + (CompactClasses << ShiftForWord))) + BaseHeaderSize) + ((ClassLargeNegativeIntegerCompactIndex - 1) << ShiftForWord))))) {
		invalidCompactClassError("LargeNegativeInteger");
	}
	/* begin checkCompactIndex:isClass:named: */
	if ((ClassLargePositiveIntegerCompactIndex != 0)
	 && ((longAt((GIV(specialObjectsOop) + BaseHeaderSize) + (ClassLargePositiveInteger << ShiftForWord))) != (longAt(((longAt((GIV(specialObjectsOop) + BaseHeaderSize) + (CompactClasses << ShiftForWord))) + BaseHeaderSize) + ((ClassLargePositiveIntegerCompactIndex - 1) << ShiftForWord))))) {
		invalidCompactClassError("LargePositiveInteger");
	}
	/* begin checkCompactIndex:isClass:named: */
	if ((ClassFloatCompactIndex != 0)
	 && ((longAt((GIV(specialObjectsOop) + BaseHeaderSize) + (ClassFloat << ShiftForWord))) != (longAt(((longAt((GIV(specialObjectsOop) + BaseHeaderSize) + (CompactClasses << ShiftForWord))) + BaseHeaderSize) + ((ClassFloatCompactIndex - 1) << ShiftForWord))))) {
		invalidCompactClassError("Float");
	}
	/* begin checkCompactIndex:isClass:named: */
	if ((ClassBlockClosureCompactIndex != 0)
	 && ((longAt((GIV(specialObjectsOop) + BaseHeaderSize) + (ClassBlockClosure << ShiftForWord))) != (longAt(((longAt((GIV(specialObjectsOop) + BaseHeaderSize) + (CompactClasses << ShiftForWord))) + BaseHeaderSize) + ((ClassBlockClosureCompactIndex - 1) << ShiftForWord))))) {
		invalidCompactClassError("BlockClosure");
	}
	/* begin checkCompactIndex:isClass:named: */
	if ((ClassMethodContextCompactIndex != 0)
	 && ((longAt((GIV(specialObjectsOop) + BaseHeaderSize) + (ClassMethodContext << ShiftForWord))) != (longAt(((longAt((GIV(specialObjectsOop) + BaseHeaderSize) + (CompactClasses << ShiftForWord))) + BaseHeaderSize) + ((ClassMethodContextCompactIndex - 1) << ShiftForWord))))) {
		invalidCompactClassError("MethodContext");
	}
	/* begin compactIndexOfClass: */
	cct = longAt((GIV(specialObjectsOop) + BaseHeaderSize) + (CompactClasses << ShiftForWord));
	for (index = ((lengthOf(cct)) - 1); index >= 0; index += -2) {
		if ((longAt((cct + BaseHeaderSize) + (index << ShiftForWord))) == (longAt((GIV(specialObjectsOop) + BaseHeaderSize) + (ClassByteArray << ShiftForWord)))) {
			GIV(classByteArrayCompactIndex) = index + 1;
			goto l1;
		}
	}
	GIV(classByteArrayCompactIndex) = 0;
l1:	/* end compactIndexOfClass: */;
	GIV(primFailCode) = 0;
	/* begin initializeExtraClassInstVarIndices */
	VM_LABEL(0initializeExtraClassInstVarIndices);

	/* default */

	GIV(classNameIndex) = 6;

	/* default */

	GIV(thisClassIndex) = 5;
	classArrayObj = longAt((GIV(specialObjectsOop) + BaseHeaderSize) + (ClassArray << ShiftForWord));
	/* begin fetchClassOfNonInt: */
	if (((ccIndex = (((usqInt) (longAt(classArrayObj))) >> 12) & 31)) == 0) {
		classArrayClass = (longAt(classArrayObj - BaseHeaderSize)) & AllButTypeMask;
		goto l2;
	}
	else {
		classArrayClass = longAt(((longAt((GIV(specialObjectsOop) + BaseHeaderSize) + (CompactClasses << ShiftForWord))) + BaseHeaderSize) + ((ccIndex - 1) << ShiftForWord));
		goto l2;
	}
l2:	/* end fetchClassOfNonInt: */;
	/* begin sizeBitsOf: */
	header = longAt(classArrayClass);
	GIV(metaclassSizeBytes) = ((header & TypeMask) == HeaderTypeSizeAndClass
		? (longAt(classArrayClass - (BytesPerWord * 2))) & LongSizeMask
		: header & SizeMask);
	for (i4 = (InstanceSpecificationIndex + 1); i4 <= (lengthOf(classArrayClass)); i4 += 1) {
		if ((longAt((classArrayClass + BaseHeaderSize) + (i4 << ShiftForWord))) == classArrayObj) {
			GIV(thisClassIndex) = i4;
		}
	}
	for (i4 = (InstanceSpecificationIndex + 1); i4 <= (lengthOf(classArrayObj)); i4 += 1) {
		oop = longAt((classArrayObj + BaseHeaderSize) + (i4 << ShiftForWord));
		if ((((oop & 1) == 0)
 && (((((usqInt) (longAt(oop))) >> 8) & 15) >= 8))
		 && (((lengthOf(oop)) == 5)
 && ((strncmp("Array", firstFixedField(oop), 5)) == 0))) {
			GIV(classNameIndex) = i4;
		}
	}

	/* This is also the initialization flag for the stack system. */

	GIV(stackLimit) = 0;
	GIV(stackPage) = GIV(overflowedPage) = 0;
	GIV(extraFramesToMoveOnOverflow) = 0;
	/* begin setMethod: */
	assert((((usqInt)GIV(nilObj))) >= (startOfMemory()));
	GIV(method) = GIV(nilObj);
	GIV(messageSelector) = GIV(nilObj);
	GIV(newMethod) = GIV(nilObj);
	GIV(lkupClass) = GIV(nilObj);
	/* begin flushMethodCache */
	for (i = 1; i <= MethodCacheSize; i += 1) {
		GIV(methodCache)[i] = 0;
	}

	/* this for primitiveExternalMethod */

	GIV(lastMethodCacheProbeWrite) = 0;
	unlinkAllSends();
	/* begin flushAtCache */
	for (i1 = 1; i1 <= AtCacheTotalSize; i1 += 1) {
		GIV(atCache)[i1] = 0;
	}
	/* begin initialCleanup */
	/* begin flushMethodCache */
	for (i3 = 1; i3 <= MethodCacheSize; i3 += 1) {
		GIV(methodCache)[i3] = 0;
	}

	/* this for primitiveExternalMethod */

	GIV(lastMethodCacheProbeWrite) = 0;
	unlinkAllSends();
	/* begin flushAtCache */
	for (i11 = 1; i11 <= AtCacheTotalSize; i11 += 1) {
		GIV(atCache)[i11] = 0;
	}
	/* begin flushExternalPrimitiveTable */
	for (i2 = 0; i2 <= (MaxExternalPrimitiveTableSize - 1); i2 += 1) {
		externalPrimitiveTable[i2] = 0;
	}
	GIV(externalPrimitiveTableFirstFreeIndex) = 0;
	GIV(highestRunnableProcessPriority) = 0;
	GIV(nextProfileTick) = 0;
	GIV(profileSemaphore) = GIV(nilObj);
	GIV(profileProcess) = GIV(nilObj);
	GIV(profileMethod) = GIV(nilObj);
	GIV(nextPollUsecs) = 0;
	GIV(nextWakeupUsecs) = 0;
	GIV(tempOop) = 0;

	/* cmd-. as used for Mac but no other OS */

	GIV(interruptKeycode) = 2094;
	GIV(interruptPending) = 0;
	inIOProcessEvents = 0;
	deferDisplayUpdates = 0;
	GIV(pendingFinalizationSignals) = GIV(statPendingFinalizationSignals) = 0;
	GIV(globalSessionID) = 0;
	while (GIV(globalSessionID) == 0) {
		GIV(globalSessionID) = time(NULL) + ioMSecs();
	}
	GIV(jmpDepth) = 0;
	GIV(longRunningPrimitiveStartUsecs) = GIV(longRunningPrimitiveStopUsecs) = 0;
	GIV(maxExtSemTabSizeSet) = 0;
	GIV(statForceInterruptCheck) = 0;
	GIV(statStackOverflow) = 0;
	GIV(statCheckForEvents) = 0;
	GIV(statProcessSwitch) = 0;
	GIV(statIOProcessEvents) = 0;
	GIV(statStackPageDivorce) = 0;
}


/*	Initialize endOfMemory to the top of oop storage space, reserving some
	space for forwarding blocks, and set freeStart from which space is
	allocated. 
 */
/*	Note: The amount of space reserved for forwarding blocks should be chosen
	to ensure that incremental compactions can usually be done in a single
	pass. However, there should be enough forwarding blocks so a full
	compaction can be done
	in a reasonable number of passes, say ten. (A full compaction requires N
	object-moving passes, where N = number of non-garbage objects / number of
	forwarding blocks).
	
	di 11/18/2000 Re totalObjectCount: Provide a margin of one byte per object
	to be
	used for forwarding pointers at GC time. Since fwd blocks are 8 bytes,
	this means
	an absolute worst case of 8 passes to compact memory. In most cases it
	will be
	adequate to do compaction in a single pass. */
/*	reserve space for forwarding blocks and the interpreter. We can sacrifice
	forwarding block space at the cost of slower compactions but we cannot
	safely sacrifice interpreter allocation headroom. */

static void
initializeMemoryFirstFree(sqInt firstFree)
{   DECL_MAYBE_SQ_GLOBAL_STRUCT
    sqInt fwdBlockBytes;
    sqInt i;
    sqInt totalReserve;

	fwdBlockBytes = GIV(totalObjectCount) & ((WordMask - BytesPerWord) + 1);
	totalReserve = fwdBlockBytes + (interpreterAllocationReserveBytes());
	if ((((usqInt) (GIV(memoryLimit) - totalReserve))) < (((usqInt) (firstFree + BaseHeaderSize)))) {

		/* reserve enough space for a minimal free block of BaseHeaderSize bytes.
		  We are apparently in an emergency situation here because we have no space
		  for reserve and forwarding blocks.  But a full GC will occur immediately in	
		  sufficientSpaceAfterGC: which will grow memory and restore the reserve. */

		fwdBlockBytes = GIV(memoryLimit) - (firstFree + BaseHeaderSize);
	}
	/* begin setEndOfMemory: */
	assert(((GIV(memoryLimit) - fwdBlockBytes) & (BytesPerWord - 1)) == 0);
	GIV(endOfMemory) = GIV(memoryLimit) - fwdBlockBytes;
	GIV(reserveStart) = GIV(endOfMemory) - (interpreterAllocationReserveBytes());

	/* bytes available for oops */

	GIV(freeStart) = firstFree;
	GIV(scavengeThreshold) = (((GIV(freeStart) + GIV(edenBytes)) < GIV(reserveStart)) ? (GIV(freeStart) + GIV(edenBytes)) : GIV(reserveStart));
	if (AllocationCheckFiller != 0) {
		for (i = GIV(freeStart); i <= GIV(scavengeThreshold); i += BytesPerWord) {
			longAtput(i, (AllocationCheckFiller == 182275669
				? i
				: AllocationCheckFiller));
		}
	}
	GIV(needGCFlag) = 0;
	assert(GIV(freeStart) < GIV(reserveStart));
	assert(GIV(reserveStart) < GIV(endOfMemory));
	assert(GIV(endOfMemory) < GIV(memoryLimit));
}


/*	Initialize object memory variables at startup time. Assume endOfMemory is
	initially set (by the image-reading code) to the end of the last object in
	the image. Initialization redefines endOfMemory to be the end of the
	object allocation area based on the total available memory, but reserving
	some space for forwarding blocks.
 */
/*	Assume: image reader initializes the following variables:
	memory
	endOfMemory
	memoryLimit
	specialObjectsOop
	lastHash
	 */
/*	di 11/18/2000 fix slow full GC */
/*	set the start of the young object space */

static void
initializeObjectMemory(sqInt bytesToShift)
{   DECL_MAYBE_SQ_GLOBAL_STRUCT

	/* image may be at a different address; adjust oops for new location */

	GIV(youngStart) = GIV(endOfMemory);
	GIV(totalObjectCount) = adjustAllOopsBy(bytesToShift);
	initializeMemoryFirstFree(GIV(endOfMemory));

	/* heavily used special objects */

	GIV(specialObjectsOop) += bytesToShift;
	GIV(nilObj) = longAt((GIV(specialObjectsOop) + BaseHeaderSize) + (NilObject << ShiftForWord));
	GIV(falseObj) = longAt((GIV(specialObjectsOop) + BaseHeaderSize) + (FalseObject << ShiftForWord));
	GIV(trueObj) = longAt((GIV(specialObjectsOop) + BaseHeaderSize) + (TrueObject << ShiftForWord));
	GIV(rootTableCount) = 0;
	GIV(lowSpaceThreshold) = 0;
	GIV(signalLowSpace) = 0;
	GIV(compStart) = 0;
	GIV(compEnd) = 0;
	GIV(fwdTableNext) = 0;
	GIV(fwdTableLast) = 0;
	GIV(remapBufferCount) = 0;

	/* tenure all suriving objects if survivor count is over this threshold */

	GIV(tenuringThreshold) = 2000;

	/* four megabytes of headroom when growing */

	GIV(growHeadroom) = (4 * 1024) * 1024;

	/* eight megabytes of free space before shrinking */
	/* garbage collection statistics */

	GIV(shrinkThreshold) = (8 * 1024) * 1024;
	GIV(statFullGCs) = 0;
	GIV(statFullGCUsecs) = 0;
	GIV(statIncrGCs) = 0;
	GIV(statIncrGCUsecs) = 0;
	GIV(statTenures) = 0;
	GIV(statRootTableOverflows) = 0;
	GIV(statGrowMemory) = 0;
	GIV(statShrinkMemory) = 0;
	GIV(forceTenureFlag) = 0;
	GIV(gcBiasToGrow) = 0;
	GIV(gcBiasToGrowGCLimit) = 0;
	GIV(extraRootCount) = 0;
}


/*	Initialize the stack pages. In the C VM theStackPages will be alloca'ed
	memory to hold the
	stack pages on the C stack. In the simulator they are housed in the memory
	between the
	cogMethodZone and the heap. */

static void
initializeStacknumSlotspageSizestackLimitOffsetstackPageHeadroom(char *theStackPages, sqInt stackSlots, sqInt slotsPerPage, sqInt stackLimitOffsetBytes, sqInt stackPageHeadroomBytes)
{   DECL_MAYBE_SQ_GLOBAL_STRUCT
    sqInt count;
    sqInt index;
    sqInt memIndex;
    sqInt numPages;
    StackPage *page;
    char *pageStructBase;
    void *pointer;
    sqInt structStackPageSize;
    sqInt theIndex;

	;
	structStackPageSize = sizeof(CogStackPage);
	GIV(bytesPerPage) = slotsPerPage * BytesPerWord;

	/* Because stack pages grow down baseAddress is at the top of a stack page and so to avoid
	 subtracting BytesPerWord from baseAddress and lastAddress in the init loop below we simply
	 push the stackPage array up one word to avoid the overlap.  This word is extraStackBytes. */

	numPages = GIV(numStackPages);
	pageStructBase = (theStackPages + (numPages * GIV(bytesPerPage))) + BytesPerWord;
	GIV(pages) = ((StackPage *) pageStructBase);
	for (index = 0; index <= (numPages - 1); index += 1) {
		/* begin stackPageAt: */
		page = stackPageAtpages(index, GIV(pages));
		(page->lastAddress = theStackPages + (index * GIV(bytesPerPage)));
		(page->baseAddress = ((page->lastAddress)) + GIV(bytesPerPage));
		(page->stackLimit = (((page->lastAddress)) + stackLimitOffsetBytes) + stackPageHeadroomBytes);
		(page->realStackLimit = (page->stackLimit));
		(page->baseFP = 0);
		(page->nextPage = stackPageAt((index == (numPages - 1)
			? 0
			: index + 1)));
		(page->prevPage = stackPageAt((index == 0
			? numPages - 1
			: index - 1)));
	}
	GIV(stackBasePlus1) = (((char *) theStackPages)) + 1;
	;
	/* begin stackPageAt: */
	page = stackPageAtpages(0, GIV(pages));
	GIV(overflowLimit) = ((((page->baseAddress)) - ((page->realStackLimit))) * 3) / 5;
	for (index = 0; index <= (numPages - 1); index += 1) {
		/* begin stackPageAt: */
		page = stackPageAtpages(index, GIV(pages));
		assert((pageIndexFor((page->baseAddress))) == index);
		assert((pageIndexFor(((page->baseAddress)) - ((slotsPerPage - 1) * BytesPerWord))) == index);
		assert((stackPageFor((page->baseAddress))) == page);
		assert((stackPageFor((page->stackLimit))) == page);
		;
		assert(((page->trace = -1)) != 0);
	}
	/* begin stackPageAt: */
	GIV(mostRecentlyUsedPage) = stackPageAtpages(0, GIV(pages));
	page = GIV(mostRecentlyUsedPage);
	count = 0;
	do {
		count += 1;
		/* begin pageIndexFor: */
		pointer = (page->baseAddress);
		assert((((((char *) pointer)) >= (GIV(stackBasePlus1) - 1)) && ((((char *) pointer)) <= (((char *) GIV(pages))))));
		theIndex = pageIndexForstackBasePlus1bytesPerPage(pointer, GIV(stackBasePlus1), GIV(bytesPerPage));
		assert((stackPageAt(theIndex)) == page);
		assert((pageIndexFor((page->baseAddress))) == theIndex);
		assert((pageIndexFor((page->stackLimit))) == theIndex);
		assert((pageIndexFor(((page->lastAddress)) + 1)) == theIndex);
	} while(((page = (page->nextPage))) != GIV(mostRecentlyUsedPage));
	assert(count == numPages);
	assert(pageListIsWellFormed());
}


/*	Initialize the stack pages and enter interpret. Use alloca'ed memory so
	that when
	we have a JIT its stack pointer will be on the native stack since alloca
	allocates memory on the stack. Certain thread systems use the native stack
	pointer as the
	frame ID so putting the stack anywhere else can confuse the thread system. */
/*	Override to establish the setjmp/longjmp handler for reentering the
	interpreter from machine code, and disable executablity on the heap and
	stack pages. */
/*	This should be in its own initStackPages method but Slang can't inline
	C code strings. */

static sqInt
initStackPagesAndInterpret(void)
{   DECL_MAYBE_SQ_GLOBAL_STRUCT
    sqInt activeContext;
    sqInt activeProc;
    sqInt aMethodObj;
    StackPage *newPage;
    sqInt stackPageBytes;
    sqInt stackPagesBytes;
    char *theFP;
    char *theStackMemory;
    sqInt top;

	stackPageBytes = stackPageByteSize();
	stackPagesBytes = (GIV(numStackPages) * ((sizeof(CogStackPage)) + (stackPageByteSize()))) + BytesPerWord;
	theStackMemory = alloca(stackPagesBytes);
	sqMakeMemoryNotExecutableFromTo(((usqInt)heapBase), ((usqInt)GIV(memoryLimit)));
	sqMakeMemoryNotExecutableFromTo(((usqInt)theStackMemory), (((usqInt)theStackMemory)) + stackPagesBytes);
	initializeStacknumSlotspageSizestackLimitOffsetstackPageHeadroom(theStackMemory, ((sqInt) stackPagesBytes >> 2), ((sqInt) stackPageBytes >> 2), (IFrameSlots + 64) * BytesPerWord, (stackPageHeadroomBytes()) + 1024);
	/* begin loadInitialContext */
	VM_LABEL(0loadInitialContext);
	if ((checkForLeaks & 1) != 0) {
		clearLeakMapAndMapAccessibleObjects();
		assert(checkHeapIntegrity());
	}
	activeProc = longAt(((longAt(((longAt((GIV(specialObjectsOop) + BaseHeaderSize) + (SchedulerAssociation << ShiftForWord))) + BaseHeaderSize) + (ValueIndex << ShiftForWord))) + BaseHeaderSize) + (ActiveProcessIndex << ShiftForWord));
	activeContext = longAt((activeProc + BaseHeaderSize) + (SuspendedContextIndex << ShiftForWord));
	/* begin marryContextInNewStackPageAndInitializeInterpreterRegisters: */
	VM_LABEL(0marryContextInNewStackPageAndInitializeInterpreterRegisters);
	assert(GIV(stackPage) == 0);
	newPage = makeBaseFrameFor(activeContext);
	/* begin setStackPageAndLimit: */
	GIV(stackPage) = newPage;
	if (GIV(stackLimit) != (((char *) (((usqInt) -1))))) {
		GIV(stackLimit) = (GIV(stackPage)->stackLimit);
	}
	markStackPageMostRecentlyUsed(newPage);
	GIV(framePointer) = (GIV(stackPage)->headFP);
	GIV(stackPointer) = (GIV(stackPage)->headSP);
	/* begin setMethod: */
	/* begin iframeMethod: */
	theFP = (GIV(stackPage)->headFP);
	aMethodObj = longAt(theFP + FoxMethod);
	assert((((usqInt)aMethodObj)) >= (startOfMemory()));
	GIV(method) = aMethodObj;
	/* begin popStack */
	top = longAt(GIV(stackPointer));
	GIV(stackPointer) += BytesPerWord;
	GIV(instructionPointer) = ((sqInt) top);
	ioInitHeartbeat();
	initialEnterSmalltalkExecutive();
	return null;
}


/*	Install the oop of this object in the given cache (at or atPut), along
	with its size, format and fixedSize */

static void
installinAtCacheatstring(sqInt rcvr, sqInt *cache, sqInt atIx, sqInt stringy)
{   DECL_MAYBE_SQ_GLOBAL_STRUCT
    sqInt ccIndex;
    sqInt class;
    sqInt classFormat;
    sqInt fixedFields;
    sqInt fmt;
    sqInt hdr;
    sqInt sz;
    sqInt totalLength;

	hdr = longAt(rcvr);
	fmt = (((usqInt) hdr) >> 8) & 15;
	if ((fmt == 3)
	 && (((((usqInt) hdr) >> 12) & 31) == ClassMethodContextCompactIndex)) {
		/* begin primitiveFail */
		if (GIV(primFailCode) == 0) {
			GIV(primFailCode) = 1;
		}
		return;
	}
	/* begin lengthOf:baseHeader:format: */
	if ((hdr & TypeMask) == HeaderTypeSizeAndClass) {
		sz = (longAt(rcvr - (BytesPerWord * 2))) & LongSizeMask;
	}
	else {
		sz = hdr & SizeMask;
	}
	sz -= hdr & Size4Bit;
	if (fmt <= 4) {
		totalLength = ((usqInt) (sz - BaseHeaderSize)) >> ShiftForWord;
		goto l1;
	}
	if (fmt < 8) {
		totalLength = ((usqInt) (sz - BaseHeaderSize)) >> 2;
		goto l1;
	}
	else {
		totalLength = (sz - BaseHeaderSize) - (fmt & 3);
		goto l1;
	}
l1:	/* end lengthOf:baseHeader:format: */;
	/* begin fixedFieldsOf:format:length: */
	if ((fmt > 4)
	 || (fmt == 2)) {
		fixedFields = 0;
		goto l3;
	}
	if (fmt < 2) {
		fixedFields = totalLength;
		goto l3;
	}
	/* begin fetchClassOfNonInt: */
	if (((ccIndex = (((usqInt) (longAt(rcvr))) >> 12) & 31)) == 0) {
		class = (longAt(rcvr - BaseHeaderSize)) & AllButTypeMask;
		goto l2;
	}
	else {
		class = longAt(((longAt((GIV(specialObjectsOop) + BaseHeaderSize) + (CompactClasses << ShiftForWord))) + BaseHeaderSize) + ((ccIndex - 1) << ShiftForWord));
		goto l2;
	}
l2:	/* end fetchClassOfNonInt: */;
	classFormat = (longAt((class + BaseHeaderSize) + (InstanceSpecificationIndex << ShiftForWord))) - 1;
	fixedFields = (((((usqInt) classFormat) >> 11) & 192) + ((((usqInt) classFormat) >> 2) & 63)) - 1;
l3:	/* end fixedFieldsOf:format:length: */;
	cache[atIx + AtCacheOop] = rcvr;
	cache[atIx + AtCacheFmt] = ((stringy
	? fmt + 16
	: fmt));
	cache[atIx + AtCacheFixedFields] = fixedFields;
	cache[atIx + AtCacheSize] = (totalLength - fixedFields);
}


/*	Answer the number of slots in a class. For example the instanceSizeOf: 
	ClassPoint is 2, for the x & y slots. The instance size of non-pointer
	classes is 0. */

sqInt
instanceSizeOf(sqInt classObj)
{
    sqInt byteSize;
    sqInt classHdr;
    sqInt sizeHiBits;

	assert(addressCouldBeObj(classObj));

	/* Low 2 bits are 0 */
	/* Compute the size of instances of the class (used for fixed field classes only) */

	classHdr = (longAt((classObj + BaseHeaderSize) + (InstanceSpecificationIndex << ShiftForWord))) - 1;
	sizeHiBits = (((usqInt) classHdr) >> 9) & 768;

	/* size in bytes -- low 2 bits are 0 */

	byteSize = (classHdr & SizeMask) + sizeHiBits;
	return ((sqInt) (byteSize - BaseHeaderSize) >> 2);
}


/*	NOTE: This method supports the backward-compatible split instSize field of
	the 
	class format word. The sizeHiBits will go away and other shifts change by
	2 
	when the split fields get merged in an (incompatible) image change.
 */

sqInt
instantiateClassindexableSize(sqInt classPointer, sqInt size)
{   DECL_MAYBE_SQ_GLOBAL_STRUCT
    sqInt binc;
    sqInt bm1;
    sqInt byteSize;
    sqInt cClass;
    sqInt classFormat;
    sqInt classOop;
    usqInt end;
    sqInt enoughSpace;
    sqInt fillWord;
    sqInt format;
    sqInt hash;
    sqInt hdrSize;
    sqInt header1;
    sqInt header2;
    sqInt header3;
    usqInt i;
    sqInt minFree;
    usqInt newChunk;
    usqInt newChunk1;
    usqInt newFreeStart;
    sqInt newObj;
    sqInt newObj1;
    sqInt oop;
    sqInt sizeHiBits;

	assert(size >= 0);
	hash = ((usqInt) GIV(freeStart)) >> BytesPerWord;

	/* Low 2 bits are 0 */

	classFormat = (longAt((classPointer + BaseHeaderSize) + (InstanceSpecificationIndex << ShiftForWord))) - 1;
	header1 = (classFormat & 130816) | ((hash & HashMaskUnshifted) << HashBitsOffset);
	header2 = classPointer;
	header3 = 0;
	sizeHiBits = ((usqInt) (classFormat & 393216)) >> 9;

	/* compact class field from format word */

	cClass = header1 & CompactClassMask;

	/* size in bytes -- low 2 bits are 0 */
	/* Note this byteSize comes from the format word of the class which is pre-shifted
		to 4 bytes per field.  Need another shift for 8 bytes per word... */

	byteSize = (classFormat & (SizeMask + Size4Bit)) + sizeHiBits;
	byteSize = byteSize << (ShiftForWord - 2);
	format = (((usqInt) classFormat) >> 8) & 15;
	flag("sizeLowBits");
	if (format < 8) {
		if (format == 6) {

			/* long32 bitmaps */

			bm1 = BytesPerWord - 1;

			/* round up */

			byteSize = ((byteSize + (size * 4)) + bm1) & LongSizeMask;

			/* odd bytes */
			/* extra low bit (4) for 64-bit VM goes in 4-bit (betw hdr bits and sizeBits) */

			binc = bm1 - (((size * 4) + bm1) & bm1);
			header1 = header1 | (binc & 4);
		}
		else {

			/* Arrays and 64-bit bitmaps */

			byteSize += size * BytesPerWord;
		}
	}
	else {

		/* Strings and Methods */

		bm1 = BytesPerWord - 1;

		/* round up */

		byteSize = ((byteSize + size) + bm1) & LongSizeMask;

		/* odd bytes */
		/* low bits of byte size go in format field */

		binc = bm1 - ((size + bm1) & bm1);

		/* extra low bit (4) for 64-bit VM goes in 4-bit (betw hdr bits and sizeBits) */

		header1 = header1 | ((binc & 3) << 8);
		header1 = header1 | (binc & 4);
	}
	if (byteSize > 255) {

		/* requires size header word */

		header3 = byteSize;
		header1 = header1;
	}
	else {
		header1 = header1 | byteSize;
	}
	hdrSize = (header3 > 0
		? 3
		: (cClass == 0
	? 2
	: 1));
	/* begin allocate:headerSize:h1:h2:h3:doFill:format: */
	VM_LABEL(0allocateheaderSizeh1h2h3doFillformat);
	/* begin allocateChunk: */
	newChunk = GIV(freeStart);
	newFreeStart = GIV(freeStart) + (byteSize + ((hdrSize - 1) * BytesPerWord));
	if (newFreeStart < GIV(scavengeThreshold)) {
		if ((AllocationCheckFiller != 0)
		 && ((longAt(newChunk)) != ((AllocationCheckFiller == 182275669
	? newChunk
	: AllocationCheckFiller)))) {
			error("last object overwritten");
		}
		GIV(freeStart) = newFreeStart;
		newObj1 = oopForPointer(newChunk);
		goto l1;
	}
	/* begin scheduleIncrementalGC */
	GIV(needGCFlag) = 1;
	forceInterruptCheck();
	if (GIV(freeStart) <= GIV(reserveStart)) {
		GIV(freeStart) = newFreeStart;
		newObj1 = oopForPointer(newChunk);
		goto l1;
	}
	newObj1 = 0;
l1:	/* end allocateChunk: */;
	if (newObj1 == 0) {
		if (hdrSize > 1) {
			/* begin pushRemappableOop: */
			assert(addressCouldBeOop(header2));
			GIV(remapBuffer)[(GIV(remapBufferCount) += 1)] = header2;
		}
		/* begin allocateChunkAfterGC: */
		/* begin sufficientSpaceToAllocate: */

		/* check for low-space */

		minFree = ((((GIV(lowSpaceThreshold) + (byteSize + ((hdrSize - 1) * BytesPerWord))) + BaseHeaderSize) + BytesPerWord) - 1) & (~(BytesPerWord - 1));
		if ((((usqInt) (GIV(freeStart) + minFree))) <= (((usqInt) GIV(reserveStart)))) {
			enoughSpace = 1;
			goto l3;
		}
		enoughSpace = sufficientSpaceAfterGC(minFree);
	l3:	/* end sufficientSpaceToAllocate: */;
		if (!(enoughSpace)) {
			setSignalLowSpaceFlagAndSaveProcess();
		}
		if ((((usqInt) (GIV(freeStart) + (byteSize + ((hdrSize - 1) * BytesPerWord))))) > (((usqInt) GIV(reserveStart)))) {
			newObj1 = 0;
			goto l2;
		}
		newChunk1 = GIV(freeStart);
		GIV(freeStart) += byteSize + ((hdrSize - 1) * BytesPerWord);
		newObj1 = oopForPointer(newChunk1);
	l2:	/* end allocateChunkAfterGC: */;
		if (hdrSize > 1) {
			/* begin popRemappableOop */
			oop = GIV(remapBuffer)[GIV(remapBufferCount)];
			GIV(remapBufferCount) -= 1;
			classOop = oop;
		}
		if (newObj1 == 0) {
			newObj = newObj1;
			goto l4;
		}
	}
	else {
		classOop = header2;
	}
	if (hdrSize == 3) {
		longAtput(newObj1, header3 | HeaderTypeSizeAndClass);
		longAtput(newObj1 + BytesPerWord, classOop | HeaderTypeSizeAndClass);
		longAtput(newObj1 + (BytesPerWord * 2), header1 | HeaderTypeSizeAndClass);
		newObj1 += BytesPerWord * 2;
	}
	if (hdrSize == 2) {
		longAtput(newObj1, classOop | HeaderTypeClass);
		longAtput(newObj1 + BytesPerWord, header1 | HeaderTypeClass);
		newObj1 += BytesPerWord;
	}
	if (hdrSize == 1) {
		longAtput(newObj1, header1 | HeaderTypeShort);
	}
	if (1) {
		fillWord = (format <= 4
			? GIV(nilObj)
			: 0);
		end = newObj1 + byteSize;
		i = newObj1 + BytesPerWord;
		while (i < end) {
			longAtput(i, fillWord);
			i += BytesPerWord;
		}
	}
	if (DoExpensiveAssertionChecks) {
		okayOop(newObj1);
		oopHasOkayClass(newObj1);
		if (!((safeObjectAfter(newObj1)) == GIV(freeStart))) {
			error("allocate bug: did not set header of new oop correctly");
		}
	}
	newObj = newObj1;
l4:	/* end allocate:headerSize:h1:h2:h3:doFill:format: */;
	return newObj;
}

usqInt
instructionPointerAddress(void)
{
	return ((usqInt)((&GIV(instructionPointer))));
}


/*	Like #stackIntegerValue: but access method arguments left-to-right */

sqInt
integerArg(sqInt index)
{   DECL_MAYBE_SQ_GLOBAL_STRUCT
    sqInt oop;

	oop = methodArg(index);
	if (oop == 0) {
		return 0.0;
	}
	/* begin checkedIntegerValueOf: */
	if ((oop & 1)) {
		return (oop >> 1);
	}
	else {
		/* begin primitiveFail */
		if (GIV(primFailCode) == 0) {
			GIV(primFailCode) = 1;
		}
		return 0;
	}
}

sqInt
integerObjectOf(sqInt value)
{
	return (value << 1) + 1;
}


/*	Translator produces 'objectPointer >> 1' */

sqInt
integerValueOf(sqInt objectPointer)
{
	if ((objectPointer & 2147483648UL) != 0) {
		return ((((usqInt) (objectPointer & 2147483647UL)) >> 1) - 1073741823) - 1;
	}
	else {
		return ((usqInt) objectPointer) >> 1;
	}
}


/*	At a rough approximation we may need to allocate up to a couple
	of page's worth of contexts when switching stack pages, assigning
	to senders, etc. But the snapshot primitive voids all stack pages.
	So a safe margin is the size of a large context times the maximum
	number of frames per page times the number of pages. */

static sqInt
interpreterAllocationReserveBytes(void)
{
    sqInt availableBytesPerPage;
    sqInt maxFramesPerPage;

	availableBytesPerPage = ((stackPageByteSize()) - ((IFrameSlots + 64) * BytesPerWord)) - ((stackPageHeadroomBytes()) + 1024);
	maxFramesPerPage = (((sqInt) availableBytesPerPage >> 2)) / MFrameSlots;
	return pow(2,(highBit((maxFramesPerPage * LargeContextSize) * GIV(numStackPages))));
}


/*	the vm has to convert aFilenameString via any canonicalization and
	char-mapping and put the result in aCharBuffer.
	Note the resolveAliases flag - this is an awful artefact of OSX and Apples
	demented alias handling. When opening a file, the flag must be true, when
	closing or renaming it must be false. Sigh.
 */

void
ioFilenamefromStringofLengthresolveAliases(char *aCharBuffer, char *aFilenameString, sqInt filenameLength, sqInt aBoolean)
{
	sqGetFilenameFromString(aCharBuffer, aFilenameString, filenameLength, aBoolean);
}


/*	Answer true if this is an indexable object with pointer elements, e.g., an
	array 
 */

sqInt
isArray(sqInt oop)
{
	return ((oop & 1) == 0)
	 && (((((usqInt) (longAt(oop))) >> 8) & 15) == 2);
}


/*	A base frame (first frame in a stack page) is so marked by having a null
	saved fp.
 */

static sqInt
isBaseFrame(char *theFP)
{
	return (longAt(theFP + FoxSavedFP)) == 0;
}


/*	Answer true if the argument contains indexable bytes. See comment in
	formatOf: 
 */
/*	Note: Includes CompiledMethods. */

sqInt
isBytes(sqInt oop)
{
	return ((oop & 1) == 0)
	 && (((((usqInt) (longAt(oop))) >> 8) & 15) >= 8);
}


/*	Answer if the given (non-immediate) object is an instance of the given
	class. 
 */

static sqInt
isClassOfNonImmequalTo(sqInt oop, sqInt classOop)
{
    sqInt ccIndex;
    sqInt cl;

	if ((oop & 1)) {
		return 0;
	}
	cl = (((ccIndex = (((usqInt) (longAt(oop))) >> 12) & 31)) == 0
		? (longAt(oop - BaseHeaderSize)) & AllButTypeMask
		: longAt(((longAt((GIV(specialObjectsOop) + BaseHeaderSize) + (CompactClasses << ShiftForWord))) + BaseHeaderSize) + ((ccIndex - 1) << ShiftForWord)));
	return cl == classOop;
}

static sqInt
isCogMethodReference(sqInt methodHeader)
{
	assert(((methodHeader & 1))
	 || (((((usqInt)methodHeader)) < (startOfMemory()))
 && ((((usqInt)methodHeader)) >= (minCogMethodAddress()))));
	return (methodHeader & 1) == 0;
}


/*	c.f. {BlockContext. MethodContext. PseudoContext} collect: [:class| class
	-> class indexIfCompact]
 */

static sqInt
isContextHeader(sqInt aHeader)
{
	return ((((usqInt) aHeader) >> 12) & 31) == ClassMethodContextCompactIndex;
}

static sqInt
isContext(sqInt oop)
{
	return ((oop & 1) == 0)
	 && (((((usqInt) (longAt(oop))) >> 12) & 31) == ClassMethodContextCompactIndex);
}

sqInt
isFloatObject(sqInt oop)
{
	return ((oop & 1) == 0)
	 && ((ClassFloatCompactIndex != 0
	? ((((usqInt) (longAt(oop))) >> 12) & 31) == ClassFloatCompactIndex
	: (fetchClassOfNonInt(oop)) == (longAt((GIV(specialObjectsOop) + BaseHeaderSize) + (ClassFloat << ShiftForWord)))));
}

static sqInt
isFree(StackPage * self_in_isFree)
{
	return ((self_in_isFree->baseFP)) == 0;
}

static sqInt
isFreeObject(sqInt oop)
{
	return ((longAt(oop)) & TypeMask) == HeaderTypeFree;
}

sqInt
isIndexable(sqInt oop)
{
	return ((((usqInt) (longAt(oop))) >> 8) & 15) >= 2;
}


/*	Return true if the given address is in ST object memory */

sqInt
isInMemory(sqInt address)
{
	return ((((usqInt) address)) >= (((usqInt) heapBase)))
	 && ((((usqInt) address)) < (((usqInt) GIV(endOfMemory))));
}

sqInt
isIntegerObject(sqInt objectPointer)
{
	return (objectPointer & 1) > 0;
}


/*	Return true if the given value can be represented as a Smalltalk integer
	value. 
 */
/*	Use a shift and XOR to set the sign bit if and only if the top two bits of
	the given value are the same, then test the sign bit. Note that the top
	two bits are equal for exactly those integers in the range that can be
	represented in 31-bits or 63-bits.
 */

sqInt
isIntegerValue(sqInt intValue)
{
	return (intValue ^ (intValue << 1)) >= 0;
}


/*	Answer if the argument, which can be any object, is a live context. */

static sqInt
isLiveContext(sqInt oop)
{
	if (!(((oop & 1) == 0)
		 && (((((usqInt) (longAt(oop))) >> 12) & 31) == ClassMethodContextCompactIndex))) {
		return 0;
	}
	if (((longAt((oop + BaseHeaderSize) + (SenderIndex << ShiftForWord))) & 1) == 0) {
		return ((longAt((oop + BaseHeaderSize) + (InstructionPointerIndex << ShiftForWord))) & 1);
	}
	return !(isWidowedContext(oop));
}

static sqInt
isMachineCodeFrame(char *theFP)
{
	return (((usqInt)(longAt(theFP + FoxMethod)))) < heapBase;
}


/*	Answer if oop's mark bit is set */

sqInt
isMarked(sqInt oop)
{
	return ((longAt(oop)) & MarkBit) != 0;
}

static sqInt
isMarriedOrWidowedContext(sqInt aContext)
{
	return ((longAt((aContext + BaseHeaderSize) + (SenderIndex << ShiftForWord))) & 1);
}

sqInt
isNonIntegerObject(sqInt objectPointer)
{
	return (objectPointer & 1) == 0;
}


/*	Answer whether the oop is an object of compiled method format */

sqInt
isOopCompiledMethod(sqInt oop)
{
	return ((oop & 1) == 0)
	 && (((((usqInt) (longAt(oop))) >> 8) & 15) >= 12);
}


/*	Answer true if the argument has only fields that can hold oops. See
	comment in formatOf:
 */

sqInt
isPointers(sqInt oop)
{
	return ((oop & 1) == 0)
	 && (((((usqInt) (longAt(oop))) >> 8) & 15) <= 4);
}


/*	We save slots in the method cache by using the primitiveFunctionPointer
	to hold either a function pointer or the index of a quick primitive. Since
	quick primitive indices are small they can't be confused with function
	addresses. */

static sqInt
isPrimitiveFunctionPointerAnIndex(void)
{
	return (((unsigned long) primitiveFunctionPointer)) <= MaxQuickPrimitiveIndex;
}

sqInt
isQuickPrimitiveIndex(sqInt anInteger)
{
	return ((anInteger >= 256) && (anInteger <= 519));
}


/*	For machien code assertion checking. Answer true iif not in a fulGC and
	obj is young. */

sqInt
isReallyYoungObject(sqInt obj)
{
	return (!GIV(inFullGC))
	 && (oopisGreaterThanOrEqualTo(obj, youngStart()));
}

static sqInt
isSingleContext(sqInt aContext)
{
	return ((longAt((aContext + BaseHeaderSize) + (SenderIndex << ShiftForWord))) & 1) == 0;
}


/*	Answer true if the argument has only weak fields that can hold oops. See
	comment in formatOf:
 */

static sqInt
isWeakNonInt(sqInt oop)
{
	return ((((usqInt) (longAt(oop))) >> 8) & 15) == 4;
}


/*	Answer true if the argument has only weak fields that can hold oops. See
	comment in formatOf:
 */

sqInt
isWeak(sqInt oop)
{
	return ((oop & 1) == 0)
	 && (((((usqInt) (longAt(oop))) >> 8) & 15) == 4);
}


/*	See if the argument is connected with a live frame or not.
	If it is not, turn it into a bereaved single context. */

static sqInt
isWidowedContext(sqInt aOnceMarriedContext)
{   DECL_MAYBE_SQ_GLOBAL_STRUCT
    sqInt index;
    char *shouldBeFrameCallerField;
    char *theFrame;
    StackPage *thePage;
    sqInt value;

	assert(isContext(aOnceMarriedContext));
	/* begin frameOfMarriedContext: */
	value = longAt((aOnceMarriedContext + BaseHeaderSize) + (SenderIndex << ShiftForWord));
	/* begin withoutSmallIntegerTags: */
	assert((value & 1));
	theFrame = pointerForOop(value - 1);
	/* begin stackPageFor: */
	/* begin stackPageAt: */
	/* begin pageIndexFor: */
	assert((((((char *) theFrame)) >= (GIV(stackBasePlus1) - 1)) && ((((char *) theFrame)) <= (((char *) GIV(pages))))));
	index = pageIndexForstackBasePlus1bytesPerPage(theFrame, GIV(stackBasePlus1), GIV(bytesPerPage));
	thePage = stackPageAtpages(index, GIV(pages));
	if (!((isFree(thePage))
		 || (theFrame < ((thePage->headFP))))) {
		/* begin withoutSmallIntegerTags: */
		assert(((longAt((aOnceMarriedContext + BaseHeaderSize) + (InstructionPointerIndex << ShiftForWord))) & 1));
		shouldBeFrameCallerField = pointerForOop((longAt((aOnceMarriedContext + BaseHeaderSize) + (InstructionPointerIndex << ShiftForWord))) - 1);
		if (((frameCallerFP(theFrame)) == shouldBeFrameCallerField)
		 && (((((((usqInt)(longAt(theFrame + FoxMethod)))) < heapBase
	? (mframeHomeMethod(theFrame)->methodObject)
	: longAt(theFrame + FoxMethod))) == (longAt((aOnceMarriedContext + BaseHeaderSize) + (MethodIndex << ShiftForWord))))
 && ((((((usqInt)(longAt(theFrame + FoxMethod)))) < heapBase
	? ((longAt(theFrame + FoxMethod)) & MFMethodFlagHasContextFlag) != 0
	: (byteAt((theFrame + FoxIFrameFlags) + 2)) != 0))
 && ((longAt(theFrame + FoxThisContext)) == aOnceMarriedContext)))) {
			return 0;
		}
	}
	/* begin markContextAsDead: */
	assert(isContext(aOnceMarriedContext));
	longAtput((aOnceMarriedContext + BaseHeaderSize) + (SenderIndex << ShiftForWord), GIV(nilObj));
	longAtput((aOnceMarriedContext + BaseHeaderSize) + (InstructionPointerIndex << ShiftForWord), GIV(nilObj));
	return 1;
}


/*	Answer true if the contains only indexable words or bytes (no oops). See
	comment in formatOf:
 */
/*	Note: Excludes CompiledMethods. */

static sqInt
isWordsOrBytesNonInt(sqInt oop)
{
    sqInt fmt;

	fmt = (((usqInt) (longAt(oop))) >> 8) & 15;
	return (fmt == 6)
	 || ((fmt >= 8)
 && (fmt <= 11));
}


/*	Answer true if the contains only indexable words or bytes (no oops). See
	comment in formatOf:
 */
/*	Note: Excludes CompiledMethods. */

sqInt
isWordsOrBytes(sqInt oop)
{
	return ((oop & 1) == 0)
	 && (isWordsOrBytesNonInt(oop));
}


/*	Answer true if the argument contains only indexable words (no oops). See
	comment in formatOf:
 */

sqInt
isWords(sqInt oop)
{
	return ((oop & 1) == 0)
	 && (((((usqInt) (longAt(oop))) >> 8) & 15) == 6);
}

sqInt
isYoung(sqInt oop)
{
	return ((oop & 1) == 0)
	 && ((((usqInt) oop)) >= (((usqInt) GIV(youngStart))));
}


/*	Answer if oop is an instance of the given class. If the class has a
	(non-zero) compactClassIndex use that to speed up the check. N.B. Inlining
	should result in classOop not being accessed if compactClassIndex is
	non-zero.  */

static sqInt
isinstanceOfcompactClassIndex(sqInt oop, sqInt classOop, sqInt compactClassIndex)
{
    sqInt ccIndex;

	if ((oop & 1)) {
		return 0;
	}
	ccIndex = (((usqInt) (longAt(oop))) >> 12) & 31;
	if (compactClassIndex != 0) {
		return compactClassIndex == ccIndex;
	}
	return (ccIndex == 0)
	 && (((longAt(oop - BaseHeaderSize)) & AllButTypeMask) == classOop);
}


/*	Support for external primitives. */

sqInt
isKindOfClass(sqInt oop, sqInt aClass)
{   DECL_MAYBE_SQ_GLOBAL_STRUCT
    sqInt ccIndex;
    sqInt oopClass;

	/* begin fetchClassOf: */
	if ((oop & 1)) {
		oopClass = longAt((GIV(specialObjectsOop) + BaseHeaderSize) + (ClassInteger << ShiftForWord));
		goto l1;
	}
	if (((ccIndex = (((usqInt) (longAt(oop))) >> 12) & 31)) == 0) {
		oopClass = (longAt(oop - BaseHeaderSize)) & AllButTypeMask;
		goto l1;
	}
	else {
		oopClass = longAt(((longAt((GIV(specialObjectsOop) + BaseHeaderSize) + (CompactClasses << ShiftForWord))) + BaseHeaderSize) + ((ccIndex - 1) << ShiftForWord));
		goto l1;
	}
l1:	/* end fetchClassOf: */;
	while (!(oopClass == GIV(nilObj))) {
		if (oopClass == aClass) {
			return 1;
		}
		oopClass = longAt((oopClass + BaseHeaderSize) + (SuperclassIndex << ShiftForWord));
	}
	return 0;
}


/*	Support for external primitives. */

sqInt
isKindOf(sqInt oop, char *className)
{   DECL_MAYBE_SQ_GLOBAL_STRUCT
    sqInt ccIndex;
    sqInt oopClass;

	/* begin fetchClassOf: */
	if ((oop & 1)) {
		oopClass = longAt((GIV(specialObjectsOop) + BaseHeaderSize) + (ClassInteger << ShiftForWord));
		goto l1;
	}
	if (((ccIndex = (((usqInt) (longAt(oop))) >> 12) & 31)) == 0) {
		oopClass = (longAt(oop - BaseHeaderSize)) & AllButTypeMask;
		goto l1;
	}
	else {
		oopClass = longAt(((longAt((GIV(specialObjectsOop) + BaseHeaderSize) + (CompactClasses << ShiftForWord))) + BaseHeaderSize) + ((ccIndex - 1) << ShiftForWord));
		goto l1;
	}
l1:	/* end fetchClassOf: */;
	while (!(oopClass == GIV(nilObj))) {
		if (classNameOfIs(oopClass, className)) {
			return 1;
		}
		oopClass = longAt((oopClass + BaseHeaderSize) + (SuperclassIndex << ShiftForWord));
	}
	return 0;
}


/*	Support for external primitives */

sqInt
isMemberOf(sqInt oop, char *className)
{   DECL_MAYBE_SQ_GLOBAL_STRUCT
    sqInt ccIndex;
    sqInt oopClass;

	/* begin fetchClassOf: */
	if ((oop & 1)) {
		oopClass = longAt((GIV(specialObjectsOop) + BaseHeaderSize) + (ClassInteger << ShiftForWord));
		goto l1;
	}
	if (((ccIndex = (((usqInt) (longAt(oop))) >> 12) & 31)) == 0) {
		oopClass = (longAt(oop - BaseHeaderSize)) & AllButTypeMask;
		goto l1;
	}
	else {
		oopClass = longAt(((longAt((GIV(specialObjectsOop) + BaseHeaderSize) + (CompactClasses << ShiftForWord))) + BaseHeaderSize) + ((ccIndex - 1) << ShiftForWord));
		goto l1;
	}
l1:	/* end fetchClassOf: */;
	return classNameOfIs(oopClass, className);
}


/*	Return the byte offset of the last pointer field of the given object. 
	Can be used even when the type bits are not correct.
	Works with CompiledMethods, as well as ordinary objects.
	Override to handle hidden pointer to CogMethod in a CompiledMethod header
	field.  */

sqInt
lastPointerOf(sqInt oop)
{
    sqInt contextSize;
    sqInt fmt;
    sqInt header;
    sqInt methodHeader;
    sqInt sp;

	header = longAt(oop);
	fmt = (((usqInt) header) >> 8) & 15;
	if (fmt <= 4) {
		if ((fmt == 3)
		 && (((((usqInt) header) >> 12) & 31) == ClassMethodContextCompactIndex)) {
			/* begin fetchStackPointerOf: */
			sp = longAt((oop + BaseHeaderSize) + (StackPointerIndex << ShiftForWord));
			if (!((sp & 1))) {
				contextSize = 0;
				goto l1;
			}
			assert((ReceiverIndex + ((sp >> 1))) < (lengthOf(oop)));
			contextSize = (sp >> 1);
		l1:	/* end fetchStackPointerOf: */;
			return (CtxtTempFrameStart + contextSize) * BytesPerWord;
		}
		return (sizeBitsOfSafe(oop)) - BaseHeaderSize;
	}
	if (fmt < 12) {
		return 0;
	}
	methodHeader = longAt(oop + BaseHeaderSize);
	if (isCogMethodReference(methodHeader)) {
		assert(((((CogMethod *) methodHeader)->cmType)) == CMMethod);
		methodHeader = (((CogMethod *) methodHeader)->methodHeader);
	}
	return (((((usqInt) methodHeader) >> 10) & 255) * BytesPerWord) + BaseHeaderSize;
}

sqInt
leakCheckBecome(void)
{
	return (checkForLeaks & 4) != 0;
}

sqInt
leakCheckFullGC(void)
{
	return (checkForLeaks & 1) != 0;
}

sqInt
leakCheckIncrementalGC(void)
{
	return (checkForLeaks & 2) != 0;
}

static sqInt
lengthOfNameOfClass(sqInt classOop)
{   DECL_MAYBE_SQ_GLOBAL_STRUCT
    sqInt header;
    sqInt sz;

	if ((sizeBitsOf(classOop)) == GIV(metaclassSizeBytes)) {
		return lengthOfNameOfClass(longAt((classOop + BaseHeaderSize) + (GIV(thisClassIndex) << ShiftForWord)));
	}
	/* begin lengthOf: */
	header = longAt(longAt((classOop + BaseHeaderSize) + (GIV(classNameIndex) << ShiftForWord)));
	/* begin lengthOf:baseHeader:format: */
	if ((header & TypeMask) == HeaderTypeSizeAndClass) {
		sz = (longAt((longAt((classOop + BaseHeaderSize) + (GIV(classNameIndex) << ShiftForWord))) - (BytesPerWord * 2))) & LongSizeMask;
	}
	else {
		sz = header & SizeMask;
	}
	sz -= header & Size4Bit;
	if (((((usqInt) header) >> 8) & 15) <= 4) {
		return ((usqInt) (sz - BaseHeaderSize)) >> ShiftForWord;
	}
	if (((((usqInt) header) >> 8) & 15) < 8) {
		return ((usqInt) (sz - BaseHeaderSize)) >> 2;
	}
	else {
		return (sz - BaseHeaderSize) - (((((usqInt) header) >> 8) & 15) & 3);
	}
}


/*	Return the number of indexable bytes or words in the given object. Assume
	the argument is not an integer. For a CompiledMethod, the size of the
	method header (in bytes) should be subtracted from the result.
 */

sqInt
lengthOf(sqInt oop)
{
    sqInt header;
    sqInt sz;

	header = longAt(oop);
	/* begin lengthOf:baseHeader:format: */
	if ((header & TypeMask) == HeaderTypeSizeAndClass) {
		sz = (longAt(oop - (BytesPerWord * 2))) & LongSizeMask;
	}
	else {
		sz = header & SizeMask;
	}
	sz -= header & Size4Bit;
	if (((((usqInt) header) >> 8) & 15) <= 4) {
		return ((usqInt) (sz - BaseHeaderSize)) >> ShiftForWord;
	}
	if (((((usqInt) header) >> 8) & 15) < 8) {
		return ((usqInt) (sz - BaseHeaderSize)) >> 2;
	}
	else {
		return (sz - BaseHeaderSize) - (((((usqInt) header) >> 8) & 15) & 3);
	}
}


/*	Return the number of indexable bytes or words in the given object. Assume
	the given oop is not an integer. For a CompiledMethod, the size of the
	method header (in bytes) should be subtracted from the result of this
	method. 
 */

static sqInt
lengthOfbaseHeaderformat(sqInt oop, sqInt hdr, sqInt fmt)
{
    sqInt sz;

	if ((hdr & TypeMask) == HeaderTypeSizeAndClass) {
		sz = (longAt(oop - (BytesPerWord * 2))) & LongSizeMask;
	}
	else {
		sz = hdr & SizeMask;
	}
	sz -= hdr & Size4Bit;
	if (fmt <= 4) {
		return ((usqInt) (sz - BaseHeaderSize)) >> ShiftForWord;
	}
	if (fmt < 8) {
		return ((usqInt) (sz - BaseHeaderSize)) >> 2;
	}
	else {
		return (sz - BaseHeaderSize) - (fmt & 3);
	}
}

sqInt
literalCountOfHeader(sqInt headerPointer)
{
	return (((usqInt) headerPointer) >> 10) & 255;
}

sqInt
literalCountOf(sqInt methodPointer)
{
    sqInt headerPointer;
    sqInt methodHeader;

	/* begin literalCountOfHeader: */
	/* begin headerOf: */
	methodHeader = longAt((methodPointer + BaseHeaderSize) + (HeaderIndex << ShiftForWord));
	headerPointer = (isCogMethodReference(methodHeader)
		? (((CogMethod *) methodHeader)->methodHeader)
		: methodHeader);
	return (((usqInt) headerPointer) >> 10) & 255;
}

sqInt
literalofMethod(sqInt offset, sqInt methodPointer)
{
	return longAt((methodPointer + BaseHeaderSize) + ((offset + LiteralStart) << ShiftForWord));
}


/*	This entry point needs to be implemented for the interpreter proxy.
	Since BitBlt is now a plugin we need to look up
	BitBltPlugin:=loadBitBltFrom and call it. This entire mechanism should
	eventually go away and be
	replaced with a dynamic lookup from BitBltPlugin itself but for backward
	compatibility this stub is provided
 */

sqInt
loadBitBltFrom(sqInt bb)
{   DECL_MAYBE_SQ_GLOBAL_STRUCT
    void *fn;

	fn = ioLoadFunctionFrom("loadBitBltFrom", "BitBltPlugin");
	if (fn == 0) {
		/* begin primitiveFail */
		if (GIV(primFailCode) == 0) {
			GIV(primFailCode) = 1;
		}
		return null;
	}
	return ((sqInt (*)(sqInt))fn)(bb);
}


/*	This primitive is called from Squeak as...
	<imageSegment> loadSegmentFrom: aWordArray outPointers: anArray. */
/*	This primitive will load a binary image segment created by
	primitiveStoreImageSegment. It expects the outPointer array to be of the
	proper size, and the wordArray to be well formed. It will return as its
	value the original array of roots, and the erstwhile segmentWordArray will
	have been truncated to a size of zero. If this primitive should fail, the
	segmentWordArray will, sadly, have been reduced to an unrecognizable and
	unusable jumble. But what more could you have done with it anyway?
 */

static sqInt
loadImageSegmentFromoutPointers(sqInt segmentWordArray, sqInt outPointerArray)
{   DECL_MAYBE_SQ_GLOBAL_STRUCT
    sqInt addr;
    sqInt addr1;
    sqInt addr11;
    sqInt addr2;
    sqInt data;
    sqInt doingClass;
    usqInt endSeg;
    sqInt extraSize;
    sqInt fieldOop;
    usqInt fieldPtr;
    sqInt fmt;
    sqInt hdrTypeBits;
    sqInt header;
    sqInt header1;
    sqInt header2;
    sqInt header3;
    sqInt header4;
    usqInt lastOut;
    usqInt lastPtr;
    sqInt mapOop;
    sqInt oop;
    sqInt oop1;
    usqInt outPtr;
    usqInt segOop;
    sqInt stopAddr1;
    sqInt stopAddr2;
    sqInt sz;
    sqInt sz1;
    sqInt sz2;
    sqInt sz3;
    sqInt temp;
    sqInt temp1;
    sqInt wordAddr;

	if (DoAssertionChecks) {
		verifyCleanHeaders();
	}
	lastOut = outPointerArray + (lastPointerOf(outPointerArray));

	/* Version check.  Byte order of the WordArray now */

	endSeg = (segmentWordArray + (sizeBitsOf(segmentWordArray))) - BaseHeaderSize;
	data = longAt(segmentWordArray + BaseHeaderSize);
	if (!(((data & 65535) == ((BytesPerWord == 4
	? 6505
	: 68003)))
		 || ((data & 65535) == ((BytesPerWord == 4
	? 6504
	: 68002))))) {
		/* begin reverseBytesFrom:to: */
		flag("Dan");
		addr1 = segmentWordArray + BaseHeaderSize;
		while ((((usqInt) addr1)) < (((usqInt) (endSeg + BytesPerWord)))) {
			longAtput(addr1, byteSwapped(longAt(addr1)));
			addr1 += BytesPerWord;
		}
		data = longAt(segmentWordArray + BaseHeaderSize);
		if (!(((data & 65535) == ((BytesPerWord == 4
	? 6505
	: 68003)))
			 || ((data & 65535) == ((BytesPerWord == 4
	? 6504
	: 68002))))) {
			/* begin reverseBytesFrom:to: */
			flag("Dan");
			addr = segmentWordArray + BaseHeaderSize;
			while ((((usqInt) addr)) < (((usqInt) (endSeg + BytesPerWord)))) {
				longAtput(addr, byteSwapped(longAt(addr)));
				addr += BytesPerWord;
			}
			if (DoAssertionChecks) {
				verifyCleanHeaders();
			}
			return 0;
		}
	}
	if ((((usqInt) data) >> 16) == (((usqInt) (imageSegmentVersion())) >> 16)) {
		if (!((data & 65535) >= 6505)) {
			if (((VMBIGENDIAN
	? 1
	: 0)) != 1) {

				/* Need to swap floats if the segment is being loaded into a little-endian VM from a version
			 that keeps Floats in big-endian word order as was the case prior to the 6505 image format. */
				/* low 2 bytes */
				/* ~= 1 => little-endian */

				segOop = ((segmentWordArray + BaseHeaderSize) + BytesPerWord) + (headerTypeBytes[(longAt((segmentWordArray + BaseHeaderSize) + BytesPerWord)) & TypeMask]);
				/* begin wordSwapFloatsFrom:to: */
				VM_LABEL(0wordSwapFloatsFromto);
				oop = segOop;
				while ((((usqInt) oop)) < (((usqInt) (endSeg + BytesPerWord)))) {
					if (!(((longAt(oop)) & TypeMask) == HeaderTypeFree)) {
						if ((((((usqInt) (longAt(oop))) >> 8) & 15) == 6)
						 && (((((usqInt) (longAt(oop))) >> 12) & 31) == ClassFloatCompactIndex)) {
							temp = longAt(oop + BaseHeaderSize);
							longAtput(oop + BaseHeaderSize, longAt((oop + BaseHeaderSize) + 4));
							longAtput((oop + BaseHeaderSize) + 4, temp);
						}
					}
					/* begin objectAfter: */
					if (DoAssertionChecks) {
						if ((((usqInt) oop)) >= (((usqInt) GIV(endOfMemory)))) {
							error("no objects after the end of memory");
						}
					}
					if (((longAt(oop)) & TypeMask) == HeaderTypeFree) {
						sz = (longAt(oop)) & AllButTypeMask;
					}
					else {
						/* begin sizeBitsOf: */
						header1 = longAt(oop);
						sz = ((header1 & TypeMask) == HeaderTypeSizeAndClass
							? (longAt(oop - (BytesPerWord * 2))) & LongSizeMask
							: header1 & SizeMask);
					}
					oop = (oop + sz) + (headerTypeBytes[(longAt(oop + sz)) & TypeMask]);
				}
			}
		}
	}
	else {

		/* Reverse the byte-type objects once */
		/* Oop of first embedded object */

		segOop = ((segmentWordArray + BaseHeaderSize) + BytesPerWord) + (headerTypeBytes[(longAt((segmentWordArray + BaseHeaderSize) + BytesPerWord)) & TypeMask]);
		/* begin byteSwapByteObjectsFrom:to:flipFloatsIf: */
		VM_LABEL(0byteSwapByteObjectsFromtoflipFloatsIf);
		oop1 = segOop;
		while ((((usqInt) oop1)) < (((usqInt) (endSeg + BytesPerWord)))) {
			if (!(((longAt(oop1)) & TypeMask) == HeaderTypeFree)) {
				fmt = (((usqInt) (longAt(oop1))) >> 8) & 15;
				if (fmt >= 8) {

					/* oop contains bytes; unswap */

					wordAddr = oop1 + BaseHeaderSize;
					if (fmt >= 12) {

						/* compiled method; start after methodHeader and literals */

						wordAddr = (wordAddr + BytesPerWord) + ((literalCountOfHeader(headerOf(oop1))) * BytesPerWord);
					}
					/* begin reverseBytesFrom:to: */
					stopAddr1 = oop1 + (sizeBitsOf(oop1));
					flag("Dan");
					addr2 = wordAddr;
					while ((((usqInt) addr2)) < (((usqInt) stopAddr1))) {
						longAtput(addr2, byteSwapped(longAt(addr2)));
						addr2 += BytesPerWord;
					}
				}
				if (fmt == 6) {
					if (((((usqInt) (longAt(oop1))) >> 12) & 31) == ClassFloatCompactIndex) {
						if ((data & 65535) >= 6505) {

							/* Bitmap, Float etc */

							temp1 = longAt(oop1 + BaseHeaderSize);
							longAtput(oop1 + BaseHeaderSize, longAt((oop1 + BaseHeaderSize) + 4));
							longAtput((oop1 + BaseHeaderSize) + 4, temp1);
						}
					}
					else {
						if (BytesPerWord == 8) {

							/* Object contains 32-bit half-words packed into 64-bit machine words. */

							wordAddr = oop1 + BaseHeaderSize;
							/* begin reverseWordsFrom:to: */
							stopAddr2 = oop1 + (sizeBitsOf(oop1));
							addr11 = wordAddr;
							while ((((usqInt) addr11)) < (((usqInt) stopAddr2))) {
								longAtput(addr11, wordSwapped(longAt(addr11)));
								addr11 += BytesPerWord;
							}
						}
					}
				}
			}
			/* begin objectAfter: */
			if (DoAssertionChecks) {
				if ((((usqInt) oop1)) >= (((usqInt) GIV(endOfMemory)))) {
					error("no objects after the end of memory");
				}
			}
			if (((longAt(oop1)) & TypeMask) == HeaderTypeFree) {
				sz1 = (longAt(oop1)) & AllButTypeMask;
			}
			else {
				/* begin sizeBitsOf: */
				header2 = longAt(oop1);
				sz1 = ((header2 & TypeMask) == HeaderTypeSizeAndClass
					? (longAt(oop1 - (BytesPerWord * 2))) & LongSizeMask
					: header2 & SizeMask);
			}
			oop1 = (oop1 + sz1) + (headerTypeBytes[(longAt(oop1 + sz1)) & TypeMask]);
		}
	}
	segOop = ((segmentWordArray + BaseHeaderSize) + BytesPerWord) + (headerTypeBytes[(longAt((segmentWordArray + BaseHeaderSize) + BytesPerWord)) & TypeMask]);
	while (segOop <= endSeg) {
		if (((longAt(segOop)) & TypeMask) <= 1) {

			/* This object has a class field (type = 0 or 1) -- start with that. */

			fieldPtr = segOop - BytesPerWord;
			doingClass = 1;
		}
		else {

			/* No class field -- start with first data field */

			fieldPtr = segOop + BaseHeaderSize;
			doingClass = 0;
		}

		/* last field */

		lastPtr = segOop + (lastPointerOf(segOop));
		if (lastPtr > endSeg) {
			if (DoAssertionChecks) {
				verifyCleanHeaders();
			}
			return 0;
		}
		while (!(fieldPtr > lastPtr)) {

			/* Examine each pointer field */

			fieldOop = longAt(fieldPtr);
			if (doingClass) {
				hdrTypeBits = (longAt(fieldPtr)) & TypeMask;
				fieldOop -= hdrTypeBits;
			}
			if ((fieldOop & 1)) {

				/* Integer -- nothing to do */

				fieldPtr += BytesPerWord;
			}
			else {
				if (!((fieldOop & 3) == 0)) {
					return 0;
				}
				if ((fieldOop & 2147483648UL) == 0) {

					/* Internal pointer -- add segment offset */

					mapOop = fieldOop + segmentWordArray;
				}
				else {

					/* External pointer -- look it up in outPointers */

					outPtr = outPointerArray + (fieldOop & 2147483647UL);
					if (outPtr > lastOut) {
						return 0;
					}
					mapOop = longAt(outPtr);
				}
				if (doingClass) {
					longAtput(fieldPtr, mapOop + hdrTypeBits);
					fieldPtr += 8;
					doingClass = 0;
				}
				else {
					longAtput(fieldPtr, mapOop);
					fieldPtr += BytesPerWord;
				}
				if (segOop < GIV(youngStart)) {
					possibleRootStoreIntovalue(segOop, mapOop);
				}
			}
		}
		/* begin objectAfter: */
		if (DoAssertionChecks) {
			if ((((usqInt) segOop)) >= (((usqInt) GIV(endOfMemory)))) {
				error("no objects after the end of memory");
			}
		}
		if (((longAt(segOop)) & TypeMask) == HeaderTypeFree) {
			sz2 = (longAt(segOop)) & AllButTypeMask;
		}
		else {
			/* begin sizeBitsOf: */
			header3 = longAt(segOop);
			sz2 = ((header3 & TypeMask) == HeaderTypeSizeAndClass
				? (longAt(segOop - (BytesPerWord * 2))) & LongSizeMask
				: header3 & SizeMask);
		}
		segOop = ((sqInt) ((segOop + sz2) + (headerTypeBytes[(longAt(segOop + sz2)) & TypeMask])));
	}
	segOop = ((segmentWordArray + BaseHeaderSize) + BytesPerWord) + (headerTypeBytes[(longAt((segmentWordArray + BaseHeaderSize) + BytesPerWord)) & TypeMask]);
	while (segOop <= endSeg) {
		if (!(oopHasAcceptableClass(segOop))) {
			return 0;
		}

		/* first field */

		fieldPtr = segOop + BaseHeaderSize;

		/* last field */
		/* Go through all oops, remapping them... */

		lastPtr = segOop + (lastPointerOf(segOop));
		while (!(fieldPtr > lastPtr)) {

			/* Examine each pointer field */

			fieldOop = longAt(fieldPtr);
			if (!(oopHasAcceptableClass(fieldOop))) {
				return 0;
			}
			fieldPtr += BytesPerWord;
		}
		/* begin objectAfter: */
		if (DoAssertionChecks) {
			if ((((usqInt) segOop)) >= (((usqInt) GIV(endOfMemory)))) {
				error("no objects after the end of memory");
			}
		}
		if (((longAt(segOop)) & TypeMask) == HeaderTypeFree) {
			sz3 = (longAt(segOop)) & AllButTypeMask;
		}
		else {
			/* begin sizeBitsOf: */
			header4 = longAt(segOop);
			sz3 = ((header4 & TypeMask) == HeaderTypeSizeAndClass
				? (longAt(segOop - (BytesPerWord * 2))) & LongSizeMask
				: header4 & SizeMask);
		}
		segOop = ((sqInt) ((segOop + sz3) + (headerTypeBytes[(longAt(segOop + sz3)) & TypeMask])));
	}
	extraSize = headerTypeBytes[(longAt(segmentWordArray)) & TypeMask];
	hdrTypeBits = (longAt(segmentWordArray)) & TypeMask;
	if (extraSize == 8) {
		longAtput(segmentWordArray - extraSize, (BaseHeaderSize + BytesPerWord) + hdrTypeBits);
	}
	else {
		header = longAt(segmentWordArray);
		longAtput(segmentWordArray, ((header - (header & SizeMask)) + BaseHeaderSize) + BytesPerWord);
	}
	if (DoAssertionChecks) {
		verifyCleanHeaders();
	}
	return ((segmentWordArray + BaseHeaderSize) + BytesPerWord) + (headerTypeBytes[(longAt((segmentWordArray + BaseHeaderSize) + BytesPerWord)) & TypeMask]);
}

void
loadInitialContext(void)
{   DECL_MAYBE_SQ_GLOBAL_STRUCT
    sqInt activeContext;
    sqInt activeProc;
    sqInt aMethodObj;
    StackPage *newPage;
    char *theFP;
    sqInt top;

	if ((checkForLeaks & 1) != 0) {
		clearLeakMapAndMapAccessibleObjects();
		assert(checkHeapIntegrity());
	}
	activeProc = longAt(((longAt(((longAt((GIV(specialObjectsOop) + BaseHeaderSize) + (SchedulerAssociation << ShiftForWord))) + BaseHeaderSize) + (ValueIndex << ShiftForWord))) + BaseHeaderSize) + (ActiveProcessIndex << ShiftForWord));
	activeContext = longAt((activeProc + BaseHeaderSize) + (SuspendedContextIndex << ShiftForWord));
	/* begin marryContextInNewStackPageAndInitializeInterpreterRegisters: */
	VM_LABEL(1marryContextInNewStackPageAndInitializeInterpreterRegisters);
	assert(GIV(stackPage) == 0);
	newPage = makeBaseFrameFor(activeContext);
	/* begin setStackPageAndLimit: */
	GIV(stackPage) = newPage;
	if (GIV(stackLimit) != (((char *) (((usqInt) -1))))) {
		GIV(stackLimit) = (GIV(stackPage)->stackLimit);
	}
	markStackPageMostRecentlyUsed(newPage);
	GIV(framePointer) = (GIV(stackPage)->headFP);
	GIV(stackPointer) = (GIV(stackPage)->headSP);
	/* begin setMethod: */
	/* begin iframeMethod: */
	theFP = (GIV(stackPage)->headFP);
	aMethodObj = longAt(theFP + FoxMethod);
	assert((((usqInt)aMethodObj)) >= (startOfMemory()));
	GIV(method) = aMethodObj;
	/* begin popStack */
	top = longAt(GIV(stackPointer));
	GIV(stackPointer) += BytesPerWord;
	GIV(instructionPointer) = ((sqInt) top);
}


/*	This method implements a simple method lookup cache. If an entry for the
	given selector and class is found in the cache, set the values of
	'newMethod' and 'primitiveFunctionPointer' and return true. Otherwise,
	return false.
 */
/*	About the re-probe scheme: The hash is the low bits of the XOR of two
	large addresses, minus their useless lowest two bits. If a probe doesn't
	get a hit, the hash is shifted right one bit to compute the next probe,
	introducing a new randomish bit. The cache is probed CacheProbeMax times
	before giving up.
 */
/*	WARNING: Since the hash computation is based on the object addresses of
	the class and selector, we must rehash or flush when compacting storage.
	We've chosen to flush, since that also saves the trouble of updating the
	addresses of the objects in the cache.
 */

static sqInt
lookupInMethodCacheSelclass(sqInt selector, sqInt class)
{   DECL_MAYBE_SQ_GLOBAL_STRUCT
    sqInt hash;
    sqInt probe;


	/* shift drops two low-order zeros from addresses */

	hash = selector ^ class;

	/* first probe */

	probe = hash & MethodCacheMask;
	if (((GIV(methodCache)[probe + MethodCacheSelector]) == selector)
	 && ((GIV(methodCache)[probe + MethodCacheClass]) == class)) {
		GIV(newMethod) = GIV(methodCache)[probe + MethodCacheMethod];
		primitiveFunctionPointer = ((void (*)()) (GIV(methodCache)[probe + MethodCachePrimFunction]));
		return 1;
	}

	/* second probe */

	probe = (((usqInt) hash) >> 1) & MethodCacheMask;
	if (((GIV(methodCache)[probe + MethodCacheSelector]) == selector)
	 && ((GIV(methodCache)[probe + MethodCacheClass]) == class)) {
		GIV(newMethod) = GIV(methodCache)[probe + MethodCacheMethod];
		primitiveFunctionPointer = ((void (*)()) (GIV(methodCache)[probe + MethodCachePrimFunction]));
		return 1;
	}
	probe = (((usqInt) hash) >> 2) & MethodCacheMask;
	if (((GIV(methodCache)[probe + MethodCacheSelector]) == selector)
	 && ((GIV(methodCache)[probe + MethodCacheClass]) == class)) {
		GIV(newMethod) = GIV(methodCache)[probe + MethodCacheMethod];
		primitiveFunctionPointer = ((void (*)()) (GIV(methodCache)[probe + MethodCachePrimFunction]));
		return 1;
	}
	return 0;
}

static sqInt
lookupMethodInClass(sqInt class)
{   DECL_MAYBE_SQ_GLOBAL_STRUCT
    sqInt currentClass;
    sqInt dictionary;
    sqInt found;
    sqInt header;
    sqInt index;
    sqInt length;
    sqInt mask;
    sqInt methodArray;
    sqInt nextSelector;
    sqInt sz;
    sqInt wrapAround;

	assert(class != (nilObject()));
	currentClass = class;
	while (currentClass != GIV(nilObj)) {
		dictionary = longAt((currentClass + BaseHeaderSize) + (MethodDictionaryIndex << ShiftForWord));
		if (dictionary == GIV(nilObj)) {
			createActualMessageTo(class);
			GIV(messageSelector) = longAt((GIV(specialObjectsOop) + BaseHeaderSize) + (SelectorCannotInterpret << ShiftForWord));
			sendBreakpointreceiver(GIV(messageSelector) + BaseHeaderSize, lengthOf(GIV(messageSelector)), null);
			return lookupMethodInClass(longAt((currentClass + BaseHeaderSize) + (SuperclassIndex << ShiftForWord)));
		}
		/* begin lookupMethodInDictionary: */
		/* begin fetchWordLengthOf: */
		/* begin sizeBitsOf: */
		header = longAt(dictionary);
		sz = ((header & TypeMask) == HeaderTypeSizeAndClass
			? (longAt(dictionary - (BytesPerWord * 2))) & LongSizeMask
			: header & SizeMask);
		length = ((usqInt) (sz - BaseHeaderSize)) >> ShiftForWord;
		mask = (length - SelectorStart) - 1;

		/* It is assumed that there are some nils in this dictionary, and search will 
	 stop when one is encountered. However, if there are no nils, then wrapAround 
	 will be detected the second time the loop gets to the end of the table. */

		index = SelectorStart + (mask & (((GIV(messageSelector) & 1)
	? (GIV(messageSelector) >> 1)
	: (((usqInt) (longAt(GIV(messageSelector)))) >> HashBitsOffset) & HashMaskUnshifted)));
		wrapAround = 0;
		while (1) {
			nextSelector = longAt((dictionary + BaseHeaderSize) + (index << ShiftForWord));
			if (nextSelector == GIV(nilObj)) {
				found = 0;
				goto l1;
			}
			if (nextSelector == GIV(messageSelector)) {
				methodArray = longAt((dictionary + BaseHeaderSize) + (MethodArrayIndex << ShiftForWord));
				GIV(newMethod) = longAt((methodArray + BaseHeaderSize) + ((index - SelectorStart) << ShiftForWord));
				found = 1;
				goto l1;
			}
			index += 1;
			if (index == length) {
				if (wrapAround) {
					found = 0;
					goto l1;
				}
				wrapAround = 1;
				index = SelectorStart;
			}
		}
		found = 0;
	l1:	/* end lookupMethodInDictionary: */;
		if (found) {
			return currentClass;
		}
		currentClass = longAt((currentClass + BaseHeaderSize) + (SuperclassIndex << ShiftForWord));
	}
	if (GIV(messageSelector) == (longAt((GIV(specialObjectsOop) + BaseHeaderSize) + (SelectorDoesNotUnderstand << ShiftForWord)))) {
		error("Recursive not understood error encountered");
	}
	createActualMessageTo(class);
	GIV(messageSelector) = longAt((GIV(specialObjectsOop) + BaseHeaderSize) + (SelectorDoesNotUnderstand << ShiftForWord));
	sendBreakpointreceiver(GIV(messageSelector) + BaseHeaderSize, lengthOf(GIV(messageSelector)), null);
	return lookupMethodInClass(class);
}


/*	This method lookup tolerates integers as Dictionary keys to suoport
	execution of images in which Symbols have been compacted out. */

static sqInt
lookupMethodInDictionary(sqInt dictionary)
{   DECL_MAYBE_SQ_GLOBAL_STRUCT
    sqInt header;
    sqInt index;
    sqInt length;
    sqInt mask;
    sqInt methodArray;
    sqInt nextSelector;
    sqInt sz;
    sqInt wrapAround;

	/* begin fetchWordLengthOf: */
	/* begin sizeBitsOf: */
	header = longAt(dictionary);
	sz = ((header & TypeMask) == HeaderTypeSizeAndClass
		? (longAt(dictionary - (BytesPerWord * 2))) & LongSizeMask
		: header & SizeMask);
	length = ((usqInt) (sz - BaseHeaderSize)) >> ShiftForWord;
	mask = (length - SelectorStart) - 1;

	/* It is assumed that there are some nils in this dictionary, and search will 
	 stop when one is encountered. However, if there are no nils, then wrapAround 
	 will be detected the second time the loop gets to the end of the table. */

	index = SelectorStart + (mask & (((GIV(messageSelector) & 1)
	? (GIV(messageSelector) >> 1)
	: (((usqInt) (longAt(GIV(messageSelector)))) >> HashBitsOffset) & HashMaskUnshifted)));
	wrapAround = 0;
	while (1) {
		nextSelector = longAt((dictionary + BaseHeaderSize) + (index << ShiftForWord));
		if (nextSelector == GIV(nilObj)) {
			return 0;
		}
		if (nextSelector == GIV(messageSelector)) {
			methodArray = longAt((dictionary + BaseHeaderSize) + (MethodArrayIndex << ShiftForWord));
			GIV(newMethod) = longAt((methodArray + BaseHeaderSize) + ((index - SelectorStart) << ShiftForWord));
			return 1;
		}
		index += 1;
		if (index == length) {
			if (wrapAround) {
				return 0;
			}
			wrapAround = 1;
			index = SelectorStart;
		}
	}
	return 0;
}


/*	Lookup messageSelector in class. Answer 0 on success. Answer the splObj:
	index for the error selector to use on failure rather than performing MNU
	processing etc. */

static sqInt
lookupMethodNoMNUEtcInClass(sqInt class)
{   DECL_MAYBE_SQ_GLOBAL_STRUCT
    sqInt currentClass;
    sqInt dictionary;

	currentClass = class;
	while (currentClass != GIV(nilObj)) {
		dictionary = longAt((currentClass + BaseHeaderSize) + (MethodDictionaryIndex << ShiftForWord));
		if (dictionary == GIV(nilObj)) {
			GIV(lkupClass) = longAt((currentClass + BaseHeaderSize) + (SuperclassIndex << ShiftForWord));
			return SelectorCannotInterpret;
		}
		if (lookupMethodInDictionary(dictionary)) {
			addNewMethodToCache(class);
			return 0;
		}
		currentClass = longAt((currentClass + BaseHeaderSize) + (SuperclassIndex << ShiftForWord));
	}
	GIV(lkupClass) = class;
	return SelectorDoesNotUnderstand;
}


/*	Lookup selector in rcvr, without doing MNU processing, and answer either a
	method or nil if the message was not understood. Used to populate closed
	PICs.  */
/*	self printFrame: stackPage headFP WithSP: stackPage headSP */
/*	self printStringOf: selector */

sqInt
lookupreceiver(sqInt selector, sqInt rcvr)
{   DECL_MAYBE_SQ_GLOBAL_STRUCT
    sqInt ccIndex;
    sqInt class;

	/* begin fetchClassOf: */
	if ((rcvr & 1)) {
		class = longAt((GIV(specialObjectsOop) + BaseHeaderSize) + (ClassInteger << ShiftForWord));
		goto l1;
	}
	if (((ccIndex = (((usqInt) (longAt(rcvr))) >> 12) & 31)) == 0) {
		class = (longAt(rcvr - BaseHeaderSize)) & AllButTypeMask;
		goto l1;
	}
	else {
		class = longAt(((longAt((GIV(specialObjectsOop) + BaseHeaderSize) + (CompactClasses << ShiftForWord))) + BaseHeaderSize) + ((ccIndex - 1) << ShiftForWord));
		goto l1;
	}
l1:	/* end fetchClassOf: */;
	if (!(lookupInMethodCacheSelclass(selector, class))) {
		GIV(messageSelector) = selector;
		if ((lookupMethodNoMNUEtcInClass(class)) != 0) {
			return null;
		}
	}
	return GIV(newMethod);
}


/*	Return the first free block after the given chunk in memory. */

static sqInt
lowestFreeAfter(sqInt chunk)
{
    sqInt oop;
    sqInt oopHeader;
    sqInt oopHeaderType;
    sqInt oopSize;

	oop = chunk + (headerTypeBytes[(longAt(chunk)) & TypeMask]);
	while ((((usqInt) oop)) < (((usqInt) GIV(endOfMemory)))) {
		oopHeader = longAt(oop);
		oopHeaderType = oopHeader & TypeMask;
		if (oopHeaderType == HeaderTypeFree) {
			return oop;
		}
		if (oopHeaderType == HeaderTypeSizeAndClass) {
			oopSize = (longAt(oop - (BytesPerWord * 2))) & AllButTypeMask;
		}
		else {
			oopSize = oopHeader & SizeMask;
		}
		oop = (oop + oopSize) + (headerTypeBytes[(longAt(oop + oopSize)) & TypeMask]);
	}
	error("expected to find at least one free object");
	return null;
}


/*	<Integer> */
/*	Marry aContext with the base frame of a new stack page. Build the base
	frame to reflect the context's state. Answer the new page. Override to
	hold the caller context in a different place, In the StackInterpreter we
	use the caller saved ip, but in the Cog VM caller saved ip is the
	ceBaseReturn: trampoline. Simply hold the caller context in the first word
	of the stack. */

static StackPage *
makeBaseFrameFor(sqInt aContext)
{   DECL_MAYBE_SQ_GLOBAL_STRUCT
    sqInt header;
    sqInt i;
    StackPage *lruOrFree;
    sqInt maybeClosure;
    sqInt methodHeader;
    sqInt numArgs;
    sqInt oop;
    sqInt oop1;
    StackPage *page;
    char *pointer;
    sqInt stackPtrIndex;
    sqInt theIP;
    sqInt theMethod;
    char *value;
    sqInt valuePointer;
    sqInt valuePointer1;

	assert(isSingleContext(aContext));
	theIP = longAt((aContext + BaseHeaderSize) + (InstructionPointerIndex << ShiftForWord));
	assert((((sqInt) HasBeenReturnedFromMCPC)) < 0);
	theIP = ((theIP & 1)
		? (theIP >> 1)
		: HasBeenReturnedFromMCPC);
	theMethod = longAt((aContext + BaseHeaderSize) + (MethodIndex << ShiftForWord));
	/* begin newStackPage */
	lruOrFree = (mostRecentlyUsedPage()->nextPage);
	if (isFree(lruOrFree)) {
		page = lruOrFree;
		goto l1;
	}
	divorceFramesIn(lruOrFree);
	page = lruOrFree;
l1:	/* end newStackPage */;
	longAtput(pointer = (page->baseAddress), longAt((aContext + BaseHeaderSize) + (SenderIndex << ShiftForWord)));
	longAtput(pointer -= BytesPerWord, aContext);
	maybeClosure = longAt((aContext + BaseHeaderSize) + (ClosureIndex << ShiftForWord));
	if (maybeClosure != GIV(nilObj)) {
		/* begin quickFetchInteger:ofObject: */
		oop = longAt((maybeClosure + BaseHeaderSize) + (ClosureNumArgsIndex << ShiftForWord));
		assert((oop & 1));
		numArgs = (oop >> 1);
		longAtput(pointer -= BytesPerWord, maybeClosure);
	}
	else {
		/* begin argumentCountOf: */
		/* begin argumentCountOfMethodHeader: */
		/* begin headerOf: */
		methodHeader = longAt((theMethod + BaseHeaderSize) + (HeaderIndex << ShiftForWord));
		header = (isCogMethodReference(methodHeader)
			? (((CogMethod *) methodHeader)->methodHeader)
			: methodHeader);
		numArgs = (((usqInt) header) >> 25) & 15;
		longAtput(pointer -= BytesPerWord, longAt((aContext + BaseHeaderSize) + (ReceiverIndex << ShiftForWord)));
	}
	for (i = 1; i <= numArgs; i += 1) {
		longAtput(pointer -= BytesPerWord, longAt((aContext + BaseHeaderSize) + ((ReceiverIndex + i) << ShiftForWord)));
	}
	longAtput(pointer -= BytesPerWord, ceBaseFrameReturnPC());
	longAtput(pointer -= BytesPerWord, 0);
	(page->headFP = pointer);
	if ((((sqInt) theIP)) < 0) {
		/* begin ensureMethodIsCogged: */
		if (!(methodHasCogMethod(theMethod))) {
			if (((cogselector(theMethod, GIV(nilObj))) == null)
			 && (GIV(cogCompiledCodeCompactionCalledFor))) {
				commenceCogCompiledCodeCompaction();
				cogselector(theMethod, GIV(nilObj));
			}
		}
		if (!(asserta(methodHasCogMethod(theMethod)))) {
			error("could not compile method that should have been compiled");
		}
		theMethod = ((sqInt)(cogMethodOf(theMethod)));
		if (maybeClosure != GIV(nilObj)) {
			if (theIP == (((sqInt) HasBeenReturnedFromMCPC))) {

				/* If the pc is the special HasBeenReturnedFromMCPC pc set the pc
					  appropriately so that the frame stays in the cannotReturn: state. */

				theMethod = ((sqInt)(findMethodForStartBcpcinHomeMethod((((longAt((maybeClosure + BaseHeaderSize) + (ClosureStartPCIndex << ShiftForWord))) >> 1)) - 1, ((CogMethod *) theMethod))));
				if (theMethod == 0) {
					error("cannot find machine code block matching closure's startpc");
				}
				theIP = ceCannotResumePC();
			}
			else {
				assert((((signed)theIP >> 16)) < -1);
				theMethod -= (((signed)theIP >> 16)) * (sizeof(CogBlockMethod));
				theIP = theMethod - (((short)theIP));
			}
			longAtput(pointer -= BytesPerWord, (theMethod + MFMethodFlagHasContextFlag) + MFMethodFlagIsBlockFlag);
		}
		else {
			assert((((signed)theIP >> 16)) >= -1);
			theIP = (theIP == (((sqInt) HasBeenReturnedFromMCPC))
				? ceCannotResumePC()
				: (((sqInt)theMethod)) - theIP);
			longAtput(pointer -= BytesPerWord, theMethod + MFMethodFlagHasContextFlag);
		}
		longAtput(pointer -= BytesPerWord, aContext);
	}
	else {
		longAtput(pointer -= BytesPerWord, theMethod);
		longAtput(pointer -= BytesPerWord, aContext);
		longAtput(pointer -= BytesPerWord, (VMBIGENDIAN
			? ((1 + (numArgs << ((BytesPerWord * 8) - 8))) + ((1
	? 1 << ((BytesPerWord * 8) - 16)
	: 0))) + ((maybeClosure != GIV(nilObj)
	? 1 << ((BytesPerWord * 8) - 24)
	: 0))
			: ((1 + (numArgs << 8)) + ((1
	? 1 << 16
	: 0))) + ((maybeClosure != GIV(nilObj)
	? 1 << 24
	: 0))));
		longAtput(pointer -= BytesPerWord, 0);
		/* begin iframeInstructionPointerForIndex:method: */
		assert(((theIP >= (lastPointerOf(theMethod))) && (theIP <= (lengthOf(theMethod)))));
		theIP = ((theMethod + theIP) + BaseHeaderSize) - 2;
	}
	(page->baseFP = (page->headFP));
	assert(frameHasContext((page->baseFP)));
	assert((frameNumArgs((page->baseFP))) == numArgs);
	longAtput(pointer -= BytesPerWord, longAt((aContext + BaseHeaderSize) + (ReceiverIndex << ShiftForWord)));
	/* begin quickFetchInteger:ofObject: */
	oop1 = longAt((aContext + BaseHeaderSize) + (StackPointerIndex << ShiftForWord));
	assert((oop1 & 1));
	stackPtrIndex = (oop1 >> 1);
	assert((ReceiverIndex + stackPtrIndex) < (lengthOf(aContext)));
	for (i = (numArgs + 1); i <= stackPtrIndex; i += 1) {
		longAtput(pointer -= BytesPerWord, longAt((aContext + BaseHeaderSize) + ((ReceiverIndex + i) << ShiftForWord)));
	}
	longAtput(pointer -= BytesPerWord, theIP);
	assert((fetchPointerofObject(InstructionPointerIndex, aContext)) == (contextInstructionPointerframe(theIP, (page->baseFP))));
	(page->headSP = pointer);
	/* begin storePointerUnchecked:ofObject:withValue: */
	/* begin withSmallIntegerTags: */
	value = (page->baseFP);
	assert(((oopForPointer(value)) & (BytesPerWord - 1)) == 0);
	valuePointer = (oopForPointer(value)) + 1;
	longAtput((aContext + BaseHeaderSize) + (SenderIndex << ShiftForWord), valuePointer);
	/* begin storePointerUnchecked:ofObject:withValue: */
	/* begin withSmallIntegerTags: */
	assert(((oopForPointer(0)) & (BytesPerWord - 1)) == 0);
	valuePointer1 = (oopForPointer(0)) + 1;
	longAtput((aContext + BaseHeaderSize) + (InstructionPointerIndex << ShiftForWord), valuePointer1);
	assert(((fetchPointerofObject(SenderIndex, aContext)) & 1));
	assert((frameOfMarriedContext(aContext)) == ((page->baseFP)));
	assert(validStackPageBaseFrames());
	return page;
}


/*	make a Point xValue@yValue.
	We know both will be integers so no value nor root checking is needed
 */

sqInt
makePointwithxValueyValue(sqInt xValue, sqInt yValue)
{
    sqInt pointResult;

	pointResult = eeInstantiateSmallClasssizeInBytes(longAt((GIV(specialObjectsOop) + BaseHeaderSize) + (ClassPoint << ShiftForWord)), 3 * BytesPerWord);
	longAtput((pointResult + BaseHeaderSize) + (XIndex << ShiftForWord), ((xValue << 1) | 1));
	longAtput((pointResult + BaseHeaderSize) + (YIndex << ShiftForWord), ((yValue << 1) | 1));
	return pointResult;
}


/*	Use the forwarding table to update the pointers of all non-free objects in
	the given range of memory.
	Also remap pointers in root objects which may contains pointers into the
	given memory range, and
	don't forget to flush the method cache based on the range. */
/*	update interpreter variables */

static void
mapPointersInObjectsFromto(sqInt memStart, sqInt memEnd)
{   DECL_MAYBE_SQ_GLOBAL_STRUCT
    sqInt aMethodObj;
    sqInt anObject;
    sqInt anOop;
    sqInt anOop1;
    sqInt anOop2;
    sqInt i;
    sqInt i1;
    sqInt i2;
    sqInt mapInstructionPointer;
    sqInt oop;
    sqInt oop1;
    sqInt probe;

	/* begin mapInterpreterOops */
	VM_LABEL(0mapInterpreterOops);
	/* begin nilObject: */
	anOop = remap(GIV(nilObj));
	GIV(nilObj) = anOop;
	/* begin falseObject: */
	anOop1 = remap(GIV(falseObj));
	GIV(falseObj) = anOop1;
	/* begin trueObject: */
	anOop2 = remap(GIV(trueObj));
	GIV(trueObj) = anOop2;
	/* begin specialObjectsOop: */
	anObject = remap(GIV(specialObjectsOop));
	GIV(specialObjectsOop) = anObject;
	mapStackPages();
	/* begin mapMachineCode */
	mapObjectReferencesInMachineCode(GIV(inFullGC));
	/* begin mapTraceLogs */
	mapTraceLog();
	mapPrimTraceLog();
	/* begin mapVMRegisters */
	mapInstructionPointer = GIV(instructionPointer) > GIV(method);
	if (mapInstructionPointer) {
		GIV(instructionPointer) -= GIV(method);
	}
	/* begin setMethod: */
	aMethodObj = remap(GIV(method));
	assert((((usqInt)aMethodObj)) >= (startOfMemory()));
	GIV(method) = aMethodObj;
	if (mapInstructionPointer) {
		GIV(instructionPointer) += GIV(method);
	}
	GIV(messageSelector) = remap(GIV(messageSelector));
	if (!((GIV(newMethod) & 1))) {
		GIV(newMethod) = remap(GIV(newMethod));
	}
	GIV(lkupClass) = remap(GIV(lkupClass));
	/* begin mapProfileState */
	GIV(profileProcess) = remap(GIV(profileProcess));
	GIV(profileMethod) = remap(GIV(profileMethod));

	/* The longRunningPrimitiveCheckMethod (LRPCM) is sampled in an interrupt.  Be very careful with it.
	  If longRunningPrimitiveCheckSequenceNumber (LRPCSN) = statCheckForEvents then LRPCM has
	  been recenty sampled and could be mapped or not, but it must be newMethod and we can simply
	  copy newMethod.  If LRPCSN ~= statCheckForEvents then LRPCM must be some extant object and
	  needs to be remapped. */

	GIV(profileSemaphore) = remap(GIV(profileSemaphore));
	sqLowLevelMFence();
	if (GIV(longRunningPrimitiveCheckMethod) != null) {
		GIV(longRunningPrimitiveCheckMethod) = (GIV(longRunningPrimitiveCheckSequenceNumber) == GIV(statCheckForEvents)
			? GIV(newMethod)
			: remap(GIV(longRunningPrimitiveCheckMethod)));
		sqLowLevelMFence();
	}
	if (GIV(longRunningPrimitiveCheckSemaphore) != null) {
		GIV(longRunningPrimitiveCheckSemaphore) = remap(GIV(longRunningPrimitiveCheckSemaphore));
	}
	if (!(GIV(tempOop) == 0)) {
		GIV(tempOop) = remap(GIV(tempOop));
	}
	for (i2 = 1; i2 <= (remapBufferCount()); i2 += 1) {
		oop1 = GIV(remapBuffer)[i2];
		if (!((oop1 & 1))) {
			GIV(remapBuffer)[i2] = (remap(oop1));
		}
	}
	for (i2 = 1; i2 <= GIV(jmpDepth); i2 += 1) {
		oop1 = GIV(suspendedCallbacks)[i2];
		if (!((oop1 & 1))) {
			GIV(suspendedCallbacks)[i2] = (remap(oop1));
		}
		oop1 = GIV(suspendedMethods)[i2];
		if (!((oop1 & 1))) {
			GIV(suspendedMethods)[i2] = (remap(oop1));
		}
	}
	for (i = 1; i <= GIV(extraRootCount); i += 1) {
		oop = (GIV(extraRoots)[i])[0];
		if (!((oop & 1))) {
			(GIV(extraRoots)[i])[0] = (remap(oop));
		}
	}
	/* begin flushMethodCacheFrom:to: */
	VM_LABEL(0flushMethodCacheFromto);
	probe = 0;
	for (i1 = 1; i1 <= MethodCacheEntries; i1 += 1) {
		if (!((GIV(methodCache)[probe + MethodCacheSelector]) == 0)) {
			if (((((((usqInt) (GIV(methodCache)[probe + MethodCacheSelector]))) >= (((usqInt) memStart)))
 && ((((usqInt) (GIV(methodCache)[probe + MethodCacheSelector]))) < (((usqInt) memEnd))))
 || (((((usqInt) (GIV(methodCache)[probe + MethodCacheClass]))) >= (((usqInt) memStart)))
 && ((((usqInt) (GIV(methodCache)[probe + MethodCacheClass]))) < (((usqInt) memEnd)))))
			 || (((((usqInt) (GIV(methodCache)[probe + MethodCacheMethod]))) >= (((usqInt) memStart)))
 && ((((usqInt) (GIV(methodCache)[probe + MethodCacheMethod]))) < (((usqInt) memEnd))))) {
				GIV(methodCache)[probe + MethodCacheSelector] = 0;
			}
		}
		probe += MethodCacheEntrySize;
	}
	for (i1 = 1; i1 <= AtCacheTotalSize; i1 += 1) {
		GIV(atCache)[i1] = 0;
	}
	updatePointersInRootObjectsFromto(memStart, memEnd);
	updatePointersInRangeFromto(memStart, memEnd);
}


/*	The prim trace log is a circular buffer of selectors. If there is
	an entry at primTraceLogIndex - 1 \\ PrimTraceBufferSize it has entries.
	If there is something at primTraceLogIndex it has wrapped. */

static void
mapPrimTraceLog(void)
{   DECL_MAYBE_SQ_GLOBAL_STRUCT
    sqInt i;
    sqInt limit;
    sqInt remainder;
    sqInt selector;

	limit = (((remainder = (GIV(primTraceLogIndex) - 1) % PrimTraceLogSize)) < 0
		? remainder + PrimTraceLogSize
		: remainder);
	if ((GIV(primTraceLog)[limit]) == 0) {
		return;
	}
	if ((GIV(primTraceLog)[GIV(primTraceLogIndex)]) != 0) {
		limit = PrimTraceLogSize - 1;
	}
	for (i = 0; i <= limit; i += 1) {
		selector = GIV(primTraceLog)[i];
		if (!((selector & 1))) {
			GIV(primTraceLog)[i] = (remap(selector));
		}
	}
}


/*	Need to write back the frame pointers unless all pages are free (as in
	snapshot) 
 */

static void
mapStackPages(void)
{   DECL_MAYBE_SQ_GLOBAL_STRUCT
    char *callerFP;
    char *frameRcvrOffset;
    sqInt i;
    sqInt oop;
    char *theFP;
    sqInt theIP;
    char *theIPPtr;
    StackPage *thePage;
    char *theSP;

	if (GIV(stackPage) != 0) {
		/* begin externalWriteBackHeadFramePointers */
		assert((GIV(framePointer) - GIV(stackPointer)) < LargeContextSize);
		assert(GIV(stackPage) == (mostRecentlyUsedPage()));
		/* begin setHeadFP:andSP:inPage: */
		assert(GIV(stackPointer) < GIV(framePointer));
		assert((GIV(stackPointer) < ((GIV(stackPage)->baseAddress)))
		 && (GIV(stackPointer) > (((GIV(stackPage)->realStackLimit)) - LargeContextSize)));
		assert((GIV(framePointer) < ((GIV(stackPage)->baseAddress)))
		 && (GIV(framePointer) > (((GIV(stackPage)->realStackLimit)) - (((sqInt) LargeContextSize >> 1)))));
		(GIV(stackPage)->headFP = GIV(framePointer));
		(GIV(stackPage)->headSP = GIV(stackPointer));
		assert(pageListIsWellFormed());
	}
	for (i = 0; i <= (GIV(numStackPages) - 1); i += 1) {
		/* begin stackPageAt: */
		thePage = stackPageAtpages(i, GIV(pages));
		if (!(((thePage->baseFP)) == 0)) {
			theSP = (thePage->headSP);

			/* Skip the instruction pointer on top of stack of inactive pages. */

			theFP = (thePage->headFP);
			if (thePage == GIV(stackPage)) {
				theIPPtr = (((((usqInt)(longAt(theFP + FoxMethod)))) < heapBase)
				 || ((longAt(theFP + FoxIFSavedIP)) == 0)
					? 0
					: theFP + FoxIFSavedIP);
			}
			else {
				theIPPtr = theSP;
				theSP += BytesPerWord;
			}
					while (1) {
				assert(addressIsInPage(thePage, theFP));
				assert(addressIsInPage(thePage, theSP));
				assert((theIPPtr == 0)
				 || (addressIsInPage(thePage, theFP)));
				frameRcvrOffset = ((((usqInt)(longAt(theFP + FoxMethod)))) < heapBase
					? theFP + FoxMFReceiver
					: theFP + FoxIFReceiver);
				while (theSP <= frameRcvrOffset) {
					oop = longAt(theSP);
					if (!((oop & 1))) {
						longAtput(theSP, remap(oop));
					}
					theSP += BytesPerWord;
				}
				if (((((usqInt)(longAt(theFP + FoxMethod)))) < heapBase
					? ((longAt(theFP + FoxMethod)) & MFMethodFlagHasContextFlag) != 0
					: (byteAt((theFP + FoxIFrameFlags) + 2)) != 0)) {
					longAtput(theFP + FoxThisContext, remap(longAt(theFP + FoxThisContext)));
				}
				if (!((((usqInt)(longAt(theFP + FoxMethod)))) < heapBase)) {
					if (theIPPtr != 0) {
						theIP = longAt(theIPPtr);
						if (theIP == (ceReturnToInterpreterPC())) {
							assert((iframeSavedIP(theFP)) > (iframeMethod(theFP)));
							theIPPtr = theFP + FoxIFSavedIP;
							theIP = longAt(theIPPtr);
						}
						else {
							assert(theIP > (iframeMethod(theFP)));
						}
						theIP -= longAt(theFP + FoxMethod);
					}
					longAtput(theFP + FoxMethod, remap(longAt(theFP + FoxMethod)));
					if (theIPPtr != 0) {
						longAtput(theIPPtr, theIP + (longAt(theFP + FoxMethod)));
					}
				}
				if (!(((callerFP = frameCallerFP(theFP))) != 0)) break;
				theSP = ((theIPPtr = theFP + FoxCallerSavedIP)) + BytesPerWord;
				theFP = callerFP;
			}
			theSP = (theFP + FoxCallerSavedIP) + BytesPerWord;
			while (theSP <= ((thePage->baseAddress))) {
				oop = longAt(theSP);
				if (!((oop & 1))) {
					longAtput(theSP, remap(oop));
				}
				theSP += BytesPerWord;
			}
		}
	}
}


/*	The trace log is a circular buffer of pairs of entries. If there is
	an entry at traceLogIndex - 3 \\ TraceBufferSize it has entries.
	If there is something at traceLogIndex it has wrapped. */

static void
mapTraceLog(void)
{   DECL_MAYBE_SQ_GLOBAL_STRUCT
    sqInt i;
    sqInt intOrClass;
    sqInt limit;
    sqInt remainder;
    sqInt selectorOrMethod;

	limit = (((remainder = (GIV(traceLogIndex) - 3) % TraceBufferSize)) < 0
		? remainder + TraceBufferSize
		: remainder);
	if ((GIV(traceLog)[limit]) == 0) {
		return;
	}
	if ((GIV(traceLog)[GIV(traceLogIndex)]) != 0) {
		limit = TraceBufferSize - 3;
	}
	for (i = 0; i <= limit; i += 3) {
		intOrClass = GIV(traceLog)[i];
		if (!((intOrClass & 1))) {
			GIV(traceLog)[i] = (remap(intOrClass));
		}
		selectorOrMethod = GIV(traceLog)[i + 1];
		if (!((selectorOrMethod & 1))) {
			GIV(traceLog)[i + 1] = (remap(selectorOrMethod));
		}
	}
}

void
markActiveMethodsAndReferents(void)
{   DECL_MAYBE_SQ_GLOBAL_STRUCT
    sqInt i;
    StackPage *thePage;

	for (i = 0; i <= (GIV(numStackPages) - 1); i += 1) {
		/* begin stackPageAt: */
		thePage = stackPageAtpages(i, GIV(pages));
		if (!(isFree(thePage))) {
			markCogMethodsAndReferentsOnPage(thePage);
		}
	}
}


/*	Read markAndTraceStackPages:'s comment. Finish tracing to-be-traced pages.
	Then free any untraced pages. */

static void
markAndTraceAndMaybeFreeStackPages(sqInt fullGCFlag)
{   DECL_MAYBE_SQ_GLOBAL_STRUCT
    sqInt foundToBeTracedPage;
    sqInt i;
    StackPage *thePage;

	if (!(fullGCFlag)) {
		for (i = 0; i <= (GIV(numStackPages) - 1); i += 1) {
			/* begin stackPageAt: */
			thePage = stackPageAtpages(i, GIV(pages));
			assert(((thePage->trace = -1)) != 0);
		}
		return;
	}
	do {
		foundToBeTracedPage = 0;
		for (i = 0; i <= (GIV(numStackPages) - 1); i += 1) {
			/* begin stackPageAt: */
			thePage = stackPageAtpages(i, GIV(pages));
			if ((!(isFree(thePage)))
			 && (((thePage->trace)) == 1)) {
				foundToBeTracedPage = 1;
				(thePage->trace = 2);
				markAndTraceStackPage(thePage);
			}
		}
	} while(foundToBeTracedPage);
	for (i = 0; i <= (GIV(numStackPages) - 1); i += 1) {
		/* begin stackPageAt: */
		thePage = stackPageAtpages(i, GIV(pages));
		if ((!(isFree(thePage)))
		 && (((thePage->trace)) == 0)) {
			assert(noMarkedContextsOnPage(thePage));
			/* begin freeStackPage: */
			freeStackPageNoAssert(thePage);
			assert(pageListIsWellFormed());
		}
		assert(((thePage->trace = -1)) != 0);
	}
}


/*	Mark and trace all oops in the interpreter's state. */
/*	Assume: All traced variables contain valid oops. */
/*	Must mark stack pages first to initialize the per-page trace
	flags for full garbage collect before any subsequent tracing. */

static void
markAndTraceInterpreterOops(sqInt fullGCFlag)
{   DECL_MAYBE_SQ_GLOBAL_STRUCT
    sqInt i;
    sqInt oop;

	markAndTraceStackPages(fullGCFlag);
	markAndTraceTraceLog();
	markAndTracePrimTraceLog();
	markAndTrace(GIV(specialObjectsOop));
	if (!((GIV(messageSelector) & 1))) {
		markAndTrace(GIV(messageSelector));
	}
	if (!((GIV(newMethod) & 1))) {
		markAndTrace(GIV(newMethod));
		markAndTrace(GIV(lkupClass));
	}
	/* begin traceProfileState */
	markAndTrace(GIV(profileProcess));
	markAndTrace(GIV(profileMethod));
	markAndTrace(GIV(profileSemaphore));
	sqLowLevelMFence();
	if ((GIV(longRunningPrimitiveCheckMethod) != null)
	 && (GIV(longRunningPrimitiveCheckSequenceNumber) != GIV(statCheckForEvents))) {
		markAndTrace(GIV(longRunningPrimitiveCheckMethod));
	}
	if (GIV(longRunningPrimitiveCheckSemaphore) != null) {
		markAndTrace(GIV(longRunningPrimitiveCheckSemaphore));
	}
	if (!(GIV(tempOop) == 0)) {
		markAndTrace(GIV(tempOop));
	}
	for (i = 1; i <= (remapBufferCount()); i += 1) {
		oop = GIV(remapBuffer)[i];
		if (!((oop & 1))) {
			markAndTrace(oop);
		}
	}
	for (i = 1; i <= GIV(jmpDepth); i += 1) {
		oop = GIV(suspendedCallbacks)[i];
		if (!((oop & 1))) {
			markAndTrace(oop);
		}
		oop = GIV(suspendedMethods)[i];
		if (!((oop & 1))) {
			markAndTrace(oop);
		}
	}
}


/*	The prim trace log is a circular buffer of selectors. If there is
	an entry at primTraceLogIndex - 1 \\ PrimTraceBufferSize it has entries.
	If there is something at primTraceLogIndex it has wrapped. */

static void
markAndTracePrimTraceLog(void)
{   DECL_MAYBE_SQ_GLOBAL_STRUCT
    sqInt i;
    sqInt limit;
    sqInt remainder;
    sqInt selector;

	limit = (((remainder = (GIV(primTraceLogIndex) - 1) % PrimTraceLogSize)) < 0
		? remainder + PrimTraceLogSize
		: remainder);
	if ((GIV(primTraceLog)[limit]) == 0) {
		return;
	}
	if ((GIV(primTraceLog)[GIV(primTraceLogIndex)]) != 0) {
		limit = PrimTraceLogSize - 1;
	}
	for (i = 0; i <= limit; i += 1) {
		selector = GIV(primTraceLog)[i];
		if (!((selector & 1))) {
			markAndTrace(selector);
		}
	}
}


/*	GC of pages. Throwing away all stack pages on full GC is simple but
	dangerous because it causes us to allocate lots of contexts immediately
	before a GC.
	Reclaiming pages whose top context is not referenced is poor because it
	would take N incrementalGCs to reclaim N unused pages. Only the page whose
	top context is not referred to by the bottom context of any other page
	would be
	reclaimed. Not until the next GC would the page whose top contect is the
	previously reclaimed page's base frame's bottom context be reclaimed.
	
	Better is to not mark stack pages until their contexts are encountered. We
	can eagerly trace the active page and the page reachable from its bottom
	context if any, and so on. Other pages can be marked when we encounter a
	married context. */

static void
markAndTraceStackPages(sqInt fullGCFlag)
{   DECL_MAYBE_SQ_GLOBAL_STRUCT
    sqInt callerContextOrNil;
    sqInt context;
    sqInt i;
    sqInt index;
    sqInt index1;
    void *pointer;
    char *theFP;
    StackPage *thePage;
    StackPage *thePage1;
    sqInt value;

	if (GIV(stackPage) != 0) {
		/* begin externalWriteBackHeadFramePointers */
		assert((GIV(framePointer) - GIV(stackPointer)) < LargeContextSize);
		assert(GIV(stackPage) == (mostRecentlyUsedPage()));
		/* begin setHeadFP:andSP:inPage: */
		assert(GIV(stackPointer) < GIV(framePointer));
		assert((GIV(stackPointer) < ((GIV(stackPage)->baseAddress)))
		 && (GIV(stackPointer) > (((GIV(stackPage)->realStackLimit)) - LargeContextSize)));
		assert((GIV(framePointer) < ((GIV(stackPage)->baseAddress)))
		 && (GIV(framePointer) > (((GIV(stackPage)->realStackLimit)) - (((sqInt) LargeContextSize >> 1)))));
		(GIV(stackPage)->headFP = GIV(framePointer));
		(GIV(stackPage)->headSP = GIV(stackPointer));
		assert(pageListIsWellFormed());
	}
	for (i = 0; i <= (GIV(numStackPages) - 1); i += 1) {
		/* begin stackPageAt: */
		thePage = stackPageAtpages(i, GIV(pages));
		(thePage->trace = 0);
	}
	if (!(fullGCFlag)) {
		for (i = 0; i <= (GIV(numStackPages) - 1); i += 1) {
			/* begin stackPageAt: */
			thePage = stackPageAtpages(i, GIV(pages));
			if (!(isFree(thePage))) {
				(thePage->trace = 2);
				markAndTraceStackPage(thePage);
			}
		}
		return;
	}
	if (GIV(stackPage) == 0) {
		return;
	}
	thePage = GIV(stackPage);
	do {
		(thePage->trace = 2);
		markAndTraceStackPage(thePage);
		/* begin frameCallerContext: */
		theFP = (thePage->baseFP);
		assert(isBaseFrame(theFP));
		/* begin stackPageFor: */
		/* begin stackPageAt: */
		/* begin pageIndexFor: */
		assert((((((char *) theFP)) >= (GIV(stackBasePlus1) - 1)) && ((((char *) theFP)) <= (((char *) GIV(pages))))));
		index1 = pageIndexForstackBasePlus1bytesPerPage(theFP, GIV(stackBasePlus1), GIV(bytesPerPage));
		thePage1 = stackPageAtpages(index1, GIV(pages));
		callerContextOrNil = longAt((thePage1->baseAddress));
		assert(addressCouldBeObj(callerContextOrNil));
		assert((callerContextOrNil == (nilObject()))
		 || (isContext(callerContextOrNil)));
		context = callerContextOrNil;
		if ((((context & 1) == 0)
 && (((((usqInt) (longAt(context))) >> 12) & 31) == ClassMethodContextCompactIndex))
		 && ((((longAt((context + BaseHeaderSize) + (SenderIndex << ShiftForWord))) & 1))
 && ((((longAt((context + BaseHeaderSize) + (SenderIndex << ShiftForWord))) & 1))
 && (!(isWidowedContext(context)))))) {
			/* begin stackPageFor: */
			/* begin frameOfMarriedContext: */
			value = longAt((context + BaseHeaderSize) + (SenderIndex << ShiftForWord));
			/* begin withoutSmallIntegerTags: */
			assert((value & 1));
			pointer = ((char *) (pointerForOop(value - 1)));
			/* begin stackPageAt: */
			/* begin pageIndexFor: */
			assert((((((char *) pointer)) >= (GIV(stackBasePlus1) - 1)) && ((((char *) pointer)) <= (((char *) GIV(pages))))));
			index = pageIndexForstackBasePlus1bytesPerPage(pointer, GIV(stackBasePlus1), GIV(bytesPerPage));
			thePage = stackPageAtpages(index, GIV(pages));
			assert(!(isFree(thePage)));
		}
	} while(((thePage->trace)) == 0);
}

static void
markAndTraceStackPage(StackPage *thePage)
{
    CogBlockMethod *aCogMethod;
    char *callerFP;
    char *frameRcvrOffset;
    CogMethod *homeMethod;
    sqInt oop;
    char *theFP;
    char *theSP;

	assert(!(isFree(thePage)));
	theSP = (thePage->headSP);

	/* Skip the instruction pointer on top of stack of inactive pages. */

	theFP = (thePage->headFP);
	if (!(thePage == GIV(stackPage))) {
		theSP += BytesPerWord;
	}
	while (1) {
		frameRcvrOffset = ((((usqInt)(longAt(theFP + FoxMethod)))) < heapBase
			? theFP + FoxMFReceiver
			: theFP + FoxIFReceiver);
		while (theSP <= frameRcvrOffset) {
			oop = longAt(theSP);
			if (!((oop & 1))) {
				markAndTrace(oop);
			}
			theSP += BytesPerWord;
		}
		if (((((usqInt)(longAt(theFP + FoxMethod)))) < heapBase
			? ((longAt(theFP + FoxMethod)) & MFMethodFlagHasContextFlag) != 0
			: (byteAt((theFP + FoxIFrameFlags) + 2)) != 0)) {
			assert(isContext(frameContext(theFP)));
			markAndTrace(longAt(theFP + FoxThisContext));
		}
		if ((((usqInt)(longAt(theFP + FoxMethod)))) < heapBase) {
			/* begin markAndTraceMachineCodeMethod: */
			/* begin mframeCogMethod: */
			aCogMethod = ((CogBlockMethod *) ((longAt(theFP + FoxMethod)) & MFMethodMask));
			/* begin asCogHomeMethod: */
			homeMethod = (((aCogMethod->cmType)) == CMMethod
				? ((CogMethod *) aCogMethod)
				: cmHomeMethod(aCogMethod));
			markAndTrace((homeMethod->methodObject));
		}
		else {
			markAndTrace(longAt(theFP + FoxMethod));
		}
		if (!(((callerFP = frameCallerFP(theFP))) != 0)) break;
		theSP = (theFP + FoxCallerSavedIP) + BytesPerWord;
		theFP = callerFP;
	}

	/* caller ip is frameCallerContext in a base frame */

	theSP = (1
		? (theFP + FoxCallerSavedIP) + BytesPerWord
		: theFP + FoxCallerSavedIP);
	while (theSP <= ((thePage->baseAddress))) {
		oop = longAt(theSP);
		if (!((oop & 1))) {
			markAndTrace(oop);
		}
		theSP += BytesPerWord;
	}
}


/*	The trace log is a circular buffer of pairs of entries. If there is an
	entry at
	traceLogIndex - 3 \\ TraceBufferSize it has entries. If there is something
	at traceLogIndex it has wrapped. */

static void
markAndTraceTraceLog(void)
{   DECL_MAYBE_SQ_GLOBAL_STRUCT
    sqInt i;
    sqInt limit;
    sqInt oop;
    sqInt remainder;

	limit = (((remainder = (GIV(traceLogIndex) - 3) % TraceBufferSize)) < 0
		? remainder + TraceBufferSize
		: remainder);
	if ((GIV(traceLog)[limit]) == 0) {
		return;
	}
	if ((GIV(traceLog)[GIV(traceLogIndex)]) != 0) {
		limit = TraceBufferSize - 3;
	}
	for (i = 0; i <= limit; i += 3) {
		oop = GIV(traceLog)[i];
		if (!((oop & 1))) {
			markAndTrace(oop);
		}
		oop = GIV(traceLog)[i + 1];
		if (!((oop & 1))) {
			markAndTrace(oop);
		}
	}
}


/*	Mark all objects reachable from the given one.
	Trace from the given object even if it is old.
	Do not trace if it is already marked.
	Mark it only if it is a young object. */
/*	Tracer state variables:
	child		object being examined
	field		next field of child to examine
	parentField	field where child was stored in its referencing object */

void
markAndTrace(sqInt oop)
{   DECL_MAYBE_SQ_GLOBAL_STRUCT
    sqInt action;
    sqInt child;
    sqInt childType;
    sqInt contextSize;
    sqInt contextSize1;
    sqInt field;
    sqInt fmt;
    sqInt fmt1;
    sqInt header;
    sqInt header1;
    sqInt header11;
    sqInt header12;
    sqInt header2;
    sqInt header3;
    sqInt header4;
    sqInt index;
    sqInt index1;
    sqInt lastFieldOffset;
    sqInt lastFieldOffset1;
    sqInt methodHeader;
    sqInt methodHeader1;
    sqInt oop1;
    sqInt parentField;
    void *pointer;
    void *pointer1;
    sqInt sp;
    sqInt sp1;
    sqInt statMarkCountLocal;
    sqInt sz;
    sqInt sz1;
    StackPage *thePage;
    StackPage *thePage1;
    sqInt type;
    sqInt type1;
    sqInt type2;
    sqInt typeBits;
    sqInt value;
    sqInt value1;
    usqInt youngStartLocal;

	assert(addressCouldBeObjWhileForwarding(oop));
	header = longAt(oop);
	if (!((header & MarkBit) == 0)) {
		return;
	}
	header = (header & AllButTypeMask) | HeaderTypeGC;
	if ((((usqInt) oop)) >= (((usqInt) GIV(youngStart)))) {
		header = header | MarkBit;
	}
	longAtput(oop, header);
	parentField = GCTopMarker;
	child = oop;
	/* begin lastPointerOf:recordWeakRoot: */
	header4 = longAt(oop);
	fmt1 = (((usqInt) header4) >> 8) & 15;
	if (fmt1 <= 4) {
		if (fmt1 >= 3) {
			if (fmt1 == 4) {
				if (1) {

					/* And remember as weak root */

					GIV(weakRootCount) += 1;
					assert(GIV(weakRootCount) <= WeakRootTableSize);
					GIV(weakRoots)[GIV(weakRootCount)] = oop;
				}
				lastFieldOffset = (nonWeakFieldsOf(oop)) << ShiftForWord;
				goto l7;
			}
			if (((((usqInt) header4) >> 12) & 31) == ClassMethodContextCompactIndex) {
				/* begin setTraceFlagOnContextsFramesPageIfNeeded: */
				if ((((longAt((oop + BaseHeaderSize) + (SenderIndex << ShiftForWord))) & 1))
				 && (!(isWidowedContext(oop)))) {
					/* begin stackPageFor: */
					/* begin frameOfMarriedContext: */
					value1 = longAt((oop + BaseHeaderSize) + (SenderIndex << ShiftForWord));
					/* begin withoutSmallIntegerTags: */
					assert((value1 & 1));
					pointer1 = ((char *) (pointerForOop(value1 - 1)));
					/* begin stackPageAt: */
					/* begin pageIndexFor: */
					assert((((((char *) pointer1)) >= (GIV(stackBasePlus1) - 1)) && ((((char *) pointer1)) <= (((char *) GIV(pages))))));
					index1 = pageIndexForstackBasePlus1bytesPerPage(pointer1, GIV(stackBasePlus1), GIV(bytesPerPage));
					thePage1 = stackPageAtpages(index1, GIV(pages));
					assert(((((thePage1->trace)) >= 0) && (((thePage1->trace)) <= 2)));
					if (((thePage1->trace)) == 0) {
						(thePage1->trace = 1);
					}
				}
				/* begin fetchStackPointerOf: */
				sp1 = longAt((oop + BaseHeaderSize) + (StackPointerIndex << ShiftForWord));
				if (!((sp1 & 1))) {
					contextSize1 = 0;
					goto l6;
				}
				assert((ReceiverIndex + ((sp1 >> 1))) < (lengthOf(oop)));
				contextSize1 = (sp1 >> 1);
			l6:	/* end fetchStackPointerOf: */;
				assert((ReceiverIndex + contextSize1) < (lengthOfbaseHeaderformat(oop, header4, fmt1)));
				lastFieldOffset = (CtxtTempFrameStart + contextSize1) * BytesPerWord;
				goto l7;
			}
		}
		/* begin sizeBitsOfSafe: */
		header12 = longAt(oop);
		type2 = ((header12 & SizeMask) == 0
			? HeaderTypeSizeAndClass
			: ((header12 & CompactClassMask) == 0
	? HeaderTypeClass
	: HeaderTypeShort));
		sz1 = (type2 == HeaderTypeSizeAndClass
			? (longAt(oop - (BytesPerWord * 2))) & AllButTypeMask
			: header12 & SizeMask);
		lastFieldOffset = sz1 - BaseHeaderSize;
		goto l7;
	}
	if (fmt1 < 12) {
		lastFieldOffset = 0;
		goto l7;
	}
	methodHeader1 = longAt(oop + BaseHeaderSize);
	if (isCogMethodReference(methodHeader1)) {
		assert(((((CogMethod *) methodHeader1)->cmType)) == CMMethod);
		methodHeader1 = (((CogMethod *) methodHeader1)->methodHeader);
	}
	lastFieldOffset = (((((usqInt) methodHeader1) >> 10) & 255) * BytesPerWord) + BaseHeaderSize;
l7:	/* end lastPointerOf:recordWeakRoot: */;
	field = oop + lastFieldOffset;
	action = StartField;
	youngStartLocal = GIV(youngStart);

	/* run the tracer state machine until all objects reachable from oop are marked */

	statMarkCountLocal = GIV(statMarkCount);
	do {
		if (action == StartField) {
			/* begin startField */
			VM_LABEL(0startField);
					while (1) {
				child = longAt(field);
				if (!((child & 1))) break;
				field -= BytesPerWord;
			}
			typeBits = child & TypeMask;
			if (typeBits == 0) {
				longAtput(field, parentField);
				parentField = field;
				action = StartObj;
				goto l1;
			}
			assert(typeBits == 2);
			if ((child & CompactClassMask) != 0) {

				/* object's class is compact; we're done */
				/* restore the header type bits */

				child = child & AllButTypeMask;
				childType = ((child & SizeMask) == 0
					? HeaderTypeSizeAndClass
					: ((child & CompactClassMask) == 0
	? HeaderTypeClass
	: HeaderTypeShort));
				longAtput(field, child | childType);
				action = Upward;
				goto l1;
			}

			/* class word */

			child = longAt(field - BytesPerWord);

			/* clear type bits */

			child = child & AllButTypeMask;
			longAtput(field - BytesPerWord, parentField);

			/* point at class word; mark as working on the class.  */

			parentField = (field - BytesPerWord) | 1;
			action = StartObj;
		l1:	/* end startField */;
		}
		if (action == StartObj) {
			/* begin startObj */
			statMarkCountLocal += 1;
			if (((((usqInt) child)) < (((usqInt) youngStartLocal)))
			 || ((((header1 = longAt(child))) & MarkBit) != 0)) {

				/* already marked; skip it */

				field = child;
				action = Upward;
				goto l2;
			}
			/* begin lastPointerOf:recordWeakRoot: */
			oop1 = child;
			header3 = longAt(oop1);
			fmt = (((usqInt) header3) >> 8) & 15;
			if (fmt <= 4) {
				if (fmt >= 3) {
					if (fmt == 4) {
						if (0) {

							/* And remember as weak root */

							GIV(weakRootCount) += 1;
							assert(GIV(weakRootCount) <= WeakRootTableSize);
							GIV(weakRoots)[GIV(weakRootCount)] = oop1;
						}
						lastFieldOffset1 = (nonWeakFieldsOf(oop1)) << ShiftForWord;
						goto l5;
					}
					if (((((usqInt) header3) >> 12) & 31) == ClassMethodContextCompactIndex) {
						/* begin setTraceFlagOnContextsFramesPageIfNeeded: */
						if ((((longAt((oop1 + BaseHeaderSize) + (SenderIndex << ShiftForWord))) & 1))
						 && (!(isWidowedContext(oop1)))) {
							/* begin stackPageFor: */
							/* begin frameOfMarriedContext: */
							value = longAt((oop1 + BaseHeaderSize) + (SenderIndex << ShiftForWord));
							/* begin withoutSmallIntegerTags: */
							assert((value & 1));
							pointer = ((char *) (pointerForOop(value - 1)));
							/* begin stackPageAt: */
							/* begin pageIndexFor: */
							assert((((((char *) pointer)) >= (GIV(stackBasePlus1) - 1)) && ((((char *) pointer)) <= (((char *) GIV(pages))))));
							index = pageIndexForstackBasePlus1bytesPerPage(pointer, GIV(stackBasePlus1), GIV(bytesPerPage));
							thePage = stackPageAtpages(index, GIV(pages));
							assert(((((thePage->trace)) >= 0) && (((thePage->trace)) <= 2)));
							if (((thePage->trace)) == 0) {
								(thePage->trace = 1);
							}
						}
						/* begin fetchStackPointerOf: */
						sp = longAt((oop1 + BaseHeaderSize) + (StackPointerIndex << ShiftForWord));
						if (!((sp & 1))) {
							contextSize = 0;
							goto l4;
						}
						assert((ReceiverIndex + ((sp >> 1))) < (lengthOf(oop1)));
						contextSize = (sp >> 1);
					l4:	/* end fetchStackPointerOf: */;
						assert((ReceiverIndex + contextSize) < (lengthOfbaseHeaderformat(oop1, header3, fmt)));
						lastFieldOffset1 = (CtxtTempFrameStart + contextSize) * BytesPerWord;
						goto l5;
					}
				}
				/* begin sizeBitsOfSafe: */
				header11 = longAt(oop1);
				type1 = ((header11 & SizeMask) == 0
					? HeaderTypeSizeAndClass
					: ((header11 & CompactClassMask) == 0
	? HeaderTypeClass
	: HeaderTypeShort));
				sz = (type1 == HeaderTypeSizeAndClass
					? (longAt(oop1 - (BytesPerWord * 2))) & AllButTypeMask
					: header11 & SizeMask);
				lastFieldOffset1 = sz - BaseHeaderSize;
				goto l5;
			}
			if (fmt < 12) {
				lastFieldOffset1 = 0;
				goto l5;
			}
			methodHeader = longAt(oop1 + BaseHeaderSize);
			if (isCogMethodReference(methodHeader)) {
				assert(((((CogMethod *) methodHeader)->cmType)) == CMMethod);
				methodHeader = (((CogMethod *) methodHeader)->methodHeader);
			}
			lastFieldOffset1 = (((((usqInt) methodHeader) >> 10) & 255) * BytesPerWord) + BaseHeaderSize;
		l5:	/* end lastPointerOf:recordWeakRoot: */;
			header1 = (header1 & AllButTypeMask) | (MarkBit | HeaderTypeGC);
			longAtput(child, header1);
			field = child + lastFieldOffset1;
			action = StartField;
		l2:	/* end startObj */;
		}
		if (action == Upward) {
			/* begin upward */
			VM_LABEL(0upward);
			do {
				if ((parentField & 1) == 0) {

					/* normal */
					/* who we worked on below */

					child = field;

					/* where to put it */

					field = parentField;
					parentField = longAt(field);
					longAtput(field, child);

					/* point at header */

					field -= BytesPerWord;
					action = StartField;
					goto l3;
				}
				if (parentField == GCTopMarker) {

					/* top of the chain */

					header2 = (longAt(field)) & AllButTypeMask;
					type = ((header2 & SizeMask) == 0
						? HeaderTypeSizeAndClass
						: ((header2 & CompactClassMask) == 0
	? HeaderTypeClass
	: HeaderTypeShort));
					longAtput(field, header2 | type);
					action = Done;
					goto l3;
				}

				/* oop of class */

				child = field;

				/* class word, ** clear the low bit ** */

				field = parentField - 1;
				parentField = longAt(field);

				/* base header word */

				header2 = longAt(field + BytesPerWord);
				type = ((header2 & SizeMask) == 0
					? HeaderTypeSizeAndClass
					: ((header2 & CompactClassMask) == 0
	? HeaderTypeClass
	: HeaderTypeShort));
				longAtput(field, child | type);

				/* point at header */
				/* restore type bits */

				field += BytesPerWord;
				header2 = header2 & AllButTypeMask;
				longAtput(field, header2 | type);
			} while(1);
			action = null;
		l3:	/* end upward */;
		}
	} while(!(action == Done));
	GIV(statMarkCount) = statMarkCountLocal;
}

static void
markCogMethodsAndReferentsOnPage(StackPage *thePage)
{
    char *callerFP;
    char *theFP;

	assert(!(isFree(thePage)));

	/* Skip the instruction pointer on top of stack of inactive pages. */

	theFP = (thePage->headFP);
	while (1) {
		if ((((usqInt)(longAt(theFP + FoxMethod)))) < heapBase) {
			markMethodAndReferents(mframeCogMethod(theFP));
		}
		if (!(((callerFP = frameCallerFP(theFP))) != 0)) break;
		theFP = callerFP;
	}
}


/*	Mark phase of the mark and sweep garbage collector. Set 
	the mark bits of all reachable objects. Free chunks are 
	untouched by this process. */
/*	Assume: All non-free objects are initially unmarked. Root 
	objects were unmarked when they were made roots.
	(Make sure this stays true!!). */

static void
markPhase(sqInt fullGCFlag)
{   DECL_MAYBE_SQ_GLOBAL_STRUCT
    sqInt i;
    sqInt oop;
    sqInt statMarkCountPriorToStackPageFreeing;

	markAndTraceInterpreterOops(fullGCFlag);

	/* trace the roots */

	GIV(statSpecialMarkCount) = GIV(statMarkCount);
	for (i = 1; i <= GIV(rootTableCount); i += 1) {
		oop = GIV(rootTable)[i];
		markAndTrace(oop);
	}
	for (i = 1; i <= GIV(extraRootCount); i += 1) {
		oop = (GIV(extraRoots)[i])[0];
		if (!((oop & 1))) {
			markAndTrace(oop);
		}
	}

	/* Only safe to free stack pages after all roots have been traced. */

	statMarkCountPriorToStackPageFreeing = GIV(statMarkCount);
	markAndTraceAndMaybeFreeStackPages(fullGCFlag);
	/* begin markAndTraceOrFreeMachineCode: */
	markAndTraceObjectsOrFreeMachineCode(fullGCFlag);
	GIV(statSpecialMarkCount) += GIV(statMarkCount) - statMarkCountPriorToStackPageFreeing;
}


/*	<InterpreterStackPage> */
/*	MRUP-->used page<->used page<->used page<->used page<--LRUP
	^ <-next-prev-> ^
	| |
	v <-prev-next-> v
	free page<->free page<->free page<->free page */

static void
markStackPageMostRecentlyUsed(StackPage *page)
{   DECL_MAYBE_SQ_GLOBAL_STRUCT
	if (page == GIV(mostRecentlyUsedPage)) {
		return;
	}
	if (((page->prevPage)) == GIV(mostRecentlyUsedPage)) {
		GIV(mostRecentlyUsedPage) = page;
		assert(pageListIsWellFormed());
		return;
	}
	((page->prevPage)->nextPage = (page->nextPage));
	((page->nextPage)->prevPage = (page->prevPage));
	((GIV(mostRecentlyUsedPage)->nextPage)->prevPage = page);
	(page->prevPage = GIV(mostRecentlyUsedPage));
	(page->nextPage = (GIV(mostRecentlyUsedPage)->nextPage));
	(GIV(mostRecentlyUsedPage)->nextPage = page);
	GIV(mostRecentlyUsedPage) = page;
	assert(pageListIsWellFormed());
}


/*	<InterpreterStackPage> */
/*	This method is used to move a page to a position in the list such that it
	cannot be deallocated when a new page is allocated, without changing the
	most recently
	used page. There must be at least 3 pages in the system. So making the
	page the MRU's prevPage is sufficient to ensure it won't be deallocated. */
/*	MRUP-->used page<->used page<->used page<->used page<--LRUP
	^ <-next-prev-> ^
	| |
	v <-prev-next-> v
	free page<->free page<->free page<->free page */

static void
markStackPageNextMostRecentlyUsed(StackPage *page)
{   DECL_MAYBE_SQ_GLOBAL_STRUCT
	assert(page != GIV(mostRecentlyUsedPage));
	if (((page->nextPage)) == GIV(mostRecentlyUsedPage)) {
		return;
	}
	((page->prevPage)->nextPage = (page->nextPage));
	((page->nextPage)->prevPage = (page->prevPage));
	((GIV(mostRecentlyUsedPage)->prevPage)->nextPage = page);
	(page->prevPage = (GIV(mostRecentlyUsedPage)->prevPage));
	(page->nextPage = GIV(mostRecentlyUsedPage));
	(GIV(mostRecentlyUsedPage)->prevPage = page);
	assert(pageListIsWellFormed());
}


/*	This is a helper for primitiveObjectPointsTo so it *does not* check the
	frameContext field because that is an implicit self-reference not present
	in the stale .
 */

static sqInt
marriedContextpointsTostackDeltaForCurrentFrame(sqInt spouseContext, sqInt anOop, sqInt stackDeltaForCurrentFrame)
{   DECL_MAYBE_SQ_GLOBAL_STRUCT
    sqInt index;
    char *rcvrOffset;
    char *theFP;
    StackPage *thePage;
    char *theSP;
    sqInt value;

	/* begin frameOfMarriedContext: */
	value = longAt((spouseContext + BaseHeaderSize) + (SenderIndex << ShiftForWord));
	/* begin withoutSmallIntegerTags: */
	assert((value & 1));
	theFP = pointerForOop(value - 1);
	if (theFP == GIV(framePointer)) {
		theSP = GIV(stackPointer) + (stackDeltaForCurrentFrame * BytesPerWord);
	}
	else {
		/* begin stackPageFor: */
		/* begin stackPageAt: */
		/* begin pageIndexFor: */
		assert((((((char *) theFP)) >= (GIV(stackBasePlus1) - 1)) && ((((char *) theFP)) <= (((char *) GIV(pages))))));
		index = pageIndexForstackBasePlus1bytesPerPage(theFP, GIV(stackBasePlus1), GIV(bytesPerPage));
		thePage = stackPageAtpages(index, GIV(pages));
		theSP = findSPOfon(theFP, thePage);
	}
	if ((anOop & 1)) {
		if ((anOop == ((((((((usqInt)(longAt(theFP + FoxMethod)))) < heapBase
	? (((usqInt) ((theFP + FoxMFReceiver) - theSP)) >> ShiftForWord) + ((mframeCogMethod(theFP)->cmNumArgs))
	: (((usqInt) ((theFP + FoxIFReceiver) - theSP)) >> ShiftForWord) + (byteAt((theFP + FoxIFrameFlags) + 1)))) << 1) | 1)))
		 || (anOop == (externalInstVarofContext(InstructionPointerIndex, spouseContext)))) {
			return 1;
		}
	}
	else {
		if (anOop == (((((usqInt)(longAt(theFP + FoxMethod)))) < heapBase
	? (mframeHomeMethod(theFP)->methodObject)
	: longAt(theFP + FoxMethod)))) {
			return 1;
		}
		if ((longAt(theFP + FoxSavedFP)) == 0) {
			if (anOop == (frameCallerContext(theFP))) {
				return 1;
			}
		}
		else {
			if ((frameHasContext(frameCallerFP(theFP)))
			 && (anOop == (frameContext(frameCallerFP(theFP))))) {
				return 1;
			}
		}
	}
	rcvrOffset = ((((usqInt)(longAt(theFP + FoxMethod)))) < heapBase
		? theFP + FoxMFReceiver
		: theFP + FoxIFReceiver);
	while (theSP <= rcvrOffset) {
		if (anOop == (longAt(theSP))) {
			return 1;
		}
		theSP += BytesPerWord;
	}
	theSP = (theFP + FoxCallerSavedIP) + BytesPerWord;
	rcvrOffset = theFP + ((FoxCallerSavedIP + BytesPerWord) + ((((((usqInt)(longAt(theFP + FoxMethod)))) < heapBase
	? (mframeCogMethod(theFP)->cmNumArgs)
	: byteAt((theFP + FoxIFrameFlags) + 1))) << ShiftForWord));
	while (theSP <= rcvrOffset) {
		if (anOop == (longAt(theSP))) {
			return 1;
		}
		theSP += BytesPerWord;
	}
	return 0;
}


/*	Marry an unmarried frame. This means creating a spouse context initialized
	with a subset of the frame's state (state through the last argument) that
	references the
	frame. This is important enough for performance to be worth streamlining.
	
	Override to set the ``has context'' flag appropriately for both machine
	code and interpreter frames
	and to streamline the machine code/interpreter differences.. */

static sqInt
marryFrameSP(char *theFP, char *theSP)
{   DECL_MAYBE_SQ_GLOBAL_STRUCT
    sqInt byteSize;
    sqInt closureOrNil;
    CogMethod *cogMethod;
    sqInt frameNumArgs;
    sqInt frameNumArgs1;
    sqInt hash;
    sqInt header1;
    usqInt i;
    sqInt methodFieldOrObj;
    usqInt newChunk;
    usqInt newFreeStart;
    sqInt newObj;
    sqInt numArgs;
    sqInt numStack;
    sqInt rcvr;
    sqInt theContext;
    char *value;
    sqInt valuePointer;
    sqInt valuePointer1;
    sqInt valuePointer2;

	assert(!(frameHasContext(theFP)));
	assert(!(isBaseFrame(theFP)));
	methodFieldOrObj = longAt(theFP + FoxMethod);
	if ((((usqInt)methodFieldOrObj)) < heapBase) {
		longAtput(theFP + FoxMethod, methodFieldOrObj + MFMethodFlagHasContextFlag);
		cogMethod = ((CogMethod *) (methodFieldOrObj & MFMethodMask));
		numArgs = (cogMethod->cmNumArgs);
		if (((cogMethod->cmType)) == CMMethod) {
			closureOrNil = GIV(nilObj);
		}
		else {
			cogMethod = cmHomeMethod(((CogBlockMethod *) cogMethod));
			closureOrNil = longAt(((theFP + FoxCallerSavedIP) + BytesPerWord) + (numArgs << ShiftForWord));
		}
		byteSize = ((((cogMethod->methodHeader)) & LargeContextBit) != 0
			? LargeContextSize
			: SmallContextSize);
		methodFieldOrObj = (cogMethod->methodObject);
		rcvr = longAt(theFP + FoxMFReceiver);
		numStack = (((usqInt) ((theFP + FoxMFReceiver) - theSP)) >> ShiftForWord) + numArgs;
	}
	else {
		byteAtput((theFP + FoxIFrameFlags) + 2, 1);
		numArgs = byteAt((theFP + FoxIFrameFlags) + 1);
		byteSize = (((headerOf(methodFieldOrObj)) & LargeContextBit) != 0
			? LargeContextSize
			: SmallContextSize);
		closureOrNil = ((byteAt((theFP + FoxIFrameFlags) + 3)) != 0
			? longAt(((theFP + FoxCallerSavedIP) + BytesPerWord) + (numArgs << ShiftForWord))
			: GIV(nilObj));
		rcvr = longAt(theFP + FoxIFReceiver);
		numStack = (((usqInt) ((theFP + FoxIFReceiver) - theSP)) >> ShiftForWord) + numArgs;
	}
	/* begin eeInstantiateMethodContextByteSize: */
	VM_LABEL(0eeInstantiateMethodContextByteSize);
	hash = ((usqInt) GIV(freeStart)) >> BytesPerWord;
	header1 = ((hash & HashMaskUnshifted) << HashBitsOffset) | (((ClassMethodContextCompactIndex << 12) + (3 << 8)) + ((CtxtTempFrameStart + (((sqInt) BaseHeaderSize >> 2))) << 2));
	assert(byteSize <= SizeMask);
	assert((header1 & CompactClassMask) > 0);
	header1 += byteSize - (header1 & SizeMask);
	flag("Dan");
	/* begin eeAllocate:headerSize:h1:h2:h3: */
	/* begin allocateInterpreterChunk: */
	newChunk = GIV(freeStart);
	newFreeStart = GIV(freeStart) + (byteSize + ((1 - 1) * BytesPerWord));
	if (newFreeStart < GIV(scavengeThreshold)) {
		if ((AllocationCheckFiller != 0)
		 && ((longAt(newChunk)) != ((AllocationCheckFiller == 182275669
	? newChunk
	: AllocationCheckFiller)))) {
			error("last object overwritten");
		}
		GIV(freeStart) = newFreeStart;
		newObj = oopForPointer(newChunk);
		goto l1;
	}
	if (GIV(freeStart) < GIV(scavengeThreshold)) {
		/* begin scheduleIncrementalGC */
		GIV(needGCFlag) = 1;
		forceInterruptCheck();
	}
	if (newFreeStart < GIV(reserveStart)) {
		GIV(freeStart) = newFreeStart;
		newObj = oopForPointer(newChunk);
		goto l1;
	}
	/* begin scheduleIncrementalGC */
	GIV(needGCFlag) = 1;
	forceInterruptCheck();
	if (GIV(freeStart) <= GIV(endOfMemory)) {
		GIV(freeStart) = newFreeStart;
		newObj = oopForPointer(newChunk);
		goto l1;
	}
	error("out of memory");
	newObj = null;
l1:	/* end allocateInterpreterChunk: */;
	if (newObj == 0) {
		theContext = newObj;
		goto l2;
	}
	if (1 == 3) {
		longAtput(newObj, null | HeaderTypeSizeAndClass);
		longAtput(newObj + BytesPerWord, null | HeaderTypeSizeAndClass);
		longAtput(newObj + (BytesPerWord * 2), header1 | HeaderTypeSizeAndClass);
		newObj += BytesPerWord * 2;
	}
	if (1 == 2) {
		longAtput(newObj, null | HeaderTypeClass);
		longAtput(newObj + BytesPerWord, header1 | HeaderTypeClass);
		newObj += BytesPerWord;
	}
	if (1 == 1) {
		longAtput(newObj, header1 | HeaderTypeShort);
	}
	if (DoExpensiveAssertionChecks) {
		okayOop(newObj);
		oopHasOkayClass(newObj);
		if (!((safeObjectAfter(newObj)) == GIV(freeStart))) {
			error("allocate bug: did not set header of new oop correctly");
		}
	}
	theContext = newObj;
l2:	/* end eeInstantiateMethodContextByteSize: */;
	longAtput(theFP + FoxThisContext, theContext);
	/* begin storePointerUnchecked:ofObject:withValue: */
	/* begin withSmallIntegerTags: */
	assert(((oopForPointer(theFP)) & (BytesPerWord - 1)) == 0);
	valuePointer1 = (oopForPointer(theFP)) + 1;
	longAtput((theContext + BaseHeaderSize) + (SenderIndex << ShiftForWord), valuePointer1);
	/* begin storePointerUnchecked:ofObject:withValue: */
	/* begin withSmallIntegerTags: */
	/* begin frameCallerFP: */
	value = pointerForOop(longAt(theFP + FoxSavedFP));
	assert(((oopForPointer(value)) & (BytesPerWord - 1)) == 0);
	valuePointer2 = (oopForPointer(value)) + 1;
	longAtput((theContext + BaseHeaderSize) + (InstructionPointerIndex << ShiftForWord), valuePointer2);
	longAtput((theContext + BaseHeaderSize) + (StackPointerIndex << ShiftForWord), ((numStack << 1) | 1));
	longAtput((theContext + BaseHeaderSize) + (MethodIndex << ShiftForWord), methodFieldOrObj);
	longAtput((theContext + BaseHeaderSize) + (ClosureIndex << ShiftForWord), closureOrNil);
	longAtput((theContext + BaseHeaderSize) + (ReceiverIndex << ShiftForWord), rcvr);
	for (i = 1; i <= numArgs; i += 1) {
		/* begin storePointerUnchecked:ofObject:withValue: */
		valuePointer = ((((usqInt)(longAt(theFP + FoxMethod)))) < heapBase
			? ((i - 1) < ((frameNumArgs = (mframeCogMethod(theFP)->cmNumArgs)))
	? longAt((theFP + FoxCallerSavedIP) + ((frameNumArgs - (i - 1)) * BytesPerWord))
	: longAt(((theFP + FoxMFReceiver) - BytesPerWord) + ((frameNumArgs - (i - 1)) * BytesPerWord)))
			: ((i - 1) < ((frameNumArgs1 = byteAt((theFP + FoxIFrameFlags) + 1)))
	? longAt((theFP + FoxCallerSavedIP) + ((frameNumArgs1 - (i - 1)) * BytesPerWord))
	: longAt(((theFP + FoxIFReceiver) - BytesPerWord) + ((frameNumArgs1 - (i - 1)) * BytesPerWord))));
		longAtput((theContext + BaseHeaderSize) + ((ReceiverIndex + i) << ShiftForWord), valuePointer);
	}
	for (i = (numArgs + 1); i <= numStack; i += 1) {
		longAtput((theContext + BaseHeaderSize) + ((ReceiverIndex + i) << ShiftForWord), GIV(nilObj));
	}
	assert(frameHasContext(theFP));
	assert((frameOfMarriedContext(theContext)) == theFP);
	assert((numStack + ReceiverIndex) < (lengthOf(theContext)));
	return theContext;
}

static void
maybeFlagMethodAsInterpreted(sqInt aMethod)
{
    sqInt rawHeader;
    sqInt realHeader;

	if (GIV(flagInterpretedMethods)) {
		rawHeader = longAt((aMethod + BaseHeaderSize) + (HeaderIndex << ShiftForWord));
		realHeader = (isCogMethodReference(rawHeader)
			? (((CogMethod *) rawHeader)->methodHeader)
			: rawHeader);
		realHeader = realHeader | ((((1 << HeaderFlagBitPosition) << 1) | 1));
		if (isCogMethodReference(rawHeader)) {
			(((CogMethod *) rawHeader)->methodHeader = realHeader);
		}
		else {
			longAtput((aMethod + BaseHeaderSize) + (0 << ShiftForWord), realHeader);
		}
	}
}


/*	Return one of the objects in the SpecialObjectsArray, if in range,
	otherwise ansser nil
 */

sqInt
maybeSplObj(sqInt index)
{   DECL_MAYBE_SQ_GLOBAL_STRUCT
	return (index < (lengthOf(GIV(specialObjectsOop)))
		? longAt((GIV(specialObjectsOop) + BaseHeaderSize) + (index << ShiftForWord))
		: 0);
}

sqInt
methodArgumentCount(void)
{
	return GIV(argumentCount);
}


/*	Like #stackValue: but access method arguments left-to-right */

sqInt
methodArg(sqInt index)
{   DECL_MAYBE_SQ_GLOBAL_STRUCT
	if ((index > GIV(argumentCount)) + 1) {
		fprintf(stderr,"[VM]: Attempt to access method args beyond range\n");
		printCallStack();
		/* begin primitiveFail */
		if (GIV(primFailCode) == 0) {
			GIV(primFailCode) = 1;
		}
		return 0;
	}
	return longAt(GIV(stackPointer) + ((GIV(argumentCount) - index) * BytesPerWord));
}

void *
methodCacheAddress(void)
{
	return GIV(methodCache);
}

sqInt
methodHasCogMethod(sqInt aMethodOop)
{
	assert(isNonIntegerObject(aMethodOop));
	/* begin isCogMethodReference: */
	VM_LABEL(0isCogMethodReference);
	assert((((longAt((aMethodOop + BaseHeaderSize) + (HeaderIndex << ShiftForWord))) & 1))
	 || (((((usqInt)(longAt((aMethodOop + BaseHeaderSize) + (HeaderIndex << ShiftForWord))))) < (startOfMemory()))
 && ((((usqInt)(longAt((aMethodOop + BaseHeaderSize) + (HeaderIndex << ShiftForWord))))) >= (minCogMethodAddress()))));
	return ((longAt((aMethodOop + BaseHeaderSize) + (HeaderIndex << ShiftForWord))) & 1) == 0;
}

sqInt
methodPrimitiveIndex(void)
{   DECL_MAYBE_SQ_GLOBAL_STRUCT
    sqInt primBits;

	if (!((((GIV(newMethod) & 3) == 0)
 && (((((usqInt)GIV(newMethod))) >= heapBase)
 && (((((usqInt)GIV(newMethod))) < GIV(freeStart))
 && (((longAt(GIV(newMethod))) & TypeMask) != HeaderTypeGC))))
		 && (((((usqInt) (longAt(GIV(newMethod)))) >> 8) & 15) >= 12))) {
		return -1;
	}
	/* begin primitiveIndexOf: */
	primBits = (((usqInt) (headerOf(GIV(newMethod)))) >> 1) & 268435967;
	return (primBits & 511) + (((usqInt) primBits) >> 19);
}


/*	Sets the return value for a method. In the CoInterpreter we replace the
	cumbersome primResult machinery. */

sqInt
methodReturnValue(sqInt oop)
{   DECL_MAYBE_SQ_GLOBAL_STRUCT
    char *sp;

	/* begin pop:thenPush: */
	longAtput(sp = GIV(stackPointer) + (((GIV(argumentCount) + 1) - 1) * BytesPerWord), oop);
	GIV(stackPointer) = sp;
	return 0;
}

sqInt
methodShouldBeCogged(sqInt aMethodObj)
{
	if (methodWithHeaderShouldBeCogged(headerOf(aMethodObj))) {
		return 1;
	}
	maybeFlagMethodAsInterpreted(aMethodObj);
	return 0;
}


/*	At the moment jit any method with less than N literals, where N defaults
	to 60.
	See e.g. SimpleStackBasedCogit class>>initialize.
	In my dev image eem 2/22/2009 13:39
	(30 to: 100 by: 5) collect:
	[:n| n -> (SystemNavigation default allSelect: [:m| m numLiterals > n])
	size] #(30->1681 35->1150 40->765 45->523 50->389 55->289 60->206
	65->151 70->124 75->99 80->73 85->63 90->54 95->42 100->38).
	And running the CogVMSimulator with flagging of interpreted methods turned
	on reveals
	the following sizes of interpreted methods.
	| sizes |
	sizes := Bag new.
	SystemNavigation default allSelect: [:m| m flag ifTrue: [sizes add: m
	numLiterals]. false].
	sizes sortedElements asArray
	#(	40->4 41->1 42->2 44->1 45->3 46->1 47->2 48->1
	50->2 51->1 53->1 55->1 56->1
	87->1 108->1 171->1)
	literalCountOfHeader: does not include the header word. */

static sqInt
methodWithHeaderShouldBeCogged(sqInt methodHeader)
{
	return ((((usqInt) methodHeader) >> 10) & 255) <= maxLiteralCountForCompile;
}

sqInt
methodwithInitialPCHasErrorCode(sqInt methodObj, sqInt initialPC)
{
	return (byteAt((methodObj + BaseHeaderSize) + initialPC)) == 129;
}


/*	Answer the Cog method for a machine code frame. This may be
	either a full CogMethod or merely a CogBlockMethod rump header. */

static CogBlockMethod *
mframeCogMethod(char *theFP)
{
	return ((CogBlockMethod *) ((longAt(theFP + FoxMethod)) & MFMethodMask));
}


/*	Answer the home method for a machine code frame. From a block frame we
	find the home method through the block's homeOffset field which is the
	delta to it.
	In both cases we need to strip the isBlock and isContext flags from the
	method field. */

static CogMethod *
mframeHomeMethod(char *theFP)
{
    sqInt methodField;

	methodField = longAt(theFP + FoxMethod);
	if ((methodField & MFMethodFlagIsBlockFlag) != 0) {
		return cmHomeMethod(((CogBlockMethod *) (methodField & MFMethodMask)));
	}
	return ((CogMethod *) (methodField & MFMethodMask));
}


/*	<Integer> */

static sqInt
mframeIsBlockActivation(char *theFP)
{
	return ((longAt(theFP + FoxMethod)) & MFMethodFlagIsBlockFlag) != 0;
}

static sqInt
mframeReceiver(char *theFP)
{
	return longAt(theFP + FoxMFReceiver);
}


/*	The module with the given name was just unloaded. 
	Make sure we have no dangling references. */

EXPORT(void)
moduleUnloaded(char *aModuleName)
{
	if ((strcmp(aModuleName, "SurfacePlugin")) == 0) {

		/* Surface plugin went away. Should never happen. But  then, who knows */

		showSurfaceFn = 0;
	}
}


/*	Move frames from the hot end of oldPage through to theFP to newPage.
	This has the effect of making theFP a base frame which can be stored into.
	Answer theFP's new location. */

static char *
moveFramesInthroughtoPage(StackPage *oldPage, char *theFP, StackPage *newPage)
{
    char *callerFP;
    sqInt callerIP;
    sqInt delta;
    char *fpInNewPage;
    char *newFP;
    char *newSP;
    char *offsetCallerFP;
    char *source;
    sqInt stackedReceiverOffset;
    sqInt theContext;
    char *theFP1;
    char *theSP;
    sqInt valuePointer;
    sqInt valuePointer1;

	assert(!(isBaseFrame(theFP)));
	assert(validStackPageBaseFrames());
	/* begin frameCallerFP: */
	callerFP = pointerForOop(longAt(theFP + FoxSavedFP));
	assert(frameHasContext(callerFP));
	assert(isContext(frameContext(callerFP)));
	/* begin ensureFrameIsMarried:SP: */
	VM_LABEL(17ensureFrameIsMarriedSP);
	theSP = theFP + (((((usqInt)(longAt(theFP + FoxMethod)))) < heapBase
	? FoxMFReceiver
	: FoxIFReceiver));
	if (((((usqInt)(longAt(theFP + FoxMethod)))) < heapBase
		? ((longAt(theFP + FoxMethod)) & MFMethodFlagHasContextFlag) != 0
		: (byteAt((theFP + FoxIFrameFlags) + 2)) != 0)) {
		assert(isContext(frameContext(theFP)));
		theContext = longAt(theFP + FoxThisContext);
		goto l1;
	}
	theContext = marryFrameSP(theFP, theSP);
l1:	/* end ensureFrameIsMarried:SP: */;
	longAtput(newSP = (newPage->baseAddress), longAt(callerFP + FoxThisContext));
	longAtput(newSP -= BytesPerWord, theContext);

	/* First move the data, leaving room for the caller and base frame contexts.  We will fix up frame pointers later. */

	stackedReceiverOffset = (FoxCallerSavedIP + BytesPerWord) + ((((((usqInt)(longAt(theFP + FoxMethod)))) < heapBase
	? (mframeCogMethod(theFP)->cmNumArgs)
	: byteAt((theFP + FoxIFrameFlags) + 1))) << ShiftForWord);
	for (source = (theFP + stackedReceiverOffset); source >= ((oldPage->headSP)); source += (-BytesPerWord)) {
		newSP -= BytesPerWord;
		longAtput(newSP, longAt(source));
	}
	delta = newSP - ((oldPage->headSP));
	newFP = (((newPage->baseAddress)) - stackedReceiverOffset) - (2 * BytesPerWord);
	/* begin setHeadFP:andSP:inPage: */
	theFP1 = ((oldPage->headFP)) + delta;
	assert(newSP < theFP1);
	assert((newSP < ((newPage->baseAddress)))
	 && (newSP > (((newPage->realStackLimit)) - LargeContextSize)));
	assert((theFP1 < ((newPage->baseAddress)))
	 && (theFP1 > (((newPage->realStackLimit)) - (((sqInt) LargeContextSize >> 1)))));
	(newPage->headFP = theFP1);
	(newPage->headSP = newSP);
	(newPage->baseFP = newFP);
	callerIP = oopForPointer(frameCallerSavedIP(theFP));
	if ((((usqInt)callerIP)) >= heapBase) {
		/* begin iframeSavedIP:put: */
		assert(!(isMachineCodeFrame(callerFP)));
		longAtput(callerFP + FoxIFSavedIP, callerIP);
		callerIP = ceReturnToInterpreterPC();
	}
	longAtput(theFP + stackedReceiverOffset, callerIP);
	(oldPage->headFP = callerFP);
	(oldPage->headSP = theFP + stackedReceiverOffset);
	longAtput(newFP + FoxCallerSavedIP, ceBaseFrameReturnPC());
	longAtput(newFP + FoxSavedFP, 0);
	fpInNewPage = (newPage->headFP);
	do {
		/* begin frameCallerFP: */
		offsetCallerFP = pointerForOop(longAt(fpInNewPage + FoxSavedFP));
		if (offsetCallerFP != 0) {
			offsetCallerFP += delta;
		}
		longAtput(fpInNewPage + FoxSavedFP, oopForPointer(offsetCallerFP));
		if (((((usqInt)(longAt(fpInNewPage + FoxMethod)))) < heapBase
			? ((longAt(fpInNewPage + FoxMethod)) & MFMethodFlagHasContextFlag) != 0
			: (byteAt((fpInNewPage + FoxIFrameFlags) + 2)) != 0)) {
			theContext = longAt(fpInNewPage + FoxThisContext);
			/* begin storePointerUnchecked:ofObject:withValue: */
			/* begin withSmallIntegerTags: */
			assert(((oopForPointer(fpInNewPage)) & (BytesPerWord - 1)) == 0);
			valuePointer = (oopForPointer(fpInNewPage)) + 1;
			longAtput((theContext + BaseHeaderSize) + (SenderIndex << ShiftForWord), valuePointer);
			/* begin storePointerUnchecked:ofObject:withValue: */
			/* begin withSmallIntegerTags: */
			assert(((oopForPointer(offsetCallerFP)) & (BytesPerWord - 1)) == 0);
			valuePointer1 = (oopForPointer(offsetCallerFP)) + 1;
			longAtput((theContext + BaseHeaderSize) + (InstructionPointerIndex << ShiftForWord), valuePointer1);
		}
		fpInNewPage = offsetCallerFP;
	} while(fpInNewPage != 0);
	assert(validStackPageBaseFrames());
	return newFP;
}


/*	Map the native pc theIP into a bytecode pc integer object and answer it.
	See contextInstructionPointer:frame: for the explanation. */

static sqInt
mustMapMachineCodePCcontext(sqInt theIP, sqInt aOnceMarriedContext)
{   DECL_MAYBE_SQ_GLOBAL_STRUCT
    sqInt bcpc;
    CogMethod *cogMethod;
    CogBlockMethod *cogMethodForIP;
    sqInt contextSize;
    sqInt fmt;
    sqInt header;
    sqInt maybeClosure;
    sqInt mcpc;
    sqInt methodHeader;
    sqInt methodHeader1;
    sqInt methodObj;
    sqInt sp;
    sqInt startBcpc;

	if (theIP == (((sqInt) HasBeenReturnedFromMCPC))) {
		return GIV(nilObj);
	}
	maybeClosure = longAt((aOnceMarriedContext + BaseHeaderSize) + (ClosureIndex << ShiftForWord));
	methodObj = longAt((aOnceMarriedContext + BaseHeaderSize) + (MethodIndex << ShiftForWord));
	if (maybeClosure != GIV(nilObj)) {
		assert((((signed)theIP >> 16)) < -1);
		startBcpc = (((longAt((maybeClosure + BaseHeaderSize) + (ClosureStartPCIndex << ShiftForWord))) >> 1)) - 1;
	}
	else {
		assert((((signed)theIP >> 16)) == -1);
		/* begin lastPointerOf: */
		header = longAt(methodObj);
		fmt = (((usqInt) header) >> 8) & 15;
		if (fmt <= 4) {
			if ((fmt == 3)
			 && (((((usqInt) header) >> 12) & 31) == ClassMethodContextCompactIndex)) {
				/* begin fetchStackPointerOf: */
				sp = longAt((methodObj + BaseHeaderSize) + (StackPointerIndex << ShiftForWord));
				if (!((sp & 1))) {
					contextSize = 0;
					goto l1;
				}
				assert((ReceiverIndex + ((sp >> 1))) < (lengthOf(methodObj)));
				contextSize = (sp >> 1);
			l1:	/* end fetchStackPointerOf: */;
				startBcpc = (CtxtTempFrameStart + contextSize) * BytesPerWord;
				goto l2;
			}
			startBcpc = (sizeBitsOfSafe(methodObj)) - BaseHeaderSize;
			goto l2;
		}
		if (fmt < 12) {
			startBcpc = 0;
			goto l2;
		}
		methodHeader = longAt(methodObj + BaseHeaderSize);
		if (isCogMethodReference(methodHeader)) {
			assert(((((CogMethod *) methodHeader)->cmType)) == CMMethod);
			methodHeader = (((CogMethod *) methodHeader)->methodHeader);
		}
		startBcpc = (((((usqInt) methodHeader) >> 10) & 255) * BytesPerWord) + BaseHeaderSize;
	l2:	/* end lastPointerOf: */;
	}
	/* begin ensureMethodIsCogged: */
	if (!(methodHasCogMethod(methodObj))) {
		if (((cogselector(methodObj, GIV(nilObj))) == null)
		 && (GIV(cogCompiledCodeCompactionCalledFor))) {
			commenceCogCompiledCodeCompaction();
			cogselector(methodObj, GIV(nilObj));
		}
	}
	if (!(asserta(methodHasCogMethod(methodObj)))) {
		error("could not compile method that should have been compiled");
	}
	/* begin bytecodePCFor:cogMethod:startBcpc: */
	VM_LABEL(0bytecodePCForcogMethodstartBcpc);
	/* begin cogMethodOf: */
	methodHeader1 = longAt((methodObj + BaseHeaderSize) + (HeaderIndex << ShiftForWord));
	assert((isNonIntegerObject(methodHeader1))
	 && ((((usqInt)methodHeader1)) < (startOfMemory())));
	cogMethod = ((CogMethod *) methodHeader1);
	assert(theIP < 0);
	if ((((signed)theIP >> 16)) < -1) {

		/* See contextInstructionPointer:frame: */

		cogMethodForIP = ((CogBlockMethod *) ((((sqInt)cogMethod)) - ((((signed)theIP >> 16)) * (sizeof(CogBlockMethod)))));
		assert(((cogMethodForIP->cmType)) == CMBlock);
		assert((cmHomeMethod(cogMethodForIP)) == cogMethod);
		mcpc = (((sqInt)cogMethodForIP)) - (((short)theIP));
	}
	else {
		cogMethodForIP = ((CogBlockMethod *) cogMethod);
		assert(((cogMethodForIP->cmType)) == CMMethod);
		mcpc = (((sqInt)cogMethod)) - theIP;
	}
	assert(((mcpc >= (((sqInt)cogMethod))) && (mcpc <= ((((sqInt)cogMethod)) + ((cogMethod->blockSize))))));
	bcpc = bytecodePCForstartBcpcin(mcpc, startBcpc, cogMethodForIP);
	assert(bcpc >= (startPCOfMethod(methodObj)));
	return (((bcpc + 1) << 1) | 1);
}


/*	Brain-damaged nameOfClass: for C VM. Does *not* answer Foo class for
	metaclasses. Use e.g. classIsMeta: to avoid being fooled. */

static char *
nameOfClass(sqInt classOop)
{   DECL_MAYBE_SQ_GLOBAL_STRUCT
	if ((sizeBitsOf(classOop)) == GIV(metaclassSizeBytes)) {
		return nameOfClass(longAt((classOop + BaseHeaderSize) + (GIV(thisClassIndex) << ShiftForWord)));
	}
	/* begin firstFixedField: */
	return ((void *) (pointerForOop((longAt((classOop + BaseHeaderSize) + (GIV(classNameIndex) << ShiftForWord))) + BaseHeaderSize)));
}

usqInt
newMethodAddress(void)
{
	return ((usqInt)((&GIV(newMethod))));
}


/*	MRUP-->used page<->used page<->used page<->used page<--LRUP
	^ <-next-prev-> ^
	| |
	v <-prev-next-> v
	free page<->free page<->free page<->free page */

static StackPage *
newStackPage(void)
{
    StackPage *lruOrFree;

	lruOrFree = (mostRecentlyUsedPage()->nextPage);
	if (isFree(lruOrFree)) {
		return lruOrFree;
	}
	divorceFramesIn(lruOrFree);
	return lruOrFree;
}


/*	N.B. nextProfileTick is 64-bits */

usqInt
nextProfileTickAddress(void)
{
	return ((usqInt)((&GIV(nextProfileTick))));
}


/*	For access from BitBlt module & Cogit */

sqInt
nilObject(void)
{
	return GIV(nilObj);
}


/*	This code is called if the receiver responds primitively to at:Put:.
	The cogit can implement at: & at:put: quickly in machine code, and needs a
	backup that provides error codes. But it does not want the at cache so it
	does not have to
	waste time assigning messageSelector and lkupClass. */

static void
noAtCacheCommonAtPut(sqInt stringy)
{   DECL_MAYBE_SQ_GLOBAL_STRUCT
    sqInt index;
    sqInt rcvr;
    char *sp;
    sqInt value;

	value = longAt(GIV(stackPointer));
	/* begin initPrimCall */
	GIV(primFailCode) = 0;
	rcvr = longAt(GIV(stackPointer) + (2 * BytesPerWord));
	if (!((rcvr & 1) == 0)) {
		GIV(primFailCode) = PrimErrInappropriate; return;
	}

	/* No need to test for large positive integers here.  No object has 1g elements */

	index = longAt(GIV(stackPointer) + (1 * BytesPerWord));
	if (!((index & 1))) {
		GIV(primFailCode) = PrimErrBadArgument; return;
	}
	index = (index >> 1);
	if (stringy) {
		stObjectatput(rcvr, index, asciiOfCharacter(value));
	}
	else {
		stObjectatput(rcvr, index, value);
	}
	if (GIV(primFailCode) == 0) {
		/* begin pop:thenPush: */
		longAtput(sp = GIV(stackPointer) + (((GIV(argumentCount) + 1) - 1) * BytesPerWord), value);
		GIV(stackPointer) = sp;
		return;
	}
}


/*	This code is called if the receiver responds primitively to at:.
	The cogit can implement at: & at:put: quickly in machine code, and needs a
	backup that provides error codes. But it does not want the at cache so it
	does not have to
	waste time assigning messageSelector and lkupClass. */

static void
noAtCacheCommonAt(sqInt stringy)
{   DECL_MAYBE_SQ_GLOBAL_STRUCT
    sqInt index;
    sqInt rcvr;
    sqInt result;
    char *sp;

	/* begin initPrimCall */
	GIV(primFailCode) = 0;
	rcvr = longAt(GIV(stackPointer) + (1 * BytesPerWord));
	if (!((rcvr & 1) == 0)) {
		GIV(primFailCode) = PrimErrInappropriate; return;
	}

	/* No need to test for large positive integers here.  No object has 1g elements */

	index = longAt(GIV(stackPointer));
	if (!((index & 1))) {
		GIV(primFailCode) = PrimErrBadArgument; return;
	}
	index = (index >> 1);
	result = stObjectat(rcvr, index);
	if (GIV(primFailCode) == 0) {
		if (stringy) {
			result = longAt(((longAt((GIV(specialObjectsOop) + BaseHeaderSize) + (CharacterTable << ShiftForWord))) + BaseHeaderSize) + (((result >> 1)) << ShiftForWord));
		}
		/* begin pop:thenPush: */
		longAtput(sp = GIV(stackPointer) + (((GIV(argumentCount) + 1) - 1) * BytesPerWord), result);
		GIV(stackPointer) = sp;
		return;
	}
}


/*	Answer true if there are no marked contexts on thePage. */

static sqInt
noMarkedContextsOnPage(StackPage *thePage)
{
    char *theFP;

	assert(!(isFree(thePage)));
	theFP = (thePage->headFP);
	do {
		if (((((usqInt)(longAt(theFP + FoxMethod)))) < heapBase
			? ((longAt(theFP + FoxMethod)) & MFMethodFlagHasContextFlag) != 0
			: (byteAt((theFP + FoxIFrameFlags) + 2)) != 0)) {
			assert(isContext(frameContext(theFP)));
			if (((longAt(longAt(theFP + FoxThisContext))) & MarkBit) != 0) {
				return 0;
			}
		}
	} while(((theFP = frameCallerFP(theFP))) != 0);
	return 1;
}


/*	Return the number of non-weak fields in oop (i.e. the number of fixed
	fields). Note: The following is copied from fixedFieldsOf:format:length:
	since we do know
	the format of the oop (e.g. format = 4) and thus don't need the length.
 */

static sqInt
nonWeakFieldsOf(sqInt oop)
{
    sqInt ccIndex;
    sqInt class;
    sqInt classFormat;

	assert(isWeakNonInt(oop));
	/* begin fetchClassOfNonInt: */
	if (((ccIndex = (((usqInt) (longAt(oop))) >> 12) & 31)) == 0) {
		class = (longAt(oop - BaseHeaderSize)) & AllButTypeMask;
		goto l1;
	}
	else {
		class = longAt(((longAt((GIV(specialObjectsOop) + BaseHeaderSize) + (CompactClasses << ShiftForWord))) + BaseHeaderSize) + ((ccIndex - 1) << ShiftForWord));
		goto l1;
	}
l1:	/* end fetchClassOfNonInt: */;
	classFormat = (longAt((class + BaseHeaderSize) + (InstanceSpecificationIndex << ShiftForWord))) - 1;
	return (((((usqInt) classFormat) >> 11) & 192) + ((((usqInt) classFormat) >> 2) & 63)) - 1;
}

sqInt
nullHeaderForMachineCodeMethod(void)
{
	return (1 << 12) + HeaderTypeShort;
}


/*	Return the object or free chunk immediately following the 
	given object or free chunk in memory. Return endOfMemory 
	when enumeration is complete. */

sqInt
objectAfter(sqInt oop)
{
    sqInt header;
    sqInt sz;

	if (DoAssertionChecks) {
		if ((((usqInt) oop)) >= (((usqInt) GIV(endOfMemory)))) {
			error("no objects after the end of memory");
		}
	}
	if (((longAt(oop)) & TypeMask) == HeaderTypeFree) {
		sz = (longAt(oop)) & AllButTypeMask;
	}
	else {
		/* begin sizeBitsOf: */
		header = longAt(oop);
		sz = ((header & TypeMask) == HeaderTypeSizeAndClass
			? (longAt(oop - (BytesPerWord * 2))) & LongSizeMask
			: header & SizeMask);
	}
	return (oop + sz) + (headerTypeBytes[(longAt(oop + sz)) & TypeMask]);
}


/*	Like #stackObjectValue: but access method arguments left-to-right */

sqInt
objectArg(sqInt index)
{   DECL_MAYBE_SQ_GLOBAL_STRUCT
    sqInt oop;

	oop = methodArg(index);
	if (oop == 0) {
		return 0.0;
	}
	if ((oop & 1)) {
		/* begin primitiveFail */
		if (GIV(primFailCode) == 0) {
			GIV(primFailCode) = 1;
		}
		return null;
	}
	return oop;
}


/*	Return the object or start of free space immediately preceeding the given
	address, object or free chunk in memory. If none, return 0. This is for
	debugging only. */

sqInt
objectBefore(sqInt address)
{   DECL_MAYBE_SQ_GLOBAL_STRUCT
    sqInt chunk;
    sqInt header;
    sqInt nextObj;
    sqInt obj;
    sqInt sz;

	/* begin oopFromChunk: */
	chunk = ((((usqInt) address)) > (((usqInt) GIV(youngStart)))
		? GIV(youngStart)
		: heapBase);
	obj = chunk + (headerTypeBytes[(longAt(chunk)) & TypeMask]);
	while ((((usqInt) obj)) < (((usqInt) address))) {
		if (((longAt(obj)) & TypeMask) == HeaderTypeFree) {
			sz = (longAt(obj)) & AllButTypeMask;
		}
		else {
			/* begin sizeBitsOf: */
			header = longAt(obj);
			sz = ((header & TypeMask) == HeaderTypeSizeAndClass
				? (longAt(obj - (BytesPerWord * 2))) & LongSizeMask
				: header & SizeMask);
		}
		nextObj = (obj + sz) + (headerTypeBytes[(longAt(obj + sz)) & TypeMask]);
		if ((((usqInt) nextObj)) >= (((usqInt) address))) {
			return obj;
		}
		obj = nextObj;
	}
	return 0;
}


/*	Return the object or start of free space immediately preceeding the given
	object or free chunk in memory. If none, return 0. This is for debugging
	only.  */

sqInt
objectExactlyBefore(sqInt oop)
{   DECL_MAYBE_SQ_GLOBAL_STRUCT
    sqInt chunk;
    sqInt header;
    sqInt nextObj;
    sqInt obj;
    sqInt sz;

	/* begin oopFromChunk: */
	chunk = ((((usqInt) oop)) > (((usqInt) GIV(youngStart)))
		? GIV(youngStart)
		: heapBase);
	obj = chunk + (headerTypeBytes[(longAt(chunk)) & TypeMask]);
	while ((((usqInt) obj)) < (((usqInt) obj))) {
		if (((longAt(obj)) & TypeMask) == HeaderTypeFree) {
			sz = (longAt(obj)) & AllButTypeMask;
		}
		else {
			/* begin sizeBitsOf: */
			header = longAt(obj);
			sz = ((header & TypeMask) == HeaderTypeSizeAndClass
				? (longAt(obj - (BytesPerWord * 2))) & LongSizeMask
				: header & SizeMask);
		}
		nextObj = (obj + sz) + (headerTypeBytes[(longAt(obj + sz)) & TypeMask]);
		if (nextObj == oop) {
			return obj;
		}
		obj = nextObj;
	}
	return 0;
}

sqInt
objectIsOld(sqInt anObject)
{
    sqInt otherOop;

	/* begin oop:isLessThan: */
	otherOop = youngStart();
	return (((usqInt) anObject)) < (((usqInt) otherOop));
}


/*	This message is deprecated but supported for a while via a tweak to
	sqVirtualMachine.[ch] Use fetchLong32, fetchLong64 or fetchPointer instead
	for new code
 */

sqInt
obsoleteDontUseThisFetchWordofObject(sqInt fieldIndex, sqInt oop)
{
	return long32At((oop + BaseHeaderSize) + (fieldIndex << 2));
}


/*	Check if the argument is an ok object.
	If this is a pointers object, check that its fields are all okay oops. */

static sqInt
okayFields(sqInt oop)
{
    sqInt fieldOop;
    sqInt i;

	if ((oop == null)
	 || (oop == 0)) {
		return 1;
	}
	if ((oop & 1)) {
		return 1;
	}
	if (!(okayOop(oop))) {
		return 0;
	}
	if (!(oopHasOkayClass(oop))) {
		return 0;
	}
	if (!((((oop & 1) == 0)
 && (((((usqInt) (longAt(oop))) >> 8) & 15) <= 4))
		 || (((((usqInt) (longAt(oop))) >> 8) & 15) >= 12))) {
		return 1;
	}
	if (((((usqInt) (longAt(oop))) >> 8) & 15) >= 12) {
		i = (literalCountOf(oop)) - 1;
	}
	else {
		if (((oop & 1) == 0)
		 && (((((usqInt) (longAt(oop))) >> 12) & 31) == ClassMethodContextCompactIndex)) {
			i = (CtxtTempFrameStart + (fetchStackPointerOf(oop))) - 1;
		}
		else {
			i = (lengthOf(oop)) - 1;
		}
	}
	while (i >= 0) {
		fieldOop = longAt((oop + BaseHeaderSize) + (i << ShiftForWord));
		if (!((fieldOop & 1))) {
			if (!(okayOop(fieldOop))) {
				return 0;
			}
			if (!(oopHasOkayClass(fieldOop))) {
				return 0;
			}
		}
		i -= 1;
	}
	return 1;
}


/*	Verify that the given oop is legitimate. Check address, header, and size
	but not class.
 */

static sqInt
okayOop(sqInt signedOop)
{   DECL_MAYBE_SQ_GLOBAL_STRUCT
    sqInt fmt;
    sqInt header;
    usqInt oop;
    sqInt sz;
    sqInt type;
    sqInt unusedBit;


	/* address and size checks */

	oop = ((usqInt) signedOop);
	if ((oop & 1)) {
		return 1;
	}
	if (!(oop < GIV(freeStart))) {
		error("oop is not a valid address");
		return 0;
	}
	if (!((oop % BytesPerWord) == 0)) {
		error("oop is not a word-aligned address");
		return 0;
	}
	/* begin sizeBitsOf: */
	header = longAt(oop);
	sz = ((header & TypeMask) == HeaderTypeSizeAndClass
		? (longAt(oop - (BytesPerWord * 2))) & LongSizeMask
		: header & SizeMask);
	if (!((oop + sz) < GIV(endOfMemory))) {
		error("oop size would make it extend beyond the end of memory");
		return 0;
	}
	type = (longAt(oop)) & TypeMask;
	if (type == HeaderTypeFree) {
		error("oop is a free chunk, not an object");
		return 0;
	}
	if (type == HeaderTypeShort) {
		if (((((usqInt) (longAt(oop))) >> 12) & 31) == 0) {
			error("cannot have zero compact class field in a short header");
			return 0;
		}
	}
	if (type == HeaderTypeClass) {
		if (!((oop >= BytesPerWord)
			 && (((longAt(oop - BytesPerWord)) & TypeMask) == type))) {
			error("class header word has wrong type");
			return 0;
		}
	}
	if (type == HeaderTypeSizeAndClass) {
		if (!((oop >= (BytesPerWord * 2))
			 && ((((longAt(oop - (BytesPerWord * 2))) & TypeMask) == type)
 && (((longAt(oop - BytesPerWord)) & TypeMask) == type)))) {
			error("class header word has wrong type");
			return 0;
		}
	}
	fmt = (((usqInt) (longAt(oop))) >> 8) & 15;
	if ((fmt == 5) || (fmt == 7)) {
		error("oop has an unknown format type");
		return 0;
	}
	unusedBit = 536870912;
	if (BytesPerWord == 8) {
		unusedBit = unusedBit << 16;
		unusedBit = unusedBit << 16;
	}
	if (!(((longAt(oop)) & unusedBit) == 0)) {
		error("unused header bit 30 is set; should be zero");
		return 0;
	}
	if ((((longAt(oop)) & RootBit) == 1)
	 && (oop >= GIV(youngStart))) {
		error("root bit is set in a young object");
		return 0;
	}
	return 1;
}


/*	Compute the oop of this chunk by adding its extra header bytes. */

sqInt
oopFromChunk(sqInt chunk)
{
	return chunk + (headerTypeBytes[(longAt(chunk)) & TypeMask]);
}


/*	Similar to oopHasOkayClass:, except that it only returns true or false. */

static sqInt
oopHasAcceptableClass(sqInt signedOop)
{   DECL_MAYBE_SQ_GLOBAL_STRUCT
    sqInt behaviorFormatBits;
    sqInt formatMask;
    usqInt oop;
    usqInt oopClass;
    sqInt oopFormatBits;

	if ((signedOop & 1)) {
		return 1;
	}
	oop = ((usqInt) signedOop);
	if (!(oop < GIV(freeStart))) {
		return 0;
	}
	if (!((oop % BytesPerWord) == 0)) {
		return 0;
	}
	if (!((oop + (sizeBitsOf(oop))) <= GIV(freeStart))) {
		return 0;
	}
	oopClass = ((usqInt) (fetchClassOfNonInt(oop)));
	if ((oopClass & 1)) {
		return 0;
	}
	if (!(oopClass < GIV(freeStart))) {
		return 0;
	}
	if (!((oopClass % BytesPerWord) == 0)) {
		return 0;
	}
	if (!((oopClass + (sizeBitsOf(oopClass))) <= GIV(freeStart))) {
		return 0;
	}
	if (!((((((usqInt) (longAt(oopClass))) >> 8) & 15) <= 4)
		 && ((lengthOf(oopClass)) >= 3))) {
		return 0;
	}
	formatMask = (((((usqInt) (longAt(oop))) >> 8) & 15) >= 8
		? 3072
		: 3840);
	behaviorFormatBits = ((longAt((oopClass + BaseHeaderSize) + (InstanceSpecificationIndex << ShiftForWord))) - 1) & formatMask;
	oopFormatBits = (longAt(oop)) & formatMask;
	if (!(behaviorFormatBits == oopFormatBits)) {
		return 0;
	}
	return 1;
}


/*	Attempt to verify that the given oop has a reasonable behavior. The class
	must be a valid, non-integer oop and must not be nilObj. It must be a
	pointers object with three or more fields. Finally, the instance
	specification field of the behavior must match that of the instance.
 */

static sqInt
oopHasOkayClass(sqInt signedOop)
{
    sqInt behaviorFormatBits;
    sqInt formatMask;
    usqInt oop;
    usqInt oopClass;
    sqInt oopFormatBits;

	oop = ((usqInt) signedOop);
	okayOop(oop);
	oopClass = ((usqInt) (fetchClassOf(oop)));
	if ((oopClass & 1)) {
		error("a SmallInteger is not a valid class or behavior");
		return 0;
	}
	if (!(okayOop(oopClass))) {
		error("class oop is not ok");
		return 0;
	}
	if (!((((oopClass & 1) == 0)
 && (((((usqInt) (longAt(oopClass))) >> 8) & 15) <= 4))
		 && ((lengthOf(oopClass)) >= 3))) {
		error("a class (behavior) must be a pointers object of size >= 3");
		return 0;
	}
	if (((oop & 1) == 0)
	 && (((((usqInt) (longAt(oop))) >> 8) & 15) >= 8)) {

		/* ignore extra bytes size bits */

		formatMask = 3072;
	}
	else {
		formatMask = 3840;
	}
	behaviorFormatBits = ((longAt((oopClass + BaseHeaderSize) + (InstanceSpecificationIndex << ShiftForWord))) - 1) & formatMask;
	oopFormatBits = (longAt(oop)) & formatMask;
	if (!(behaviorFormatBits == oopFormatBits)) {
		error("object and its class (behavior) formats differ");
		return 0;
	}
	return 1;
}


/*	Compare two oop values, treating them as object memory locations.
	Use #cCoerce:to: to ensure comparison of unsigned magnitudes. This
	method will be inlined during C translation. */

static sqInt
oopisGreaterThanOrEqualTo(sqInt anOop, sqInt otherOop)
{
	return (((usqInt) anOop)) >= (((usqInt) otherOop));
}


/*	Compare two oop values, treating them as object memory locations.
	Use #cCoerce:to: to ensure comparison of unsigned magnitudes. This
	method will be inlined during C translation. */

static sqInt
oopisGreaterThanandLessThan(sqInt anOop, sqInt baseOop, sqInt limitOop)
{
	return ((((usqInt) anOop)) > (((usqInt) baseOop)))
	 && ((((usqInt) anOop)) < (((usqInt) limitOop)));
}


/*	Compare two oop values, treating them as object memory locations.
	Use #cCoerce:to: to ensure comparison of unsigned magnitudes. This
	method will be inlined during C translation. */

static sqInt
oopisLessThan(sqInt anOop, sqInt otherOop)
{
	return (((usqInt) anOop)) < (((usqInt) otherOop));
}


/*	<Integer> */
/*	Answer the page index for a pointer into stack memory, i.e. the index
	for the page the address is in. N.B. This is a zero-relative index. */

static sqInt
pageIndexFor(void *pointer)
{   DECL_MAYBE_SQ_GLOBAL_STRUCT
	assert((((((char *) pointer)) >= (GIV(stackBasePlus1) - 1)) && ((((char *) pointer)) <= (((char *) GIV(pages))))));
	return pageIndexForstackBasePlus1bytesPerPage(pointer, GIV(stackBasePlus1), GIV(bytesPerPage));
}


/*	Answer if the stack page list is well-formed.
	MRUP-->used page<->used page<->used page<->used page<--LRUP
	^ <-next-prev-> ^
	| |
	v <-prev-next-> v
	free page<->free page<->free page<->free page */

static sqInt
pageListIsWellFormed(void)
{   DECL_MAYBE_SQ_GLOBAL_STRUCT
    sqInt count;
    sqInt limit;
    sqInt ok;
    StackPage *page;

	ok = 1;
	page = (GIV(mostRecentlyUsedPage)->nextPage);
	count = 1;
	limit = GIV(numStackPages) * 2;
	while ((((page->baseFP)) == 0)
 && ((page != GIV(mostRecentlyUsedPage))
 && (count <= limit))) {
		if (!(asserta((((page->nextPage)->prevPage)) == page))) {
			ok = 0;
		}
		page = (page->nextPage);
		count += 1;
	}
	while ((page != GIV(mostRecentlyUsedPage))
 && (count <= limit)) {
		if (!(asserta((((page->nextPage)->prevPage)) == page))) {
			ok = 0;
		}
		if (asserta(!(((page->baseFP)) == 0))) {
			if (!(asserta((stackPageFor((page->baseFP))) == page))) {
				ok = 0;
			}
			if (!(asserta((stackPageFor((page->headSP))) == page))) {
				ok = 0;
			}
		}
		else {
			ok = 0;
		}
		page = (page->nextPage);
		count += 1;
	}
	if (!(asserta(count == GIV(numStackPages)))) {
		ok = 0;
	}
	return ok;
}


/*	Pop and return the possibly remapped object from the remap buffer. */

sqInt
popRemappableOop(void)
{   DECL_MAYBE_SQ_GLOBAL_STRUCT
    sqInt oop;

	oop = GIV(remapBuffer)[GIV(remapBufferCount)];
	GIV(remapBufferCount) -= 1;
	return oop;
}


/*	In the StackInterpreter stacks grow down. */

sqInt
popStack(void)
{   DECL_MAYBE_SQ_GLOBAL_STRUCT
    sqInt top;

	top = longAt(GIV(stackPointer));
	GIV(stackPointer) += BytesPerWord;
	return top;
}


/*	In the StackInterpreter stacks grow down. */

sqInt
pop(sqInt nItems)
{   DECL_MAYBE_SQ_GLOBAL_STRUCT
	GIV(stackPointer) += nItems * BytesPerWord;
	return null;
}


/*	In the StackInterpreter stacks grow down. */

void
popthenPush(sqInt nItems, sqInt oop)
{   DECL_MAYBE_SQ_GLOBAL_STRUCT
    char *sp;

	longAtput(sp = GIV(stackPointer) + ((nItems - 1) * BytesPerWord), oop);
	GIV(stackPointer) = sp;
}


/*	Note - integerValue is interpreted as POSITIVE, eg, as the result of
	Bitmap>at:, or integer>bitAnd:. */

sqInt
positive32BitIntegerFor(sqInt integerValue)
{   DECL_MAYBE_SQ_GLOBAL_STRUCT
    sqInt newLargeInteger;

	if (integerValue >= 0) {
		if ((integerValue ^ (integerValue << 1)) >= 0) {
			return ((integerValue << 1) | 1);
		}
	}
	
#  if BytesPerWord == 4

	/* Faster instantiateSmallClass: currently only works with integral word size. */

	newLargeInteger = eeInstantiateSmallClasssizeInBytes(longAt((GIV(specialObjectsOop) + BaseHeaderSize) + (ClassLargePositiveInteger << ShiftForWord)), BaseHeaderSize + 4);

#  else /* BytesPerWord == 4 */

	/* Cant use instantiateSmallClass: due to integral word requirement. */

	newLargeInteger = eeInstantiateClassindexableSize(longAt((GIV(specialObjectsOop) + BaseHeaderSize) + (ClassLargePositiveInteger << ShiftForWord)), 4);

#  endif /* BytesPerWord == 4 */

	byteAtput((newLargeInteger + BaseHeaderSize) + 3, (((usqInt) integerValue) >> 24) & 255);
	byteAtput((newLargeInteger + BaseHeaderSize) + 2, (((usqInt) integerValue) >> 16) & 255);
	byteAtput((newLargeInteger + BaseHeaderSize) + 1, (((usqInt) integerValue) >> 8) & 255);
	byteAtput((newLargeInteger + BaseHeaderSize) + 0, integerValue & 255);
	return newLargeInteger;
}


/*	Convert the given object into an integer value.
	The object may be either a positive SmallInteger or a four-byte
	LargePositiveInteger. 
 */

sqInt
positive32BitValueOf(sqInt oop)
{   DECL_MAYBE_SQ_GLOBAL_STRUCT
    sqInt ccIndex;
    sqInt ok;
    sqInt value;

	if ((oop & 1)) {
		value = (oop >> 1);
		if (value < 0) {
			/* begin primitiveFail */
			if (GIV(primFailCode) == 0) {
				GIV(primFailCode) = 1;
			}
			value = 0;
		}
		return value;
	}
	/* begin isClassOfNonImm:equalTo:compactClassIndex: */
	assert(!((oop & 1)));
	ccIndex = (((usqInt) (longAt(oop))) >> 12) & 31;
	ok = (ClassLargePositiveIntegerCompactIndex == 0
		? (ccIndex == 0
	? ((longAt(oop - BaseHeaderSize)) & AllButTypeMask) == (longAt((GIV(specialObjectsOop) + BaseHeaderSize) + (ClassLargePositiveInteger << ShiftForWord)))
	: 0)
		: ClassLargePositiveIntegerCompactIndex == ccIndex);
	if (!(ok
		 && ((lengthOf(oop)) == 4))) {
		/* begin primitiveFail */
		if (GIV(primFailCode) == 0) {
			GIV(primFailCode) = 1;
		}
		return 0;
	}
	return (((byteAt((oop + BaseHeaderSize) + 0)) + ((byteAt((oop + BaseHeaderSize) + 1)) << 8)) + ((byteAt((oop + BaseHeaderSize) + 2)) << 16)) + ((byteAt((oop + BaseHeaderSize) + 3)) << 24);
}


/*	Note - integerValue is interpreted as POSITIVE, eg, as the result of
	Bitmap>at:, or integer>bitAnd:. */

sqInt
positive64BitIntegerFor(sqLong integerValue)
{
    sqInt highWord;
    sqInt i;
    sqInt newLargeInteger;
    sqInt sz;
    sqInt value;

	if ((sizeof(integerValue)) == 4) {
		return positive32BitIntegerFor(integerValue);
	}

	/* shift is coerced to usqInt otherwise */

	highWord = integerValue >> 32;
	if (highWord == 0) {
		return positive32BitIntegerFor(integerValue);
	}
	sz = 5;
	if (!(((highWord = ((usqInt) highWord) >> 8)) == 0)) {
		sz += 1;
	}
	if (!(((highWord = ((usqInt) highWord) >> 8)) == 0)) {
		sz += 1;
	}
	if (!(((highWord = ((usqInt) highWord) >> 8)) == 0)) {
		sz += 1;
	}
	newLargeInteger = instantiateClassindexableSize(longAt((GIV(specialObjectsOop) + BaseHeaderSize) + (ClassLargePositiveInteger << ShiftForWord)), sz);
	for (i = 0; i <= (sz - 1); i += 1) {
		value = (integerValue >> (i * 8)) & 255;
		byteAtput((newLargeInteger + BaseHeaderSize) + i, value);
	}
	return newLargeInteger;
}


/*	Convert the given object into an integer value.
	The object may be either a positive SmallInteger or an eight-byte
	LargePositiveInteger. 
 */

sqLong
positive64BitValueOf(sqInt oop)
{   DECL_MAYBE_SQ_GLOBAL_STRUCT
    sqInt ccIndex;
    sqInt i;
    sqInt ok;
    sqInt sz;
    sqLong value;

	if ((oop & 1)) {
		value = (oop >> 1);
		if (value < 0) {
			/* begin primitiveFail */
			if (GIV(primFailCode) == 0) {
				GIV(primFailCode) = 1;
			}
			return null;
		}
		return value;
	}
	/* begin isClassOfNonImm:equalTo:compactClassIndex: */
	assert(!((oop & 1)));
	ccIndex = (((usqInt) (longAt(oop))) >> 12) & 31;
	ok = (ClassLargePositiveIntegerCompactIndex == 0
		? (ccIndex == 0
	? ((longAt(oop - BaseHeaderSize)) & AllButTypeMask) == (longAt((GIV(specialObjectsOop) + BaseHeaderSize) + (ClassLargePositiveInteger << ShiftForWord)))
	: 0)
		: ClassLargePositiveIntegerCompactIndex == ccIndex);
	if (!(ok
		 && (((sz = lengthOf(oop))) <= (sizeof(sqLong))))) {
		/* begin primitiveFail */
		if (GIV(primFailCode) == 0) {
			GIV(primFailCode) = 1;
		}
		return null;
	}
	value = 0;
	for (i = 0; i <= (sz - 1); i += 1) {
		value += (((sqLong) (byteAt((oop + BaseHeaderSize) + i)))) << (i * 8);
	}
	return value;
}


/*	Answer a value of an integer in address range, i.e up to the size of a
	machine word.
	The object may be either a positive SmallInteger or a LargePositiveInteger
	of size <= word size.
 */

unsigned long
positiveMachineIntegerValueOf(sqInt oop)
{   DECL_MAYBE_SQ_GLOBAL_STRUCT
    sqInt bs;
    sqInt ccIndex;
    sqInt ok;
    sqInt value;

	if ((oop & 1)) {
		value = (oop >> 1);
		if (value < 0) {
			/* begin primitiveFail */
			if (GIV(primFailCode) == 0) {
				GIV(primFailCode) = 1;
			}
			return null;
		}
		return value;
	}
	/* begin isClassOfNonImm:equalTo:compactClassIndex: */
	assert(!((oop & 1)));
	ccIndex = (((usqInt) (longAt(oop))) >> 12) & 31;
	ok = (ClassLargePositiveIntegerCompactIndex == 0
		? (ccIndex == 0
	? ((longAt(oop - BaseHeaderSize)) & AllButTypeMask) == (longAt((GIV(specialObjectsOop) + BaseHeaderSize) + (ClassLargePositiveInteger << ShiftForWord)))
	: 0)
		: ClassLargePositiveIntegerCompactIndex == ccIndex);
	if (!(ok
		 && (((bs = lengthOf(oop))) <= (sizeof(unsigned long))))) {
		/* begin primitiveFail */
		if (GIV(primFailCode) == 0) {
			GIV(primFailCode) = 1;
		}
		return null;
	}
	if (((sizeof(unsigned long)) == 8)
	 && (bs > 4)) {
		return (((((((byteAt((oop + BaseHeaderSize) + 0)) + ((byteAt((oop + BaseHeaderSize) + 1)) << 8)) + ((byteAt((oop + BaseHeaderSize) + 2)) << 16)) + ((byteAt((oop + BaseHeaderSize) + 3)) << 24)) + ((byteAt((oop + BaseHeaderSize) + 4)) << 32)) + ((byteAt((oop + BaseHeaderSize) + 5)) << 40)) + ((byteAt((oop + BaseHeaderSize) + 6)) << 48)) + ((byteAt((oop + BaseHeaderSize) + 7)) << 56);
	}
	return (((byteAt((oop + BaseHeaderSize) + 0)) + ((byteAt((oop + BaseHeaderSize) + 1)) << 8)) + ((byteAt((oop + BaseHeaderSize) + 2)) << 16)) + ((byteAt((oop + BaseHeaderSize) + 3)) << 24);
}


/*	oop is an old object. If valueObj is young, mark the object as a root. */

static void
possibleRootStoreIntovalue(sqInt oop, sqInt valueObj)
{   DECL_MAYBE_SQ_GLOBAL_STRUCT
    sqInt header;

	if (((((usqInt) valueObj)) >= (((usqInt) GIV(youngStart))))
	 && (!((valueObj & 1)))) {
		/* begin noteAsRoot:headerLoc: */
		header = longAt(oop);
		if ((header & RootBit) == 0) {
			if (GIV(rootTableCount) < RootTableSize) {

				/* record oop as root only if not already recorded */
				/* record root if there is enough room in the roots  table  */

				GIV(rootTableCount) += 1;
				GIV(rootTable)[GIV(rootTableCount)] = oop;
				longAtput(oop, header | RootBit);
				if (GIV(rootTableCount) > RootTableRedZone) {
					/* begin scheduleIncrementalGC */
					GIV(needGCFlag) = 1;
					forceInterruptCheck();
				}
			}
		}
	}
}


/*	Ensure that there are enough forwarding blocks to 
	accomodate this become, then prepare forwarding blocks for 
	the pointer swap. Return true if successful. */
/*	Details: Doing a GC might generate enough space for 
	forwarding blocks if we're short. However, this is an 
	uncommon enough case that it is better handled by primitive 
	fail code at the Smalltalk level. */
/*	Important note on multiple references to same object - since the
	preparation of
	fwdBlocks is NOT idempotent we get VM crashes if the same object is
	referenced more
	than once in such a way as to require multiple fwdBlocks.
	oop1 forwardBecome: oop1 is ok since only a single fwdBlock is needed.
	oop1 become: oop1 would fail because the second fwdBlock woudl not have
	the actual object
	header but rather the mutated ref to the first fwdBlock.
	Further problems can arise with an array1 or array2 that refer multiply to
	the same 
	object. This would notbe expected input for programmer writen code but
	might arise from
	automatic usage such as in ImageSegment loading.
	To avoid the simple and rather common case of oop1 become*: oop1, we skip
	such pairs
	and simply avoid making fwdBlocks - it is redundant anyway
 */

static sqInt
prepareForwardingTableForBecomingwithtwoWay(sqInt array1, sqInt array2, sqInt twoWayFlag)
{   DECL_MAYBE_SQ_GLOBAL_STRUCT
    sqInt contextSize;
    sqInt entriesAvailable;
    sqInt entriesNeeded;
    sqInt fieldOffset;
    sqInt fmt;
    sqInt fwdBlkSize;
    sqInt fwdBlock;
    sqInt header;
    sqInt methodHeader;
    sqInt oop1;
    sqInt oop2;
    sqInt originalHeader;
    sqInt originalHeader1;
    sqInt originalHeaderType;
    sqInt originalHeaderType1;
    sqInt sp;


	/* need enough entries for all oops */
	/* Note: Forward blocks must be quadword aligned - see fwdTableInit:. */

	entriesNeeded = ((sqInt) (lastPointerOf(array1)) >> 2);
	if (twoWayFlag) {

		/* Double the number of blocks for two-way become */

		entriesNeeded = entriesNeeded * 2;
		fwdBlkSize = BytesPerWord * 2;
	}
	else {

		/* One-way become needs backPointers in fwd blocks. */

		fwdBlkSize = BytesPerWord * 4;
	}
	entriesAvailable = fwdTableInit(fwdBlkSize);
	if (entriesAvailable < entriesNeeded) {
		initializeMemoryFirstFree(GIV(freeStart));
		return 0;
	}
	/* begin lastPointerOf: */
	header = longAt(array1);
	fmt = (((usqInt) header) >> 8) & 15;
	if (fmt <= 4) {
		if ((fmt == 3)
		 && (((((usqInt) header) >> 12) & 31) == ClassMethodContextCompactIndex)) {
			/* begin fetchStackPointerOf: */
			sp = longAt((array1 + BaseHeaderSize) + (StackPointerIndex << ShiftForWord));
			if (!((sp & 1))) {
				contextSize = 0;
				goto l3;
			}
			assert((ReceiverIndex + ((sp >> 1))) < (lengthOf(array1)));
			contextSize = (sp >> 1);
		l3:	/* end fetchStackPointerOf: */;
			fieldOffset = (CtxtTempFrameStart + contextSize) * BytesPerWord;
			goto l4;
		}
		fieldOffset = (sizeBitsOfSafe(array1)) - BaseHeaderSize;
		goto l4;
	}
	if (fmt < 12) {
		fieldOffset = 0;
		goto l4;
	}
	methodHeader = longAt(array1 + BaseHeaderSize);
	if (isCogMethodReference(methodHeader)) {
		assert(((((CogMethod *) methodHeader)->cmType)) == CMMethod);
		methodHeader = (((CogMethod *) methodHeader)->methodHeader);
	}
	fieldOffset = (((((usqInt) methodHeader) >> 10) & 255) * BytesPerWord) + BaseHeaderSize;
l4:	/* end lastPointerOf: */;
	while (fieldOffset >= BaseHeaderSize) {
		oop1 = longAt(array1 + fieldOffset);

		/* if oop1 == oop2, no need to do any work for this pair.
		  May still be other entries in the arrays though so keep looking */

		oop2 = longAt(array2 + fieldOffset);
		if (!(oop1 == oop2)) {
			/* begin fwdBlockGet: */
			GIV(fwdTableNext) += fwdBlkSize;
			if (GIV(fwdTableNext) <= GIV(fwdTableLast)) {
				fwdBlock = GIV(fwdTableNext);
				goto l2;
			}
			else {
				fwdBlock = null;
				goto l2;
			}
		l2:	/* end fwdBlockGet: */;
			/* begin initForwardBlock:mapping:to:withBackPtr: */
			originalHeader1 = longAt(oop1);
			assert(fwdBlock != null);
			assert((originalHeader1 & MarkBit) == 0);
			originalHeaderType1 = originalHeader1 & TypeMask;
			longAtput(fwdBlock, oop2);
			longAtput(fwdBlock + BytesPerWord, originalHeader1);
			if (!twoWayFlag) {
				longAtput(fwdBlock + (BytesPerWord * 2), oop1);
			}
			longAtput(oop1, (((usqInt) fwdBlock) >> 1) | (MarkBit | originalHeaderType1));
			if (twoWayFlag) {
				/* begin fwdBlockGet: */
				GIV(fwdTableNext) += fwdBlkSize;
				if (GIV(fwdTableNext) <= GIV(fwdTableLast)) {
					fwdBlock = GIV(fwdTableNext);
					goto l1;
				}
				else {
					fwdBlock = null;
					goto l1;
				}
			l1:	/* end fwdBlockGet: */;
				/* begin initForwardBlock:mapping:to:withBackPtr: */
				originalHeader = longAt(oop2);
				assert(fwdBlock != null);
				assert((originalHeader & MarkBit) == 0);
				originalHeaderType = originalHeader & TypeMask;
				longAtput(fwdBlock, oop1);
				longAtput(fwdBlock + BytesPerWord, originalHeader);
				if (!twoWayFlag) {
					longAtput(fwdBlock + (BytesPerWord * 2), oop2);
				}
				longAtput(oop2, (((usqInt) fwdBlock) >> 1) | (MarkBit | originalHeaderType));
			}
		}
		fieldOffset -= BytesPerWord;
	}
	return 1;
}

sqInt
primErrTable(void)
{
	return longAt((GIV(specialObjectsOop) + BaseHeaderSize) + (PrimErrTableIndex << ShiftForWord));
}

usqInt
primFailCodeAddress(void)
{
	return ((usqInt)((&GIV(primFailCode))));
}

static void
primitiveAdd(void)
{   DECL_MAYBE_SQ_GLOBAL_STRUCT
    sqInt integerResult;
    char *sp;

	/* begin pop2AndPushIntegerIfOK: */
	integerResult = (stackIntegerValue(1)) + (stackIntegerValue(0));
	if (GIV(primFailCode) == 0) {
		if ((integerResult ^ (integerResult << 1)) >= 0) {
			/* begin pop:thenPush: */
			longAtput(sp = GIV(stackPointer) + ((2 - 1) * BytesPerWord), ((integerResult << 1) | 1));
			GIV(stackPointer) = sp;
		}
		else {
			/* begin success: */
			if (!(0)) {
				if (GIV(primFailCode) == 0) {

					/* Don't overwrite an error code that has already been set. */

					GIV(primFailCode) = 1;
				}
			}
		}
	}
}


/*	Primitive arithmetic operations for large integers in 64 bit range */

EXPORT(void)
primitiveAddLargeIntegers(void)
{   DECL_MAYBE_SQ_GLOBAL_STRUCT
    sqLong integerArg;
    sqLong integerRcvr;
    sqInt oopResult;
    sqLong result;
    char *sp;

	integerArg = signed64BitValueOf(longAt(GIV(stackPointer) + (0 * BytesPerWord)));
	integerRcvr = signed64BitValueOf(longAt(GIV(stackPointer) + (1 * BytesPerWord)));
	if (!(GIV(primFailCode) == 0)) {
		return;
	}

	/* Now check overflow conditions. First is whether rcvr and arg are of the same sign.
	If they are we need to check for overflow more carefully. */

	result = integerRcvr + integerArg;
	if (!((integerRcvr ^ integerArg) < 0)) {
		if ((integerRcvr ^ result) < 0) {
			/* begin primitiveFail */
			if (GIV(primFailCode) == 0) {
				GIV(primFailCode) = 1;
			}
		}
	}
	if (!(GIV(primFailCode) == 0)) {
		return;
	}
	oopResult = signed64BitIntegerFor(result);
	if (GIV(primFailCode) == 0) {
		/* begin pop:thenPush: */
		longAtput(sp = GIV(stackPointer) + ((2 - 1) * BytesPerWord), oopResult);
		GIV(stackPointer) = sp;
	}
}


/*	Primitive. Change the class of the argument to make it an instance of the
	receiver given that the format of the receiver matches the format of the
	argument's class.
	Fail if receiver or argument are SmallIntegers, or the receiver is an
	instance of a
	compact class and the argument isn't, or when the argument's class is
	compact and
	the receiver isn't, or when the format of the receiver is different from
	the format of
	the argument's class, or when the arguments class is fixed and the
	receiver's size
	differs from the size that an instance of the argument's class should
	have. 
 */

static void
primitiveAdoptInstance(void)
{   DECL_MAYBE_SQ_GLOBAL_STRUCT
    sqInt arg;
    sqInt argFormat;
    sqInt byteSize;
    sqInt ccIndex;
    sqInt classHdr;
    sqInt err;
    sqInt i;
    sqInt oop;
    sqInt oop1;
    sqInt rcvr;
    sqInt rcvrFormat;
    sqInt sizeHiBits;

	/* begin stackObjectValue: */
	oop = longAt(GIV(stackPointer) + (0 * BytesPerWord));
	if ((oop & 1)) {
		/* begin primitiveFail */
		if (GIV(primFailCode) == 0) {
			GIV(primFailCode) = 1;
		}
		arg = null;
		goto l1;
	}
	arg = oop;
l1:	/* end stackObjectValue: */;
	/* begin stackObjectValue: */
	oop1 = longAt(GIV(stackPointer) + (1 * BytesPerWord));
	if ((oop1 & 1)) {
		/* begin primitiveFail */
		if (GIV(primFailCode) == 0) {
			GIV(primFailCode) = 1;
		}
		rcvr = null;
		goto l2;
	}
	rcvr = oop1;
l2:	/* end stackObjectValue: */;
	/* begin changeClassOf:to: */
	VM_LABEL(0changeClassOfto);

	/* Low 2 bits are 0 */
	/* Compute the size of instances of the class (used for fixed field classes only) */

	classHdr = (longAt((rcvr + BaseHeaderSize) + (InstanceSpecificationIndex << ShiftForWord))) - 1;
	sizeHiBits = ((usqInt) (classHdr & 393216)) >> 9;
	classHdr = classHdr & 131071;

	/* size in bytes -- low 2 bits are 0 */
	/* Check the receiver's format against that of the class */

	byteSize = (classHdr & SizeMask) + sizeHiBits;
	argFormat = (((usqInt) classHdr) >> 8) & 15;

	/* If the receiver is a byte object we need to clear the number of odd bytes from the format. */

	rcvrFormat = (((usqInt) (longAt(arg))) >> 8) & 15;
	if (rcvrFormat > 8) {
		rcvrFormat = rcvrFormat & 12;
	}
	if (!(argFormat == rcvrFormat)) {
		err = PrimErrInappropriate;
		goto l3;
	}
	if (argFormat < 2) {
		if ((byteSize - BaseHeaderSize) != (byteSizeOf(arg))) {
			err = PrimErrBadReceiver;
			goto l3;
		}
	}
	else {
		if (argFormat == 3) {
			if ((byteSize - BaseHeaderSize) > (byteSizeOf(arg))) {
				err = PrimErrBadReceiver;
				goto l3;
			}
		}
	}
	if (((longAt(arg)) & TypeMask) == HeaderTypeShort) {

		/* Compact classes. Check if the arg's class is compact and exchange ccIndex */

		ccIndex = classHdr & CompactClassMask;
		if (ccIndex == 0) {
			err = PrimErrInappropriate;
			goto l3;
		}
		longAtput(arg, ((longAt(arg)) & (~CompactClassMask)) | ccIndex);
	}
	else {
		longAtput(arg - BaseHeaderSize, rcvr | ((longAt(arg)) & TypeMask));
		if ((((usqInt) arg)) < (((usqInt) GIV(youngStart)))) {
			possibleRootStoreIntovalue(arg, rcvr);
		}
	}
	err = 0;
l3:	/* end changeClassOf:to: */;
	if (err == 0) {
		/* begin flushAtCache */
		for (i = 1; i <= AtCacheTotalSize; i += 1) {
			GIV(atCache)[i] = 0;
		}
		/* begin pop: */
		GIV(stackPointer) += GIV(argumentCount) * BytesPerWord;
	}
	else {
		GIV(primFailCode) = err;
	}
	return;
}

static void
primitiveArctan(void)
{   DECL_MAYBE_SQ_GLOBAL_STRUCT
    sqInt ccIndex;
    double f;
    sqInt object;
    double rcvr;
    double result;
    char *sp;
    sqInt successBoolean;
    sqInt top;
    sqInt top1;

	/* begin popFloat */
	VM_LABEL(0popFloat);
	/* begin popStack */
	top1 = longAt(GIV(stackPointer));
	GIV(stackPointer) += BytesPerWord;
	top = top1;
	/* begin assertClassOf:is:compactClassIndex: */
	VM_LABEL(23assertClassOfiscompactClassIndex);
	/* begin success: */
	/* begin is:instanceOf:compactClassIndex: */
	if ((top & 1)) {
		successBoolean = 0;
		goto l1;
	}
	ccIndex = (((usqInt) (longAt(top))) >> 12) & 31;
	if (ClassFloatCompactIndex != 0) {
		successBoolean = ClassFloatCompactIndex == ccIndex;
		goto l1;
	}
	successBoolean = (ccIndex == 0)
	 && (((longAt(top - BaseHeaderSize)) & AllButTypeMask) == (longAt((GIV(specialObjectsOop) + BaseHeaderSize) + (ClassFloat << ShiftForWord))));
l1:	/* end is:instanceOf:compactClassIndex: */;
	if (!(successBoolean)) {
		if (GIV(primFailCode) == 0) {

			/* Don't overwrite an error code that has already been set. */

			GIV(primFailCode) = 1;
		}
	}
	if (GIV(primFailCode) == 0) {
		;
		fetchFloatAtinto(top + BaseHeaderSize, result);
	}
	rcvr = result;
	if (GIV(primFailCode) == 0) {
		/* begin pushFloat: */
		f = atan(rcvr);
		/* begin push: */
		object = floatObjectOf(f);
		longAtput(sp = GIV(stackPointer) - BytesPerWord, object);
		GIV(stackPointer) = sp;
	}
	else {
		/* begin unPop: */
		GIV(stackPointer) -= 1 * BytesPerWord;
	}
}


/*	We must flush the method cache here, to eliminate stale references
	to mutated classes and/or selectors. */

static void
primitiveArrayBecome(void)
{   DECL_MAYBE_SQ_GLOBAL_STRUCT
    sqInt arg;
    sqInt ec;
    sqInt rcvr;

	arg = longAt(GIV(stackPointer));
	rcvr = longAt(GIV(stackPointer) + (1 * BytesPerWord));
	ec = becomewithtwoWaycopyHash(rcvr, arg, 1, 1);
	if (ec == PrimNoErr) {
		/* begin pop: */
		GIV(stackPointer) += 1 * BytesPerWord;
	}
	else {
		GIV(primFailCode) = ec;
	}
}


/*	We must flush the method cache here, to eliminate stale references
	to mutated classes and/or selectors. */

static void
primitiveArrayBecomeOneWay(void)
{   DECL_MAYBE_SQ_GLOBAL_STRUCT
    sqInt arg;
    sqInt ec;
    sqInt rcvr;

	arg = longAt(GIV(stackPointer));
	rcvr = longAt(GIV(stackPointer) + (1 * BytesPerWord));
	ec = becomewithtwoWaycopyHash(rcvr, arg, 0, 1);
	if (ec == PrimNoErr) {
		/* begin pop: */
		GIV(stackPointer) += 1 * BytesPerWord;
	}
	else {
		GIV(primFailCode) = ec;
	}
}


/*	Similar to primitiveArrayBecomeOneWay but accepts a third argument whether
	to copy
	the receiver's identity hash over the argument's identity hash.
 */

static void
primitiveArrayBecomeOneWayCopyHash(void)
{   DECL_MAYBE_SQ_GLOBAL_STRUCT
    sqInt arg;
    sqInt copyHashFlag;
    sqInt ec;
    sqInt rcvr;

	/* begin booleanValueOf: */
	if ((longAt(GIV(stackPointer))) == GIV(trueObj)) {
		copyHashFlag = 1;
		goto l1;
	}
	if ((longAt(GIV(stackPointer))) == GIV(falseObj)) {
		copyHashFlag = 0;
		goto l1;
	}
	/* begin success: */
	if (!(0)) {
		if (GIV(primFailCode) == 0) {

			/* Don't overwrite an error code that has already been set. */

			GIV(primFailCode) = 1;
		}
	}
	copyHashFlag = null;
l1:	/* end booleanValueOf: */;
	arg = longAt(GIV(stackPointer) + (1 * BytesPerWord));
	rcvr = longAt(GIV(stackPointer) + (2 * BytesPerWord));
	ec = becomewithtwoWaycopyHash(rcvr, arg, 0, copyHashFlag);
	if (ec == PrimNoErr) {
		/* begin pop: */
		GIV(stackPointer) += 2 * BytesPerWord;
	}
	else {
		GIV(primFailCode) = ec;
	}
}

static void
primitiveAsFloat(void)
{   DECL_MAYBE_SQ_GLOBAL_STRUCT
    sqInt arg;
    double f;
    sqInt integerPointer;
    sqInt object;
    char *sp;
    sqInt top;

	/* begin popInteger */
	/* begin popStack */
	top = longAt(GIV(stackPointer));
	GIV(stackPointer) += BytesPerWord;
	integerPointer = top;
	/* begin checkedIntegerValueOf: */
	if ((integerPointer & 1)) {
		arg = (integerPointer >> 1);
		goto l1;
	}
	else {
		/* begin primitiveFail */
		if (GIV(primFailCode) == 0) {
			GIV(primFailCode) = 1;
		}
		arg = 0;
		goto l1;
	}
l1:	/* end popInteger */;
	if (GIV(primFailCode) == 0) {
		/* begin pushFloat: */
		f = ((double) arg);
		/* begin push: */
		object = floatObjectOf(f);
		longAtput(sp = GIV(stackPointer) - BytesPerWord, object);
		GIV(stackPointer) = sp;
	}
	else {
		/* begin unPop: */
		GIV(stackPointer) -= 1 * BytesPerWord;
	}
}

static void
primitiveAt(void)
{
	commonAt(0);
}

static void
primitiveAtPut(void)
{
	commonAtPut(0);
}


/*	Set the cursor to the given shape. The Mac only supports 16x16 pixel
	cursors. Cursor offsets are handled by Smalltalk.
 */

static void
primitiveBeCursor(void)
{   DECL_MAYBE_SQ_GLOBAL_STRUCT
    sqInt bitsObj;
    sqInt cursorBitsIndex;
    sqInt cursorObj;
    sqInt depth;
    sqInt extentX;
    sqInt extentY;
    sqInt i;
    sqInt maskBitsIndex;
    sqInt maskObj;
    sqInt offsetObj;
    sqInt offsetX;
    sqInt offsetY;
    sqInt ourCursor;
    sqInt successBoolean;
    sqInt successBoolean1;
    sqInt successBoolean10;
    sqInt successBoolean11;
    sqInt successBoolean12;
    sqInt successBoolean2;
    sqInt successBoolean3;
    sqInt successBoolean4;
    sqInt successBoolean5;
    sqInt successBoolean6;
    sqInt successBoolean7;
    sqInt successBoolean8;
    sqInt successBoolean9;

	flag("Dan");
	if (BytesPerWord == 8) {
		/* begin pop: */
		GIV(stackPointer) += GIV(argumentCount) * BytesPerWord;
		return;
	}
	if (GIV(argumentCount) == 0) {
		cursorObj = longAt(GIV(stackPointer));
		maskBitsIndex = null;
	}
	if (GIV(argumentCount) == 1) {
		cursorObj = longAt(GIV(stackPointer) + (1 * BytesPerWord));
		maskObj = longAt(GIV(stackPointer));
	}
	/* begin success: */
	if (!(GIV(argumentCount) < 2)) {
		if (GIV(primFailCode) == 0) {

			/* Don't overwrite an error code that has already been set. */

			GIV(primFailCode) = 1;
		}
	}
	/* begin success: */
	successBoolean11 = (((cursorObj & 1) == 0)
 && (((((usqInt) (longAt(cursorObj))) >> 8) & 15) <= 4))
	 && ((lengthOf(cursorObj)) >= 5);
	if (!(successBoolean11)) {
		if (GIV(primFailCode) == 0) {

			/* Don't overwrite an error code that has already been set. */

			GIV(primFailCode) = 1;
		}
	}
	if (GIV(primFailCode) == 0) {
		bitsObj = longAt((cursorObj + BaseHeaderSize) + (0 << ShiftForWord));
		extentX = fetchIntegerofObject(1, cursorObj);
		extentY = fetchIntegerofObject(2, cursorObj);
		depth = fetchIntegerofObject(3, cursorObj);
		offsetObj = longAt((cursorObj + BaseHeaderSize) + (4 << ShiftForWord));
	}
	/* begin success: */
	successBoolean12 = (((offsetObj & 1) == 0)
 && (((((usqInt) (longAt(offsetObj))) >> 8) & 15) <= 4))
	 && ((lengthOf(offsetObj)) >= 2);
	if (!(successBoolean12)) {
		if (GIV(primFailCode) == 0) {

			/* Don't overwrite an error code that has already been set. */

			GIV(primFailCode) = 1;
		}
	}
	if (GIV(primFailCode) == 0) {
		offsetX = fetchIntegerofObject(0, offsetObj);
		offsetY = fetchIntegerofObject(1, offsetObj);
		if ((GIV(argumentCount) == 0)
		 && (depth == 32)) {
			/* begin success: */
			successBoolean = (extentX > 0)
			 && (extentY > 0);
			if (!(successBoolean)) {
				if (GIV(primFailCode) == 0) {

					/* Don't overwrite an error code that has already been set. */

					GIV(primFailCode) = 1;
				}
			}
			/* begin success: */
			successBoolean1 = (offsetX >= (extentX * -1))
			 && (offsetX <= 0);
			if (!(successBoolean1)) {
				if (GIV(primFailCode) == 0) {

					/* Don't overwrite an error code that has already been set. */

					GIV(primFailCode) = 1;
				}
			}
			/* begin success: */
			successBoolean2 = (offsetY >= (extentY * -1))
			 && (offsetY <= 0);
			if (!(successBoolean2)) {
				if (GIV(primFailCode) == 0) {

					/* Don't overwrite an error code that has already been set. */

					GIV(primFailCode) = 1;
				}
			}
			/* begin success: */
			successBoolean3 = (((bitsObj & 1) == 0)
 && (((((usqInt) (longAt(bitsObj))) >> 8) & 15) == 6))
			 && ((lengthOf(bitsObj)) == (extentX * extentY));
			if (!(successBoolean3)) {
				if (GIV(primFailCode) == 0) {

					/* Don't overwrite an error code that has already been set. */

					GIV(primFailCode) = 1;
				}
			}
			cursorBitsIndex = bitsObj + BaseHeaderSize;
			;
		}
		else {
			/* begin success: */
			successBoolean4 = (extentX == 16)
			 && ((extentY == 16)
 && (depth == 1));
			if (!(successBoolean4)) {
				if (GIV(primFailCode) == 0) {

					/* Don't overwrite an error code that has already been set. */

					GIV(primFailCode) = 1;
				}
			}
			/* begin success: */
			successBoolean5 = (offsetX >= -16)
			 && (offsetX <= 0);
			if (!(successBoolean5)) {
				if (GIV(primFailCode) == 0) {

					/* Don't overwrite an error code that has already been set. */

					GIV(primFailCode) = 1;
				}
			}
			/* begin success: */
			successBoolean6 = (offsetY >= -16)
			 && (offsetY <= 0);
			if (!(successBoolean6)) {
				if (GIV(primFailCode) == 0) {

					/* Don't overwrite an error code that has already been set. */

					GIV(primFailCode) = 1;
				}
			}
			/* begin success: */
			successBoolean7 = (((bitsObj & 1) == 0)
 && (((((usqInt) (longAt(bitsObj))) >> 8) & 15) == 6))
			 && ((lengthOf(bitsObj)) == 16);
			if (!(successBoolean7)) {
				if (GIV(primFailCode) == 0) {

					/* Don't overwrite an error code that has already been set. */

					GIV(primFailCode) = 1;
				}
			}
			cursorBitsIndex = bitsObj + BaseHeaderSize;
			;
		}
	}
	if (GIV(argumentCount) == 1) {
		/* begin success: */
		successBoolean10 = (((maskObj & 1) == 0)
 && (((((usqInt) (longAt(maskObj))) >> 8) & 15) <= 4))
		 && ((lengthOf(maskObj)) >= 5);
		if (!(successBoolean10)) {
			if (GIV(primFailCode) == 0) {

				/* Don't overwrite an error code that has already been set. */

				GIV(primFailCode) = 1;
			}
		}
		if (GIV(primFailCode) == 0) {
			bitsObj = longAt((maskObj + BaseHeaderSize) + (0 << ShiftForWord));
			extentX = fetchIntegerofObject(1, maskObj);
			extentY = fetchIntegerofObject(2, maskObj);
			depth = fetchIntegerofObject(3, maskObj);
		}
		if (GIV(primFailCode) == 0) {
			/* begin success: */
			successBoolean8 = (extentX == 16)
			 && ((extentY == 16)
 && (depth == 1));
			if (!(successBoolean8)) {
				if (GIV(primFailCode) == 0) {

					/* Don't overwrite an error code that has already been set. */

					GIV(primFailCode) = 1;
				}
			}
			/* begin success: */
			successBoolean9 = (((bitsObj & 1) == 0)
 && (((((usqInt) (longAt(bitsObj))) >> 8) & 15) == 6))
			 && ((lengthOf(bitsObj)) == 16);
			if (!(successBoolean9)) {
				if (GIV(primFailCode) == 0) {

					/* Don't overwrite an error code that has already been set. */

					GIV(primFailCode) = 1;
				}
			}
			maskBitsIndex = bitsObj + BaseHeaderSize;
		}
	}
	if (GIV(primFailCode) == 0) {
		if (GIV(argumentCount) == 0) {
			if (depth == 32) {
				if (!(ioSetCursorARGB(cursorBitsIndex, extentX, extentY, offsetX, offsetY))) {
					/* begin success: */
					if (!(0)) {
						if (GIV(primFailCode) == 0) {

							/* Don't overwrite an error code that has already been set. */

							GIV(primFailCode) = 1;
						}
					}
					return;
				}
			}
			else {
				ioSetCursor(cursorBitsIndex, offsetX, offsetY);
			}
		}
		else {
			ioSetCursorWithMask(cursorBitsIndex, maskBitsIndex, offsetX, offsetY);
		}
		/* begin pop: */
		GIV(stackPointer) += GIV(argumentCount) * BytesPerWord;
	}
}


/*	Record the system Display object in the specialObjectsTable. */

static void
primitiveBeDisplay(void)
{   DECL_MAYBE_SQ_GLOBAL_STRUCT
    sqInt rcvr;
    sqInt successBoolean;

	rcvr = longAt(GIV(stackPointer));
	/* begin success: */
	successBoolean = (((rcvr & 1) == 0)
 && (((((usqInt) (longAt(rcvr))) >> 8) & 15) <= 4))
	 && ((lengthOf(rcvr)) >= 4);
	if (!(successBoolean)) {
		if (GIV(primFailCode) == 0) {

			/* Don't overwrite an error code that has already been set. */

			GIV(primFailCode) = 1;
		}
	}
	if (GIV(primFailCode) == 0) {
		/* begin splObj:put: */
		/* begin storePointer:ofObject:withValue: */
		if ((((usqInt) GIV(specialObjectsOop))) < (((usqInt) GIV(youngStart)))) {
			possibleRootStoreIntovalue(GIV(specialObjectsOop), rcvr);
		}
		longAtput((GIV(specialObjectsOop) + BaseHeaderSize) + (TheDisplay << ShiftForWord), rcvr);
	}
}


/*	make the basic beep noise */

static void
primitiveBeep(void)
{
	ioBeep();
}

static void
primitiveBehaviorHash(void)
{   DECL_MAYBE_SQ_GLOBAL_STRUCT
    sqInt hashOrError;
    char *sp;

	assert(!(((stackTop()) & 1)));
	hashOrError = (((usqInt) (longAt(longAt(GIV(stackPointer))))) >> HashBitsOffset) & HashMaskUnshifted;
	if (hashOrError >= 0) {
		/* begin pop:thenPushInteger: */
		longAtput(sp = GIV(stackPointer) + ((1 - 1) * BytesPerWord), ((hashOrError << 1) | 1));
		GIV(stackPointer) = sp;
	}
	else {
		GIV(primFailCode) = -hashOrError;
	}
}

static void
primitiveBitAnd(void)
{   DECL_MAYBE_SQ_GLOBAL_STRUCT
    sqInt integerArgument;
    sqInt integerReceiver;
    sqInt object;
    char *sp;
    sqInt top;
    sqInt top1;
    sqInt top11;
    sqInt top2;

	/* begin popPos32BitInteger */
	/* begin popStack */
	top1 = longAt(GIV(stackPointer));
	GIV(stackPointer) += BytesPerWord;
	top = top1;
	integerArgument = positive32BitValueOf(top);
	/* begin popPos32BitInteger */
	/* begin popStack */
	top11 = longAt(GIV(stackPointer));
	GIV(stackPointer) += BytesPerWord;
	top2 = top11;
	integerReceiver = positive32BitValueOf(top2);
	if (GIV(primFailCode) == 0) {
		/* begin push: */
		object = positive32BitIntegerFor(integerReceiver & integerArgument);
		longAtput(sp = GIV(stackPointer) - BytesPerWord, object);
		GIV(stackPointer) = sp;
	}
	else {
		/* begin unPop: */
		GIV(stackPointer) -= 2 * BytesPerWord;
	}
}


/*	Primitive logical operations for large integers in 64 bit range */

EXPORT(void)
primitiveBitAndLargeIntegers(void)
{   DECL_MAYBE_SQ_GLOBAL_STRUCT
    sqLong integerArg;
    sqLong integerRcvr;
    sqInt oopResult;
    char *sp;

	integerArg = positive64BitValueOf(longAt(GIV(stackPointer) + (0 * BytesPerWord)));
	integerRcvr = positive64BitValueOf(longAt(GIV(stackPointer) + (1 * BytesPerWord)));
	if (!(GIV(primFailCode) == 0)) {
		return;
	}
	oopResult = positive64BitIntegerFor(integerRcvr & integerArg);
	if (GIV(primFailCode) == 0) {
		/* begin pop:thenPush: */
		longAtput(sp = GIV(stackPointer) + ((2 - 1) * BytesPerWord), oopResult);
		GIV(stackPointer) = sp;
	}
}

static void
primitiveBitOr(void)
{   DECL_MAYBE_SQ_GLOBAL_STRUCT
    sqInt integerArgument;
    sqInt integerReceiver;
    sqInt object;
    char *sp;
    sqInt top;
    sqInt top1;
    sqInt top11;
    sqInt top2;

	/* begin popPos32BitInteger */
	/* begin popStack */
	top1 = longAt(GIV(stackPointer));
	GIV(stackPointer) += BytesPerWord;
	top = top1;
	integerArgument = positive32BitValueOf(top);
	/* begin popPos32BitInteger */
	/* begin popStack */
	top11 = longAt(GIV(stackPointer));
	GIV(stackPointer) += BytesPerWord;
	top2 = top11;
	integerReceiver = positive32BitValueOf(top2);
	if (GIV(primFailCode) == 0) {
		/* begin push: */
		object = positive32BitIntegerFor(integerReceiver | integerArgument);
		longAtput(sp = GIV(stackPointer) - BytesPerWord, object);
		GIV(stackPointer) = sp;
	}
	else {
		/* begin unPop: */
		GIV(stackPointer) -= 2 * BytesPerWord;
	}
}


/*	Primitive logical operations for large integers in 64 bit range */

EXPORT(void)
primitiveBitOrLargeIntegers(void)
{   DECL_MAYBE_SQ_GLOBAL_STRUCT
    sqLong integerArg;
    sqLong integerRcvr;
    sqInt oopResult;
    char *sp;

	integerArg = positive64BitValueOf(longAt(GIV(stackPointer) + (0 * BytesPerWord)));
	integerRcvr = positive64BitValueOf(longAt(GIV(stackPointer) + (1 * BytesPerWord)));
	if (!(GIV(primFailCode) == 0)) {
		return;
	}
	oopResult = positive64BitIntegerFor(integerRcvr | integerArg);
	if (GIV(primFailCode) == 0) {
		/* begin pop:thenPush: */
		longAtput(sp = GIV(stackPointer) + ((2 - 1) * BytesPerWord), oopResult);
		GIV(stackPointer) = sp;
	}
}

static void
primitiveBitShift(void)
{   DECL_MAYBE_SQ_GLOBAL_STRUCT
    sqInt integerArgument;
    sqInt integerPointer;
    sqInt integerReceiver;
    sqInt object;
    sqInt shifted;
    char *sp;
    sqInt top;
    sqInt top1;
    sqInt top2;

	/* begin popInteger */
	/* begin popStack */
	top2 = longAt(GIV(stackPointer));
	GIV(stackPointer) += BytesPerWord;
	integerPointer = top2;
	/* begin checkedIntegerValueOf: */
	if ((integerPointer & 1)) {
		integerArgument = (integerPointer >> 1);
		goto l1;
	}
	else {
		/* begin primitiveFail */
		if (GIV(primFailCode) == 0) {
			GIV(primFailCode) = 1;
		}
		integerArgument = 0;
		goto l1;
	}
l1:	/* end popInteger */;
	/* begin popPos32BitInteger */
	/* begin popStack */
	top1 = longAt(GIV(stackPointer));
	GIV(stackPointer) += BytesPerWord;
	top = top1;
	integerReceiver = positive32BitValueOf(top);
	if (GIV(primFailCode) == 0) {
		if (integerArgument >= 0) {
			/* begin success: */
			if (!(integerArgument <= 31)) {
				if (GIV(primFailCode) == 0) {

					/* Don't overwrite an error code that has already been set. */

					GIV(primFailCode) = 1;
				}
			}
			shifted = integerReceiver << integerArgument;
			/* begin success: */
			if (!((((usqInt) shifted) >> integerArgument) == integerReceiver)) {
				if (GIV(primFailCode) == 0) {

					/* Don't overwrite an error code that has already been set. */

					GIV(primFailCode) = 1;
				}
			}
		}
		else {
			/* begin success: */
			if (!(integerArgument >= -31)) {
				if (GIV(primFailCode) == 0) {

					/* Don't overwrite an error code that has already been set. */

					GIV(primFailCode) = 1;
				}
			}
			shifted = ((integerArgument < 0) ? ((usqInt) integerReceiver >> -integerArgument) : ((usqInt) integerReceiver << integerArgument));
		}
	}
	if (GIV(primFailCode) == 0) {
		/* begin push: */
		object = positive32BitIntegerFor(shifted);
		longAtput(sp = GIV(stackPointer) - BytesPerWord, object);
		GIV(stackPointer) = sp;
	}
	else {
		/* begin unPop: */
		GIV(stackPointer) -= 2 * BytesPerWord;
	}
}


/*	Primitive logical operations for large integers in 64 bit range */

EXPORT(void)
primitiveBitShiftLargeIntegers(void)
{   DECL_MAYBE_SQ_GLOBAL_STRUCT
    sqLong integerArg;
    sqInt integerPointer;
    sqLong integerRcvr;
    sqInt oopResult;
    sqLong shifted;
    char *sp;
    sqInt successBoolean;

	/* begin stackIntegerValue: */
	integerPointer = longAt(GIV(stackPointer) + (0 * BytesPerWord));
	/* begin checkedIntegerValueOf: */
	if ((integerPointer & 1)) {
		integerArg = ((sqInt) ((integerPointer >> 1)));
		goto l1;
	}
	else {
		/* begin primitiveFail */
		if (GIV(primFailCode) == 0) {
			GIV(primFailCode) = 1;
		}
		integerArg = ((sqInt) 0);
		goto l1;
	}
l1:	/* end stackIntegerValue: */;
	integerRcvr = signed64BitValueOf(longAt(GIV(stackPointer) + (1 * BytesPerWord)));
	if (GIV(primFailCode) == 0) {
		if (integerArg >= 0) {
			/* begin success: */
			if (!(integerArg < 64)) {
				if (GIV(primFailCode) == 0) {

					/* Don't overwrite an error code that has already been set. */

					GIV(primFailCode) = 1;
				}
			}
			shifted = integerRcvr << integerArg;
			/* begin success: */
			successBoolean = integerRcvr == (shifted >> integerArg);
			if (!(successBoolean)) {
				if (GIV(primFailCode) == 0) {

					/* Don't overwrite an error code that has already been set. */

					GIV(primFailCode) = 1;
				}
			}
		}
		else {
			/* begin success: */
			if (!(integerArg > -64)) {
				if (GIV(primFailCode) == 0) {

					/* Don't overwrite an error code that has already been set. */

					GIV(primFailCode) = 1;
				}
			}
			shifted = integerRcvr >> (0 - integerArg);
		}
	}
	if (!(GIV(primFailCode) == 0)) {
		return;
	}
	oopResult = signed64BitIntegerFor(shifted);
	if (GIV(primFailCode) == 0) {
		/* begin pop:thenPush: */
		longAtput(sp = GIV(stackPointer) + ((2 - 1) * BytesPerWord), oopResult);
		GIV(stackPointer) = sp;
	}
}

static void
primitiveBitXor(void)
{   DECL_MAYBE_SQ_GLOBAL_STRUCT
    sqInt integerArgument;
    sqInt integerReceiver;
    sqInt object;
    char *sp;
    sqInt top;
    sqInt top1;
    sqInt top11;
    sqInt top2;

	/* begin popPos32BitInteger */
	/* begin popStack */
	top1 = longAt(GIV(stackPointer));
	GIV(stackPointer) += BytesPerWord;
	top = top1;
	integerArgument = positive32BitValueOf(top);
	/* begin popPos32BitInteger */
	/* begin popStack */
	top11 = longAt(GIV(stackPointer));
	GIV(stackPointer) += BytesPerWord;
	top2 = top11;
	integerReceiver = positive32BitValueOf(top2);
	if (GIV(primFailCode) == 0) {
		/* begin push: */
		object = positive32BitIntegerFor(integerReceiver ^ integerArgument);
		longAtput(sp = GIV(stackPointer) - BytesPerWord, object);
		GIV(stackPointer) = sp;
	}
	else {
		/* begin unPop: */
		GIV(stackPointer) -= 2 * BytesPerWord;
	}
}


/*	Primitive logical operations for large integers in 64 bit range */

EXPORT(void)
primitiveBitXorLargeIntegers(void)
{   DECL_MAYBE_SQ_GLOBAL_STRUCT
    sqLong integerArg;
    sqLong integerRcvr;
    sqInt oopResult;
    char *sp;

	integerArg = positive64BitValueOf(longAt(GIV(stackPointer) + (0 * BytesPerWord)));
	integerRcvr = positive64BitValueOf(longAt(GIV(stackPointer) + (1 * BytesPerWord)));
	if (!(GIV(primFailCode) == 0)) {
		return;
	}
	oopResult = positive64BitIntegerFor(integerRcvr ^ integerArg);
	if (GIV(primFailCode) == 0) {
		/* begin pop:thenPush: */
		longAtput(sp = GIV(stackPointer) + ((2 - 1) * BytesPerWord), oopResult);
		GIV(stackPointer) = sp;
	}
}


/*	Reports bytes available at this moment. For more meaningful 
	results, calls to this primitive should be preceeded by a full 
	or incremental garbage collection. */

static void
primitiveBytesLeft(void)
{   DECL_MAYBE_SQ_GLOBAL_STRUCT
    sqInt aBool;
    sqInt integerVal;
    sqInt integerVal1;
    char *sp;
    char *sp1;

	if (GIV(argumentCount) == 0) {
		/* begin pop:thenPushInteger: */
		integerVal = ((((usqInt) GIV(freeStart))) < (((usqInt) GIV(reserveStart)))
			? (((usqInt) GIV(reserveStart))) - (((usqInt) GIV(freeStart)))
			: 0);
		longAtput(sp = GIV(stackPointer) + ((1 - 1) * BytesPerWord), ((integerVal << 1) | 1));
		GIV(stackPointer) = sp;
		return;
	}
	if (GIV(argumentCount) == 1) {
		/* begin booleanValueOf: */
		if ((longAt(GIV(stackPointer))) == GIV(trueObj)) {
			aBool = 1;
			goto l1;
		}
		if ((longAt(GIV(stackPointer))) == GIV(falseObj)) {
			aBool = 0;
			goto l1;
		}
		/* begin success: */
		if (!(0)) {
			if (GIV(primFailCode) == 0) {

				/* Don't overwrite an error code that has already been set. */

				GIV(primFailCode) = 1;
			}
		}
		aBool = null;
	l1:	/* end booleanValueOf: */;
		if (GIV(primFailCode) == 0) {
			/* begin pop:thenPushInteger: */
			integerVal1 = (((((usqInt) GIV(freeStart))) < (((usqInt) GIV(reserveStart)))
	? (((usqInt) GIV(reserveStart))) - (((usqInt) GIV(freeStart)))
	: 0)) + (sqMemoryExtraBytesLeft(aBool));
			longAtput(sp1 = GIV(stackPointer) + ((2 - 1) * BytesPerWord), ((integerVal1 << 1) | 1));
			GIV(stackPointer) = sp1;
			return;
		}
	}
	/* begin primitiveFail */
	if (GIV(primFailCode) == 0) {
		GIV(primFailCode) = 1;
	}
	return;
}


/*	Perform a function call to a foreign function.
	Only invoked from method containing explicit external call spec.
	Due to this we use the pluggable prim mechanism explicitly here
	(the first literal of any FFI spec'ed method is an ExternalFunction
	and not an array as used in the pluggable primitive mechanism). */

static void
primitiveCalloutToFFI(void)
{   DECL_MAYBE_SQ_GLOBAL_STRUCT
    void (*primitiveCallout)(void);

	primitiveCallout = functionForPrimitiveCallout();
	if (primitiveCallout == null) {
		/* begin primitiveFail */
		if (GIV(primFailCode) == 0) {
			GIV(primFailCode) = 1;
		}
	}
	else {
		primitiveCallout();
	}
}


/*	Primitive. Change the class of the receiver into the class of the argument
	given that the format of the receiver matches the format of the argument's
	class. Fail if receiver or argument are SmallIntegers, or the receiver is
	an instance of a compact class and the argument isn't, or when the
	argument's class is compact and the receiver isn't, or when the format of
	the receiver is different from the format of the argument's class, or when
	the arguments class is fixed and the receiver's size differs from the size
	that an instance of the argument's class should have.
 */

static void
primitiveChangeClass(void)
{   DECL_MAYBE_SQ_GLOBAL_STRUCT
    sqInt arg;
    sqInt argClass;
    sqInt argFormat;
    sqInt byteSize;
    sqInt ccIndex;
    sqInt ccIndex1;
    sqInt classHdr;
    sqInt err;
    sqInt i;
    sqInt oop;
    sqInt oop1;
    sqInt rcvr;
    sqInt rcvrFormat;
    sqInt sizeHiBits;

	/* begin stackObjectValue: */
	oop = longAt(GIV(stackPointer) + (0 * BytesPerWord));
	if ((oop & 1)) {
		/* begin primitiveFail */
		if (GIV(primFailCode) == 0) {
			GIV(primFailCode) = 1;
		}
		arg = null;
		goto l1;
	}
	arg = oop;
l1:	/* end stackObjectValue: */;
	/* begin stackObjectValue: */
	oop1 = longAt(GIV(stackPointer) + (1 * BytesPerWord));
	if ((oop1 & 1)) {
		/* begin primitiveFail */
		if (GIV(primFailCode) == 0) {
			GIV(primFailCode) = 1;
		}
		rcvr = null;
		goto l2;
	}
	rcvr = oop1;
l2:	/* end stackObjectValue: */;
	if (!(GIV(primFailCode) == 0)) {
		return;
	}
	/* begin changeClassOf:toThatOf: */
	VM_LABEL(0changeClassOftoThatOf);
	/* begin fetchClassOf: */
	if ((arg & 1)) {
		argClass = longAt((GIV(specialObjectsOop) + BaseHeaderSize) + (ClassInteger << ShiftForWord));
		goto l4;
	}
	if (((ccIndex1 = (((usqInt) (longAt(arg))) >> 12) & 31)) == 0) {
		argClass = (longAt(arg - BaseHeaderSize)) & AllButTypeMask;
		goto l4;
	}
	else {
		argClass = longAt(((longAt((GIV(specialObjectsOop) + BaseHeaderSize) + (CompactClasses << ShiftForWord))) + BaseHeaderSize) + ((ccIndex1 - 1) << ShiftForWord));
		goto l4;
	}
l4:	/* end fetchClassOf: */;

	/* Low 2 bits are 0 */
	/* Compute the size of instances of the class (used for fixed field classes only) */

	classHdr = (longAt((argClass + BaseHeaderSize) + (InstanceSpecificationIndex << ShiftForWord))) - 1;
	sizeHiBits = ((usqInt) (classHdr & 393216)) >> 9;
	classHdr = classHdr & 131071;

	/* size in bytes -- low 2 bits are 0 */
	/* Check the receiver's format against that of the class */

	byteSize = (classHdr & SizeMask) + sizeHiBits;
	argFormat = (((usqInt) classHdr) >> 8) & 15;
	rcvrFormat = (((usqInt) (longAt(rcvr))) >> 8) & 15;
	if (!(argFormat == rcvrFormat)) {
		if ((rcvrFormat > 8)
		 && (argFormat > 8)) {
			rcvrFormat = rcvrFormat & 12;
			argFormat = argFormat & 12;
		}
		if (!(argFormat == rcvrFormat)) {
			err = PrimErrInappropriate;
			goto l3;
		}
	}
	if (argFormat < 2) {
		if ((byteSize - BaseHeaderSize) != (byteSizeOf(rcvr))) {
			err = PrimErrBadReceiver;
			goto l3;
		}
	}
	else {
		if (argFormat == 3) {
			if ((byteSize - BaseHeaderSize) > (byteSizeOf(rcvr))) {
				err = PrimErrBadReceiver;
				goto l3;
			}
		}
	}
	if (((longAt(rcvr)) & TypeMask) == HeaderTypeShort) {

		/* Compact classes. Check if the arg's class is compact and exchange ccIndex */

		ccIndex = classHdr & CompactClassMask;
		if (ccIndex == 0) {
			err = PrimErrInappropriate;
			goto l3;
		}
		longAtput(rcvr, ((longAt(rcvr)) & (~CompactClassMask)) | ccIndex);
	}
	else {
		longAtput(rcvr - BaseHeaderSize, argClass | ((longAt(rcvr)) & TypeMask));
		if (rcvr < GIV(youngStart)) {
			possibleRootStoreIntovalue(rcvr, argClass);
		}
	}
	err = 0;
l3:	/* end changeClassOf:toThatOf: */;
	if (err == 0) {
		/* begin flushAtCache */
		for (i = 1; i <= AtCacheTotalSize; i += 1) {
			GIV(atCache)[i] = 0;
		}
		/* begin pop: */
		GIV(stackPointer) += GIV(argumentCount) * BytesPerWord;
	}
	else {
		GIV(primFailCode) = err;
	}
	return;
}

static void
primitiveClass(void)
{   DECL_MAYBE_SQ_GLOBAL_STRUCT
    sqInt ccIndex;
    sqInt instance;
    sqInt oop;
    char *sp;

	instance = longAt(GIV(stackPointer));
	/* begin pop:thenPush: */
	/* begin fetchClassOf: */
	if ((instance & 1)) {
		oop = longAt((GIV(specialObjectsOop) + BaseHeaderSize) + (ClassInteger << ShiftForWord));
		goto l1;
	}
	if (((ccIndex = (((usqInt) (longAt(instance))) >> 12) & 31)) == 0) {
		oop = (longAt(instance - BaseHeaderSize)) & AllButTypeMask;
		goto l1;
	}
	else {
		oop = longAt(((longAt((GIV(specialObjectsOop) + BaseHeaderSize) + (CompactClasses << ShiftForWord))) + BaseHeaderSize) + ((ccIndex - 1) << ShiftForWord));
		goto l1;
	}
l1:	/* end fetchClassOf: */;
	longAtput(sp = GIV(stackPointer) + (((GIV(argumentCount) + 1) - 1) * BytesPerWord), oop);
	GIV(stackPointer) = sp;
}


/*	Primitive. Void the VM profile histograms. */

static void
primitiveClearVMProfile(void)
{   DECL_MAYBE_SQ_GLOBAL_STRUCT
	ioClearProfile();
	/* begin pop: */
	GIV(stackPointer) += GIV(argumentCount) * BytesPerWord;
}


/*	When called with a single string argument, post the string to 
	the clipboard. When called with zero arguments, return a 
	string containing the current clipboard contents. */

static void
primitiveClipboardText(void)
{   DECL_MAYBE_SQ_GLOBAL_STRUCT
    sqInt s;
    char *sp;
    sqInt sz;

	if (GIV(argumentCount) == 1) {
		s = longAt(GIV(stackPointer));
		if (!(((s & 1) == 0)
			 && (((((usqInt) (longAt(s))) >> 8) & 15) >= 8))) {
			/* begin primitiveFail */
			if (GIV(primFailCode) == 0) {
				GIV(primFailCode) = 1;
			}
			return;
		}
		if (GIV(primFailCode) == 0) {
			sz = stSizeOf(s);
			clipboardWriteFromAt(sz, s + BaseHeaderSize, 0);
			/* begin pop: */
			GIV(stackPointer) += 1 * BytesPerWord;
		}
	}
	else {
		sz = clipboardSize();
		if (!(sufficientSpaceToAllocate(sz))) {
			/* begin primitiveFail */
			if (GIV(primFailCode) == 0) {
				GIV(primFailCode) = 1;
			}
			return;
		}
		s = instantiateClassindexableSize(longAt((GIV(specialObjectsOop) + BaseHeaderSize) + (ClassString << ShiftForWord)), sz);
		clipboardReadIntoAt(sz, s + BaseHeaderSize, 0);
		/* begin pop:thenPush: */
		longAtput(sp = GIV(stackPointer) + ((1 - 1) * BytesPerWord), s);
		GIV(stackPointer) = sp;
	}
}


/*	Take a boolean which if true turns or keeps clock logging on. Answer an
	array supplying
	the size of the clock logs, the address of the usecs log, the index in it,
	the address of the
	msecs log, and the index into it. */

EXPORT(sqInt)
primitiveClockLogAddresses(void)
{   DECL_MAYBE_SQ_GLOBAL_STRUCT
    sqInt midx;
    void *msecs;
    sqInt oop;
    sqInt oop1;
    sqInt oop2;
    sqInt result;
    sqInt runInNOut;
    char *sp;
    sqInt uidx;
    void *usecs;
    sqInt v1;
    sqInt v2;

	if (GIV(argumentCount) != 1) {
		/* begin primitiveFail */
		if (GIV(primFailCode) == 0) {
			GIV(primFailCode) = 1;
		}
		return null;
	}
	runInNOut = (longAt(GIV(stackPointer) + (0 * BytesPerWord))) == GIV(trueObj);
	ioGetClockLogSizeUsecsIdxMsecsIdx((&runInNOut), (&usecs), (&uidx), (&msecs), (&midx));
	result = instantiateClassindexableSize(longAt((GIV(specialObjectsOop) + BaseHeaderSize) + (ClassArray << ShiftForWord)), 5);
	if (result == 0) {
		/* begin primitiveFail */
		if (GIV(primFailCode) == 0) {
			GIV(primFailCode) = 1;
		}
		return null;
	}
	/* begin pushRemappableOop: */
	assert(addressCouldBeOop(result));
	GIV(remapBuffer)[(GIV(remapBufferCount) += 1)] = result;
	longAtput(((GIV(remapBuffer)[GIV(remapBufferCount)]) + BaseHeaderSize) + (0 << ShiftForWord), ((runInNOut << 1) | 1));
	v1 = positive32BitIntegerFor(((usqInt)usecs));
	v2 = positive32BitIntegerFor(((usqInt)msecs));
	if (!(GIV(primFailCode) == 0)) {
		/* begin popRemappableOop */
		oop = GIV(remapBuffer)[GIV(remapBufferCount)];
		GIV(remapBufferCount) -= 1;
		/* begin primitiveFail */
		if (GIV(primFailCode) == 0) {
			GIV(primFailCode) = 1;
		}
		return null;
	}
	/* begin storePointer:ofObject:withValue: */
	if ((((usqInt) (GIV(remapBuffer)[GIV(remapBufferCount)]))) < (((usqInt) GIV(youngStart)))) {
		possibleRootStoreIntovalue(GIV(remapBuffer)[GIV(remapBufferCount)], v1);
	}
	longAtput(((GIV(remapBuffer)[GIV(remapBufferCount)]) + BaseHeaderSize) + (1 << ShiftForWord), v1);
	longAtput(((GIV(remapBuffer)[GIV(remapBufferCount)]) + BaseHeaderSize) + (2 << ShiftForWord), ((uidx << 1) | 1));
	/* begin storePointer:ofObject:withValue: */
	if ((((usqInt) (GIV(remapBuffer)[GIV(remapBufferCount)]))) < (((usqInt) GIV(youngStart)))) {
		possibleRootStoreIntovalue(GIV(remapBuffer)[GIV(remapBufferCount)], v2);
	}
	longAtput(((GIV(remapBuffer)[GIV(remapBufferCount)]) + BaseHeaderSize) + (3 << ShiftForWord), v2);
	longAtput(((GIV(remapBuffer)[GIV(remapBufferCount)]) + BaseHeaderSize) + (4 << ShiftForWord), ((midx << 1) | 1));
	/* begin pop:thenPush: */
	/* begin popRemappableOop */
	oop2 = GIV(remapBuffer)[GIV(remapBufferCount)];
	GIV(remapBufferCount) -= 1;
	oop1 = oop2;
	longAtput(sp = GIV(stackPointer) + ((2 - 1) * BytesPerWord), oop1);
	GIV(stackPointer) = sp;
}


/*	Return a shallow copy of the receiver. */

static void
primitiveClone(void)
{   DECL_MAYBE_SQ_GLOBAL_STRUCT
    sqInt newCopy;
    char *sp;

	newCopy = clone(longAt(GIV(stackPointer)));
	if (newCopy == 0) {
		/* begin primitiveFail */
		if (GIV(primFailCode) == 0) {
			GIV(primFailCode) = 1;
		}
		return;
	}
	/* begin pop:thenPush: */
	longAtput(sp = GIV(stackPointer) + ((1 - 1) * BytesPerWord), newCopy);
	GIV(stackPointer) = sp;
}


/*	This is optional old obsolete stuff tedious to implement in Cog because of
	the need to map from machine code pc to bytecode pc. So for now just fail. */

static void
primitiveClosureCopyWithCopiedValues(void)
{   DECL_MAYBE_SQ_GLOBAL_STRUCT
	/* begin primitiveFail */
	if (GIV(primFailCode) == 0) {
		GIV(primFailCode) = 1;
	}
}

static void
primitiveClosureValue(void)
{   DECL_MAYBE_SQ_GLOBAL_STRUCT
    sqInt blockClosure;
    sqInt closureIP;
    sqInt closureMethod;
    CogMethod *cogMethod;
    CogMethod *cogMethod1;
    sqInt i;
    sqInt inInterpreter;
    sqInt methodHeader;
    sqInt methodHeader1;
    sqInt methodHeader2;
    sqInt numArgs;
    sqInt numCopied;
    sqInt object;
    sqInt object1;
    sqInt object2;
    sqInt object3;
    sqInt object4;
    sqInt oop;
    sqInt oop1;
    sqInt outerContext;
    sqInt outerContext1;
    char *sp;
    char *sp1;
    char *sp10;
    char *sp11;
    char *sp12;
    char *sp13;
    char *sp14;
    char *sp15;
    char *sp2;
    char *sp3;
    char *sp4;
    char *sp5;
    char *sp6;
    char *sp7;
    char *sp8;
    char *sp9;
    sqInt switched;
    sqInt theMethod;

	blockClosure = longAt(GIV(stackPointer) + (GIV(argumentCount) * BytesPerWord));
	/* begin quickFetchInteger:ofObject: */
	oop = longAt((blockClosure + BaseHeaderSize) + (ClosureNumArgsIndex << ShiftForWord));
	assert((oop & 1));
	numArgs = (oop >> 1);
	if (!(GIV(argumentCount) == numArgs)) {
		/* begin primitiveFail */
		if (GIV(primFailCode) == 0) {
			GIV(primFailCode) = 1;
		}
		return;
	}
	outerContext = longAt((blockClosure + BaseHeaderSize) + (ClosureOuterContextIndex << ShiftForWord));
	if (!(((outerContext & 1) == 0)
		 && (((((usqInt) (longAt(outerContext))) >> 12) & 31) == ClassMethodContextCompactIndex))) {
		/* begin primitiveFail */
		if (GIV(primFailCode) == 0) {
			GIV(primFailCode) = 1;
		}
		return;
	}

	/* Check if the closure's method is actually a CompiledMethod. */

	closureMethod = longAt((outerContext + BaseHeaderSize) + (MethodIndex << ShiftForWord));
	if (!(((closureMethod & 1) == 0)
		 && (((((usqInt) (longAt(closureMethod))) >> 8) & 15) >= 12))) {
		/* begin primitiveFail */
		if (GIV(primFailCode) == 0) {
			GIV(primFailCode) = 1;
		}
		return;
	}
	/* begin activateNewClosureMethod:numArgs:mayContextSwitch: */
	VM_LABEL(0activateNewClosureMethodnumArgsmayContextSwitch);
	outerContext1 = longAt((blockClosure + BaseHeaderSize) + (ClosureOuterContextIndex << ShiftForWord));
	assert(outerContext1 != blockClosure);
	numCopied = (fetchWordLengthOf(blockClosure)) - ClosureFirstCopiedValueIndex;
	theMethod = longAt((outerContext1 + BaseHeaderSize) + (MethodIndex << ShiftForWord));
	methodHeader = longAt((theMethod + BaseHeaderSize) + (HeaderIndex << ShiftForWord));
	if (isCogMethodReference(methodHeader)) {
		/* begin executeCogBlock:closure:mayContextSwitch: */
		/* begin cogMethodOf: */
		methodHeader1 = longAt((theMethod + BaseHeaderSize) + (HeaderIndex << ShiftForWord));
		assert((isNonIntegerObject(methodHeader1))
		 && ((((usqInt)methodHeader1)) < (startOfMemory())));
		cogMethod = ((CogMethod *) methodHeader1);
		assertCStackWellAligned();
		/* begin assertValidExecutionPointe:r:s: */
		assertValidExecutionPointersimbar(GIV(instructionPointer), GIV(framePointer), GIV(stackPointer), !((((usqInt)(longAt(GIV(framePointer) + FoxMethod)))) < heapBase));
		/* begin ensurePushedInstructionPointer */
		if ((((usqInt)GIV(instructionPointer))) >= heapBase) {
			/* begin iframeSavedIP:put: */
			assert(!(isMachineCodeFrame(GIV(framePointer))));
			longAtput(GIV(framePointer) + FoxIFSavedIP, GIV(instructionPointer));
			/* begin push: */
			object3 = ceReturnToInterpreterPC();
			longAtput(sp12 = GIV(stackPointer) - BytesPerWord, object3);
			GIV(stackPointer) = sp12;
		}
		else {
			/* begin push: */
			longAtput(sp13 = GIV(stackPointer) - BytesPerWord, GIV(instructionPointer));
			GIV(stackPointer) = sp13;
		}
		/* begin push: */
		object = (((sqInt)cogMethod)) + ((1
	? (cogMethod->blockEntryOffset)
	: ((cogMethod->blockEntryOffset)) - (noContextSwitchBlockEntryOffset())));
		longAtput(sp = GIV(stackPointer) - BytesPerWord, object);
		GIV(stackPointer) = sp;
		/* begin push: */
		longAtput(sp1 = GIV(stackPointer) - BytesPerWord, blockClosure);
		GIV(stackPointer) = sp1;
		ceEnterCogCodePopReceiverReg();
		goto l1;
	}
	if (((((usqInt) methodHeader) >> 10) & 255) <= maxLiteralCountForCompile) {
		if (theMethod == GIV(lastCoggableInterpretedBlockMethod)) {
			if (theMethod != GIV(lastUncoggableInterpretedBlockMethod)) {
				cogselector(theMethod, GIV(nilObj));
				if (methodHasCogMethod(theMethod)) {
					/* begin executeCogBlock:closure:mayContextSwitch: */
					/* begin cogMethodOf: */
					methodHeader2 = longAt((theMethod + BaseHeaderSize) + (HeaderIndex << ShiftForWord));
					assert((isNonIntegerObject(methodHeader2))
					 && ((((usqInt)methodHeader2)) < (startOfMemory())));
					cogMethod1 = ((CogMethod *) methodHeader2);
					assertCStackWellAligned();
					/* begin assertValidExecutionPointe:r:s: */
					assertValidExecutionPointersimbar(GIV(instructionPointer), GIV(framePointer), GIV(stackPointer), !((((usqInt)(longAt(GIV(framePointer) + FoxMethod)))) < heapBase));
					/* begin ensurePushedInstructionPointer */
					if ((((usqInt)GIV(instructionPointer))) >= heapBase) {
						/* begin iframeSavedIP:put: */
						assert(!(isMachineCodeFrame(GIV(framePointer))));
						longAtput(GIV(framePointer) + FoxIFSavedIP, GIV(instructionPointer));
						/* begin push: */
						object4 = ceReturnToInterpreterPC();
						longAtput(sp14 = GIV(stackPointer) - BytesPerWord, object4);
						GIV(stackPointer) = sp14;
					}
					else {
						/* begin push: */
						longAtput(sp15 = GIV(stackPointer) - BytesPerWord, GIV(instructionPointer));
						GIV(stackPointer) = sp15;
					}
					/* begin push: */
					object1 = (((sqInt)cogMethod1)) + ((1
	? (cogMethod1->blockEntryOffset)
	: ((cogMethod1->blockEntryOffset)) - (noContextSwitchBlockEntryOffset())));
					longAtput(sp2 = GIV(stackPointer) - BytesPerWord, object1);
					GIV(stackPointer) = sp2;
					/* begin push: */
					longAtput(sp11 = GIV(stackPointer) - BytesPerWord, blockClosure);
					GIV(stackPointer) = sp11;
					ceEnterCogCodePopReceiverReg();
					goto l1;
				}
				if (!(GIV(cogCompiledCodeCompactionCalledFor))) {
					GIV(lastUncoggableInterpretedBlockMethod) = theMethod;
				}
			}
		}
		else {
			GIV(lastCoggableInterpretedBlockMethod) = theMethod;
		}
	}
	else {
		maybeFlagMethodAsInterpreted(theMethod);
	}
	assert(!(methodHasCogMethod(theMethod)));
	if (!((inInterpreter = GIV(instructionPointer) >= heapBase))) {
		if (GIV(instructionPointer) == (ceReturnToInterpreterPC())) {
			GIV(instructionPointer) = longAt(GIV(framePointer) + FoxIFSavedIP);
		}
	}
	/* begin push: */
	longAtput(sp4 = GIV(stackPointer) - BytesPerWord, GIV(instructionPointer));
	GIV(stackPointer) = sp4;
	/* begin push: */
	longAtput(sp5 = GIV(stackPointer) - BytesPerWord, GIV(framePointer));
	GIV(stackPointer) = sp5;
	GIV(framePointer) = GIV(stackPointer);
	/* begin push: */
	longAtput(sp6 = GIV(stackPointer) - BytesPerWord, theMethod);
	GIV(stackPointer) = sp6;
	/* begin push: */
	longAtput(sp7 = GIV(stackPointer) - BytesPerWord, GIV(nilObj));
	GIV(stackPointer) = sp7;
	/* begin push: */
	object2 = (VMBIGENDIAN
		? ((1 + (numArgs << ((BytesPerWord * 8) - 8))) + ((0
	? 1 << ((BytesPerWord * 8) - 16)
	: 0))) + ((1
	? 1 << ((BytesPerWord * 8) - 24)
	: 0))
		: ((1 + (numArgs << 8)) + ((0
	? 1 << 16
	: 0))) + ((1
	? 1 << 24
	: 0)));
	longAtput(sp8 = GIV(stackPointer) - BytesPerWord, object2);
	GIV(stackPointer) = sp8;
	/* begin push: */
	longAtput(sp9 = GIV(stackPointer) - BytesPerWord, 0);
	GIV(stackPointer) = sp9;
	/* begin push: */
	longAtput(sp10 = GIV(stackPointer) - BytesPerWord, longAt((outerContext1 + BaseHeaderSize) + (ReceiverIndex << ShiftForWord)));
	GIV(stackPointer) = sp10;
	for (i = 0; i <= (numCopied - 1); i += 1) {
		/* begin push: */
		longAtput(sp3 = GIV(stackPointer) - BytesPerWord, longAt((blockClosure + BaseHeaderSize) + ((i + ClosureFirstCopiedValueIndex) << ShiftForWord)));
		GIV(stackPointer) = sp3;
	}
	assert(frameIsBlockActivation(GIV(framePointer)));
	assert(!(frameHasContext(GIV(framePointer))));
	/* begin quickFetchInteger:ofObject: */
	oop1 = longAt((blockClosure + BaseHeaderSize) + (ClosureStartPCIndex << ShiftForWord));
	assert((oop1 & 1));
	closureIP = (oop1 >> 1);
	GIV(instructionPointer) = ((theMethod + closureIP) + BaseHeaderSize) - 2;
	/* begin setMethod: */
	assert((((usqInt)theMethod)) >= (startOfMemory()));
	GIV(method) = theMethod;
	switched = 0;
	if (GIV(stackPointer) < GIV(stackLimit)) {
		switched = handleStackOverflowOrEventAllowContextSwitch(1);
	}
	returnToExecutivepostContextSwitch(inInterpreter, switched);
l1:	/* end activateNewClosureMethod:numArgs:mayContextSwitch: */;
}


/*	An exact clone of primitiveClosureValue except that this version will not
	check for interrupts on stack overflow. It may invoke the garbage
	collector but will not switch processes. See
	checkForInterruptsMayContextSwitch:  */

void
primitiveClosureValueNoContextSwitch(void)
{   DECL_MAYBE_SQ_GLOBAL_STRUCT
    sqInt blockClosure;
    sqInt closureIP;
    sqInt closureMethod;
    CogMethod *cogMethod;
    CogMethod *cogMethod1;
    sqInt i;
    sqInt inInterpreter;
    sqInt methodHeader;
    sqInt methodHeader1;
    sqInt methodHeader2;
    sqInt numArgs;
    sqInt numCopied;
    sqInt object;
    sqInt object1;
    sqInt object2;
    sqInt object3;
    sqInt object4;
    sqInt oop;
    sqInt oop1;
    sqInt outerContext;
    sqInt outerContext1;
    char *sp;
    char *sp1;
    char *sp10;
    char *sp11;
    char *sp12;
    char *sp13;
    char *sp14;
    char *sp15;
    char *sp2;
    char *sp3;
    char *sp4;
    char *sp5;
    char *sp6;
    char *sp7;
    char *sp8;
    char *sp9;
    sqInt switched;
    sqInt theMethod;

	blockClosure = longAt(GIV(stackPointer) + (GIV(argumentCount) * BytesPerWord));
	/* begin quickFetchInteger:ofObject: */
	oop = longAt((blockClosure + BaseHeaderSize) + (ClosureNumArgsIndex << ShiftForWord));
	assert((oop & 1));
	numArgs = (oop >> 1);
	if (!(GIV(argumentCount) == numArgs)) {
		/* begin primitiveFail */
		if (GIV(primFailCode) == 0) {
			GIV(primFailCode) = 1;
		}
		return;
	}
	outerContext = longAt((blockClosure + BaseHeaderSize) + (ClosureOuterContextIndex << ShiftForWord));
	if (!(((outerContext & 1) == 0)
		 && (((((usqInt) (longAt(outerContext))) >> 12) & 31) == ClassMethodContextCompactIndex))) {
		/* begin primitiveFail */
		if (GIV(primFailCode) == 0) {
			GIV(primFailCode) = 1;
		}
		return;
	}

	/* Check if the closure's method is actually a CompiledMethod. */

	closureMethod = longAt((outerContext + BaseHeaderSize) + (MethodIndex << ShiftForWord));
	if (!(((closureMethod & 1) == 0)
		 && (((((usqInt) (longAt(closureMethod))) >> 8) & 15) >= 12))) {
		/* begin primitiveFail */
		if (GIV(primFailCode) == 0) {
			GIV(primFailCode) = 1;
		}
		return;
	}
	/* begin activateNewClosureMethod:numArgs:mayContextSwitch: */
	VM_LABEL(1activateNewClosureMethodnumArgsmayContextSwitch);
	outerContext1 = longAt((blockClosure + BaseHeaderSize) + (ClosureOuterContextIndex << ShiftForWord));
	assert(outerContext1 != blockClosure);
	numCopied = (fetchWordLengthOf(blockClosure)) - ClosureFirstCopiedValueIndex;
	theMethod = longAt((outerContext1 + BaseHeaderSize) + (MethodIndex << ShiftForWord));
	methodHeader = longAt((theMethod + BaseHeaderSize) + (HeaderIndex << ShiftForWord));
	if (isCogMethodReference(methodHeader)) {
		/* begin executeCogBlock:closure:mayContextSwitch: */
		/* begin cogMethodOf: */
		methodHeader1 = longAt((theMethod + BaseHeaderSize) + (HeaderIndex << ShiftForWord));
		assert((isNonIntegerObject(methodHeader1))
		 && ((((usqInt)methodHeader1)) < (startOfMemory())));
		cogMethod = ((CogMethod *) methodHeader1);
		assertCStackWellAligned();
		/* begin assertValidExecutionPointe:r:s: */
		assertValidExecutionPointersimbar(GIV(instructionPointer), GIV(framePointer), GIV(stackPointer), !((((usqInt)(longAt(GIV(framePointer) + FoxMethod)))) < heapBase));
		/* begin ensurePushedInstructionPointer */
		if ((((usqInt)GIV(instructionPointer))) >= heapBase) {
			/* begin iframeSavedIP:put: */
			assert(!(isMachineCodeFrame(GIV(framePointer))));
			longAtput(GIV(framePointer) + FoxIFSavedIP, GIV(instructionPointer));
			/* begin push: */
			object3 = ceReturnToInterpreterPC();
			longAtput(sp12 = GIV(stackPointer) - BytesPerWord, object3);
			GIV(stackPointer) = sp12;
		}
		else {
			/* begin push: */
			longAtput(sp13 = GIV(stackPointer) - BytesPerWord, GIV(instructionPointer));
			GIV(stackPointer) = sp13;
		}
		/* begin push: */
		object = (((sqInt)cogMethod)) + ((0
	? (cogMethod->blockEntryOffset)
	: ((cogMethod->blockEntryOffset)) - (noContextSwitchBlockEntryOffset())));
		longAtput(sp = GIV(stackPointer) - BytesPerWord, object);
		GIV(stackPointer) = sp;
		/* begin push: */
		longAtput(sp1 = GIV(stackPointer) - BytesPerWord, blockClosure);
		GIV(stackPointer) = sp1;
		ceEnterCogCodePopReceiverReg();
		goto l1;
	}
	if (((((usqInt) methodHeader) >> 10) & 255) <= maxLiteralCountForCompile) {
		if (theMethod == GIV(lastCoggableInterpretedBlockMethod)) {
			if (theMethod != GIV(lastUncoggableInterpretedBlockMethod)) {
				cogselector(theMethod, GIV(nilObj));
				if (methodHasCogMethod(theMethod)) {
					/* begin executeCogBlock:closure:mayContextSwitch: */
					/* begin cogMethodOf: */
					methodHeader2 = longAt((theMethod + BaseHeaderSize) + (HeaderIndex << ShiftForWord));
					assert((isNonIntegerObject(methodHeader2))
					 && ((((usqInt)methodHeader2)) < (startOfMemory())));
					cogMethod1 = ((CogMethod *) methodHeader2);
					assertCStackWellAligned();
					/* begin assertValidExecutionPointe:r:s: */
					assertValidExecutionPointersimbar(GIV(instructionPointer), GIV(framePointer), GIV(stackPointer), !((((usqInt)(longAt(GIV(framePointer) + FoxMethod)))) < heapBase));
					/* begin ensurePushedInstructionPointer */
					if ((((usqInt)GIV(instructionPointer))) >= heapBase) {
						/* begin iframeSavedIP:put: */
						assert(!(isMachineCodeFrame(GIV(framePointer))));
						longAtput(GIV(framePointer) + FoxIFSavedIP, GIV(instructionPointer));
						/* begin push: */
						object4 = ceReturnToInterpreterPC();
						longAtput(sp14 = GIV(stackPointer) - BytesPerWord, object4);
						GIV(stackPointer) = sp14;
					}
					else {
						/* begin push: */
						longAtput(sp15 = GIV(stackPointer) - BytesPerWord, GIV(instructionPointer));
						GIV(stackPointer) = sp15;
					}
					/* begin push: */
					object1 = (((sqInt)cogMethod1)) + ((0
	? (cogMethod1->blockEntryOffset)
	: ((cogMethod1->blockEntryOffset)) - (noContextSwitchBlockEntryOffset())));
					longAtput(sp2 = GIV(stackPointer) - BytesPerWord, object1);
					GIV(stackPointer) = sp2;
					/* begin push: */
					longAtput(sp11 = GIV(stackPointer) - BytesPerWord, blockClosure);
					GIV(stackPointer) = sp11;
					ceEnterCogCodePopReceiverReg();
					goto l1;
				}
				if (!(GIV(cogCompiledCodeCompactionCalledFor))) {
					GIV(lastUncoggableInterpretedBlockMethod) = theMethod;
				}
			}
		}
		else {
			GIV(lastCoggableInterpretedBlockMethod) = theMethod;
		}
	}
	else {
		maybeFlagMethodAsInterpreted(theMethod);
	}
	assert(!(methodHasCogMethod(theMethod)));
	if (!((inInterpreter = GIV(instructionPointer) >= heapBase))) {
		if (GIV(instructionPointer) == (ceReturnToInterpreterPC())) {
			GIV(instructionPointer) = longAt(GIV(framePointer) + FoxIFSavedIP);
		}
	}
	/* begin push: */
	longAtput(sp4 = GIV(stackPointer) - BytesPerWord, GIV(instructionPointer));
	GIV(stackPointer) = sp4;
	/* begin push: */
	longAtput(sp5 = GIV(stackPointer) - BytesPerWord, GIV(framePointer));
	GIV(stackPointer) = sp5;
	GIV(framePointer) = GIV(stackPointer);
	/* begin push: */
	longAtput(sp6 = GIV(stackPointer) - BytesPerWord, theMethod);
	GIV(stackPointer) = sp6;
	/* begin push: */
	longAtput(sp7 = GIV(stackPointer) - BytesPerWord, GIV(nilObj));
	GIV(stackPointer) = sp7;
	/* begin push: */
	object2 = (VMBIGENDIAN
		? ((1 + (numArgs << ((BytesPerWord * 8) - 8))) + ((0
	? 1 << ((BytesPerWord * 8) - 16)
	: 0))) + ((1
	? 1 << ((BytesPerWord * 8) - 24)
	: 0))
		: ((1 + (numArgs << 8)) + ((0
	? 1 << 16
	: 0))) + ((1
	? 1 << 24
	: 0)));
	longAtput(sp8 = GIV(stackPointer) - BytesPerWord, object2);
	GIV(stackPointer) = sp8;
	/* begin push: */
	longAtput(sp9 = GIV(stackPointer) - BytesPerWord, 0);
	GIV(stackPointer) = sp9;
	/* begin push: */
	longAtput(sp10 = GIV(stackPointer) - BytesPerWord, longAt((outerContext1 + BaseHeaderSize) + (ReceiverIndex << ShiftForWord)));
	GIV(stackPointer) = sp10;
	for (i = 0; i <= (numCopied - 1); i += 1) {
		/* begin push: */
		longAtput(sp3 = GIV(stackPointer) - BytesPerWord, longAt((blockClosure + BaseHeaderSize) + ((i + ClosureFirstCopiedValueIndex) << ShiftForWord)));
		GIV(stackPointer) = sp3;
	}
	assert(frameIsBlockActivation(GIV(framePointer)));
	assert(!(frameHasContext(GIV(framePointer))));
	/* begin quickFetchInteger:ofObject: */
	oop1 = longAt((blockClosure + BaseHeaderSize) + (ClosureStartPCIndex << ShiftForWord));
	assert((oop1 & 1));
	closureIP = (oop1 >> 1);
	GIV(instructionPointer) = ((theMethod + closureIP) + BaseHeaderSize) - 2;
	/* begin setMethod: */
	assert((((usqInt)theMethod)) >= (startOfMemory()));
	GIV(method) = theMethod;
	switched = 0;
	if (GIV(stackPointer) < GIV(stackLimit)) {
		switched = handleStackOverflowOrEventAllowContextSwitch(0);
	}
	returnToExecutivepostContextSwitch(inInterpreter, switched);
l1:	/* end activateNewClosureMethod:numArgs:mayContextSwitch: */;
}

static void
primitiveClosureValueWithArgs(void)
{   DECL_MAYBE_SQ_GLOBAL_STRUCT
    sqInt argumentArray;
    sqInt arraySize;
    sqInt blockClosure;
    sqInt closureIP;
    sqInt closureMethod;
    CogMethod *cogMethod;
    CogMethod *cogMethod1;
    sqInt header;
    sqInt i;
    sqInt index;
    sqInt inInterpreter;
    sqInt methodHeader;
    sqInt methodHeader1;
    sqInt methodHeader2;
    sqInt numArgs;
    sqInt numCopied;
    sqInt object;
    sqInt object1;
    sqInt object2;
    sqInt object3;
    sqInt object4;
    sqInt oop;
    sqInt oop1;
    sqInt outerContext;
    sqInt outerContext1;
    char *sp;
    char *sp1;
    char *sp10;
    char *sp11;
    char *sp12;
    char *sp13;
    char *sp14;
    char *sp15;
    char *sp16;
    char *sp2;
    char *sp3;
    char *sp4;
    char *sp5;
    char *sp6;
    char *sp7;
    char *sp8;
    char *sp9;
    sqInt switched;
    sqInt sz;
    sqInt theMethod;
    sqInt top;

	argumentArray = longAt(GIV(stackPointer));
	if (!(((argumentArray & 1) == 0)
		 && (((((usqInt) (longAt(argumentArray))) >> 8) & 15) == 2))) {
		/* begin primitiveFail */
		if (GIV(primFailCode) == 0) {
			GIV(primFailCode) = 1;
		}
		return;
	}
	/* begin fetchWordLengthOf: */
	/* begin sizeBitsOf: */
	header = longAt(argumentArray);
	sz = ((header & TypeMask) == HeaderTypeSizeAndClass
		? (longAt(argumentArray - (BytesPerWord * 2))) & LongSizeMask
		: header & SizeMask);
	arraySize = ((usqInt) (sz - BaseHeaderSize)) >> ShiftForWord;
	if (!(roomToPushNArgs(arraySize))) {
		/* begin primitiveFail */
		if (GIV(primFailCode) == 0) {
			GIV(primFailCode) = 1;
		}
		return;
	}
	blockClosure = longAt(GIV(stackPointer) + (GIV(argumentCount) * BytesPerWord));
	/* begin quickFetchInteger:ofObject: */
	oop = longAt((blockClosure + BaseHeaderSize) + (ClosureNumArgsIndex << ShiftForWord));
	assert((oop & 1));
	numArgs = (oop >> 1);
	if (!(arraySize == numArgs)) {
		/* begin primitiveFail */
		if (GIV(primFailCode) == 0) {
			GIV(primFailCode) = 1;
		}
		return;
	}
	outerContext = longAt((blockClosure + BaseHeaderSize) + (ClosureOuterContextIndex << ShiftForWord));
	if (!(((outerContext & 1) == 0)
		 && (((((usqInt) (longAt(outerContext))) >> 12) & 31) == ClassMethodContextCompactIndex))) {
		/* begin primitiveFail */
		if (GIV(primFailCode) == 0) {
			GIV(primFailCode) = 1;
		}
		return;
	}

	/* Check if the closure's method is actually a CompiledMethod. */

	closureMethod = longAt((outerContext + BaseHeaderSize) + (MethodIndex << ShiftForWord));
	if (!(((closureMethod & 1) == 0)
		 && (((((usqInt) (longAt(closureMethod))) >> 8) & 15) >= 12))) {
		/* begin primitiveFail */
		if (GIV(primFailCode) == 0) {
			GIV(primFailCode) = 1;
		}
		return;
	}
	/* begin popStack */
	top = longAt(GIV(stackPointer));
	GIV(stackPointer) += BytesPerWord;
	index = 1;
	while (index <= numArgs) {
		/* begin push: */
		longAtput(sp = GIV(stackPointer) - BytesPerWord, longAt((argumentArray + BaseHeaderSize) + ((index - 1) << ShiftForWord)));
		GIV(stackPointer) = sp;
		index += 1;
	}
	/* begin activateNewClosureMethod:numArgs:mayContextSwitch: */
	VM_LABEL(2activateNewClosureMethodnumArgsmayContextSwitch);
	outerContext1 = longAt((blockClosure + BaseHeaderSize) + (ClosureOuterContextIndex << ShiftForWord));
	assert(outerContext1 != blockClosure);
	numCopied = (fetchWordLengthOf(blockClosure)) - ClosureFirstCopiedValueIndex;
	theMethod = longAt((outerContext1 + BaseHeaderSize) + (MethodIndex << ShiftForWord));
	methodHeader = longAt((theMethod + BaseHeaderSize) + (HeaderIndex << ShiftForWord));
	if (isCogMethodReference(methodHeader)) {
		/* begin executeCogBlock:closure:mayContextSwitch: */
		/* begin cogMethodOf: */
		methodHeader1 = longAt((theMethod + BaseHeaderSize) + (HeaderIndex << ShiftForWord));
		assert((isNonIntegerObject(methodHeader1))
		 && ((((usqInt)methodHeader1)) < (startOfMemory())));
		cogMethod = ((CogMethod *) methodHeader1);
		assertCStackWellAligned();
		/* begin assertValidExecutionPointe:r:s: */
		assertValidExecutionPointersimbar(GIV(instructionPointer), GIV(framePointer), GIV(stackPointer), !((((usqInt)(longAt(GIV(framePointer) + FoxMethod)))) < heapBase));
		/* begin ensurePushedInstructionPointer */
		if ((((usqInt)GIV(instructionPointer))) >= heapBase) {
			/* begin iframeSavedIP:put: */
			assert(!(isMachineCodeFrame(GIV(framePointer))));
			longAtput(GIV(framePointer) + FoxIFSavedIP, GIV(instructionPointer));
			/* begin push: */
			object3 = ceReturnToInterpreterPC();
			longAtput(sp12 = GIV(stackPointer) - BytesPerWord, object3);
			GIV(stackPointer) = sp12;
		}
		else {
			/* begin push: */
			longAtput(sp13 = GIV(stackPointer) - BytesPerWord, GIV(instructionPointer));
			GIV(stackPointer) = sp13;
		}
		/* begin push: */
		object = (((sqInt)cogMethod)) + ((1
	? (cogMethod->blockEntryOffset)
	: ((cogMethod->blockEntryOffset)) - (noContextSwitchBlockEntryOffset())));
		longAtput(sp16 = GIV(stackPointer) - BytesPerWord, object);
		GIV(stackPointer) = sp16;
		/* begin push: */
		longAtput(sp1 = GIV(stackPointer) - BytesPerWord, blockClosure);
		GIV(stackPointer) = sp1;
		ceEnterCogCodePopReceiverReg();
		goto l1;
	}
	if (((((usqInt) methodHeader) >> 10) & 255) <= maxLiteralCountForCompile) {
		if (theMethod == GIV(lastCoggableInterpretedBlockMethod)) {
			if (theMethod != GIV(lastUncoggableInterpretedBlockMethod)) {
				cogselector(theMethod, GIV(nilObj));
				if (methodHasCogMethod(theMethod)) {
					/* begin executeCogBlock:closure:mayContextSwitch: */
					/* begin cogMethodOf: */
					methodHeader2 = longAt((theMethod + BaseHeaderSize) + (HeaderIndex << ShiftForWord));
					assert((isNonIntegerObject(methodHeader2))
					 && ((((usqInt)methodHeader2)) < (startOfMemory())));
					cogMethod1 = ((CogMethod *) methodHeader2);
					assertCStackWellAligned();
					/* begin assertValidExecutionPointe:r:s: */
					assertValidExecutionPointersimbar(GIV(instructionPointer), GIV(framePointer), GIV(stackPointer), !((((usqInt)(longAt(GIV(framePointer) + FoxMethod)))) < heapBase));
					/* begin ensurePushedInstructionPointer */
					if ((((usqInt)GIV(instructionPointer))) >= heapBase) {
						/* begin iframeSavedIP:put: */
						assert(!(isMachineCodeFrame(GIV(framePointer))));
						longAtput(GIV(framePointer) + FoxIFSavedIP, GIV(instructionPointer));
						/* begin push: */
						object4 = ceReturnToInterpreterPC();
						longAtput(sp14 = GIV(stackPointer) - BytesPerWord, object4);
						GIV(stackPointer) = sp14;
					}
					else {
						/* begin push: */
						longAtput(sp15 = GIV(stackPointer) - BytesPerWord, GIV(instructionPointer));
						GIV(stackPointer) = sp15;
					}
					/* begin push: */
					object1 = (((sqInt)cogMethod1)) + ((1
	? (cogMethod1->blockEntryOffset)
	: ((cogMethod1->blockEntryOffset)) - (noContextSwitchBlockEntryOffset())));
					longAtput(sp2 = GIV(stackPointer) - BytesPerWord, object1);
					GIV(stackPointer) = sp2;
					/* begin push: */
					longAtput(sp11 = GIV(stackPointer) - BytesPerWord, blockClosure);
					GIV(stackPointer) = sp11;
					ceEnterCogCodePopReceiverReg();
					goto l1;
				}
				if (!(GIV(cogCompiledCodeCompactionCalledFor))) {
					GIV(lastUncoggableInterpretedBlockMethod) = theMethod;
				}
			}
		}
		else {
			GIV(lastCoggableInterpretedBlockMethod) = theMethod;
		}
	}
	else {
		maybeFlagMethodAsInterpreted(theMethod);
	}
	assert(!(methodHasCogMethod(theMethod)));
	if (!((inInterpreter = GIV(instructionPointer) >= heapBase))) {
		if (GIV(instructionPointer) == (ceReturnToInterpreterPC())) {
			GIV(instructionPointer) = longAt(GIV(framePointer) + FoxIFSavedIP);
		}
	}
	/* begin push: */
	longAtput(sp4 = GIV(stackPointer) - BytesPerWord, GIV(instructionPointer));
	GIV(stackPointer) = sp4;
	/* begin push: */
	longAtput(sp5 = GIV(stackPointer) - BytesPerWord, GIV(framePointer));
	GIV(stackPointer) = sp5;
	GIV(framePointer) = GIV(stackPointer);
	/* begin push: */
	longAtput(sp6 = GIV(stackPointer) - BytesPerWord, theMethod);
	GIV(stackPointer) = sp6;
	/* begin push: */
	longAtput(sp7 = GIV(stackPointer) - BytesPerWord, GIV(nilObj));
	GIV(stackPointer) = sp7;
	/* begin push: */
	object2 = (VMBIGENDIAN
		? ((1 + (numArgs << ((BytesPerWord * 8) - 8))) + ((0
	? 1 << ((BytesPerWord * 8) - 16)
	: 0))) + ((1
	? 1 << ((BytesPerWord * 8) - 24)
	: 0))
		: ((1 + (numArgs << 8)) + ((0
	? 1 << 16
	: 0))) + ((1
	? 1 << 24
	: 0)));
	longAtput(sp8 = GIV(stackPointer) - BytesPerWord, object2);
	GIV(stackPointer) = sp8;
	/* begin push: */
	longAtput(sp9 = GIV(stackPointer) - BytesPerWord, 0);
	GIV(stackPointer) = sp9;
	/* begin push: */
	longAtput(sp10 = GIV(stackPointer) - BytesPerWord, longAt((outerContext1 + BaseHeaderSize) + (ReceiverIndex << ShiftForWord)));
	GIV(stackPointer) = sp10;
	for (i = 0; i <= (numCopied - 1); i += 1) {
		/* begin push: */
		longAtput(sp3 = GIV(stackPointer) - BytesPerWord, longAt((blockClosure + BaseHeaderSize) + ((i + ClosureFirstCopiedValueIndex) << ShiftForWord)));
		GIV(stackPointer) = sp3;
	}
	assert(frameIsBlockActivation(GIV(framePointer)));
	assert(!(frameHasContext(GIV(framePointer))));
	/* begin quickFetchInteger:ofObject: */
	oop1 = longAt((blockClosure + BaseHeaderSize) + (ClosureStartPCIndex << ShiftForWord));
	assert((oop1 & 1));
	closureIP = (oop1 >> 1);
	GIV(instructionPointer) = ((theMethod + closureIP) + BaseHeaderSize) - 2;
	/* begin setMethod: */
	assert((((usqInt)theMethod)) >= (startOfMemory()));
	GIV(method) = theMethod;
	switched = 0;
	if (GIV(stackPointer) < GIV(stackLimit)) {
		switched = handleStackOverflowOrEventAllowContextSwitch(1);
	}
	returnToExecutivepostContextSwitch(inInterpreter, switched);
l1:	/* end activateNewClosureMethod:numArgs:mayContextSwitch: */;
}


/*	Answer the contents of the code zone as an array of pair-wise element,
	address in ascending address order.
	Answer a string for a runtime routine or abstract label (beginning, end,
	etc), a CompiledMethod for a CMMethod,
	or a selector (presumably a Symbol) for a PIC. */

static void
primitiveCollectCogCodeConstituents(void)
{   DECL_MAYBE_SQ_GLOBAL_STRUCT
    sqInt constituents;
    char *sp;

	constituents = cogCodeConstituents();
	if (constituents == null) {
		GIV(primFailCode) = PrimErrNoMemory; return;
	}
	/* begin pop:thenPush: */
	longAtput(sp = GIV(stackPointer) + ((1 - 1) * BytesPerWord), constituents);
	GIV(stackPointer) = sp;
}


/*	Primitive. Compare two byte-indexed objects for equality */

EXPORT(sqInt)
primitiveCompareBytes(void)
{   DECL_MAYBE_SQ_GLOBAL_STRUCT
    sqInt arg1;
    sqInt arg2;
    sqInt i;
    sqInt len1;
    sqInt len2;
    char *sp;
    char *sp1;
    char *sp2;
    char *sp3;

	if (!(GIV(argumentCount) == 1)) {
		/* begin primitiveFail */
		if (GIV(primFailCode) == 0) {
			GIV(primFailCode) = 1;
		}
		return null;
	}
	arg1 = longAt(GIV(stackPointer) + (1 * BytesPerWord));
	arg2 = longAt(GIV(stackPointer) + (0 * BytesPerWord));
	if (!((((arg1 & 1) == 0)
 && (((((usqInt) (longAt(arg1))) >> 8) & 15) >= 8))
		 && (((arg2 & 1) == 0)
 && (((((usqInt) (longAt(arg2))) >> 8) & 15) >= 8)))) {
		/* begin primitiveFail */
		if (GIV(primFailCode) == 0) {
			GIV(primFailCode) = 1;
		}
		return null;
	}
	if (arg1 == arg2) {
		/* begin pop:thenPush: */
		longAtput(sp = GIV(stackPointer) + ((2 - 1) * BytesPerWord), GIV(trueObj));
		GIV(stackPointer) = sp;
		return null;
	}
	len1 = byteSizeOf(arg1);
	len2 = byteSizeOf(arg2);
	if (!(len1 == len2)) {
		/* begin pop:thenPush: */
		longAtput(sp1 = GIV(stackPointer) + ((2 - 1) * BytesPerWord), GIV(falseObj));
		GIV(stackPointer) = sp1;
		return null;
	}
	for (i = 0; i <= (len1 - 1); i += 1) {
		if (!((byteAt((arg1 + BaseHeaderSize) + i)) == (byteAt((arg2 + BaseHeaderSize) + i)))) {
			/* begin pop:thenPush: */
			longAtput(sp2 = GIV(stackPointer) + ((2 - 1) * BytesPerWord), GIV(falseObj));
			GIV(stackPointer) = sp2;
			return null;
		}
	}
	/* begin pop:thenPush: */
	longAtput(sp3 = GIV(stackPointer) + ((2 - 1) * BytesPerWord), GIV(trueObj));
	GIV(stackPointer) = sp3;
}


/*	Fill the receiver, which must be an indexable bytes or words 
	objects, with the given integer value. */

static void
primitiveConstantFill(void)
{   DECL_MAYBE_SQ_GLOBAL_STRUCT
    usqInt end;
    sqInt fillValue;
    usqInt i;
    sqInt rcvr;
    sqInt rcvrIsBytes;
    sqInt successBoolean;
    sqInt successBoolean1;

	fillValue = positive32BitValueOf(longAt(GIV(stackPointer)));
	rcvr = longAt(GIV(stackPointer) + (1 * BytesPerWord));
	/* begin success: */
	successBoolean1 = ((rcvr & 1) == 0)
	 && (isWordsOrBytesNonInt(rcvr));
	if (!(successBoolean1)) {
		if (GIV(primFailCode) == 0) {

			/* Don't overwrite an error code that has already been set. */

			GIV(primFailCode) = 1;
		}
	}
	rcvrIsBytes = ((rcvr & 1) == 0)
	 && (((((usqInt) (longAt(rcvr))) >> 8) & 15) >= 8);
	if (rcvrIsBytes) {
		/* begin success: */
		successBoolean = (fillValue >= 0)
		 && (fillValue <= 255);
		if (!(successBoolean)) {
			if (GIV(primFailCode) == 0) {

				/* Don't overwrite an error code that has already been set. */

				GIV(primFailCode) = 1;
			}
		}
	}
	if (GIV(primFailCode) == 0) {
		end = rcvr + (sizeBitsOf(rcvr));
		i = rcvr + BaseHeaderSize;
		if (rcvrIsBytes) {
			while (i < end) {
				byteAtput(i, fillValue);
				i += 1;
			}
		}
		else {
			while (i < end) {
				long32Atput(i, fillValue);
				i += 4;
			}
		}
		/* begin pop: */
		GIV(stackPointer) += 1 * BytesPerWord;
	}
}

static void
primitiveContextAt(void)
{   DECL_MAYBE_SQ_GLOBAL_STRUCT
    sqInt aContext;
    sqInt ccIndex;
    sqInt class;
    sqInt classFormat;
    sqInt fixedFields;
    sqInt fmt;
    sqInt frameNumArgs;
    sqInt frameNumArgs1;
    sqInt hdr;
    sqInt index;
    char *sp;
    char *sp1;
    sqInt sp11;
    char *sp2;
    sqInt sp3;
    char *spouseFP;
    sqInt stSize;
    sqInt sz;
    sqInt totalLength;
    sqInt value;
    sqInt value1;

	index = longAt(GIV(stackPointer));
	if (!((index & 1))) {
		/* begin primitiveFail */
		if (GIV(primFailCode) == 0) {
			GIV(primFailCode) = 1;
		}
		return;
	}
	index = (index >> 1);

	/* Duplicating much of stObject:at:put: here allows stObject:at:put: to omit tests for contexts. */

	aContext = longAt(GIV(stackPointer) + (1 * BytesPerWord));
	hdr = longAt(aContext);
	if (!(((((usqInt) hdr) >> 12) & 31) == ClassMethodContextCompactIndex)) {

		/* might be an instance of a subclass */

		value = stObjectat(aContext, index);
		/* begin pop:thenPush: */
		longAtput(sp = GIV(stackPointer) + ((2 - 1) * BytesPerWord), value);
		GIV(stackPointer) = sp;
		return;
	}
	/* begin externalWriteBackHeadFramePointers */
	assert((GIV(framePointer) - GIV(stackPointer)) < LargeContextSize);
	assert(GIV(stackPage) == (mostRecentlyUsedPage()));
	/* begin setHeadFP:andSP:inPage: */
	assert(GIV(stackPointer) < GIV(framePointer));
	assert((GIV(stackPointer) < ((GIV(stackPage)->baseAddress)))
	 && (GIV(stackPointer) > (((GIV(stackPage)->realStackLimit)) - LargeContextSize)));
	assert((GIV(framePointer) < ((GIV(stackPage)->baseAddress)))
	 && (GIV(framePointer) > (((GIV(stackPage)->realStackLimit)) - (((sqInt) LargeContextSize >> 1)))));
	(GIV(stackPage)->headFP = GIV(framePointer));
	(GIV(stackPage)->headSP = GIV(stackPointer));
	assert(pageListIsWellFormed());
	if (!((((longAt((aContext + BaseHeaderSize) + (SenderIndex << ShiftForWord))) & 1))
		 && (!(isWidowedContext(aContext))))) {
		fmt = (((usqInt) hdr) >> 8) & 15;
		/* begin lengthOf:baseHeader:format: */
		if ((hdr & TypeMask) == HeaderTypeSizeAndClass) {
			sz = (longAt(aContext - (BytesPerWord * 2))) & LongSizeMask;
		}
		else {
			sz = hdr & SizeMask;
		}
		sz -= hdr & Size4Bit;
		if (fmt <= 4) {
			totalLength = ((usqInt) (sz - BaseHeaderSize)) >> ShiftForWord;
			goto l1;
		}
		if (fmt < 8) {
			totalLength = ((usqInt) (sz - BaseHeaderSize)) >> 2;
			goto l1;
		}
		else {
			totalLength = (sz - BaseHeaderSize) - (fmt & 3);
			goto l1;
		}
	l1:	/* end lengthOf:baseHeader:format: */;
		/* begin fixedFieldsOf:format:length: */
		if ((fmt > 4)
		 || (fmt == 2)) {
			fixedFields = 0;
			goto l4;
		}
		if (fmt < 2) {
			fixedFields = totalLength;
			goto l4;
		}
		/* begin fetchClassOfNonInt: */
		if (((ccIndex = (((usqInt) (longAt(aContext))) >> 12) & 31)) == 0) {
			class = (longAt(aContext - BaseHeaderSize)) & AllButTypeMask;
			goto l3;
		}
		else {
			class = longAt(((longAt((GIV(specialObjectsOop) + BaseHeaderSize) + (CompactClasses << ShiftForWord))) + BaseHeaderSize) + ((ccIndex - 1) << ShiftForWord));
			goto l3;
		}
	l3:	/* end fetchClassOfNonInt: */;
		classFormat = (longAt((class + BaseHeaderSize) + (InstanceSpecificationIndex << ShiftForWord))) - 1;
		fixedFields = (((((usqInt) classFormat) >> 11) & 192) + ((((usqInt) classFormat) >> 2) & 63)) - 1;
	l4:	/* end fixedFieldsOf:format:length: */;
		/* begin stackPointerForMaybeMarriedContext: */
		VM_LABEL(0stackPointerForMaybeMarriedContext);
		if ((((longAt((aContext + BaseHeaderSize) + (SenderIndex << ShiftForWord))) & 1))
		 && (!(isWidowedContext(aContext)))) {
			sp3 = stackPointerIndexForFrame(frameOfMarriedContext(aContext));
			assert((ReceiverIndex + ((sp3 >> 1))) < (lengthOf(aContext)));
			stSize = sp3;
			goto l5;
		}
		/* begin fetchStackPointerOf: */
		sp11 = longAt((aContext + BaseHeaderSize) + (StackPointerIndex << ShiftForWord));
		if (!((sp11 & 1))) {
			stSize = 0;
			goto l5;
		}
		assert((ReceiverIndex + ((sp11 >> 1))) < (lengthOf(aContext)));
		stSize = (sp11 >> 1);
	l5:	/* end stackPointerForMaybeMarriedContext: */;
		if (!(((index >= 1) && (index <= stSize)))) {
			/* begin primitiveFail */
			if (GIV(primFailCode) == 0) {
				GIV(primFailCode) = 1;
			}
			return;
		}
		/* begin subscript:with:format: */
		if (fmt <= 4) {
			value = longAt((aContext + BaseHeaderSize) + (((index + fixedFields) - 1) << ShiftForWord));
			goto l2;
		}
		if (fmt < 8) {
			value = positive32BitIntegerFor(long32At((aContext + BaseHeaderSize) + (((index + fixedFields) - 1) << 2)));
			goto l2;
		}
		else {
			value = (((byteAt((aContext + BaseHeaderSize) + ((index + fixedFields) - 1))) << 1) | 1);
			goto l2;
		}
	l2:	/* end subscript:with:format: */;
		/* begin pop:thenPush: */
		longAtput(sp1 = GIV(stackPointer) + ((2 - 1) * BytesPerWord), value);
		GIV(stackPointer) = sp1;
		return;
	}
	/* begin frameOfMarriedContext: */
	value1 = longAt((aContext + BaseHeaderSize) + (SenderIndex << ShiftForWord));
	/* begin withoutSmallIntegerTags: */
	assert((value1 & 1));
	spouseFP = pointerForOop(value1 - 1);
	if (!(((index >= 1) && (index <= (stackPointerIndexForFrame(spouseFP)))))) {
		/* begin primitiveFail */
		if (GIV(primFailCode) == 0) {
			GIV(primFailCode) = 1;
		}
		return;
	}
	value = ((((usqInt)(longAt(spouseFP + FoxMethod)))) < heapBase
		? ((index - 1) < ((frameNumArgs = (mframeCogMethod(spouseFP)->cmNumArgs)))
	? longAt((spouseFP + FoxCallerSavedIP) + ((frameNumArgs - (index - 1)) * BytesPerWord))
	: longAt(((spouseFP + FoxMFReceiver) - BytesPerWord) + ((frameNumArgs - (index - 1)) * BytesPerWord)))
		: ((index - 1) < ((frameNumArgs1 = byteAt((spouseFP + FoxIFrameFlags) + 1)))
	? longAt((spouseFP + FoxCallerSavedIP) + ((frameNumArgs1 - (index - 1)) * BytesPerWord))
	: longAt(((spouseFP + FoxIFReceiver) - BytesPerWord) + ((frameNumArgs1 - (index - 1)) * BytesPerWord))));
	/* begin pop:thenPush: */
	longAtput(sp2 = GIV(stackPointer) + ((2 - 1) * BytesPerWord), value);
	GIV(stackPointer) = sp2;
}

static void
primitiveContextAtPut(void)
{   DECL_MAYBE_SQ_GLOBAL_STRUCT
    sqInt aContext;
    sqInt ccIndex;
    sqInt class;
    sqInt classFormat;
    sqInt fixedFields;
    sqInt fmt;
    sqInt frameNumArgs;
    sqInt frameNumArgs1;
    sqInt hdr;
    sqInt index;
    char *sp;
    char *sp1;
    sqInt sp11;
    char *sp2;
    sqInt sp3;
    char *spouseFP;
    sqInt stSize;
    sqInt sz;
    sqInt totalLength;
    sqInt value;
    sqInt value1;
    sqInt valueToStore;

	value = longAt(GIV(stackPointer));
	index = longAt(GIV(stackPointer) + (1 * BytesPerWord));
	aContext = longAt(GIV(stackPointer) + (2 * BytesPerWord));
	if (!((index & 1))) {
		/* begin primitiveFail */
		if (GIV(primFailCode) == 0) {
			GIV(primFailCode) = 1;
		}
		return;
	}
	hdr = longAt(aContext);
	index = (index >> 1);
	if (!(((((usqInt) hdr) >> 12) & 31) == ClassMethodContextCompactIndex)) {
		stObjectatput(aContext, index, value);
		/* begin pop:thenPush: */
		longAtput(sp = GIV(stackPointer) + ((3 - 1) * BytesPerWord), value);
		GIV(stackPointer) = sp;
		return;
	}
	/* begin externalWriteBackHeadFramePointers */
	assert((GIV(framePointer) - GIV(stackPointer)) < LargeContextSize);
	assert(GIV(stackPage) == (mostRecentlyUsedPage()));
	/* begin setHeadFP:andSP:inPage: */
	assert(GIV(stackPointer) < GIV(framePointer));
	assert((GIV(stackPointer) < ((GIV(stackPage)->baseAddress)))
	 && (GIV(stackPointer) > (((GIV(stackPage)->realStackLimit)) - LargeContextSize)));
	assert((GIV(framePointer) < ((GIV(stackPage)->baseAddress)))
	 && (GIV(framePointer) > (((GIV(stackPage)->realStackLimit)) - (((sqInt) LargeContextSize >> 1)))));
	(GIV(stackPage)->headFP = GIV(framePointer));
	(GIV(stackPage)->headSP = GIV(stackPointer));
	assert(pageListIsWellFormed());
	if (!((((longAt((aContext + BaseHeaderSize) + (SenderIndex << ShiftForWord))) & 1))
		 && (!(isWidowedContext(aContext))))) {
		fmt = (((usqInt) hdr) >> 8) & 15;
		/* begin lengthOf:baseHeader:format: */
		if ((hdr & TypeMask) == HeaderTypeSizeAndClass) {
			sz = (longAt(aContext - (BytesPerWord * 2))) & LongSizeMask;
		}
		else {
			sz = hdr & SizeMask;
		}
		sz -= hdr & Size4Bit;
		if (fmt <= 4) {
			totalLength = ((usqInt) (sz - BaseHeaderSize)) >> ShiftForWord;
			goto l1;
		}
		if (fmt < 8) {
			totalLength = ((usqInt) (sz - BaseHeaderSize)) >> 2;
			goto l1;
		}
		else {
			totalLength = (sz - BaseHeaderSize) - (fmt & 3);
			goto l1;
		}
	l1:	/* end lengthOf:baseHeader:format: */;
		/* begin fixedFieldsOf:format:length: */
		if ((fmt > 4)
		 || (fmt == 2)) {
			fixedFields = 0;
			goto l3;
		}
		if (fmt < 2) {
			fixedFields = totalLength;
			goto l3;
		}
		/* begin fetchClassOfNonInt: */
		if (((ccIndex = (((usqInt) (longAt(aContext))) >> 12) & 31)) == 0) {
			class = (longAt(aContext - BaseHeaderSize)) & AllButTypeMask;
			goto l2;
		}
		else {
			class = longAt(((longAt((GIV(specialObjectsOop) + BaseHeaderSize) + (CompactClasses << ShiftForWord))) + BaseHeaderSize) + ((ccIndex - 1) << ShiftForWord));
			goto l2;
		}
	l2:	/* end fetchClassOfNonInt: */;
		classFormat = (longAt((class + BaseHeaderSize) + (InstanceSpecificationIndex << ShiftForWord))) - 1;
		fixedFields = (((((usqInt) classFormat) >> 11) & 192) + ((((usqInt) classFormat) >> 2) & 63)) - 1;
	l3:	/* end fixedFieldsOf:format:length: */;
		/* begin stackPointerForMaybeMarriedContext: */
		VM_LABEL(1stackPointerForMaybeMarriedContext);
		if ((((longAt((aContext + BaseHeaderSize) + (SenderIndex << ShiftForWord))) & 1))
		 && (!(isWidowedContext(aContext)))) {
			sp3 = stackPointerIndexForFrame(frameOfMarriedContext(aContext));
			assert((ReceiverIndex + ((sp3 >> 1))) < (lengthOf(aContext)));
			stSize = sp3;
			goto l4;
		}
		/* begin fetchStackPointerOf: */
		sp11 = longAt((aContext + BaseHeaderSize) + (StackPointerIndex << ShiftForWord));
		if (!((sp11 & 1))) {
			stSize = 0;
			goto l4;
		}
		assert((ReceiverIndex + ((sp11 >> 1))) < (lengthOf(aContext)));
		stSize = (sp11 >> 1);
	l4:	/* end stackPointerForMaybeMarriedContext: */;
		if (!(((index >= 1) && (index <= stSize)))) {
			/* begin primitiveFail */
			if (GIV(primFailCode) == 0) {
				GIV(primFailCode) = 1;
			}
			return;
		}
		/* begin subscript:with:storing:format: */
		VM_LABEL(0subscriptwithstoringformat);
		if (fmt <= 4) {
			/* begin storePointer:ofObject:withValue: */
			if ((((usqInt) aContext)) < (((usqInt) GIV(youngStart)))) {
				possibleRootStoreIntovalue(aContext, value);
			}
			longAtput((aContext + BaseHeaderSize) + (((index + fixedFields) - 1) << ShiftForWord), value);
		}
		else {
			if (fmt < 8) {

				/* long-word type objects */

				valueToStore = positive32BitValueOf(value);
				if (GIV(primFailCode) == 0) {
					long32Atput((aContext + BaseHeaderSize) + (((index + fixedFields) - 1) << 2), valueToStore);
				}
			}
			else {
				if (!((value & 1))) {
					/* begin success: */
					if (!(0)) {
						if (GIV(primFailCode) == 0) {

							/* Don't overwrite an error code that has already been set. */

							GIV(primFailCode) = 1;
						}
					}
				}
				valueToStore = (value >> 1);
				if (!((valueToStore >= 0)
					 && (valueToStore <= 255))) {
					/* begin success: */
					if (!(0)) {
						if (GIV(primFailCode) == 0) {

							/* Don't overwrite an error code that has already been set. */

							GIV(primFailCode) = 1;
						}
					}
				}
				if (GIV(primFailCode) == 0) {
					byteAtput((aContext + BaseHeaderSize) + ((index + fixedFields) - 1), valueToStore);
				}
			}
		}
		/* begin pop:thenPush: */
		longAtput(sp1 = GIV(stackPointer) + ((3 - 1) * BytesPerWord), value);
		GIV(stackPointer) = sp1;
		return;
	}
	/* begin frameOfMarriedContext: */
	value1 = longAt((aContext + BaseHeaderSize) + (SenderIndex << ShiftForWord));
	/* begin withoutSmallIntegerTags: */
	assert((value1 & 1));
	spouseFP = pointerForOop(value1 - 1);
	if (!(((index >= 1) && (index <= (stackPointerIndexForFrame(spouseFP)))))) {
		/* begin primitiveFail */
		if (GIV(primFailCode) == 0) {
			GIV(primFailCode) = 1;
		}
		return;
	}
	/* begin temporary:in:put: */
	VM_LABEL(0temporaryinput);
	;
	if ((((usqInt)(longAt(spouseFP + FoxMethod)))) < heapBase) {
		/* begin mtemporary:in:put: */
		longAtput(((index - 1) < ((frameNumArgs = (mframeCogMethod(spouseFP)->cmNumArgs)))
			? (spouseFP + FoxCallerSavedIP) + ((frameNumArgs - (index - 1)) * BytesPerWord)
			: ((spouseFP + FoxMFReceiver) - BytesPerWord) + ((frameNumArgs - (index - 1)) * BytesPerWord)), value);
	}
	else {
		/* begin itemporary:in:put: */
		if ((index - 1) < ((frameNumArgs1 = byteAt((spouseFP + FoxIFrameFlags) + 1)))) {
			longAtput((spouseFP + FoxCallerSavedIP) + ((frameNumArgs1 - (index - 1)) * BytesPerWord), value);
		}
		else {
			longAtput(((spouseFP + FoxIFReceiver) - BytesPerWord) + ((frameNumArgs1 - (index - 1)) * BytesPerWord), value);
		}
	}
	/* begin pop:thenPush: */
	longAtput(sp2 = GIV(stackPointer) + ((3 - 1) * BytesPerWord), value);
	GIV(stackPointer) = sp2;
	return;
}

static void
primitiveContextSize(void)
{   DECL_MAYBE_SQ_GLOBAL_STRUCT
    sqInt ccIndex;
    sqInt class;
    sqInt classFormat;
    sqInt fixedFields;
    sqInt fmt;
    sqInt hdr;
    sqInt rcvr;
    char *sp;
    sqInt sp1;
    sqInt sp2;
    sqInt sz;
    sqInt sz1;
    sqInt totalLength;

	rcvr = longAt(GIV(stackPointer));
	hdr = longAt(rcvr);
	fmt = (((usqInt) hdr) >> 8) & 15;
	/* begin lengthOf:baseHeader:format: */
	if ((hdr & TypeMask) == HeaderTypeSizeAndClass) {
		sz1 = (longAt(rcvr - (BytesPerWord * 2))) & LongSizeMask;
	}
	else {
		sz1 = hdr & SizeMask;
	}
	sz1 -= hdr & Size4Bit;
	if (fmt <= 4) {
		totalLength = ((usqInt) (sz1 - BaseHeaderSize)) >> ShiftForWord;
		goto l1;
	}
	if (fmt < 8) {
		totalLength = ((usqInt) (sz1 - BaseHeaderSize)) >> 2;
		goto l1;
	}
	else {
		totalLength = (sz1 - BaseHeaderSize) - (fmt & 3);
		goto l1;
	}
l1:	/* end lengthOf:baseHeader:format: */;
	/* begin fixedFieldsOf:format:length: */
	if ((fmt > 4)
	 || (fmt == 2)) {
		fixedFields = 0;
		goto l4;
	}
	if (fmt < 2) {
		fixedFields = totalLength;
		goto l4;
	}
	/* begin fetchClassOfNonInt: */
	if (((ccIndex = (((usqInt) (longAt(rcvr))) >> 12) & 31)) == 0) {
		class = (longAt(rcvr - BaseHeaderSize)) & AllButTypeMask;
		goto l3;
	}
	else {
		class = longAt(((longAt((GIV(specialObjectsOop) + BaseHeaderSize) + (CompactClasses << ShiftForWord))) + BaseHeaderSize) + ((ccIndex - 1) << ShiftForWord));
		goto l3;
	}
l3:	/* end fetchClassOfNonInt: */;
	classFormat = (longAt((class + BaseHeaderSize) + (InstanceSpecificationIndex << ShiftForWord))) - 1;
	fixedFields = (((((usqInt) classFormat) >> 11) & 192) + ((((usqInt) classFormat) >> 2) & 63)) - 1;
l4:	/* end fixedFieldsOf:format:length: */;
	if (((((usqInt) hdr) >> 12) & 31) == ClassMethodContextCompactIndex) {
		/* begin externalWriteBackHeadFramePointers */
		assert((GIV(framePointer) - GIV(stackPointer)) < LargeContextSize);
		assert(GIV(stackPage) == (mostRecentlyUsedPage()));
		/* begin setHeadFP:andSP:inPage: */
		assert(GIV(stackPointer) < GIV(framePointer));
		assert((GIV(stackPointer) < ((GIV(stackPage)->baseAddress)))
		 && (GIV(stackPointer) > (((GIV(stackPage)->realStackLimit)) - LargeContextSize)));
		assert((GIV(framePointer) < ((GIV(stackPage)->baseAddress)))
		 && (GIV(framePointer) > (((GIV(stackPage)->realStackLimit)) - (((sqInt) LargeContextSize >> 1)))));
		(GIV(stackPage)->headFP = GIV(framePointer));
		(GIV(stackPage)->headSP = GIV(stackPointer));
		assert(pageListIsWellFormed());
		/* begin stackPointerForMaybeMarriedContext: */
		VM_LABEL(2stackPointerForMaybeMarriedContext);
		if ((((longAt((rcvr + BaseHeaderSize) + (SenderIndex << ShiftForWord))) & 1))
		 && (!(isWidowedContext(rcvr)))) {
			sp2 = stackPointerIndexForFrame(frameOfMarriedContext(rcvr));
			assert((ReceiverIndex + ((sp2 >> 1))) < (lengthOf(rcvr)));
			sz = sp2;
			goto l2;
		}
		/* begin fetchStackPointerOf: */
		sp1 = longAt((rcvr + BaseHeaderSize) + (StackPointerIndex << ShiftForWord));
		if (!((sp1 & 1))) {
			sz = 0;
			goto l2;
		}
		assert((ReceiverIndex + ((sp1 >> 1))) < (lengthOf(rcvr)));
		sz = (sp1 >> 1);
	l2:	/* end stackPointerForMaybeMarriedContext: */;
	}
	else {
		sz = totalLength - fixedFields;
	}
	if (GIV(primFailCode) == 0) {
		/* begin pop:thenPush: */
		longAtput(sp = GIV(stackPointer) + ((1 - 1) * BytesPerWord), ((sz << 1) | 1));
		GIV(stackPointer) = sp;
	}
}


/*	Lift the veil from a context and answer an integer describing its interior
	state. Used for e.g. VM tests so they can verify they're testing what they
	think they're testing.
	0 implies a vanilla heap context.
	Bit 0 = is or was married to a frame
	Bit 1 = is still married to a frame
	Bit 2 = frame is executing machine code
	Bit 3 = has machine code pc (as opposed to nil or a bytecode pc)
	Bit 4 = method is currently compiled to machine code */

static void
primitiveContextXray(void)
{   DECL_MAYBE_SQ_GLOBAL_STRUCT
    sqInt context;
    sqInt flags;
    sqInt pc;
    char *sp;
    char *theFP;
    sqInt theMethod;
    sqInt value;

	context = longAt(GIV(stackPointer));
	pc = longAt((context + BaseHeaderSize) + (InstructionPointerIndex << ShiftForWord));
	if (((longAt((context + BaseHeaderSize) + (SenderIndex << ShiftForWord))) & 1)) {
		if (checkIsStillMarriedContextcurrentFP(context, GIV(framePointer))) {
			/* begin frameOfMarriedContext: */
			value = longAt((context + BaseHeaderSize) + (SenderIndex << ShiftForWord));
			/* begin withoutSmallIntegerTags: */
			assert((value & 1));
			theFP = pointerForOop(value - 1);
			if ((((usqInt)(longAt(theFP + FoxMethod)))) < heapBase) {
				flags = 7;
			}
			else {
				flags = 3;
			}
		}
		else {
			flags = 1;
		}
	}
	else {
		flags = 0;
	}
	if (((pc & 1))
	 && (((pc >> 1)) < 0)) {
		flags = flags | 8;
	}
	theMethod = longAt((context + BaseHeaderSize) + (MethodIndex << ShiftForWord));
	if (((theMethod & 1) == 0)
	 && ((((((usqInt) (longAt(theMethod))) >> 8) & 15) >= 12)
 && (isCogMethodReference(longAt((theMethod + BaseHeaderSize) + (HeaderIndex << ShiftForWord)))))) {
		flags = flags | 16;
	}
	/* begin pop:thenPush: */
	longAtput(sp = GIV(stackPointer) + ((1 - 1) * BytesPerWord), ((flags << 1) | 1));
	GIV(stackPointer) = sp;
}


/*	Primitive. Start or stop the VM profiler. The first argument is a boolean
	to switch profiling on or off. The second argument is an integer or nil.
	If an integer it determines the maximum number of samples in the VM's
	sample buffer. Answer the current number of samples in the buffer. */

static void
primitiveControlVMProfiling(void)
{   DECL_MAYBE_SQ_GLOBAL_STRUCT
    sqInt bufferSize;
    sqInt numSamples;
    sqInt onOffBar;
    char *sp;

	if (GIV(argumentCount) != 2) {
		/* begin primitiveFail */
		if (GIV(primFailCode) == 0) {
			GIV(primFailCode) = 1;
		}
		return;
	}
	if (((onOffBar = longAt(GIV(stackPointer) + (1 * BytesPerWord)))) == GIV(trueObj)) {
		onOffBar = 1;
	}
	else {
		if (onOffBar == GIV(falseObj)) {
			onOffBar = 0;
		}
		else {
			/* begin primitiveFail */
			if (GIV(primFailCode) == 0) {
				GIV(primFailCode) = 1;
			}
			return;
		}
	}
	if (((bufferSize = longAt(GIV(stackPointer)))) == GIV(nilObj)) {
		bufferSize = 0;
	}
	else {
		if (!(((bufferSize & 1))
			 && (((bufferSize = (bufferSize >> 1))) > 0))) {
			/* begin primitiveFail */
			if (GIV(primFailCode) == 0) {
				GIV(primFailCode) = 1;
			}
			return;
		}
	}
	numSamples = ioControlNewProfile(onOffBar,bufferSize);
	/* begin pop:thenPushInteger: */
	longAtput(sp = GIV(stackPointer) + ((3 - 1) * BytesPerWord), ((numSamples << 1) | 1));
	GIV(stackPointer) = sp;
}


/*	Primitive. Copy the state of the receiver from the argument. 
	Fail if receiver and argument are of a different class. 
	Fail if the receiver or argument are non-pointer objects.
	Fail if receiver and argument have different lengths (for indexable
	objects).  */

static void
primitiveCopyObject(void)
{   DECL_MAYBE_SQ_GLOBAL_STRUCT
    sqInt arg;
    sqInt header;
    sqInt i;
    sqInt length;
    sqInt oop;
    sqInt oop1;
    sqInt rcvr;
    sqInt sz;

	if (!(GIV(argumentCount) == 1)) {
		/* begin primitiveFail */
		if (GIV(primFailCode) == 0) {
			GIV(primFailCode) = 1;
		}
		return;
	}
	/* begin stackObjectValue: */
	oop = longAt(GIV(stackPointer) + (0 * BytesPerWord));
	if ((oop & 1)) {
		/* begin primitiveFail */
		if (GIV(primFailCode) == 0) {
			GIV(primFailCode) = 1;
		}
		arg = null;
		goto l1;
	}
	arg = oop;
l1:	/* end stackObjectValue: */;
	/* begin stackObjectValue: */
	oop1 = longAt(GIV(stackPointer) + (1 * BytesPerWord));
	if ((oop1 & 1)) {
		/* begin primitiveFail */
		if (GIV(primFailCode) == 0) {
			GIV(primFailCode) = 1;
		}
		rcvr = null;
		goto l2;
	}
	rcvr = oop1;
l2:	/* end stackObjectValue: */;
	if (GIV(primFailCode) != 0) {
		return;
	}
	if (!(((rcvr & 1) == 0)
		 && (((((usqInt) (longAt(rcvr))) >> 8) & 15) <= 4))) {
		/* begin primitiveFail */
		if (GIV(primFailCode) == 0) {
			GIV(primFailCode) = 1;
		}
		return;
	}
	if (!((fetchClassOf(rcvr)) == (fetchClassOf(arg)))) {
		/* begin primitiveFail */
		if (GIV(primFailCode) == 0) {
			GIV(primFailCode) = 1;
		}
		return;
	}
	/* begin lengthOf: */
	header = longAt(rcvr);
	/* begin lengthOf:baseHeader:format: */
	if ((header & TypeMask) == HeaderTypeSizeAndClass) {
		sz = (longAt(rcvr - (BytesPerWord * 2))) & LongSizeMask;
	}
	else {
		sz = header & SizeMask;
	}
	sz -= header & Size4Bit;
	if (((((usqInt) header) >> 8) & 15) <= 4) {
		length = ((usqInt) (sz - BaseHeaderSize)) >> ShiftForWord;
		goto l3;
	}
	if (((((usqInt) header) >> 8) & 15) < 8) {
		length = ((usqInt) (sz - BaseHeaderSize)) >> 2;
		goto l3;
	}
	else {
		length = (sz - BaseHeaderSize) - (((((usqInt) header) >> 8) & 15) & 3);
		goto l3;
	}
l3:	/* end lengthOf:baseHeader:format: */;
	if (!(length == (lengthOf(arg)))) {
		/* begin primitiveFail */
		if (GIV(primFailCode) == 0) {
			GIV(primFailCode) = 1;
		}
		return;
	}
	for (i = 0; i <= (length - 1); i += 1) {
		/* begin storePointer:ofObject:withValue: */
		if ((((usqInt) rcvr)) < (((usqInt) GIV(youngStart)))) {
			possibleRootStoreIntovalue(rcvr, longAt((arg + BaseHeaderSize) + (i << ShiftForWord)));
		}
		longAtput((rcvr + BaseHeaderSize) + (i << ShiftForWord), longAt((arg + BaseHeaderSize) + (i << ShiftForWord)));
	}
	/* begin pop: */
	GIV(stackPointer) += 1 * BytesPerWord;
}


/*	Crash the VM by indirecting through a null pointer. If the sole argument
	is true crash in this thread, and if it is false crash in a new thread. */

EXPORT(sqInt)
primitiveCrashVM(void)
{   DECL_MAYBE_SQ_GLOBAL_STRUCT
    sqInt crashInThisThread;

	/* begin booleanValueOf: */
	if ((longAt(GIV(stackPointer))) == GIV(trueObj)) {
		crashInThisThread = 1;
		goto l1;
	}
	if ((longAt(GIV(stackPointer))) == GIV(falseObj)) {
		crashInThisThread = 0;
		goto l1;
	}
	/* begin success: */
	if (!(0)) {
		if (GIV(primFailCode) == 0) {

			/* Don't overwrite an error code that has already been set. */

			GIV(primFailCode) = 1;
		}
	}
	crashInThisThread = null;
l1:	/* end booleanValueOf: */;
	if ((GIV(primFailCode) != 0)
	 || (GIV(argumentCount) != 1)) {
		return GIV(primFailCode) = PrimErrBadNumArgs;
	}
	crashInThisOrAnotherThread(crashInThisThread);
	/* begin pop: */
	GIV(stackPointer) += 1 * BytesPerWord;
}


/*	Set or clear the flag that controls whether modifications of 
	the Display object are propagated to the underlying 
	platform's screen. */

static void
primitiveDeferDisplayUpdates(void)
{   DECL_MAYBE_SQ_GLOBAL_STRUCT
    sqInt flag;

	flag = longAt(GIV(stackPointer));
	if (flag == GIV(trueObj)) {
		deferDisplayUpdates = 1;
	}
	else {
		if (flag == GIV(falseObj)) {
			deferDisplayUpdates = 0;
		}
		else {
			/* begin primitiveFail */
			if (GIV(primFailCode) == 0) {
				GIV(primFailCode) = 1;
			}
		}
	}
	if (GIV(primFailCode) == 0) {
		/* begin pop: */
		GIV(stackPointer) += 1 * BytesPerWord;
	}
}


/*	Pass in a non-negative value to disable the architectures powermanager if
	any, zero to enable. This is a named (not numbered) primitive in the null
	module (ie the VM)
 */

EXPORT(sqInt)
primitiveDisablePowerManager(void)
{   DECL_MAYBE_SQ_GLOBAL_STRUCT
    sqInt integer;
    sqInt integerPointer;

	/* begin stackIntegerValue: */
	integerPointer = longAt(GIV(stackPointer) + (0 * BytesPerWord));
	/* begin checkedIntegerValueOf: */
	if ((integerPointer & 1)) {
		integer = (integerPointer >> 1);
		goto l1;
	}
	else {
		/* begin primitiveFail */
		if (GIV(primFailCode) == 0) {
			GIV(primFailCode) = 1;
		}
		integer = 0;
		goto l1;
	}
l1:	/* end stackIntegerValue: */;
	if (GIV(primFailCode) == 0) {
		ioDisablePowerManager(integer);
		/* begin pop: */
		GIV(stackPointer) += 1 * BytesPerWord;
	}
}

static void
primitiveDiv(void)
{   DECL_MAYBE_SQ_GLOBAL_STRUCT
    sqInt quotient;
    char *sp;

	quotient = doPrimitiveDivby(longAt(GIV(stackPointer) + (1 * BytesPerWord)), longAt(GIV(stackPointer)));
	/* begin pop2AndPushIntegerIfOK: */
	if (GIV(primFailCode) == 0) {
		if ((quotient ^ (quotient << 1)) >= 0) {
			/* begin pop:thenPush: */
			longAtput(sp = GIV(stackPointer) + ((2 - 1) * BytesPerWord), ((quotient << 1) | 1));
			GIV(stackPointer) = sp;
		}
		else {
			/* begin success: */
			if (!(0)) {
				if (GIV(primFailCode) == 0) {

					/* Don't overwrite an error code that has already been set. */

					GIV(primFailCode) = 1;
				}
			}
		}
	}
}

static void
primitiveDivide(void)
{   DECL_MAYBE_SQ_GLOBAL_STRUCT
    sqInt integerArgument;
    sqInt integerPointer;
    sqInt integerPointer1;
    sqInt integerReceiver;
    char *sp;

	/* begin stackIntegerValue: */
	integerPointer = longAt(GIV(stackPointer) + (1 * BytesPerWord));
	/* begin checkedIntegerValueOf: */
	if ((integerPointer & 1)) {
		integerReceiver = (integerPointer >> 1);
		goto l1;
	}
	else {
		/* begin primitiveFail */
		if (GIV(primFailCode) == 0) {
			GIV(primFailCode) = 1;
		}
		integerReceiver = 0;
		goto l1;
	}
l1:	/* end stackIntegerValue: */;
	/* begin stackIntegerValue: */
	integerPointer1 = longAt(GIV(stackPointer) + (0 * BytesPerWord));
	/* begin checkedIntegerValueOf: */
	if ((integerPointer1 & 1)) {
		integerArgument = (integerPointer1 >> 1);
		goto l2;
	}
	else {
		/* begin primitiveFail */
		if (GIV(primFailCode) == 0) {
			GIV(primFailCode) = 1;
		}
		integerArgument = 0;
		goto l2;
	}
l2:	/* end stackIntegerValue: */;
	if ((integerArgument != 0)
	 && ((integerReceiver % integerArgument) == 0)) {
		/* begin pop2AndPushIntegerIfOK: */
		if (GIV(primFailCode) == 0) {
			if (((integerReceiver / integerArgument) ^ ((integerReceiver / integerArgument) << 1)) >= 0) {
				/* begin pop:thenPush: */
				longAtput(sp = GIV(stackPointer) + ((2 - 1) * BytesPerWord), (((integerReceiver / integerArgument) << 1) | 1));
				GIV(stackPointer) = sp;
			}
			else {
				/* begin success: */
				if (!(0)) {
					if (GIV(primFailCode) == 0) {

						/* Don't overwrite an error code that has already been set. */

						GIV(primFailCode) = 1;
					}
				}
			}
		}
	}
	else {
		/* begin primitiveFail */
		if (GIV(primFailCode) == 0) {
			GIV(primFailCode) = 1;
		}
	}
}


/*	Primitive arithmetic operations for large integers in 64 bit range */

EXPORT(void)
primitiveDivideLargeIntegers(void)
{   DECL_MAYBE_SQ_GLOBAL_STRUCT
    sqLong integerArg;
    sqLong integerRcvr;
    sqInt oopResult;
    sqLong result;
    char *sp;

	integerArg = signed64BitValueOf(longAt(GIV(stackPointer) + (0 * BytesPerWord)));
	integerRcvr = signed64BitValueOf(longAt(GIV(stackPointer) + (1 * BytesPerWord)));
	if (!((integerArg != 0)
		 && ((integerRcvr % integerArg) == 0))) {
		/* begin primitiveFail */
		if (GIV(primFailCode) == 0) {
			GIV(primFailCode) = 1;
		}
	}
	if (!(GIV(primFailCode) == 0)) {
		return;
	}
	result = integerRcvr / integerArg;
	oopResult = signed64BitIntegerFor(result);
	if (GIV(primFailCode) == 0) {
		/* begin pop:thenPush: */
		longAtput(sp = GIV(stackPointer) + ((2 - 1) * BytesPerWord), oopResult);
		GIV(stackPointer) = sp;
	}
}


/*	Primitive arithmetic operations for large integers in 64 bit range */

EXPORT(void)
primitiveDivLargeIntegers(void)
{   DECL_MAYBE_SQ_GLOBAL_STRUCT
    sqLong integerArg;
    sqLong integerRcvr;
    sqInt oopResult;
    sqLong posArg;
    sqLong posRcvr;
    sqLong result;
    char *sp;

	integerArg = signed64BitValueOf(longAt(GIV(stackPointer) + (0 * BytesPerWord)));
	integerRcvr = signed64BitValueOf(longAt(GIV(stackPointer) + (1 * BytesPerWord)));
	if (integerArg == 0) {
		/* begin primitiveFail */
		if (GIV(primFailCode) == 0) {
			GIV(primFailCode) = 1;
		}
	}
	if (!(GIV(primFailCode) == 0)) {
		return;
	}
	if (integerRcvr > 0) {
		if (integerArg > 0) {
			result = integerRcvr / integerArg;
		}
		else {

			/* round negative result toward negative infinity */

			posArg = 0 - integerArg;

			/* can overflow! */

			posRcvr = integerRcvr + (posArg - 1);
			if (posRcvr < 0) {
				/* begin primitiveFail */
				if (GIV(primFailCode) == 0) {
					GIV(primFailCode) = 1;
				}
			}
			result = 0 - (posRcvr / posArg);
		}
	}
	else {
		posRcvr = 0 - integerRcvr;
		if (integerArg > 0) {

			/* round negative result toward negative infinity */
			/* can overflow! */

			posRcvr += integerArg - 1;
			if (posRcvr < 0) {
				/* begin primitiveFail */
				if (GIV(primFailCode) == 0) {
					GIV(primFailCode) = 1;
				}
			}
			result = 0 - (posRcvr / integerArg);
		}
		else {
			posArg = 0 - integerArg;
			result = posRcvr / posArg;
		}
	}
	if (GIV(primFailCode) == 0) {
		oopResult = signed64BitIntegerFor(result);
	}
	if (GIV(primFailCode) == 0) {
		/* begin pop:thenPush: */
		longAtput(sp = GIV(stackPointer) + ((2 - 1) * BytesPerWord), oopResult);
		GIV(stackPointer) = sp;
	}
}


/*	Simulate an primitiveExternalCall invocation (e.g. for the Debugger). Do
	not cache anything.
	e.g. ContextPart>>tryNamedPrimitiveIn: aCompiledMethod for: aReceiver
	withArgs: arguments */

static void
primitiveDoNamedPrimitiveWithArgs(void)
{   DECL_MAYBE_SQ_GLOBAL_STRUCT
    void (*addr)();
    sqInt argumentArray;
    sqInt arraySize;
    sqInt ccIndex;
    sqInt ctxtRcvr;
    sqInt functionLength;
    sqInt functionName;
    sqInt header;
    sqInt header1;
    sqInt header2;
    sqInt index;
    sqInt methodArg;
    sqInt methodHeader;
    sqInt methodHeader1;
    sqInt moduleLength;
    sqInt moduleName;
    sqInt oop;
    sqInt oop1;
    sqInt oop2;
    sqInt oop3;
    sqInt oop4;
    sqInt oop5;
    sqInt oop6;
    sqInt oop7;
    sqInt oop8;
    sqInt oop9;
    sqInt primRcvr;
    char *sp;
    char *sp1;
    char *sp2;
    char *sp3;
    char *sp4;
    char *sp5;
    sqInt spec;
    sqInt successBoolean;
    sqInt successBoolean1;
    sqInt successBoolean2;
    sqInt successBoolean3;
    sqInt sz;
    sqInt sz1;
    sqInt sz2;
    sqInt top;
    sqInt top1;

	argumentArray = longAt(GIV(stackPointer));
	if (!(((argumentArray & 1) == 0)
		 && (((((usqInt) (longAt(argumentArray))) >> 8) & 15) == 2))) {
		GIV(primFailCode) = -2; return;
	}
	/* begin fetchWordLengthOf: */
	/* begin sizeBitsOf: */
	header1 = longAt(argumentArray);
	sz1 = ((header1 & TypeMask) == HeaderTypeSizeAndClass
		? (longAt(argumentArray - (BytesPerWord * 2))) & LongSizeMask
		: header1 & SizeMask);
	arraySize = ((usqInt) (sz1 - BaseHeaderSize)) >> ShiftForWord;
	/* begin success: */
	successBoolean1 = roomToPushNArgs(arraySize);
	if (!(successBoolean1)) {
		if (GIV(primFailCode) == 0) {

			/* Don't overwrite an error code that has already been set. */

			GIV(primFailCode) = 1;
		}
	}
	/* begin stackObjectValue: */
	oop = longAt(GIV(stackPointer) + (2 * BytesPerWord));
	if ((oop & 1)) {
		/* begin primitiveFail */
		if (GIV(primFailCode) == 0) {
			GIV(primFailCode) = 1;
		}
		methodArg = null;
		goto l2;
	}
	methodArg = oop;
l2:	/* end stackObjectValue: */;
	if (!(GIV(primFailCode) == 0)) {
		GIV(primFailCode) = -2; return;
	}
	if (!(((methodArg & 1) == 0)
		 && (((((usqInt) (longAt(methodArg))) >> 8) & 15) >= 12))) {
		GIV(primFailCode) = -2; return;
	}
	/* begin headerOf: */
	methodHeader1 = longAt((methodArg + BaseHeaderSize) + (HeaderIndex << ShiftForWord));
	methodHeader = (isCogMethodReference(methodHeader1)
		? (((CogMethod *) methodHeader1)->methodHeader)
		: methodHeader1);
	if (!(((((usqInt) methodHeader) >> 10) & 255) > 2)) {
		GIV(primFailCode) = -3; return;
	}
	/* begin assertClassOf:is:compactClassIndex: */
	VM_LABEL(24assertClassOfiscompactClassIndex);
	oop1 = spec = longAt((methodArg + BaseHeaderSize) + (1 << ShiftForWord));
	/* begin success: */
	/* begin is:instanceOf:compactClassIndex: */
	if ((oop1 & 1)) {
		successBoolean2 = 0;
		goto l3;
	}
	ccIndex = (((usqInt) (longAt(oop1))) >> 12) & 31;
	if (ClassArrayCompactIndex != 0) {
		successBoolean2 = ClassArrayCompactIndex == ccIndex;
		goto l3;
	}
	successBoolean2 = (ccIndex == 0)
	 && (((longAt(oop1 - BaseHeaderSize)) & AllButTypeMask) == (longAt((GIV(specialObjectsOop) + BaseHeaderSize) + (ClassArray << ShiftForWord))));
l3:	/* end is:instanceOf:compactClassIndex: */;
	if (!(successBoolean2)) {
		if (GIV(primFailCode) == 0) {

			/* Don't overwrite an error code that has already been set. */

			GIV(primFailCode) = 1;
		}
	}
	if (!((GIV(primFailCode) == 0)
		 && (((lengthOf(spec)) == 4)
 && ((primitiveIndexOfMethodHeader(methodHeader)) == 117)))) {
		GIV(primFailCode) = -3; return;
	}
	if (!(((((usqInt) methodHeader) >> 25) & 15) == arraySize)) {
		GIV(primFailCode) = -2; return;
	}
	moduleName = longAt((spec + BaseHeaderSize) + (0 << ShiftForWord));
	if (moduleName == GIV(nilObj)) {
		moduleLength = 0;
	}
	else {
		/* begin success: */
		successBoolean = ((moduleName & 1) == 0)
		 && (((((usqInt) (longAt(moduleName))) >> 8) & 15) >= 8);
		if (!(successBoolean)) {
			if (GIV(primFailCode) == 0) {

				/* Don't overwrite an error code that has already been set. */

				GIV(primFailCode) = 1;
			}
		}
		/* begin lengthOf: */
		header = longAt(moduleName);
		/* begin lengthOf:baseHeader:format: */
		if ((header & TypeMask) == HeaderTypeSizeAndClass) {
			sz = (longAt(moduleName - (BytesPerWord * 2))) & LongSizeMask;
		}
		else {
			sz = header & SizeMask;
		}
		sz -= header & Size4Bit;
		if (((((usqInt) header) >> 8) & 15) <= 4) {
			moduleLength = ((usqInt) (sz - BaseHeaderSize)) >> ShiftForWord;
			goto l1;
		}
		if (((((usqInt) header) >> 8) & 15) < 8) {
			moduleLength = ((usqInt) (sz - BaseHeaderSize)) >> 2;
			goto l1;
		}
		else {
			moduleLength = (sz - BaseHeaderSize) - (((((usqInt) header) >> 8) & 15) & 3);
			goto l1;
		}
	l1:	/* end lengthOf: */;
		;
	}
	functionName = longAt((spec + BaseHeaderSize) + (1 << ShiftForWord));
	/* begin success: */
	successBoolean3 = ((functionName & 1) == 0)
	 && (((((usqInt) (longAt(functionName))) >> 8) & 15) >= 8);
	if (!(successBoolean3)) {
		if (GIV(primFailCode) == 0) {

			/* Don't overwrite an error code that has already been set. */

			GIV(primFailCode) = 1;
		}
	}
	/* begin lengthOf: */
	header2 = longAt(functionName);
	/* begin lengthOf:baseHeader:format: */
	if ((header2 & TypeMask) == HeaderTypeSizeAndClass) {
		sz2 = (longAt(functionName - (BytesPerWord * 2))) & LongSizeMask;
	}
	else {
		sz2 = header2 & SizeMask;
	}
	sz2 -= header2 & Size4Bit;
	if (((((usqInt) header2) >> 8) & 15) <= 4) {
		functionLength = ((usqInt) (sz2 - BaseHeaderSize)) >> ShiftForWord;
		goto l4;
	}
	if (((((usqInt) header2) >> 8) & 15) < 8) {
		functionLength = ((usqInt) (sz2 - BaseHeaderSize)) >> 2;
		goto l4;
	}
	else {
		functionLength = (sz2 - BaseHeaderSize) - (((((usqInt) header2) >> 8) & 15) & 3);
		goto l4;
	}
l4:	/* end lengthOf: */;
	if (!(GIV(primFailCode) == 0)) {
		GIV(primFailCode) = -3; return;
	}
	addr = ioLoadExternalFunctionOfLengthFromModuleOfLength(functionName + BaseHeaderSize, functionLength, moduleName + BaseHeaderSize, moduleLength);
	if (addr == 0) {
		GIV(primFailCode) = -1; return;
	}
	/* begin pushRemappableOop: */
	oop2 = argumentArray = popStack();
	assert(addressCouldBeOop(oop2));
	GIV(remapBuffer)[(GIV(remapBufferCount) += 1)] = oop2;
	/* begin pushRemappableOop: */
	oop3 = primRcvr = popStack();
	assert(addressCouldBeOop(oop3));
	GIV(remapBuffer)[(GIV(remapBufferCount) += 1)] = oop3;
	/* begin pushRemappableOop: */
	/* begin popStack */
	top = longAt(GIV(stackPointer));
	GIV(stackPointer) += BytesPerWord;
	oop4 = top;
	assert(addressCouldBeOop(oop4));
	GIV(remapBuffer)[(GIV(remapBufferCount) += 1)] = oop4;
	/* begin pushRemappableOop: */
	/* begin popStack */
	top1 = longAt(GIV(stackPointer));
	GIV(stackPointer) += BytesPerWord;
	oop5 = top1;
	assert(addressCouldBeOop(oop5));
	GIV(remapBuffer)[(GIV(remapBufferCount) += 1)] = oop5;
	/* begin push: */
	longAtput(sp5 = GIV(stackPointer) - BytesPerWord, primRcvr);
	GIV(stackPointer) = sp5;
	GIV(argumentCount) = arraySize;
	for (index = 1; index <= arraySize; index += 1) {
		/* begin push: */
		longAtput(sp = GIV(stackPointer) - BytesPerWord, longAt((argumentArray + BaseHeaderSize) + ((index - 1) << ShiftForWord)));
		GIV(stackPointer) = sp;
	}
	GIV(lkupClass) = GIV(nilObj);
	callExternalPrimitive(addr);
	/* begin popRemappableOop */
	oop6 = GIV(remapBuffer)[GIV(remapBufferCount)];
	GIV(remapBufferCount) -= 1;
	ctxtRcvr = oop6;
	/* begin popRemappableOop */
	oop7 = GIV(remapBuffer)[GIV(remapBufferCount)];
	GIV(remapBufferCount) -= 1;
	methodArg = oop7;
	/* begin popRemappableOop */
	oop8 = GIV(remapBuffer)[GIV(remapBufferCount)];
	GIV(remapBufferCount) -= 1;
	primRcvr = oop8;
	/* begin popRemappableOop */
	oop9 = GIV(remapBuffer)[GIV(remapBufferCount)];
	GIV(remapBufferCount) -= 1;
	argumentArray = oop9;
	if (!(GIV(primFailCode) == 0)) {
		/* begin pop: */
		GIV(stackPointer) += (arraySize + 1) * BytesPerWord;
		/* begin push: */
		longAtput(sp1 = GIV(stackPointer) - BytesPerWord, ctxtRcvr);
		GIV(stackPointer) = sp1;
		/* begin push: */
		longAtput(sp2 = GIV(stackPointer) - BytesPerWord, methodArg);
		GIV(stackPointer) = sp2;
		/* begin push: */
		longAtput(sp3 = GIV(stackPointer) - BytesPerWord, primRcvr);
		GIV(stackPointer) = sp3;
		/* begin push: */
		longAtput(sp4 = GIV(stackPointer) - BytesPerWord, argumentArray);
		GIV(stackPointer) = sp4;

		/* Hack.  A nil prim error code (primErrorCode = 1) is interpreted by the image
		  as meaning this primitive is not implemented.  So to pass back nil as an error
		  code we use -1 to indicate generic failure. */

		GIV(argumentCount) = 3;
		if (GIV(primFailCode) == 1) {
			GIV(primFailCode) = -1;
		}
	}
}

static void
primitiveDoPrimitiveWithArgs(void)
{   DECL_MAYBE_SQ_GLOBAL_STRUCT
    sqInt argumentArray;
    sqInt arraySize;
    sqInt header;
    sqInt index;
    sqInt integerPointer;
    sqInt nArgs;
    sqInt primIdx;
    char *savedFramePointer;
    char *savedStackPointer;
    char *sp;
    char *sp1;
    char *sp2;
    sqInt successBoolean;
    sqInt sz;

	argumentArray = longAt(GIV(stackPointer));
	if (!(((argumentArray & 1) == 0)
		 && (((((usqInt) (longAt(argumentArray))) >> 8) & 15) == 2))) {
		/* begin primitiveFail */
		if (GIV(primFailCode) == 0) {
			GIV(primFailCode) = 1;
		}
		return;
	}
	/* begin fetchWordLengthOf: */
	/* begin sizeBitsOf: */
	header = longAt(argumentArray);
	sz = ((header & TypeMask) == HeaderTypeSizeAndClass
		? (longAt(argumentArray - (BytesPerWord * 2))) & LongSizeMask
		: header & SizeMask);
	arraySize = ((usqInt) (sz - BaseHeaderSize)) >> ShiftForWord;
	/* begin success: */
	successBoolean = roomToPushNArgs(arraySize);
	if (!(successBoolean)) {
		if (GIV(primFailCode) == 0) {

			/* Don't overwrite an error code that has already been set. */

			GIV(primFailCode) = 1;
		}
	}
	/* begin stackIntegerValue: */
	integerPointer = longAt(GIV(stackPointer) + (1 * BytesPerWord));
	/* begin checkedIntegerValueOf: */
	if ((integerPointer & 1)) {
		primIdx = (integerPointer >> 1);
		goto l1;
	}
	else {
		/* begin primitiveFail */
		if (GIV(primFailCode) == 0) {
			GIV(primFailCode) = 1;
		}
		primIdx = 0;
		goto l1;
	}
l1:	/* end stackIntegerValue: */;
	if (!(GIV(primFailCode) == 0)) {
		/* begin primitiveFail */
		if (GIV(primFailCode) == 0) {
			GIV(primFailCode) = 1;
		}
		return;
	}
	/* begin functionPointerFor:inClass: */
	primitiveFunctionPointer = ((void (*)(void)) ((primIdx > MaxPrimitiveIndex
	? 0
	: primitiveTable[primIdx])));
	if (primitiveFunctionPointer == 0) {
		/* begin primitiveFail */
		if (GIV(primFailCode) == 0) {
			GIV(primFailCode) = 1;
		}
		return;
	}
	/* begin pop: */
	GIV(stackPointer) += 2 * BytesPerWord;
	GIV(argumentCount) = arraySize;
	index = 1;
	while (index <= GIV(argumentCount)) {
		/* begin push: */
		longAtput(sp = GIV(stackPointer) - BytesPerWord, longAt((argumentArray + BaseHeaderSize) + ((index - 1) << ShiftForWord)));
		GIV(stackPointer) = sp;
		index += 1;
	}
	if ((((unsigned long) primitiveFunctionPointer)) <= MaxQuickPrimitiveIndex) {
		externalQuickPrimitiveResponse();
		return;
	}

	/* prim might alloc/gc */

	GIV(tempOop) = argumentArray;

	/* Run the primitive (sets primFailCode) */

	GIV(lkupClass) = GIV(nilObj);
	/* begin slowPrimitiveResponse */
	if (recordPrimTrace()) {
		/* begin fastLogPrim: */
		GIV(primTraceLog)[GIV(primTraceLogIndex)] = GIV(messageSelector);
		primTraceLogIndex(GIV(primTraceLogIndex) + 1);
	}
	if (FailImbalancedPrimitives) {
		nArgs = GIV(argumentCount);
		savedStackPointer = GIV(stackPointer);
		savedFramePointer = GIV(framePointer);
	}
	/* begin initPrimCall */
	GIV(primFailCode) = 0;
	dispatchFunctionPointer(primitiveFunctionPointer);
	if (FailImbalancedPrimitives
	 && ((GIV(primFailCode) == 0)
 && ((GIV(framePointer) == savedFramePointer)
 && (!((((usqInt)(longAt(GIV(framePointer) + FoxMethod)))) < heapBase))))) {
		if (GIV(stackPointer) != (savedStackPointer + (nArgs * BytesPerWord))) {
			flag("Would be nice to make this a message send of e.g. unbalancedPrimitive to the current process or context");
			GIV(stackPointer) = savedStackPointer;
			failUnbalancedPrimitive();
		}
	}
	if (GIV(nextProfileTick) > 0) {
		checkProfileTick(GIV(newMethod));
	}
	GIV(primFailCode) == 0;
	if (!(GIV(primFailCode) == 0)) {
		/* begin pop: */
		GIV(stackPointer) += arraySize * BytesPerWord;
		/* begin pushInteger: */
		/* begin push: */
		longAtput(sp2 = GIV(stackPointer) - BytesPerWord, ((primIdx << 1) | 1));
		GIV(stackPointer) = sp2;
		/* begin push: */
		longAtput(sp1 = GIV(stackPointer) - BytesPerWord, GIV(tempOop));
		GIV(stackPointer) = sp1;
		GIV(argumentCount) = 2;
	}
	GIV(tempOop) = 0;
}


/*	Attempt to enter a CriticalSection/Mutex. If not owned, set the owner to
	the current
	process and answer false. If owned by the current process answer true.
	Otherwise suspend the process. Answer if the receiver is owned by the
	current process. */

static void
primitiveEnterCriticalSection(void)
{   DECL_MAYBE_SQ_GLOBAL_STRUCT
    sqInt activeProc;
    sqInt criticalSection;
    sqInt inInterpreter;
    sqInt owningProcess;
    sqInt owningProcessIndex;
    char *sp;
    char *sp1;
    char *sp2;

	if (GIV(argumentCount) > 0) {

		/* rcvr */

		criticalSection = longAt(GIV(stackPointer) + (1 * BytesPerWord));
		activeProc = longAt(GIV(stackPointer));
	}
	else {

		/* rcvr */

		criticalSection = longAt(GIV(stackPointer));
		activeProc = longAt(((longAt(((longAt((GIV(specialObjectsOop) + BaseHeaderSize) + (SchedulerAssociation << ShiftForWord))) + BaseHeaderSize) + (ValueIndex << ShiftForWord))) + BaseHeaderSize) + (ActiveProcessIndex << ShiftForWord));
	}

	/* CriticalSections are laid out like Semaphores */

	owningProcessIndex = ExcessSignalsIndex;
	owningProcess = longAt((criticalSection + BaseHeaderSize) + (owningProcessIndex << ShiftForWord));
	if (owningProcess == GIV(nilObj)) {
		/* begin storePointer:ofObject:withValue: */
		if ((((usqInt) criticalSection)) < (((usqInt) GIV(youngStart)))) {
			possibleRootStoreIntovalue(criticalSection, activeProc);
		}
		longAtput((criticalSection + BaseHeaderSize) + (owningProcessIndex << ShiftForWord), activeProc);
		/* begin pop:thenPush: */
		longAtput(sp = GIV(stackPointer) + (((GIV(argumentCount) + 1) - 1) * BytesPerWord), GIV(falseObj));
		GIV(stackPointer) = sp;
		return;
	}
	if (owningProcess == activeProc) {
		/* begin pop:thenPush: */
		longAtput(sp1 = GIV(stackPointer) + (((GIV(argumentCount) + 1) - 1) * BytesPerWord), GIV(trueObj));
		GIV(stackPointer) = sp1;
		return;
	}
	/* begin pop:thenPush: */
	longAtput(sp2 = GIV(stackPointer) + (((GIV(argumentCount) + 1) - 1) * BytesPerWord), GIV(falseObj));
	GIV(stackPointer) = sp2;
	inInterpreter = GIV(instructionPointer) >= heapBase;
	addLastLinktoList(activeProc, criticalSection);
	transferTofrom(wakeHighestPriority(), CSEnterCriticalSection);
	/* begin forProcessPrimitiveReturnToExecutivePostContextSwitch: */
	if (GIV(nextProfileTick) > 0) {
		checkProfileTick(GIV(newMethod));
	}
	returnToExecutivepostContextSwitch(inInterpreter, 1);
}

static void
primitiveEqual(void)
{   DECL_MAYBE_SQ_GLOBAL_STRUCT
    sqInt integerArgument;
    sqInt integerReceiver;
    sqInt object;
    sqInt result;
    char *sp;
    sqInt top;
    sqInt top1;

	/* begin popStack */
	top = longAt(GIV(stackPointer));
	GIV(stackPointer) += BytesPerWord;
	integerArgument = top;
	/* begin popStack */
	top1 = longAt(GIV(stackPointer));
	GIV(stackPointer) += BytesPerWord;
	integerReceiver = top1;
	/* begin compare31or32Bits:equal: */
	if (((integerReceiver & 1))
	 && ((integerArgument & 1))) {
		result = integerReceiver == integerArgument;
		goto l1;
	}
	result = (positive32BitValueOf(integerReceiver)) == (positive32BitValueOf(integerArgument));
l1:	/* end compare31or32Bits:equal: */;
	/* begin checkBooleanResult: */
	if (GIV(primFailCode) == 0) {
		/* begin pushBool: */
		/* begin push: */
		object = (result
			? GIV(trueObj)
			: GIV(falseObj));
		longAtput(sp = GIV(stackPointer) - BytesPerWord, object);
		GIV(stackPointer) = sp;
	}
	else {
		/* begin unPop: */
		GIV(stackPointer) -= 2 * BytesPerWord;
	}
}


/*	Primitive comparison operations for large integers in 64 bit range */

EXPORT(void)
primitiveEqualLargeIntegers(void)
{   DECL_MAYBE_SQ_GLOBAL_STRUCT
    sqLong integerArg;
    sqLong integerRcvr;
    char *sp;

	integerArg = signed64BitValueOf(longAt(GIV(stackPointer) + (0 * BytesPerWord)));
	integerRcvr = signed64BitValueOf(longAt(GIV(stackPointer) + (1 * BytesPerWord)));
	if (GIV(primFailCode) == 0) {
		/* begin pop:thenPushBool: */
		longAtput(sp = GIV(stackPointer) + ((2 - 1) * BytesPerWord), (integerRcvr == integerArg
			? GIV(trueObj)
			: GIV(falseObj)));
		GIV(stackPointer) = sp;
	}
}

sqInt
primitiveErrorTable(void)
{
	return longAt((GIV(specialObjectsOop) + BaseHeaderSize) + (PrimErrTableIndex << ShiftForWord));
}


/*	With 0 args answers whether ioProcessEvents is enabled and being called.
	With 1 arg expects a boolean which will enable ioProcessEvents if true and
	disable it if false, answering its previous state. */

EXPORT(void)
primitiveEventProcessingControl(void)
{   DECL_MAYBE_SQ_GLOBAL_STRUCT
    sqInt enabled;
    char *sp;
    char *sp1;

	enabled = inIOProcessEvents >= 0;
	if (GIV(argumentCount) == 0) {
		/* begin pop:thenPushBool: */
		longAtput(sp = GIV(stackPointer) + ((1 - 1) * BytesPerWord), (enabled
			? GIV(trueObj)
			: GIV(falseObj)));
		GIV(stackPointer) = sp;
		return;
	}
	if (GIV(argumentCount) == 1) {
		if ((longAt(GIV(stackPointer))) == GIV(trueObj)) {
			if (inIOProcessEvents < 0) {
				inIOProcessEvents = 0;
			}
		}
		else {
			if ((longAt(GIV(stackPointer))) == GIV(falseObj)) {
				inIOProcessEvents = -1;
			}
			else {
				GIV(primFailCode) = PrimErrBadArgument; return;
			}
		}
		/* begin pop:thenPushBool: */
		longAtput(sp1 = GIV(stackPointer) + ((2 - 1) * BytesPerWord), (enabled
			? GIV(trueObj)
			: GIV(falseObj)));
		GIV(stackPointer) = sp1;
		return;
	}
	GIV(primFailCode) = PrimErrBadNumArgs;
}


/*	receiver, args, then method are on top of stack. Execute method against
	receiver and args.
	Set primitiveFunctionPointer because no cache lookup has been done for the
	method, and
	hence primitiveFunctionPointer is stale. */

static void
primitiveExecuteMethod(void)
{   DECL_MAYBE_SQ_GLOBAL_STRUCT
    sqInt methodArgument;
    sqInt primBits;
    sqInt primitiveIndex;
    sqInt top;

	methodArgument = longAt(GIV(stackPointer));
	if (!(((methodArgument & 1) == 0)
		 && (((((usqInt) (longAt(methodArgument))) >> 8) & 15) >= 12))) {
		GIV(primFailCode) = PrimErrBadArgument; return;
	}
	if (!((GIV(argumentCount) - 1) == (argumentCountOf(methodArgument)))) {
		GIV(primFailCode) = PrimErrBadNumArgs; return;
	}
	/* begin popStack */
	top = longAt(GIV(stackPointer));
	GIV(stackPointer) += BytesPerWord;
	GIV(newMethod) = ((sqInt) top);
	/* begin primitiveIndexOf: */
	primBits = (((usqInt) (headerOf(GIV(newMethod)))) >> 1) & 268435967;
	primitiveIndex = (primBits & 511) + (((usqInt) primBits) >> 19);
	/* begin functionPointerFor:inClass: */
	primitiveFunctionPointer = ((void (*)(void)) ((primitiveIndex > MaxPrimitiveIndex
	? 0
	: primitiveTable[primitiveIndex])));

	/* We set the messageSelector for executeMethod below since things
	 like the at cache read messageSelector and so it cannot be left stale. */

	GIV(argumentCount) -= 1;
	GIV(messageSelector) = GIV(nilObj);
	executeNewMethod();
	/* begin initPrimCall */
	GIV(primFailCode) = 0;
}


/*	receiver, argsArray, then method are on top of stack. Execute method
	against receiver and args.
	Set primitiveFunctionPointer because no cache lookup has been done for the
	method, and
	hence primitiveFunctionPointer is stale. */

static void
primitiveExecuteMethodArgsArray(void)
{   DECL_MAYBE_SQ_GLOBAL_STRUCT
    sqInt argCnt;
    sqInt argumentArray;
    sqInt header;
    sqInt i;
    sqInt methodArgument;
    sqInt methodHeader;
    sqInt primBits;
    sqInt primitiveIndex;
    char *sp;

	methodArgument = longAt(GIV(stackPointer));
	argumentArray = longAt(GIV(stackPointer) + (1 * BytesPerWord));
	if (!((((methodArgument & 1) == 0)
 && (((((usqInt) (longAt(methodArgument))) >> 8) & 15) >= 12))
		 && (((argumentArray & 1) == 0)
 && (((((usqInt) (longAt(argumentArray))) >> 8) & 15) == 2)))) {
		GIV(primFailCode) = PrimErrBadArgument; return;
	}
	/* begin argumentCountOf: */
	/* begin argumentCountOfMethodHeader: */
	/* begin headerOf: */
	methodHeader = longAt((methodArgument + BaseHeaderSize) + (HeaderIndex << ShiftForWord));
	header = (isCogMethodReference(methodHeader)
		? (((CogMethod *) methodHeader)->methodHeader)
		: methodHeader);
	argCnt = (((usqInt) header) >> 25) & 15;
	if (!(argCnt == (fetchWordLengthOf(argumentArray)))) {
		GIV(primFailCode) = PrimErrBadNumArgs; return;
	}
	/* begin pop: */
	GIV(stackPointer) += 2 * BytesPerWord;
	for (i = 0; i <= (argCnt - 1); i += 1) {
		/* begin push: */
		longAtput(sp = GIV(stackPointer) - BytesPerWord, longAt((argumentArray + BaseHeaderSize) + (i << ShiftForWord)));
		GIV(stackPointer) = sp;
	}
	GIV(newMethod) = methodArgument;
	/* begin primitiveIndexOf: */
	primBits = (((usqInt) (headerOf(GIV(newMethod)))) >> 1) & 268435967;
	primitiveIndex = (primBits & 511) + (((usqInt) primBits) >> 19);
	/* begin functionPointerFor:inClass: */
	primitiveFunctionPointer = ((void (*)(void)) ((primitiveIndex > MaxPrimitiveIndex
	? 0
	: primitiveTable[primitiveIndex])));

	/* We set the messageSelector for executeMethod below since things
	 like the at cache read messageSelector and so it cannot be left stale. */

	GIV(argumentCount) = argCnt;
	GIV(messageSelector) = GIV(nilObj);
	executeNewMethod();
	/* begin initPrimCall */
	GIV(primFailCode) = 0;
}


/*	Exit the critical section.
	This may change the active process as a result. */

static void
primitiveExitCriticalSection(void)
{   DECL_MAYBE_SQ_GLOBAL_STRUCT
    sqInt criticalSection;
    sqInt inInterpreter;
    sqInt owningProcess;
    sqInt owningProcessIndex;


	/* rcvr */

	criticalSection = longAt(GIV(stackPointer));

	/* CriticalSections are laid out like Semaphores */

	owningProcessIndex = ExcessSignalsIndex;
	if ((longAt((criticalSection + BaseHeaderSize) + (FirstLinkIndex << ShiftForWord))) == GIV(nilObj)) {
		longAtput((criticalSection + BaseHeaderSize) + (owningProcessIndex << ShiftForWord), GIV(nilObj));
	}
	else {

		/* We're going to switch process, either to an interpreted frame or a machine
			  code frame. To know whether to return or enter machine code we have to
			  know from whence we came.  We could have come from the interpreter,
			  either directly or via a machine code primitive.  We could have come from
			  machine code.  The instructionPointer tells us where from: */

		inInterpreter = GIV(instructionPointer) >= heapBase;

		/* store check unnecessary because aSemaphore referred to owningProcess
			  via its FirstLinkIndex slot before owningProcess was removed. */

		owningProcess = removeFirstLinkOfList(criticalSection);
		longAtput((criticalSection + BaseHeaderSize) + (owningProcessIndex << ShiftForWord), owningProcess);
		if (resumepreemptedYieldingIffrom(owningProcess, GIV(preemptionYields), CSExitCriticalSection)) {
			/* begin forProcessPrimitiveReturnToExecutivePostContextSwitch: */
			if (GIV(nextProfileTick) > 0) {
				checkProfileTick(GIV(newMethod));
			}
			returnToExecutivepostContextSwitch(inInterpreter, 1);
		}
	}
}

static void
primitiveExitToDebugger(void)
{
	error("Exit to debugger at user request");
}


/*	Computes E raised to the receiver power. */

static void
primitiveExp(void)
{   DECL_MAYBE_SQ_GLOBAL_STRUCT
    sqInt ccIndex;
    double f;
    sqInt object;
    double rcvr;
    double result;
    char *sp;
    sqInt successBoolean;
    sqInt top;
    sqInt top1;

	/* begin popFloat */
	VM_LABEL(1popFloat);
	/* begin popStack */
	top1 = longAt(GIV(stackPointer));
	GIV(stackPointer) += BytesPerWord;
	top = top1;
	/* begin assertClassOf:is:compactClassIndex: */
	VM_LABEL(25assertClassOfiscompactClassIndex);
	/* begin success: */
	/* begin is:instanceOf:compactClassIndex: */
	if ((top & 1)) {
		successBoolean = 0;
		goto l1;
	}
	ccIndex = (((usqInt) (longAt(top))) >> 12) & 31;
	if (ClassFloatCompactIndex != 0) {
		successBoolean = ClassFloatCompactIndex == ccIndex;
		goto l1;
	}
	successBoolean = (ccIndex == 0)
	 && (((longAt(top - BaseHeaderSize)) & AllButTypeMask) == (longAt((GIV(specialObjectsOop) + BaseHeaderSize) + (ClassFloat << ShiftForWord))));
l1:	/* end is:instanceOf:compactClassIndex: */;
	if (!(successBoolean)) {
		if (GIV(primFailCode) == 0) {

			/* Don't overwrite an error code that has already been set. */

			GIV(primFailCode) = 1;
		}
	}
	if (GIV(primFailCode) == 0) {
		;
		fetchFloatAtinto(top + BaseHeaderSize, result);
	}
	rcvr = result;
	if (GIV(primFailCode) == 0) {
		/* begin pushFloat: */
		f = exp(rcvr);
		/* begin push: */
		object = floatObjectOf(f);
		longAtput(sp = GIV(stackPointer) - BytesPerWord, object);
		GIV(stackPointer) = sp;
	}
	else {
		/* begin unPop: */
		GIV(stackPointer) -= 1 * BytesPerWord;
	}
}


/*	Exponent part of this float. */

static void
primitiveExponent(void)
{   DECL_MAYBE_SQ_GLOBAL_STRUCT
    sqInt ccIndex;
    double frac;
    int pwr;
    double rcvr;
    double result;
    char *sp;
    sqInt successBoolean;
    sqInt top;
    sqInt top1;

	/* begin popFloat */
	VM_LABEL(2popFloat);
	/* begin popStack */
	top1 = longAt(GIV(stackPointer));
	GIV(stackPointer) += BytesPerWord;
	top = top1;
	/* begin assertClassOf:is:compactClassIndex: */
	VM_LABEL(26assertClassOfiscompactClassIndex);
	/* begin success: */
	/* begin is:instanceOf:compactClassIndex: */
	if ((top & 1)) {
		successBoolean = 0;
		goto l1;
	}
	ccIndex = (((usqInt) (longAt(top))) >> 12) & 31;
	if (ClassFloatCompactIndex != 0) {
		successBoolean = ClassFloatCompactIndex == ccIndex;
		goto l1;
	}
	successBoolean = (ccIndex == 0)
	 && (((longAt(top - BaseHeaderSize)) & AllButTypeMask) == (longAt((GIV(specialObjectsOop) + BaseHeaderSize) + (ClassFloat << ShiftForWord))));
l1:	/* end is:instanceOf:compactClassIndex: */;
	if (!(successBoolean)) {
		if (GIV(primFailCode) == 0) {

			/* Don't overwrite an error code that has already been set. */

			GIV(primFailCode) = 1;
		}
	}
	if (GIV(primFailCode) == 0) {
		;
		fetchFloatAtinto(top + BaseHeaderSize, result);
	}
	rcvr = result;
	if (GIV(primFailCode) == 0) {
		frac = frexp(rcvr, &pwr);
		/* begin pushInteger: */
		/* begin push: */
		longAtput(sp = GIV(stackPointer) - BytesPerWord, (((pwr - 1) << 1) | 1));
		GIV(stackPointer) = sp;
	}
	else {
		/* begin unPop: */
		GIV(stackPointer) -= 1 * BytesPerWord;
	}
}


/*	Call an external primitive. External primitive methods first literals are
	an array of
	* The module name (String | Symbol) 
	* The function name (String | Symbol) 
	* The session ID (SmallInteger) [OBSOLETE] 
	* The function index (Integer) in the externalPrimitiveTable
	For fast interpreter dispatch in subsequent invocations the
	primitiveFunctionPointer in the method cache is rewritten, either to the
	function itself, or to zero if the external
	function is not found. This allows for fast responses as long as the
	method stays in
	the cache. The cache rewrite relies on lastMethodCacheProbeWrite which is
	set in
	addNewMethodToCache:. 
	Now that the VM flushes function addresses from its tables, the session ID
	is obsolete,
	but it is kept for backward compatibility. Also, a failed lookup is
	reported specially. If a
	method has been looked up and not been found, the function address is
	stored as -1
	(i.e., the SmallInteger -1 to distinguish from 16rFFFFFFFF which may be
	returned from
	lookup), and the primitive fails with PrimErrNotFound.
 */

static void
primitiveExternalCall(void)
{   DECL_MAYBE_SQ_GLOBAL_STRUCT
    void (*addr)();
    sqInt functionLength;
    sqInt functionName;
    sqInt header;
    sqInt header1;
    sqInt i;
    sqInt index;
    sqInt lit;
    sqInt moduleLength;
    sqInt moduleName;
    sqInt sz;
    sqInt sz1;

	if (!((literalCountOf(GIV(newMethod))) > 0)) {
		GIV(primFailCode) = PrimErrBadMethod; return;
	}

	/* Check if it's an array of length 4 */

	lit = longAt((GIV(newMethod) + BaseHeaderSize) + ((0 + LiteralStart) << ShiftForWord));
	if (!((((lit & 1) == 0)
 && (((((usqInt) (longAt(lit))) >> 8) & 15) == 2))
		 && ((lengthOf(lit)) == 4))) {
		GIV(primFailCode) = PrimErrBadMethod; return;
	}
	index = longAt((lit + BaseHeaderSize) + (3 << ShiftForWord));
	if (!((index & 1))) {
		GIV(primFailCode) = PrimErrBadMethod; return;
	}

	/* Check if we have already looked up the function and failed. */

	index = (index >> 1);
	if (index < 0) {
		rewriteMethodCacheEntryForExternalPrimitiveToFunction(0);
		GIV(primFailCode) = PrimErrNotFound; return;
	}
	if ((index > 0)
	 && (index <= MaxExternalPrimitiveTableSize)) {
		addr = externalPrimitiveTable[index - 1];
		if (addr != 0) {
			rewriteMethodCacheEntryForExternalPrimitiveToFunction(addr);
			callExternalPrimitive(addr);
			return;
		}
		GIV(primFailCode) = PrimErrNamedInternal; return;
	}
	longAtput((lit + BaseHeaderSize) + (2 << ShiftForWord), ConstZero);
	longAtput((lit + BaseHeaderSize) + (3 << ShiftForWord), ConstZero);
	moduleName = longAt((lit + BaseHeaderSize) + (0 << ShiftForWord));
	if (moduleName == GIV(nilObj)) {
		moduleLength = 0;
	}
	else {
		if (!(((moduleName & 1) == 0)
			 && (((((usqInt) (longAt(moduleName))) >> 8) & 15) >= 8))) {
			GIV(primFailCode) = PrimErrBadMethod;
		}
		/* begin lengthOf: */
		header = longAt(moduleName);
		/* begin lengthOf:baseHeader:format: */
		if ((header & TypeMask) == HeaderTypeSizeAndClass) {
			sz = (longAt(moduleName - (BytesPerWord * 2))) & LongSizeMask;
		}
		else {
			sz = header & SizeMask;
		}
		sz -= header & Size4Bit;
		if (((((usqInt) header) >> 8) & 15) <= 4) {
			moduleLength = ((usqInt) (sz - BaseHeaderSize)) >> ShiftForWord;
			goto l2;
		}
		if (((((usqInt) header) >> 8) & 15) < 8) {
			moduleLength = ((usqInt) (sz - BaseHeaderSize)) >> 2;
			goto l2;
		}
		else {
			moduleLength = (sz - BaseHeaderSize) - (((((usqInt) header) >> 8) & 15) & 3);
			goto l2;
		}
	l2:	/* end lengthOf:baseHeader:format: */;
	}
	functionName = longAt((lit + BaseHeaderSize) + (1 << ShiftForWord));
	if (!(((functionName & 1) == 0)
		 && (((((usqInt) (longAt(functionName))) >> 8) & 15) >= 8))) {
		GIV(primFailCode) = PrimErrBadMethod;
	}
	/* begin lengthOf: */
	header1 = longAt(functionName);
	/* begin lengthOf:baseHeader:format: */
	if ((header1 & TypeMask) == HeaderTypeSizeAndClass) {
		sz1 = (longAt(functionName - (BytesPerWord * 2))) & LongSizeMask;
	}
	else {
		sz1 = header1 & SizeMask;
	}
	sz1 -= header1 & Size4Bit;
	if (((((usqInt) header1) >> 8) & 15) <= 4) {
		functionLength = ((usqInt) (sz1 - BaseHeaderSize)) >> ShiftForWord;
		goto l3;
	}
	if (((((usqInt) header1) >> 8) & 15) < 8) {
		functionLength = ((usqInt) (sz1 - BaseHeaderSize)) >> 2;
		goto l3;
	}
	else {
		functionLength = (sz1 - BaseHeaderSize) - (((((usqInt) header1) >> 8) & 15) & 3);
		goto l3;
	}
l3:	/* end lengthOf:baseHeader:format: */;
	addr = ioLoadExternalFunctionOfLengthFromModuleOfLength(functionName + BaseHeaderSize, functionLength, moduleName + BaseHeaderSize, moduleLength);
	if (addr == 0) {
		index = -1;
	}
	else {
		/* begin addToExternalPrimitiveTable: */
		for (i = GIV(externalPrimitiveTableFirstFreeIndex); i <= (MaxExternalPrimitiveTableSize - 1); i += 1) {
			if ((externalPrimitiveTable[i]) == 0) {
				externalPrimitiveTable[i] = addr;
				index = GIV(externalPrimitiveTableFirstFreeIndex) = i + 1;
				goto l1;
			}
		}
		index = 0;
	l1:	/* end addToExternalPrimitiveTable: */;
	}
	longAtput((lit + BaseHeaderSize) + (3 << ShiftForWord), ((index << 1) | 1));
	if (index >= 0) {
		rewriteMethodCacheEntryForExternalPrimitiveToFunction(addr);
		callExternalPrimitive(addr);
	}
	else {
		rewriteMethodCacheEntryForExternalPrimitiveToFunction(0);
		GIV(primFailCode) = PrimErrNotFound; return;
	}
}


/*	Set general (unspecified) primitive failure. Don't overwrite an error code
	that has already been set. */
/*	Use returnTypeC: #sqInt because that's the way it is defined in sq.h.
	Use no explicit return so that Slang doesn't fail an inlining type-check
	when a primitive with return type void uses ^self primitiveFail to exit. */

sqInt
primitiveFail(void)
{   DECL_MAYBE_SQ_GLOBAL_STRUCT
	if (GIV(primFailCode) == 0) {
		GIV(primFailCode) = 1;
	}
}


/*	Set specific primitive failure.
	N.B. primitiveFailFor: PrimNoErr is expected to clear the primFailCode. */

sqInt
primitiveFailFor(sqInt reasonCode)
{
	return GIV(primFailCode) = reasonCode;
}

sqInt
primitiveFailureCode(void)
{
	return GIV(primFailCode);
}


/*	Primitive. Search up the context stack for the next method context marked
	for exception handling starting at the receiver. Return nil if none found */

static void
primitiveFindHandlerContext(void)
{   DECL_MAYBE_SQ_GLOBAL_STRUCT
    sqInt handlerOrNilOrZero;
    char *sp;

	/* begin externalWriteBackHeadFramePointers */
	assert((GIV(framePointer) - GIV(stackPointer)) < LargeContextSize);
	assert(GIV(stackPage) == (mostRecentlyUsedPage()));
	/* begin setHeadFP:andSP:inPage: */
	assert(GIV(stackPointer) < GIV(framePointer));
	assert((GIV(stackPointer) < ((GIV(stackPage)->baseAddress)))
	 && (GIV(stackPointer) > (((GIV(stackPage)->realStackLimit)) - LargeContextSize)));
	assert((GIV(framePointer) < ((GIV(stackPage)->baseAddress)))
	 && (GIV(framePointer) > (((GIV(stackPage)->realStackLimit)) - (((sqInt) LargeContextSize >> 1)))));
	(GIV(stackPage)->headFP = GIV(framePointer));
	(GIV(stackPage)->headSP = GIV(stackPointer));
	assert(pageListIsWellFormed());
	handlerOrNilOrZero = findMethodWithPrimitiveFromContextUpToContext(199, longAt(GIV(stackPointer)), GIV(nilObj));
	if (handlerOrNilOrZero == 0) {
		handlerOrNilOrZero = GIV(nilObj);
	}
	/* begin pop:thenPush: */
	longAtput(sp = GIV(stackPointer) + ((1 - 1) * BytesPerWord), handlerOrNilOrZero);
	GIV(stackPointer) = sp;
}


/*	Primitive. Search up the context stack for the next method context marked
	for unwind
	handling from the receiver up to but not including the argument. Return
	nil if none found.
 */

static void
primitiveFindNextUnwindContext(void)
{   DECL_MAYBE_SQ_GLOBAL_STRUCT
    sqInt calleeContext;
    sqInt handlerOrNilOrZero;
    char *sp;
    sqInt startContext;
    sqInt stopContext;
    char *theFP;
    sqInt value;

	stopContext = longAt(GIV(stackPointer));
	calleeContext = longAt(GIV(stackPointer) + (1 * BytesPerWord));
	if (!((stopContext == GIV(nilObj))
		 || (((stopContext & 1) == 0)
 && (((((usqInt) (longAt(stopContext))) >> 12) & 31) == ClassMethodContextCompactIndex)))) {
		/* begin primitiveFail */
		if (GIV(primFailCode) == 0) {
			GIV(primFailCode) = 1;
		}
		return;
	}
	/* begin externalWriteBackHeadFramePointers */
	assert((GIV(framePointer) - GIV(stackPointer)) < LargeContextSize);
	assert(GIV(stackPage) == (mostRecentlyUsedPage()));
	/* begin setHeadFP:andSP:inPage: */
	assert(GIV(stackPointer) < GIV(framePointer));
	assert((GIV(stackPointer) < ((GIV(stackPage)->baseAddress)))
	 && (GIV(stackPointer) > (((GIV(stackPage)->realStackLimit)) - LargeContextSize)));
	assert((GIV(framePointer) < ((GIV(stackPage)->baseAddress)))
	 && (GIV(framePointer) > (((GIV(stackPage)->realStackLimit)) - (((sqInt) LargeContextSize >> 1)))));
	(GIV(stackPage)->headFP = GIV(framePointer));
	(GIV(stackPage)->headSP = GIV(stackPointer));
	assert(pageListIsWellFormed());
	if ((((longAt((calleeContext + BaseHeaderSize) + (SenderIndex << ShiftForWord))) & 1))
	 && (!(isWidowedContext(calleeContext)))) {
		/* begin frameOfMarriedContext: */
		value = longAt((calleeContext + BaseHeaderSize) + (SenderIndex << ShiftForWord));
		/* begin withoutSmallIntegerTags: */
		assert((value & 1));
		theFP = pointerForOop(value - 1);
		if ((longAt(theFP + FoxSavedFP)) == 0) {
			handlerOrNilOrZero = findMethodWithPrimitiveFromContextUpToContext(198, frameCallerContext(theFP), stopContext);
		}
		else {
			handlerOrNilOrZero = findMethodWithPrimitiveFromFPUpToContext(198, frameCallerFP(theFP), stopContext);
		}
	}
	else {
		startContext = longAt((calleeContext + BaseHeaderSize) + (SenderIndex << ShiftForWord));
		if (((startContext & 1) == 0)
		 && (((((usqInt) (longAt(startContext))) >> 12) & 31) == ClassMethodContextCompactIndex)) {
			handlerOrNilOrZero = findMethodWithPrimitiveFromContextUpToContext(198, startContext, stopContext);
		}
		else {
			handlerOrNilOrZero = 0;
		}
	}
	if (handlerOrNilOrZero == 0) {
		handlerOrNilOrZero = GIV(nilObj);
	}
	/* begin pop:thenPush: */
	longAtput(sp = GIV(stackPointer) + ((2 - 1) * BytesPerWord), handlerOrNilOrZero);
	GIV(stackPointer) = sp;
}

static void
primitiveFloatAdd(void)
{   DECL_MAYBE_SQ_GLOBAL_STRUCT
    double arg;
    sqInt argOop;
    sqInt ccIndex;
    sqInt ccIndex1;
    double rcvr;
    sqInt rcvrOop;
    double result;
    double result1;
    char *sp;
    sqInt successBoolean;
    sqInt successBoolean1;

	/* begin primitiveFloatAdd:toArg: */
	rcvrOop = longAt(GIV(stackPointer) + (1 * BytesPerWord));
	argOop = longAt(GIV(stackPointer));
	/* begin loadFloatOrIntFrom: */
	if ((rcvrOop & 1)) {
		rcvr = ((double) ((rcvrOop >> 1)) );
		goto l2;
	}
	/* begin assertClassOf:is:compactClassIndex: */
	VM_LABEL(27assertClassOfiscompactClassIndex);
	/* begin success: */
	/* begin is:instanceOf:compactClassIndex: */
	if ((rcvrOop & 1)) {
		successBoolean = 0;
		goto l1;
	}
	ccIndex = (((usqInt) (longAt(rcvrOop))) >> 12) & 31;
	if (ClassFloatCompactIndex != 0) {
		successBoolean = ClassFloatCompactIndex == ccIndex;
		goto l1;
	}
	successBoolean = (ccIndex == 0)
	 && (((longAt(rcvrOop - BaseHeaderSize)) & AllButTypeMask) == (longAt((GIV(specialObjectsOop) + BaseHeaderSize) + (ClassFloat << ShiftForWord))));
l1:	/* end is:instanceOf:compactClassIndex: */;
	if (!(successBoolean)) {
		if (GIV(primFailCode) == 0) {

			/* Don't overwrite an error code that has already been set. */

			GIV(primFailCode) = 1;
		}
	}
	;
	if (GIV(primFailCode) == 0) {
		fetchFloatAtinto(rcvrOop + BaseHeaderSize, result);
	}
	rcvr = result;
l2:	/* end loadFloatOrIntFrom: */;
	/* begin loadFloatOrIntFrom: */
	if ((argOop & 1)) {
		arg = ((double) ((argOop >> 1)) );
		goto l4;
	}
	/* begin assertClassOf:is:compactClassIndex: */
	VM_LABEL(28assertClassOfiscompactClassIndex);
	/* begin success: */
	/* begin is:instanceOf:compactClassIndex: */
	if ((argOop & 1)) {
		successBoolean1 = 0;
		goto l3;
	}
	ccIndex1 = (((usqInt) (longAt(argOop))) >> 12) & 31;
	if (ClassFloatCompactIndex != 0) {
		successBoolean1 = ClassFloatCompactIndex == ccIndex1;
		goto l3;
	}
	successBoolean1 = (ccIndex1 == 0)
	 && (((longAt(argOop - BaseHeaderSize)) & AllButTypeMask) == (longAt((GIV(specialObjectsOop) + BaseHeaderSize) + (ClassFloat << ShiftForWord))));
l3:	/* end is:instanceOf:compactClassIndex: */;
	if (!(successBoolean1)) {
		if (GIV(primFailCode) == 0) {

			/* Don't overwrite an error code that has already been set. */

			GIV(primFailCode) = 1;
		}
	}
	;
	if (GIV(primFailCode) == 0) {
		fetchFloatAtinto(argOop + BaseHeaderSize, result1);
	}
	arg = result1;
l4:	/* end loadFloatOrIntFrom: */;
	if (GIV(primFailCode) == 0) {
		/* begin pop:thenPushFloat: */
		longAtput(sp = GIV(stackPointer) + ((2 - 1) * BytesPerWord), floatObjectOf(rcvr + arg));
		GIV(stackPointer) = sp;
	}
	return;
}


/*	Provide platform-independent access to 32-bit words comprising
	a Float. Map index 1 onto the most significant word and index 2
	onto the least significant word. */

static void
primitiveFloatAt(void)
{   DECL_MAYBE_SQ_GLOBAL_STRUCT
    sqInt index;
    sqInt rcvr;
    sqInt reasonCode;
    usqInt result;
    char *sp;
    char *sp1;

	/* begin initPrimCall */
	GIV(primFailCode) = 0;
	rcvr = longAt(GIV(stackPointer) + (1 * BytesPerWord));
	index = longAt(GIV(stackPointer));
	if (index == ConstOne) {
		result = positive32BitIntegerFor(fetchLong32ofObject((VMBIGENDIAN
			? 0
			: 1), rcvr));
		/* begin pop:thenPush: */
		longAtput(sp = GIV(stackPointer) + ((2 - 1) * BytesPerWord), result);
		GIV(stackPointer) = sp;
		return;
	}
	if (index == ConstTwo) {
		result = positive32BitIntegerFor(fetchLong32ofObject((VMBIGENDIAN
			? 1
			: 0), rcvr));
		/* begin pop:thenPush: */
		longAtput(sp1 = GIV(stackPointer) + ((2 - 1) * BytesPerWord), result);
		GIV(stackPointer) = sp1;
		return;
	}
	/* begin primitiveFailFor: */
	reasonCode = ((index & 1)
		? PrimErrBadIndex
		: PrimErrBadArgument);
	GIV(primFailCode) = reasonCode;
}


/*	Provide platform-independent access to 32-bit words comprising
	a Float. Map index 1 onto the most significant word and index 2
	onto the least significant word. */

static void
primitiveFloatAtPut(void)
{   DECL_MAYBE_SQ_GLOBAL_STRUCT
    sqInt fieldIndex;
    sqInt fieldIndex1;
    sqInt index;
    sqInt oopToStore;
    sqInt rcvr;
    sqInt reasonCode;
    char *sp;
    char *sp1;
    sqInt valueToStore;

	/* begin initPrimCall */
	GIV(primFailCode) = 0;
	oopToStore = longAt(GIV(stackPointer));
	valueToStore = positive32BitValueOf(oopToStore);
	if (!(GIV(primFailCode) == 0)) {
		GIV(primFailCode) = PrimErrBadArgument; return;
	}
	rcvr = longAt(GIV(stackPointer) + (2 * BytesPerWord));
	index = longAt(GIV(stackPointer) + (1 * BytesPerWord));
	if (index == ConstOne) {
		/* begin storeLong32:ofObject:withValue: */
		fieldIndex = (VMBIGENDIAN
			? 0
			: 1);
		long32Atput((rcvr + BaseHeaderSize) + (fieldIndex << 2), valueToStore);
		/* begin pop:thenPush: */
		longAtput(sp = GIV(stackPointer) + ((3 - 1) * BytesPerWord), oopToStore);
		GIV(stackPointer) = sp;
		return;
	}
	if (index == ConstTwo) {
		/* begin storeLong32:ofObject:withValue: */
		fieldIndex1 = (VMBIGENDIAN
			? 1
			: 0);
		long32Atput((rcvr + BaseHeaderSize) + (fieldIndex1 << 2), valueToStore);
		/* begin pop:thenPush: */
		longAtput(sp1 = GIV(stackPointer) + ((3 - 1) * BytesPerWord), oopToStore);
		GIV(stackPointer) = sp1;
		return;
	}
	/* begin primitiveFailFor: */
	reasonCode = ((index & 1)
		? PrimErrBadIndex
		: PrimErrBadArgument);
	GIV(primFailCode) = reasonCode;
}

static void
primitiveFloatDivide(void)
{   DECL_MAYBE_SQ_GLOBAL_STRUCT
    double arg;
    sqInt argOop;
    sqInt ccIndex;
    sqInt ccIndex1;
    double rcvr;
    sqInt rcvrOop;
    double result;
    double result1;
    char *sp;
    sqInt successBoolean;
    sqInt successBoolean1;

	/* begin primitiveFloatDivide:byArg: */
	rcvrOop = longAt(GIV(stackPointer) + (1 * BytesPerWord));
	argOop = longAt(GIV(stackPointer));
	/* begin loadFloatOrIntFrom: */
	if ((rcvrOop & 1)) {
		rcvr = ((double) ((rcvrOop >> 1)) );
		goto l2;
	}
	/* begin assertClassOf:is:compactClassIndex: */
	VM_LABEL(29assertClassOfiscompactClassIndex);
	/* begin success: */
	/* begin is:instanceOf:compactClassIndex: */
	if ((rcvrOop & 1)) {
		successBoolean = 0;
		goto l1;
	}
	ccIndex = (((usqInt) (longAt(rcvrOop))) >> 12) & 31;
	if (ClassFloatCompactIndex != 0) {
		successBoolean = ClassFloatCompactIndex == ccIndex;
		goto l1;
	}
	successBoolean = (ccIndex == 0)
	 && (((longAt(rcvrOop - BaseHeaderSize)) & AllButTypeMask) == (longAt((GIV(specialObjectsOop) + BaseHeaderSize) + (ClassFloat << ShiftForWord))));
l1:	/* end is:instanceOf:compactClassIndex: */;
	if (!(successBoolean)) {
		if (GIV(primFailCode) == 0) {

			/* Don't overwrite an error code that has already been set. */

			GIV(primFailCode) = 1;
		}
	}
	;
	if (GIV(primFailCode) == 0) {
		fetchFloatAtinto(rcvrOop + BaseHeaderSize, result);
	}
	rcvr = result;
l2:	/* end loadFloatOrIntFrom: */;
	/* begin loadFloatOrIntFrom: */
	if ((argOop & 1)) {
		arg = ((double) ((argOop >> 1)) );
		goto l4;
	}
	/* begin assertClassOf:is:compactClassIndex: */
	VM_LABEL(30assertClassOfiscompactClassIndex);
	/* begin success: */
	/* begin is:instanceOf:compactClassIndex: */
	if ((argOop & 1)) {
		successBoolean1 = 0;
		goto l3;
	}
	ccIndex1 = (((usqInt) (longAt(argOop))) >> 12) & 31;
	if (ClassFloatCompactIndex != 0) {
		successBoolean1 = ClassFloatCompactIndex == ccIndex1;
		goto l3;
	}
	successBoolean1 = (ccIndex1 == 0)
	 && (((longAt(argOop - BaseHeaderSize)) & AllButTypeMask) == (longAt((GIV(specialObjectsOop) + BaseHeaderSize) + (ClassFloat << ShiftForWord))));
l3:	/* end is:instanceOf:compactClassIndex: */;
	if (!(successBoolean1)) {
		if (GIV(primFailCode) == 0) {

			/* Don't overwrite an error code that has already been set. */

			GIV(primFailCode) = 1;
		}
	}
	;
	if (GIV(primFailCode) == 0) {
		fetchFloatAtinto(argOop + BaseHeaderSize, result1);
	}
	arg = result1;
l4:	/* end loadFloatOrIntFrom: */;
	/* begin success: */
	if (!(arg != 0.0)) {
		if (GIV(primFailCode) == 0) {

			/* Don't overwrite an error code that has already been set. */

			GIV(primFailCode) = 1;
		}
	}
	if (GIV(primFailCode) == 0) {
		/* begin pop:thenPushFloat: */
		longAtput(sp = GIV(stackPointer) + ((2 - 1) * BytesPerWord), floatObjectOf(rcvr / arg));
		GIV(stackPointer) = sp;
	}
}

static void
primitiveFloatEqual(void)
{   DECL_MAYBE_SQ_GLOBAL_STRUCT
    sqInt aBool;
    double arg;
    sqInt ccIndex;
    sqInt ccIndex1;
    double rcvr;
    double result;
    double result1;
    char *sp;
    sqInt successBoolean;
    sqInt successBoolean1;

	/* begin primitiveFloatEqual:toArg: */
	/* begin loadFloatOrIntFrom: */
	if (((longAt(GIV(stackPointer) + (1 * BytesPerWord))) & 1)) {
		rcvr = ((double) (((longAt(GIV(stackPointer) + (1 * BytesPerWord))) >> 1)) );
		goto l2;
	}
	/* begin assertClassOf:is:compactClassIndex: */
	VM_LABEL(31assertClassOfiscompactClassIndex);
	/* begin success: */
	/* begin is:instanceOf:compactClassIndex: */
	if (((longAt(GIV(stackPointer) + (1 * BytesPerWord))) & 1)) {
		successBoolean = 0;
		goto l1;
	}
	ccIndex = (((usqInt) (longAt(longAt(GIV(stackPointer) + (1 * BytesPerWord))))) >> 12) & 31;
	if (ClassFloatCompactIndex != 0) {
		successBoolean = ClassFloatCompactIndex == ccIndex;
		goto l1;
	}
	successBoolean = (ccIndex == 0)
	 && (((longAt((longAt(GIV(stackPointer) + (1 * BytesPerWord))) - BaseHeaderSize)) & AllButTypeMask) == (longAt((GIV(specialObjectsOop) + BaseHeaderSize) + (ClassFloat << ShiftForWord))));
l1:	/* end is:instanceOf:compactClassIndex: */;
	if (!(successBoolean)) {
		if (GIV(primFailCode) == 0) {

			/* Don't overwrite an error code that has already been set. */

			GIV(primFailCode) = 1;
		}
	}
	;
	if (GIV(primFailCode) == 0) {
		fetchFloatAtinto((longAt(GIV(stackPointer) + (1 * BytesPerWord))) + BaseHeaderSize, result);
	}
	rcvr = result;
l2:	/* end loadFloatOrIntFrom: */;
	/* begin loadFloatOrIntFrom: */
	if (((longAt(GIV(stackPointer))) & 1)) {
		arg = ((double) (((longAt(GIV(stackPointer))) >> 1)) );
		goto l4;
	}
	/* begin assertClassOf:is:compactClassIndex: */
	VM_LABEL(32assertClassOfiscompactClassIndex);
	/* begin success: */
	/* begin is:instanceOf:compactClassIndex: */
	if (((longAt(GIV(stackPointer))) & 1)) {
		successBoolean1 = 0;
		goto l3;
	}
	ccIndex1 = (((usqInt) (longAt(longAt(GIV(stackPointer))))) >> 12) & 31;
	if (ClassFloatCompactIndex != 0) {
		successBoolean1 = ClassFloatCompactIndex == ccIndex1;
		goto l3;
	}
	successBoolean1 = (ccIndex1 == 0)
	 && (((longAt((longAt(GIV(stackPointer))) - BaseHeaderSize)) & AllButTypeMask) == (longAt((GIV(specialObjectsOop) + BaseHeaderSize) + (ClassFloat << ShiftForWord))));
l3:	/* end is:instanceOf:compactClassIndex: */;
	if (!(successBoolean1)) {
		if (GIV(primFailCode) == 0) {

			/* Don't overwrite an error code that has already been set. */

			GIV(primFailCode) = 1;
		}
	}
	;
	if (GIV(primFailCode) == 0) {
		fetchFloatAtinto((longAt(GIV(stackPointer))) + BaseHeaderSize, result1);
	}
	arg = result1;
l4:	/* end loadFloatOrIntFrom: */;
	aBool = rcvr == arg;
	if (GIV(primFailCode) == 0) {
		/* begin pop:thenPushBool: */
		longAtput(sp = GIV(stackPointer) + ((2 - 1) * BytesPerWord), (aBool
			? GIV(trueObj)
			: GIV(falseObj)));
		GIV(stackPointer) = sp;
	}
}

static void
primitiveFloatGreaterOrEqual(void)
{   DECL_MAYBE_SQ_GLOBAL_STRUCT
    sqInt aBool;
    double arg;
    sqInt ccIndex;
    sqInt ccIndex1;
    double rcvr;
    double result;
    double result1;
    char *sp;
    sqInt successBoolean;
    sqInt successBoolean1;

	/* begin primitiveFloatGreaterOrEqual:toArg: */
	/* begin loadFloatOrIntFrom: */
	if (((longAt(GIV(stackPointer) + (1 * BytesPerWord))) & 1)) {
		rcvr = ((double) (((longAt(GIV(stackPointer) + (1 * BytesPerWord))) >> 1)) );
		goto l2;
	}
	/* begin assertClassOf:is:compactClassIndex: */
	VM_LABEL(33assertClassOfiscompactClassIndex);
	/* begin success: */
	/* begin is:instanceOf:compactClassIndex: */
	if (((longAt(GIV(stackPointer) + (1 * BytesPerWord))) & 1)) {
		successBoolean = 0;
		goto l1;
	}
	ccIndex = (((usqInt) (longAt(longAt(GIV(stackPointer) + (1 * BytesPerWord))))) >> 12) & 31;
	if (ClassFloatCompactIndex != 0) {
		successBoolean = ClassFloatCompactIndex == ccIndex;
		goto l1;
	}
	successBoolean = (ccIndex == 0)
	 && (((longAt((longAt(GIV(stackPointer) + (1 * BytesPerWord))) - BaseHeaderSize)) & AllButTypeMask) == (longAt((GIV(specialObjectsOop) + BaseHeaderSize) + (ClassFloat << ShiftForWord))));
l1:	/* end is:instanceOf:compactClassIndex: */;
	if (!(successBoolean)) {
		if (GIV(primFailCode) == 0) {

			/* Don't overwrite an error code that has already been set. */

			GIV(primFailCode) = 1;
		}
	}
	;
	if (GIV(primFailCode) == 0) {
		fetchFloatAtinto((longAt(GIV(stackPointer) + (1 * BytesPerWord))) + BaseHeaderSize, result);
	}
	rcvr = result;
l2:	/* end loadFloatOrIntFrom: */;
	/* begin loadFloatOrIntFrom: */
	if (((longAt(GIV(stackPointer))) & 1)) {
		arg = ((double) (((longAt(GIV(stackPointer))) >> 1)) );
		goto l4;
	}
	/* begin assertClassOf:is:compactClassIndex: */
	VM_LABEL(34assertClassOfiscompactClassIndex);
	/* begin success: */
	/* begin is:instanceOf:compactClassIndex: */
	if (((longAt(GIV(stackPointer))) & 1)) {
		successBoolean1 = 0;
		goto l3;
	}
	ccIndex1 = (((usqInt) (longAt(longAt(GIV(stackPointer))))) >> 12) & 31;
	if (ClassFloatCompactIndex != 0) {
		successBoolean1 = ClassFloatCompactIndex == ccIndex1;
		goto l3;
	}
	successBoolean1 = (ccIndex1 == 0)
	 && (((longAt((longAt(GIV(stackPointer))) - BaseHeaderSize)) & AllButTypeMask) == (longAt((GIV(specialObjectsOop) + BaseHeaderSize) + (ClassFloat << ShiftForWord))));
l3:	/* end is:instanceOf:compactClassIndex: */;
	if (!(successBoolean1)) {
		if (GIV(primFailCode) == 0) {

			/* Don't overwrite an error code that has already been set. */

			GIV(primFailCode) = 1;
		}
	}
	;
	if (GIV(primFailCode) == 0) {
		fetchFloatAtinto((longAt(GIV(stackPointer))) + BaseHeaderSize, result1);
	}
	arg = result1;
l4:	/* end loadFloatOrIntFrom: */;
	aBool = rcvr >= arg;
	if (GIV(primFailCode) == 0) {
		/* begin pop:thenPushBool: */
		longAtput(sp = GIV(stackPointer) + ((2 - 1) * BytesPerWord), (aBool
			? GIV(trueObj)
			: GIV(falseObj)));
		GIV(stackPointer) = sp;
	}
}

static void
primitiveFloatGreaterThan(void)
{   DECL_MAYBE_SQ_GLOBAL_STRUCT
    sqInt aBool;
    double arg;
    sqInt ccIndex;
    sqInt ccIndex1;
    double rcvr;
    double result;
    double result1;
    char *sp;
    sqInt successBoolean;
    sqInt successBoolean1;

	/* begin primitiveFloatGreater:thanArg: */
	/* begin loadFloatOrIntFrom: */
	if (((longAt(GIV(stackPointer) + (1 * BytesPerWord))) & 1)) {
		rcvr = ((double) (((longAt(GIV(stackPointer) + (1 * BytesPerWord))) >> 1)) );
		goto l2;
	}
	/* begin assertClassOf:is:compactClassIndex: */
	VM_LABEL(35assertClassOfiscompactClassIndex);
	/* begin success: */
	/* begin is:instanceOf:compactClassIndex: */
	if (((longAt(GIV(stackPointer) + (1 * BytesPerWord))) & 1)) {
		successBoolean = 0;
		goto l1;
	}
	ccIndex = (((usqInt) (longAt(longAt(GIV(stackPointer) + (1 * BytesPerWord))))) >> 12) & 31;
	if (ClassFloatCompactIndex != 0) {
		successBoolean = ClassFloatCompactIndex == ccIndex;
		goto l1;
	}
	successBoolean = (ccIndex == 0)
	 && (((longAt((longAt(GIV(stackPointer) + (1 * BytesPerWord))) - BaseHeaderSize)) & AllButTypeMask) == (longAt((GIV(specialObjectsOop) + BaseHeaderSize) + (ClassFloat << ShiftForWord))));
l1:	/* end is:instanceOf:compactClassIndex: */;
	if (!(successBoolean)) {
		if (GIV(primFailCode) == 0) {

			/* Don't overwrite an error code that has already been set. */

			GIV(primFailCode) = 1;
		}
	}
	;
	if (GIV(primFailCode) == 0) {
		fetchFloatAtinto((longAt(GIV(stackPointer) + (1 * BytesPerWord))) + BaseHeaderSize, result);
	}
	rcvr = result;
l2:	/* end loadFloatOrIntFrom: */;
	/* begin loadFloatOrIntFrom: */
	if (((longAt(GIV(stackPointer))) & 1)) {
		arg = ((double) (((longAt(GIV(stackPointer))) >> 1)) );
		goto l4;
	}
	/* begin assertClassOf:is:compactClassIndex: */
	VM_LABEL(36assertClassOfiscompactClassIndex);
	/* begin success: */
	/* begin is:instanceOf:compactClassIndex: */
	if (((longAt(GIV(stackPointer))) & 1)) {
		successBoolean1 = 0;
		goto l3;
	}
	ccIndex1 = (((usqInt) (longAt(longAt(GIV(stackPointer))))) >> 12) & 31;
	if (ClassFloatCompactIndex != 0) {
		successBoolean1 = ClassFloatCompactIndex == ccIndex1;
		goto l3;
	}
	successBoolean1 = (ccIndex1 == 0)
	 && (((longAt((longAt(GIV(stackPointer))) - BaseHeaderSize)) & AllButTypeMask) == (longAt((GIV(specialObjectsOop) + BaseHeaderSize) + (ClassFloat << ShiftForWord))));
l3:	/* end is:instanceOf:compactClassIndex: */;
	if (!(successBoolean1)) {
		if (GIV(primFailCode) == 0) {

			/* Don't overwrite an error code that has already been set. */

			GIV(primFailCode) = 1;
		}
	}
	;
	if (GIV(primFailCode) == 0) {
		fetchFloatAtinto((longAt(GIV(stackPointer))) + BaseHeaderSize, result1);
	}
	arg = result1;
l4:	/* end loadFloatOrIntFrom: */;
	aBool = rcvr > arg;
	if (GIV(primFailCode) == 0) {
		/* begin pop:thenPushBool: */
		longAtput(sp = GIV(stackPointer) + ((2 - 1) * BytesPerWord), (aBool
			? GIV(trueObj)
			: GIV(falseObj)));
		GIV(stackPointer) = sp;
	}
}

static void
primitiveFloatLessOrEqual(void)
{   DECL_MAYBE_SQ_GLOBAL_STRUCT
    sqInt aBool;
    double arg;
    sqInt ccIndex;
    sqInt ccIndex1;
    double rcvr;
    double result;
    double result1;
    char *sp;
    sqInt successBoolean;
    sqInt successBoolean1;

	/* begin primitiveFloatLessOrEqual:toArg: */
	/* begin loadFloatOrIntFrom: */
	if (((longAt(GIV(stackPointer) + (1 * BytesPerWord))) & 1)) {
		rcvr = ((double) (((longAt(GIV(stackPointer) + (1 * BytesPerWord))) >> 1)) );
		goto l2;
	}
	/* begin assertClassOf:is:compactClassIndex: */
	VM_LABEL(37assertClassOfiscompactClassIndex);
	/* begin success: */
	/* begin is:instanceOf:compactClassIndex: */
	if (((longAt(GIV(stackPointer) + (1 * BytesPerWord))) & 1)) {
		successBoolean = 0;
		goto l1;
	}
	ccIndex = (((usqInt) (longAt(longAt(GIV(stackPointer) + (1 * BytesPerWord))))) >> 12) & 31;
	if (ClassFloatCompactIndex != 0) {
		successBoolean = ClassFloatCompactIndex == ccIndex;
		goto l1;
	}
	successBoolean = (ccIndex == 0)
	 && (((longAt((longAt(GIV(stackPointer) + (1 * BytesPerWord))) - BaseHeaderSize)) & AllButTypeMask) == (longAt((GIV(specialObjectsOop) + BaseHeaderSize) + (ClassFloat << ShiftForWord))));
l1:	/* end is:instanceOf:compactClassIndex: */;
	if (!(successBoolean)) {
		if (GIV(primFailCode) == 0) {

			/* Don't overwrite an error code that has already been set. */

			GIV(primFailCode) = 1;
		}
	}
	;
	if (GIV(primFailCode) == 0) {
		fetchFloatAtinto((longAt(GIV(stackPointer) + (1 * BytesPerWord))) + BaseHeaderSize, result);
	}
	rcvr = result;
l2:	/* end loadFloatOrIntFrom: */;
	/* begin loadFloatOrIntFrom: */
	if (((longAt(GIV(stackPointer))) & 1)) {
		arg = ((double) (((longAt(GIV(stackPointer))) >> 1)) );
		goto l4;
	}
	/* begin assertClassOf:is:compactClassIndex: */
	VM_LABEL(38assertClassOfiscompactClassIndex);
	/* begin success: */
	/* begin is:instanceOf:compactClassIndex: */
	if (((longAt(GIV(stackPointer))) & 1)) {
		successBoolean1 = 0;
		goto l3;
	}
	ccIndex1 = (((usqInt) (longAt(longAt(GIV(stackPointer))))) >> 12) & 31;
	if (ClassFloatCompactIndex != 0) {
		successBoolean1 = ClassFloatCompactIndex == ccIndex1;
		goto l3;
	}
	successBoolean1 = (ccIndex1 == 0)
	 && (((longAt((longAt(GIV(stackPointer))) - BaseHeaderSize)) & AllButTypeMask) == (longAt((GIV(specialObjectsOop) + BaseHeaderSize) + (ClassFloat << ShiftForWord))));
l3:	/* end is:instanceOf:compactClassIndex: */;
	if (!(successBoolean1)) {
		if (GIV(primFailCode) == 0) {

			/* Don't overwrite an error code that has already been set. */

			GIV(primFailCode) = 1;
		}
	}
	;
	if (GIV(primFailCode) == 0) {
		fetchFloatAtinto((longAt(GIV(stackPointer))) + BaseHeaderSize, result1);
	}
	arg = result1;
l4:	/* end loadFloatOrIntFrom: */;
	aBool = rcvr <= arg;
	if (GIV(primFailCode) == 0) {
		/* begin pop:thenPushBool: */
		longAtput(sp = GIV(stackPointer) + ((2 - 1) * BytesPerWord), (aBool
			? GIV(trueObj)
			: GIV(falseObj)));
		GIV(stackPointer) = sp;
	}
}

static void
primitiveFloatLessThan(void)
{   DECL_MAYBE_SQ_GLOBAL_STRUCT
    sqInt aBool;
    double arg;
    sqInt ccIndex;
    sqInt ccIndex1;
    double rcvr;
    double result;
    double result1;
    char *sp;
    sqInt successBoolean;
    sqInt successBoolean1;

	/* begin primitiveFloatLess:thanArg: */
	/* begin loadFloatOrIntFrom: */
	if (((longAt(GIV(stackPointer) + (1 * BytesPerWord))) & 1)) {
		rcvr = ((double) (((longAt(GIV(stackPointer) + (1 * BytesPerWord))) >> 1)) );
		goto l2;
	}
	/* begin assertClassOf:is:compactClassIndex: */
	VM_LABEL(39assertClassOfiscompactClassIndex);
	/* begin success: */
	/* begin is:instanceOf:compactClassIndex: */
	if (((longAt(GIV(stackPointer) + (1 * BytesPerWord))) & 1)) {
		successBoolean = 0;
		goto l1;
	}
	ccIndex = (((usqInt) (longAt(longAt(GIV(stackPointer) + (1 * BytesPerWord))))) >> 12) & 31;
	if (ClassFloatCompactIndex != 0) {
		successBoolean = ClassFloatCompactIndex == ccIndex;
		goto l1;
	}
	successBoolean = (ccIndex == 0)
	 && (((longAt((longAt(GIV(stackPointer) + (1 * BytesPerWord))) - BaseHeaderSize)) & AllButTypeMask) == (longAt((GIV(specialObjectsOop) + BaseHeaderSize) + (ClassFloat << ShiftForWord))));
l1:	/* end is:instanceOf:compactClassIndex: */;
	if (!(successBoolean)) {
		if (GIV(primFailCode) == 0) {

			/* Don't overwrite an error code that has already been set. */

			GIV(primFailCode) = 1;
		}
	}
	;
	if (GIV(primFailCode) == 0) {
		fetchFloatAtinto((longAt(GIV(stackPointer) + (1 * BytesPerWord))) + BaseHeaderSize, result);
	}
	rcvr = result;
l2:	/* end loadFloatOrIntFrom: */;
	/* begin loadFloatOrIntFrom: */
	if (((longAt(GIV(stackPointer))) & 1)) {
		arg = ((double) (((longAt(GIV(stackPointer))) >> 1)) );
		goto l4;
	}
	/* begin assertClassOf:is:compactClassIndex: */
	VM_LABEL(40assertClassOfiscompactClassIndex);
	/* begin success: */
	/* begin is:instanceOf:compactClassIndex: */
	if (((longAt(GIV(stackPointer))) & 1)) {
		successBoolean1 = 0;
		goto l3;
	}
	ccIndex1 = (((usqInt) (longAt(longAt(GIV(stackPointer))))) >> 12) & 31;
	if (ClassFloatCompactIndex != 0) {
		successBoolean1 = ClassFloatCompactIndex == ccIndex1;
		goto l3;
	}
	successBoolean1 = (ccIndex1 == 0)
	 && (((longAt((longAt(GIV(stackPointer))) - BaseHeaderSize)) & AllButTypeMask) == (longAt((GIV(specialObjectsOop) + BaseHeaderSize) + (ClassFloat << ShiftForWord))));
l3:	/* end is:instanceOf:compactClassIndex: */;
	if (!(successBoolean1)) {
		if (GIV(primFailCode) == 0) {

			/* Don't overwrite an error code that has already been set. */

			GIV(primFailCode) = 1;
		}
	}
	;
	if (GIV(primFailCode) == 0) {
		fetchFloatAtinto((longAt(GIV(stackPointer))) + BaseHeaderSize, result1);
	}
	arg = result1;
l4:	/* end loadFloatOrIntFrom: */;
	aBool = rcvr < arg;
	if (GIV(primFailCode) == 0) {
		/* begin pop:thenPushBool: */
		longAtput(sp = GIV(stackPointer) + ((2 - 1) * BytesPerWord), (aBool
			? GIV(trueObj)
			: GIV(falseObj)));
		GIV(stackPointer) = sp;
	}
}

static void
primitiveFloatMultiply(void)
{   DECL_MAYBE_SQ_GLOBAL_STRUCT
    double arg;
    sqInt argOop;
    sqInt ccIndex;
    sqInt ccIndex1;
    double rcvr;
    sqInt rcvrOop;
    double result;
    double result1;
    char *sp;
    sqInt successBoolean;
    sqInt successBoolean1;

	/* begin primitiveFloatMultiply:byArg: */
	rcvrOop = longAt(GIV(stackPointer) + (1 * BytesPerWord));
	argOop = longAt(GIV(stackPointer));
	/* begin loadFloatOrIntFrom: */
	if ((rcvrOop & 1)) {
		rcvr = ((double) ((rcvrOop >> 1)) );
		goto l2;
	}
	/* begin assertClassOf:is:compactClassIndex: */
	VM_LABEL(41assertClassOfiscompactClassIndex);
	/* begin success: */
	/* begin is:instanceOf:compactClassIndex: */
	if ((rcvrOop & 1)) {
		successBoolean = 0;
		goto l1;
	}
	ccIndex = (((usqInt) (longAt(rcvrOop))) >> 12) & 31;
	if (ClassFloatCompactIndex != 0) {
		successBoolean = ClassFloatCompactIndex == ccIndex;
		goto l1;
	}
	successBoolean = (ccIndex == 0)
	 && (((longAt(rcvrOop - BaseHeaderSize)) & AllButTypeMask) == (longAt((GIV(specialObjectsOop) + BaseHeaderSize) + (ClassFloat << ShiftForWord))));
l1:	/* end is:instanceOf:compactClassIndex: */;
	if (!(successBoolean)) {
		if (GIV(primFailCode) == 0) {

			/* Don't overwrite an error code that has already been set. */

			GIV(primFailCode) = 1;
		}
	}
	;
	if (GIV(primFailCode) == 0) {
		fetchFloatAtinto(rcvrOop + BaseHeaderSize, result);
	}
	rcvr = result;
l2:	/* end loadFloatOrIntFrom: */;
	/* begin loadFloatOrIntFrom: */
	if ((argOop & 1)) {
		arg = ((double) ((argOop >> 1)) );
		goto l4;
	}
	/* begin assertClassOf:is:compactClassIndex: */
	VM_LABEL(42assertClassOfiscompactClassIndex);
	/* begin success: */
	/* begin is:instanceOf:compactClassIndex: */
	if ((argOop & 1)) {
		successBoolean1 = 0;
		goto l3;
	}
	ccIndex1 = (((usqInt) (longAt(argOop))) >> 12) & 31;
	if (ClassFloatCompactIndex != 0) {
		successBoolean1 = ClassFloatCompactIndex == ccIndex1;
		goto l3;
	}
	successBoolean1 = (ccIndex1 == 0)
	 && (((longAt(argOop - BaseHeaderSize)) & AllButTypeMask) == (longAt((GIV(specialObjectsOop) + BaseHeaderSize) + (ClassFloat << ShiftForWord))));
l3:	/* end is:instanceOf:compactClassIndex: */;
	if (!(successBoolean1)) {
		if (GIV(primFailCode) == 0) {

			/* Don't overwrite an error code that has already been set. */

			GIV(primFailCode) = 1;
		}
	}
	;
	if (GIV(primFailCode) == 0) {
		fetchFloatAtinto(argOop + BaseHeaderSize, result1);
	}
	arg = result1;
l4:	/* end loadFloatOrIntFrom: */;
	if (GIV(primFailCode) == 0) {
		/* begin pop:thenPushFloat: */
		longAtput(sp = GIV(stackPointer) + ((2 - 1) * BytesPerWord), floatObjectOf(rcvr * arg));
		GIV(stackPointer) = sp;
	}
}

static void
primitiveFloatNotEqual(void)
{   DECL_MAYBE_SQ_GLOBAL_STRUCT
    sqInt aBool;
    double arg;
    sqInt ccIndex;
    sqInt ccIndex1;
    double rcvr;
    double result;
    double result1;
    char *sp;
    sqInt successBoolean;
    sqInt successBoolean1;

	/* begin primitiveFloatEqual:toArg: */
	/* begin loadFloatOrIntFrom: */
	if (((longAt(GIV(stackPointer) + (1 * BytesPerWord))) & 1)) {
		rcvr = ((double) (((longAt(GIV(stackPointer) + (1 * BytesPerWord))) >> 1)) );
		goto l2;
	}
	/* begin assertClassOf:is:compactClassIndex: */
	VM_LABEL(43assertClassOfiscompactClassIndex);
	/* begin success: */
	/* begin is:instanceOf:compactClassIndex: */
	if (((longAt(GIV(stackPointer) + (1 * BytesPerWord))) & 1)) {
		successBoolean = 0;
		goto l1;
	}
	ccIndex = (((usqInt) (longAt(longAt(GIV(stackPointer) + (1 * BytesPerWord))))) >> 12) & 31;
	if (ClassFloatCompactIndex != 0) {
		successBoolean = ClassFloatCompactIndex == ccIndex;
		goto l1;
	}
	successBoolean = (ccIndex == 0)
	 && (((longAt((longAt(GIV(stackPointer) + (1 * BytesPerWord))) - BaseHeaderSize)) & AllButTypeMask) == (longAt((GIV(specialObjectsOop) + BaseHeaderSize) + (ClassFloat << ShiftForWord))));
l1:	/* end is:instanceOf:compactClassIndex: */;
	if (!(successBoolean)) {
		if (GIV(primFailCode) == 0) {

			/* Don't overwrite an error code that has already been set. */

			GIV(primFailCode) = 1;
		}
	}
	;
	if (GIV(primFailCode) == 0) {
		fetchFloatAtinto((longAt(GIV(stackPointer) + (1 * BytesPerWord))) + BaseHeaderSize, result);
	}
	rcvr = result;
l2:	/* end loadFloatOrIntFrom: */;
	/* begin loadFloatOrIntFrom: */
	if (((longAt(GIV(stackPointer))) & 1)) {
		arg = ((double) (((longAt(GIV(stackPointer))) >> 1)) );
		goto l4;
	}
	/* begin assertClassOf:is:compactClassIndex: */
	VM_LABEL(44assertClassOfiscompactClassIndex);
	/* begin success: */
	/* begin is:instanceOf:compactClassIndex: */
	if (((longAt(GIV(stackPointer))) & 1)) {
		successBoolean1 = 0;
		goto l3;
	}
	ccIndex1 = (((usqInt) (longAt(longAt(GIV(stackPointer))))) >> 12) & 31;
	if (ClassFloatCompactIndex != 0) {
		successBoolean1 = ClassFloatCompactIndex == ccIndex1;
		goto l3;
	}
	successBoolean1 = (ccIndex1 == 0)
	 && (((longAt((longAt(GIV(stackPointer))) - BaseHeaderSize)) & AllButTypeMask) == (longAt((GIV(specialObjectsOop) + BaseHeaderSize) + (ClassFloat << ShiftForWord))));
l3:	/* end is:instanceOf:compactClassIndex: */;
	if (!(successBoolean1)) {
		if (GIV(primFailCode) == 0) {

			/* Don't overwrite an error code that has already been set. */

			GIV(primFailCode) = 1;
		}
	}
	;
	if (GIV(primFailCode) == 0) {
		fetchFloatAtinto((longAt(GIV(stackPointer))) + BaseHeaderSize, result1);
	}
	arg = result1;
l4:	/* end loadFloatOrIntFrom: */;
	aBool = rcvr == arg;
	if (GIV(primFailCode) == 0) {
		/* begin pop:thenPushBool: */
		longAtput(sp = GIV(stackPointer) + ((2 - 1) * BytesPerWord), (!aBool
			? GIV(trueObj)
			: GIV(falseObj)));
		GIV(stackPointer) = sp;
	}
}

static void
primitiveFloatSubtract(void)
{   DECL_MAYBE_SQ_GLOBAL_STRUCT
    double arg;
    sqInt argOop;
    sqInt ccIndex;
    sqInt ccIndex1;
    double rcvr;
    sqInt rcvrOop;
    double result;
    double result1;
    char *sp;
    sqInt successBoolean;
    sqInt successBoolean1;

	/* begin primitiveFloatSubtract:fromArg: */
	rcvrOop = longAt(GIV(stackPointer) + (1 * BytesPerWord));
	argOop = longAt(GIV(stackPointer));
	/* begin loadFloatOrIntFrom: */
	if ((rcvrOop & 1)) {
		rcvr = ((double) ((rcvrOop >> 1)) );
		goto l2;
	}
	/* begin assertClassOf:is:compactClassIndex: */
	VM_LABEL(45assertClassOfiscompactClassIndex);
	/* begin success: */
	/* begin is:instanceOf:compactClassIndex: */
	if ((rcvrOop & 1)) {
		successBoolean = 0;
		goto l1;
	}
	ccIndex = (((usqInt) (longAt(rcvrOop))) >> 12) & 31;
	if (ClassFloatCompactIndex != 0) {
		successBoolean = ClassFloatCompactIndex == ccIndex;
		goto l1;
	}
	successBoolean = (ccIndex == 0)
	 && (((longAt(rcvrOop - BaseHeaderSize)) & AllButTypeMask) == (longAt((GIV(specialObjectsOop) + BaseHeaderSize) + (ClassFloat << ShiftForWord))));
l1:	/* end is:instanceOf:compactClassIndex: */;
	if (!(successBoolean)) {
		if (GIV(primFailCode) == 0) {

			/* Don't overwrite an error code that has already been set. */

			GIV(primFailCode) = 1;
		}
	}
	;
	if (GIV(primFailCode) == 0) {
		fetchFloatAtinto(rcvrOop + BaseHeaderSize, result);
	}
	rcvr = result;
l2:	/* end loadFloatOrIntFrom: */;
	/* begin loadFloatOrIntFrom: */
	if ((argOop & 1)) {
		arg = ((double) ((argOop >> 1)) );
		goto l4;
	}
	/* begin assertClassOf:is:compactClassIndex: */
	VM_LABEL(46assertClassOfiscompactClassIndex);
	/* begin success: */
	/* begin is:instanceOf:compactClassIndex: */
	if ((argOop & 1)) {
		successBoolean1 = 0;
		goto l3;
	}
	ccIndex1 = (((usqInt) (longAt(argOop))) >> 12) & 31;
	if (ClassFloatCompactIndex != 0) {
		successBoolean1 = ClassFloatCompactIndex == ccIndex1;
		goto l3;
	}
	successBoolean1 = (ccIndex1 == 0)
	 && (((longAt(argOop - BaseHeaderSize)) & AllButTypeMask) == (longAt((GIV(specialObjectsOop) + BaseHeaderSize) + (ClassFloat << ShiftForWord))));
l3:	/* end is:instanceOf:compactClassIndex: */;
	if (!(successBoolean1)) {
		if (GIV(primFailCode) == 0) {

			/* Don't overwrite an error code that has already been set. */

			GIV(primFailCode) = 1;
		}
	}
	;
	if (GIV(primFailCode) == 0) {
		fetchFloatAtinto(argOop + BaseHeaderSize, result1);
	}
	arg = result1;
l4:	/* end loadFloatOrIntFrom: */;
	if (GIV(primFailCode) == 0) {
		/* begin pop:thenPushFloat: */
		longAtput(sp = GIV(stackPointer) + ((2 - 1) * BytesPerWord), floatObjectOf(rcvr - arg));
		GIV(stackPointer) = sp;
	}
	return;
}


/*	Clear the method lookup cache. This must be done after every programming
	change. 
 */

static void
primitiveFlushCache(void)
{   DECL_MAYBE_SQ_GLOBAL_STRUCT
    sqInt i;
    sqInt i1;

	/* begin flushMethodCache */
	for (i = 1; i <= MethodCacheSize; i += 1) {
		GIV(methodCache)[i] = 0;
	}

	/* this for primitiveExternalMethod */

	GIV(lastMethodCacheProbeWrite) = 0;
	unlinkAllSends();
	/* begin flushAtCache */
	for (i1 = 1; i1 <= AtCacheTotalSize; i1 += 1) {
		GIV(atCache)[i1] = 0;
	}
}


/*	The receiver is a compiledMethod. Clear all entries in the method lookup
	cache that
	refer to this method, presumably because it has been redefined, overridden
	or removed.
	Override to flush appropriate machine code caches also. */

static void
primitiveFlushCacheByMethod(void)
{   DECL_MAYBE_SQ_GLOBAL_STRUCT
    sqInt i;
    sqInt oldMethod;
    sqInt primBits;
    sqInt primIdx;
    sqInt probe;

	oldMethod = longAt(GIV(stackPointer));
	probe = 0;
	for (i = 1; i <= MethodCacheEntries; i += 1) {
		if ((GIV(methodCache)[probe + MethodCacheMethod]) == oldMethod) {
			GIV(methodCache)[probe + MethodCacheSelector] = 0;
		}
		probe += MethodCacheEntrySize;
	}
	/* begin primitiveIndexOf: */
	primBits = (((usqInt) (headerOf(oldMethod))) >> 1) & 268435967;
	primIdx = (primBits & 511) + (((usqInt) primBits) >> 19);
	if (primIdx == PrimitiveExternalCallIndex) {
		flushExternalPrimitiveOf(oldMethod);
	}
	if (methodHasCogMethod(oldMethod)) {
		unlinkSendsTo(cogMethodOf(oldMethod));
	}
}


/*	The receiver is a message selector. Clear all entries in the method lookup
	cache with this selector, presumably because an associated method has been
	redefined. Override to also flush machine code caches. */

static void
primitiveFlushCacheBySelector(void)
{   DECL_MAYBE_SQ_GLOBAL_STRUCT
    sqInt i;
    sqInt i1;
    sqInt probe;
    sqInt selector;

	selector = longAt(GIV(stackPointer));
	probe = 0;
	for (i = 1; i <= MethodCacheEntries; i += 1) {
		if ((GIV(methodCache)[probe + MethodCacheSelector]) == selector) {
			GIV(methodCache)[probe + MethodCacheSelector] = 0;
		}
		probe += MethodCacheEntrySize;
	}
	if ((selector == (longAt(((longAt((GIV(specialObjectsOop) + BaseHeaderSize) + (SpecialSelectors << ShiftForWord))) + BaseHeaderSize) + ((16 * 2) << ShiftForWord))))
	 || (selector == (longAt(((longAt((GIV(specialObjectsOop) + BaseHeaderSize) + (SpecialSelectors << ShiftForWord))) + BaseHeaderSize) + ((17 * 2) << ShiftForWord))))) {
		/* begin flushAtCache */
		for (i1 = 1; i1 <= AtCacheTotalSize; i1 += 1) {
			GIV(atCache)[i1] = 0;
		}
	}
	unlinkSendsOf(selector);
}


/*	Primitive. Flush all the existing external primitives in the image thus
	forcing a reload on next invokation.
 */

static void
primitiveFlushExternalPrimitives(void)
{
	flushExternalPrimitives();
}


/*	On some platforms, this primitive forces enqueued display updates to be
	processed immediately. On others, it does nothing.
 */

static void
primitiveForceDisplayUpdate(void)
{
	ioForceDisplayUpdate();
}


/*	Set force tenure flag to true, this forces a tenure operation on the next
	incremental GC
 */

EXPORT(sqInt)
primitiveForceTenure(void)
{
	GIV(forceTenureFlag) = 1;
}


/*	On platforms that support it, this primitive prints the receiver, assumed
	to be a Form, to the default printer.
 */

static void
primitiveFormPrint(void)
{   DECL_MAYBE_SQ_GLOBAL_STRUCT
    sqInt bitsArray;
    sqInt bitsArraySize;
    sqInt ccIndex;
    sqInt ccIndex1;
    sqInt depth;
    sqInt h;
    double  hScale;
    sqInt landscapeFlag;
    sqInt ok;
    sqInt pixelsPerWord;
    sqInt rcvr;
    double result;
    double result1;
    sqInt successBoolean;
    sqInt successBoolean1;
    double  vScale;
    sqInt w;
    sqInt wordsPerLine;

	/* begin booleanValueOf: */
	if ((longAt(GIV(stackPointer))) == GIV(trueObj)) {
		landscapeFlag = 1;
		goto l1;
	}
	if ((longAt(GIV(stackPointer))) == GIV(falseObj)) {
		landscapeFlag = 0;
		goto l1;
	}
	/* begin success: */
	if (!(0)) {
		if (GIV(primFailCode) == 0) {

			/* Don't overwrite an error code that has already been set. */

			GIV(primFailCode) = 1;
		}
	}
	landscapeFlag = null;
l1:	/* end booleanValueOf: */;
	/* begin floatValueOf: */
	VM_LABEL(1floatValueOf);
	flag("Dan");
	/* begin assertClassOf:is:compactClassIndex: */
	VM_LABEL(47assertClassOfiscompactClassIndex);
	/* begin success: */
	/* begin is:instanceOf:compactClassIndex: */
	if (((longAt(GIV(stackPointer) + (1 * BytesPerWord))) & 1)) {
		successBoolean = 0;
		goto l2;
	}
	ccIndex = (((usqInt) (longAt(longAt(GIV(stackPointer) + (1 * BytesPerWord))))) >> 12) & 31;
	if (ClassFloatCompactIndex != 0) {
		successBoolean = ClassFloatCompactIndex == ccIndex;
		goto l2;
	}
	successBoolean = (ccIndex == 0)
	 && (((longAt((longAt(GIV(stackPointer) + (1 * BytesPerWord))) - BaseHeaderSize)) & AllButTypeMask) == (longAt((GIV(specialObjectsOop) + BaseHeaderSize) + (ClassFloat << ShiftForWord))));
l2:	/* end is:instanceOf:compactClassIndex: */;
	if (!(successBoolean)) {
		if (GIV(primFailCode) == 0) {

			/* Don't overwrite an error code that has already been set. */

			GIV(primFailCode) = 1;
		}
	}
	if (GIV(primFailCode) == 0) {
		;
		fetchFloatAtinto((longAt(GIV(stackPointer) + (1 * BytesPerWord))) + BaseHeaderSize, result);
		vScale = result;
		goto l3;
	}
	else {
		vScale = 0.0;
		goto l3;
	}
l3:	/* end floatValueOf: */;
	/* begin floatValueOf: */
	VM_LABEL(2floatValueOf);
	flag("Dan");
	/* begin assertClassOf:is:compactClassIndex: */
	VM_LABEL(48assertClassOfiscompactClassIndex);
	/* begin success: */
	/* begin is:instanceOf:compactClassIndex: */
	if (((longAt(GIV(stackPointer) + (2 * BytesPerWord))) & 1)) {
		successBoolean1 = 0;
		goto l4;
	}
	ccIndex1 = (((usqInt) (longAt(longAt(GIV(stackPointer) + (2 * BytesPerWord))))) >> 12) & 31;
	if (ClassFloatCompactIndex != 0) {
		successBoolean1 = ClassFloatCompactIndex == ccIndex1;
		goto l4;
	}
	successBoolean1 = (ccIndex1 == 0)
	 && (((longAt((longAt(GIV(stackPointer) + (2 * BytesPerWord))) - BaseHeaderSize)) & AllButTypeMask) == (longAt((GIV(specialObjectsOop) + BaseHeaderSize) + (ClassFloat << ShiftForWord))));
l4:	/* end is:instanceOf:compactClassIndex: */;
	if (!(successBoolean1)) {
		if (GIV(primFailCode) == 0) {

			/* Don't overwrite an error code that has already been set. */

			GIV(primFailCode) = 1;
		}
	}
	if (GIV(primFailCode) == 0) {
		;
		fetchFloatAtinto((longAt(GIV(stackPointer) + (2 * BytesPerWord))) + BaseHeaderSize, result1);
		hScale = result1;
		goto l5;
	}
	else {
		hScale = 0.0;
		goto l5;
	}
l5:	/* end floatValueOf: */;
	rcvr = longAt(GIV(stackPointer) + (3 * BytesPerWord));
	if ((rcvr & 1)) {
		/* begin success: */
		if (!(0)) {
			if (GIV(primFailCode) == 0) {

				/* Don't overwrite an error code that has already been set. */

				GIV(primFailCode) = 1;
			}
		}
	}
	if (GIV(primFailCode) == 0) {
		if (!((((rcvr & 1) == 0)
 && (((((usqInt) (longAt(rcvr))) >> 8) & 15) <= 4))
			 && ((lengthOf(rcvr)) >= 4))) {
			/* begin success: */
			if (!(0)) {
				if (GIV(primFailCode) == 0) {

					/* Don't overwrite an error code that has already been set. */

					GIV(primFailCode) = 1;
				}
			}
		}
	}
	if (GIV(primFailCode) == 0) {
		bitsArray = longAt((rcvr + BaseHeaderSize) + (0 << ShiftForWord));
		w = fetchIntegerofObject(1, rcvr);
		h = fetchIntegerofObject(2, rcvr);
		depth = fetchIntegerofObject(3, rcvr);
		if (!((w > 0)
			 && (h > 0))) {
			/* begin success: */
			if (!(0)) {
				if (GIV(primFailCode) == 0) {

					/* Don't overwrite an error code that has already been set. */

					GIV(primFailCode) = 1;
				}
			}
		}
		pixelsPerWord = 32 / depth;
		wordsPerLine = (w + (pixelsPerWord - 1)) / pixelsPerWord;
		if ((!((rcvr & 1)))
		 && (((bitsArray & 1) == 0)
 && (isWordsOrBytesNonInt(bitsArray)))) {
			bitsArraySize = byteLengthOf(bitsArray);
			/* begin success: */
			if (!(bitsArraySize == ((wordsPerLine * h) * 4))) {
				if (GIV(primFailCode) == 0) {

					/* Don't overwrite an error code that has already been set. */

					GIV(primFailCode) = 1;
				}
			}
		}
		else {
			/* begin success: */
			if (!(0)) {
				if (GIV(primFailCode) == 0) {

					/* Don't overwrite an error code that has already been set. */

					GIV(primFailCode) = 1;
				}
			}
		}
	}
	if (GIV(primFailCode) == 0) {
		if (BytesPerWord == 8) {
			ok = ioFormPrint(bitsArray + 8, w, h, depth, hScale, vScale, landscapeFlag);
		}
		else {
			ok = ioFormPrint(bitsArray + 4, w, h, depth, hScale, vScale, landscapeFlag);
		}
		/* begin success: */
		if (!(ok)) {
			if (GIV(primFailCode) == 0) {

				/* Don't overwrite an error code that has already been set. */

				GIV(primFailCode) = 1;
			}
		}
	}
	if (GIV(primFailCode) == 0) {
		/* begin pop: */
		GIV(stackPointer) += 3 * BytesPerWord;
	}
}

static void
primitiveFractionalPart(void)
{   DECL_MAYBE_SQ_GLOBAL_STRUCT
    sqInt ccIndex;
    double frac;
    sqInt object;
    double rcvr;
    double result;
    char *sp;
    sqInt successBoolean;
    sqInt top;
    sqInt top1;
    double trunc;

	/* begin popFloat */
	VM_LABEL(3popFloat);
	/* begin popStack */
	top1 = longAt(GIV(stackPointer));
	GIV(stackPointer) += BytesPerWord;
	top = top1;
	/* begin assertClassOf:is:compactClassIndex: */
	VM_LABEL(49assertClassOfiscompactClassIndex);
	/* begin success: */
	/* begin is:instanceOf:compactClassIndex: */
	if ((top & 1)) {
		successBoolean = 0;
		goto l1;
	}
	ccIndex = (((usqInt) (longAt(top))) >> 12) & 31;
	if (ClassFloatCompactIndex != 0) {
		successBoolean = ClassFloatCompactIndex == ccIndex;
		goto l1;
	}
	successBoolean = (ccIndex == 0)
	 && (((longAt(top - BaseHeaderSize)) & AllButTypeMask) == (longAt((GIV(specialObjectsOop) + BaseHeaderSize) + (ClassFloat << ShiftForWord))));
l1:	/* end is:instanceOf:compactClassIndex: */;
	if (!(successBoolean)) {
		if (GIV(primFailCode) == 0) {

			/* Don't overwrite an error code that has already been set. */

			GIV(primFailCode) = 1;
		}
	}
	if (GIV(primFailCode) == 0) {
		;
		fetchFloatAtinto(top + BaseHeaderSize, result);
	}
	rcvr = result;
	if (GIV(primFailCode) == 0) {
		frac = modf(rcvr, &trunc);
		/* begin pushFloat: */
		/* begin push: */
		object = floatObjectOf(frac);
		longAtput(sp = GIV(stackPointer) - BytesPerWord, object);
		GIV(stackPointer) = sp;
	}
	else {
		/* begin unPop: */
		GIV(stackPointer) -= 1 * BytesPerWord;
	}
}


/*	Do a full garbage collection and return the number of bytes available
	(including swap space if dynamic memory management is supported).
 */

static void
primitiveFullGC(void)
{   DECL_MAYBE_SQ_GLOBAL_STRUCT
    sqInt integerVal;
    char *sp;

	if (GIV(fullGCLock) > 0) {
		GIV(primFailCode) = PrimErrInappropriate; return;
	}
	/* begin externalWriteBackHeadFramePointers */
	assert((GIV(framePointer) - GIV(stackPointer)) < LargeContextSize);
	assert(GIV(stackPage) == (mostRecentlyUsedPage()));
	/* begin setHeadFP:andSP:inPage: */
	assert(GIV(stackPointer) < GIV(framePointer));
	assert((GIV(stackPointer) < ((GIV(stackPage)->baseAddress)))
	 && (GIV(stackPointer) > (((GIV(stackPage)->realStackLimit)) - LargeContextSize)));
	assert((GIV(framePointer) < ((GIV(stackPage)->baseAddress)))
	 && (GIV(framePointer) > (((GIV(stackPage)->realStackLimit)) - (((sqInt) LargeContextSize >> 1)))));
	(GIV(stackPage)->headFP = GIV(framePointer));
	(GIV(stackPage)->headSP = GIV(stackPointer));
	assert(pageListIsWellFormed());
	incrementalGC();
	fullGC();
	/* begin pop:thenPushInteger: */
	integerVal = (((((usqInt) GIV(freeStart))) < (((usqInt) GIV(reserveStart)))
	? (((usqInt) GIV(reserveStart))) - (((usqInt) GIV(freeStart)))
	: 0)) + (sqMemoryExtraBytesLeft(1));
	longAtput(sp = GIV(stackPointer) + ((1 - 1) * BytesPerWord), ((integerVal << 1) | 1));
	GIV(stackPointer) = sp;
}

usqInt
primitiveFunctionPointerAddress(void)
{
	return ((usqInt)((&primitiveFunctionPointer)));
}


/*	Fetch the system attribute with the given integer ID. The 
	result is a string, which will be empty if the attribute is not 
	defined. */

static void
primitiveGetAttribute(void)
{   DECL_MAYBE_SQ_GLOBAL_STRUCT
    sqInt attr;
    sqInt integerPointer;
    sqInt s;
    char *sp;
    sqInt sz;

	/* begin stackIntegerValue: */
	integerPointer = longAt(GIV(stackPointer) + (0 * BytesPerWord));
	/* begin checkedIntegerValueOf: */
	if ((integerPointer & 1)) {
		attr = (integerPointer >> 1);
		goto l1;
	}
	else {
		/* begin primitiveFail */
		if (GIV(primFailCode) == 0) {
			GIV(primFailCode) = 1;
		}
		attr = 0;
		goto l1;
	}
l1:	/* end stackIntegerValue: */;
	if (GIV(primFailCode) == 0) {
		sz = attributeSize(attr);
	}
	if (GIV(primFailCode) == 0) {
		s = instantiateClassindexableSize(longAt((GIV(specialObjectsOop) + BaseHeaderSize) + (ClassString << ShiftForWord)), sz);
		getAttributeIntoLength(attr, s + BaseHeaderSize, sz);
		/* begin pop:thenPush: */
		longAtput(sp = GIV(stackPointer) + ((2 - 1) * BytesPerWord), s);
		GIV(stackPointer) = sp;
	}
}


/*	Primitive. Answer the VM's current log directory */

EXPORT(sqInt)
primitiveGetLogDirectory(void)
{   DECL_MAYBE_SQ_GLOBAL_STRUCT
    sqInt i;
    char*ptr;
    char *sp;
    sqInt stringOop;
    sqInt sz;

	ptr = ioGetLogDirectory();
	if (ptr == null) {
		/* begin success: */
		if (!(0)) {
			if (GIV(primFailCode) == 0) {

				/* Don't overwrite an error code that has already been set. */

				GIV(primFailCode) = 1;
			}
		}
		return null;
	}
	sz = strlen(ptr);
	stringOop = instantiateClassindexableSize(longAt((GIV(specialObjectsOop) + BaseHeaderSize) + (ClassString << ShiftForWord)), sz);
	for (i = 0; i <= (sz - 1); i += 1) {
		byteAtput((stringOop + BaseHeaderSize) + i, ptr[i]);
	}
	/* begin pop: */
	GIV(stackPointer) += (GIV(argumentCount) + 1) * BytesPerWord;
	/* begin push: */
	longAtput(sp = GIV(stackPointer) - BytesPerWord, stringOop);
	GIV(stackPointer) = sp;
}


/*	Primitive. Return the next input event from the VM event queue. */

static void
primitiveGetNextEvent(void)
{   DECL_MAYBE_SQ_GLOBAL_STRUCT
    sqInt arg;
    int evtBuf[8] = { 0, 0, 0, 0, 0, 0, 0, 0 };
    sqInt i;
    sqInt value;

	;
	arg = longAt(GIV(stackPointer));
	if (!((((arg & 1) == 0)
 && (((((usqInt) (longAt(arg))) >> 8) & 15) == 2))
		 && ((slotSizeOf(arg)) == 8))) {
		/* begin primitiveFail */
		if (GIV(primFailCode) == 0) {
			GIV(primFailCode) = 1;
		}
		return;
	}
	ioGetNextEvent(((sqInputEvent*) evtBuf));
	if (!(GIV(primFailCode) == 0)) {
		return;
	}
	/* begin storeInteger:ofObject:withValue: */
	if (((evtBuf[0]) ^ ((evtBuf[0]) << 1)) >= 0) {
		longAtput((arg + BaseHeaderSize) + (0 << ShiftForWord), (((evtBuf[0]) << 1) | 1));
	}
	else {
		/* begin primitiveFail */
		if (GIV(primFailCode) == 0) {
			GIV(primFailCode) = 1;
		}
	}
	if (!(GIV(primFailCode) == 0)) {
		return;
	}
	/* begin storeInteger:ofObject:withValue: */
	if ((((evtBuf[1]) & MillisecondClockMask) ^ (((evtBuf[1]) & MillisecondClockMask) << 1)) >= 0) {
		longAtput((arg + BaseHeaderSize) + (1 << ShiftForWord), ((((evtBuf[1]) & MillisecondClockMask) << 1) | 1));
	}
	else {
		/* begin primitiveFail */
		if (GIV(primFailCode) == 0) {
			GIV(primFailCode) = 1;
		}
	}
	if (!(GIV(primFailCode) == 0)) {
		return;
	}
	for (i = 2; i <= 7; i += 1) {
		value = evtBuf[i];
		if ((value ^ (value << 1)) >= 0) {
			/* begin storeInteger:ofObject:withValue: */
			if ((value ^ (value << 1)) >= 0) {
				longAtput((arg + BaseHeaderSize) + (i << ShiftForWord), ((value << 1) | 1));
			}
			else {
				/* begin primitiveFail */
				if (GIV(primFailCode) == 0) {
					GIV(primFailCode) = 1;
				}
			}
		}
		else {
			value = positive32BitIntegerFor(value);
			/* begin storePointer:ofObject:withValue: */
			if ((((usqInt) arg)) < (((usqInt) GIV(youngStart)))) {
				possibleRootStoreIntovalue(arg, value);
			}
			longAtput((arg + BaseHeaderSize) + (i << ShiftForWord), value);
		}
	}
	if (!(GIV(primFailCode) == 0)) {
		return;
	}
	/* begin pop: */
	GIV(stackPointer) += 1 * BytesPerWord;
}


/*	Primitive. Answer the OS window's label */

EXPORT(sqInt)
primitiveGetWindowLabel(void)
{   DECL_MAYBE_SQ_GLOBAL_STRUCT
    sqInt i;
    sqInt labelOop;
    char*ptr;
    char *sp;
    sqInt sz;

	ptr = ioGetWindowLabel();
	if (ptr == null) {
		/* begin success: */
		if (!(0)) {
			if (GIV(primFailCode) == 0) {

				/* Don't overwrite an error code that has already been set. */

				GIV(primFailCode) = 1;
			}
		}
		return null;
	}
	sz = strlen(ptr);
	labelOop = instantiateClassindexableSize(longAt((GIV(specialObjectsOop) + BaseHeaderSize) + (ClassString << ShiftForWord)), sz);
	for (i = 0; i <= (sz - 1); i += 1) {
		byteAtput((labelOop + BaseHeaderSize) + i, ptr[i]);
	}
	/* begin pop: */
	GIV(stackPointer) += (GIV(argumentCount) + 1) * BytesPerWord;
	/* begin push: */
	longAtput(sp = GIV(stackPointer) - BytesPerWord, labelOop);
	GIV(stackPointer) = sp;
}


/*	Primitive. Answer the OS window's size (extent) */

EXPORT(sqInt)
primitiveGetWindowSize(void)
{   DECL_MAYBE_SQ_GLOBAL_STRUCT
    sqInt h;
    sqInt object;
    sqInt pointResult;
    char *sp;
    sqInt w;

	w = ioGetWindowWidth();
	h = ioGetWindowHeight();
	/* begin pop: */
	GIV(stackPointer) += (GIV(argumentCount) + 1) * BytesPerWord;
	/* begin push: */
	/* begin makePointwithxValue:yValue: */
	pointResult = eeInstantiateSmallClasssizeInBytes(longAt((GIV(specialObjectsOop) + BaseHeaderSize) + (ClassPoint << ShiftForWord)), 3 * BytesPerWord);
	longAtput((pointResult + BaseHeaderSize) + (XIndex << ShiftForWord), ((w << 1) | 1));
	longAtput((pointResult + BaseHeaderSize) + (YIndex << ShiftForWord), ((h << 1) | 1));
	object = pointResult;
	longAtput(sp = GIV(stackPointer) - BytesPerWord, object);
	GIV(stackPointer) = sp;
}

static void
primitiveGreaterOrEqual(void)
{   DECL_MAYBE_SQ_GLOBAL_STRUCT
    sqInt integerArgument;
    sqInt integerPointer;
    sqInt integerPointer1;
    sqInt integerReceiver;
    sqInt object;
    char *sp;
    sqInt top;
    sqInt top1;

	/* begin popInteger */
	/* begin popStack */
	top = longAt(GIV(stackPointer));
	GIV(stackPointer) += BytesPerWord;
	integerPointer = top;
	/* begin checkedIntegerValueOf: */
	if ((integerPointer & 1)) {
		integerArgument = (integerPointer >> 1);
		goto l1;
	}
	else {
		/* begin primitiveFail */
		if (GIV(primFailCode) == 0) {
			GIV(primFailCode) = 1;
		}
		integerArgument = 0;
		goto l1;
	}
l1:	/* end popInteger */;
	/* begin popInteger */
	/* begin popStack */
	top1 = longAt(GIV(stackPointer));
	GIV(stackPointer) += BytesPerWord;
	integerPointer1 = top1;
	/* begin checkedIntegerValueOf: */
	if ((integerPointer1 & 1)) {
		integerReceiver = (integerPointer1 >> 1);
		goto l2;
	}
	else {
		/* begin primitiveFail */
		if (GIV(primFailCode) == 0) {
			GIV(primFailCode) = 1;
		}
		integerReceiver = 0;
		goto l2;
	}
l2:	/* end popInteger */;
	/* begin checkBooleanResult: */
	if (GIV(primFailCode) == 0) {
		/* begin pushBool: */
		/* begin push: */
		object = (integerReceiver >= integerArgument
			? GIV(trueObj)
			: GIV(falseObj));
		longAtput(sp = GIV(stackPointer) - BytesPerWord, object);
		GIV(stackPointer) = sp;
	}
	else {
		/* begin unPop: */
		GIV(stackPointer) -= 2 * BytesPerWord;
	}
}


/*	Primitive comparison operations for large integers in 64 bit range */

EXPORT(void)
primitiveGreaterOrEqualLargeIntegers(void)
{   DECL_MAYBE_SQ_GLOBAL_STRUCT
    sqLong integerArg;
    sqLong integerRcvr;
    char *sp;

	integerArg = signed64BitValueOf(longAt(GIV(stackPointer) + (0 * BytesPerWord)));
	integerRcvr = signed64BitValueOf(longAt(GIV(stackPointer) + (1 * BytesPerWord)));
	if (GIV(primFailCode) == 0) {
		/* begin pop:thenPushBool: */
		longAtput(sp = GIV(stackPointer) + ((2 - 1) * BytesPerWord), (integerRcvr >= integerArg
			? GIV(trueObj)
			: GIV(falseObj)));
		GIV(stackPointer) = sp;
	}
}

static void
primitiveGreaterThan(void)
{   DECL_MAYBE_SQ_GLOBAL_STRUCT
    sqInt integerArgument;
    sqInt integerPointer;
    sqInt integerPointer1;
    sqInt integerReceiver;
    sqInt object;
    char *sp;
    sqInt top;
    sqInt top1;

	/* begin popInteger */
	/* begin popStack */
	top = longAt(GIV(stackPointer));
	GIV(stackPointer) += BytesPerWord;
	integerPointer = top;
	/* begin checkedIntegerValueOf: */
	if ((integerPointer & 1)) {
		integerArgument = (integerPointer >> 1);
		goto l1;
	}
	else {
		/* begin primitiveFail */
		if (GIV(primFailCode) == 0) {
			GIV(primFailCode) = 1;
		}
		integerArgument = 0;
		goto l1;
	}
l1:	/* end popInteger */;
	/* begin popInteger */
	/* begin popStack */
	top1 = longAt(GIV(stackPointer));
	GIV(stackPointer) += BytesPerWord;
	integerPointer1 = top1;
	/* begin checkedIntegerValueOf: */
	if ((integerPointer1 & 1)) {
		integerReceiver = (integerPointer1 >> 1);
		goto l2;
	}
	else {
		/* begin primitiveFail */
		if (GIV(primFailCode) == 0) {
			GIV(primFailCode) = 1;
		}
		integerReceiver = 0;
		goto l2;
	}
l2:	/* end popInteger */;
	/* begin checkBooleanResult: */
	if (GIV(primFailCode) == 0) {
		/* begin pushBool: */
		/* begin push: */
		object = (integerReceiver > integerArgument
			? GIV(trueObj)
			: GIV(falseObj));
		longAtput(sp = GIV(stackPointer) - BytesPerWord, object);
		GIV(stackPointer) = sp;
	}
	else {
		/* begin unPop: */
		GIV(stackPointer) -= 2 * BytesPerWord;
	}
}


/*	Primitive comparison operations for large integers in 64 bit range */

EXPORT(void)
primitiveGreaterThanLargeIntegers(void)
{   DECL_MAYBE_SQ_GLOBAL_STRUCT
    sqLong integerArg;
    sqLong integerRcvr;
    char *sp;

	integerArg = signed64BitValueOf(longAt(GIV(stackPointer) + (0 * BytesPerWord)));
	integerRcvr = signed64BitValueOf(longAt(GIV(stackPointer) + (1 * BytesPerWord)));
	if (GIV(primFailCode) == 0) {
		/* begin pop:thenPushBool: */
		longAtput(sp = GIV(stackPointer) + ((2 - 1) * BytesPerWord), (integerRcvr > integerArg
			? GIV(trueObj)
			: GIV(falseObj)));
		GIV(stackPointer) = sp;
	}
}


/*	Answer the heartbeat frequency in beats per second. If the argument is
	true, reset the frequency measure. */

EXPORT(sqInt)
primitiveHeartbeatFrequency(void)
{   DECL_MAYBE_SQ_GLOBAL_STRUCT
    sqInt oop;
    sqInt reset;
    char *sp;

	reset = (GIV(argumentCount) == 1)
	 && ((longAt(GIV(stackPointer))) == GIV(trueObj));
	/* begin pop:thenPush: */
	oop = positive32BitIntegerFor(ioHeartbeatFrequency(reset));
	longAtput(sp = GIV(stackPointer) + (((GIV(argumentCount) + 1) - 1) * BytesPerWord), oop);
	GIV(stackPointer) = sp;
}


/*	Return the value of the high resolution clock if this system has any. The
	exact frequency of the high res clock is undefined specifically so that we
	can use processor dependent instructions (like RDTSC). The only use for
	the high res clock is for profiling where we can allocate time based on
	sub-msec resolution of the high res clock. If no high-resolution counter
	is available, the platform should return zero.
 */

EXPORT(sqInt)
primitiveHighResClock(void)
{   DECL_MAYBE_SQ_GLOBAL_STRUCT
    sqInt object;
    char *sp;

	/* begin pop: */
	GIV(stackPointer) += 1 * BytesPerWord;
	/* begin push: */
	object = positive64BitIntegerFor(ioHighResClock());
	longAtput(sp = GIV(stackPointer) - BytesPerWord, object);
	GIV(stackPointer) = sp;
}


/*	is the receiver/first argument the same object as the (last) argument?.
	pop argumentCount because this can be used as a mirror primitive. */

static void
primitiveIdentical(void)
{   DECL_MAYBE_SQ_GLOBAL_STRUCT
    sqInt otherObject;
    char *sp;
    sqInt thisObject;

	otherObject = longAt(GIV(stackPointer) + (1 * BytesPerWord));
	thisObject = longAt(GIV(stackPointer));
	/* begin pop:thenPushBool: */
	longAtput(sp = GIV(stackPointer) + (((GIV(argumentCount) + 1) - 1) * BytesPerWord), (thisObject == otherObject
		? GIV(trueObj)
		: GIV(falseObj)));
	GIV(stackPointer) = sp;
}

static void
primitiveIdentityHash(void)
{   DECL_MAYBE_SQ_GLOBAL_STRUCT
    char *sp;
    sqInt thisReceiver;

	thisReceiver = longAt(GIV(stackPointer));
	if ((thisReceiver & 1)) {
		/* begin primitiveFail */
		if (GIV(primFailCode) == 0) {
			GIV(primFailCode) = 1;
		}
	}
	else {
		/* begin pop:thenPushInteger: */
		longAtput(sp = GIV(stackPointer) + ((1 - 1) * BytesPerWord), ((((((usqInt) (longAt(thisReceiver))) >> HashBitsOffset) & HashMaskUnshifted) << 1) | 1));
		GIV(stackPointer) = sp;
	}
}


/*	When called with a single string argument, record the string as the
	current image file name. When called with zero arguments, return a string
	containing the current image file name.
 */

static void
primitiveImageName(void)
{   DECL_MAYBE_SQ_GLOBAL_STRUCT
    sqInt ccIndex;
    sqInt cl;
    sqInt okToRename;
    sqInt s;
    void *sCRIfn;
    char *sp;
    sqInt successBoolean;
    sqInt sz;

	if (GIV(argumentCount) == 1) {

		/* If the security plugin can be loaded, use it to check for rename permission.
		If not, assume it's ok */

		sCRIfn = ioLoadFunctionFrom("secCanRenameImage", "SecurityPlugin");
		if (sCRIfn != 0) {
			okToRename =  ((sqInt (*)(void))sCRIfn)();
			if (!(okToRename)) {
				/* begin primitiveFail */
				if (GIV(primFailCode) == 0) {
					GIV(primFailCode) = 1;
				}
				return;
			}
		}
		s = longAt(GIV(stackPointer));
		/* begin assertClassOf:is: */
		/* begin success: */
		/* begin isClassOfNonImm:equalTo: */
		if ((s & 1)) {
			successBoolean = 0;
			goto l1;
		}
		cl = (((ccIndex = (((usqInt) (longAt(s))) >> 12) & 31)) == 0
			? (longAt(s - BaseHeaderSize)) & AllButTypeMask
			: longAt(((longAt((GIV(specialObjectsOop) + BaseHeaderSize) + (CompactClasses << ShiftForWord))) + BaseHeaderSize) + ((ccIndex - 1) << ShiftForWord)));
		successBoolean = cl == (longAt((GIV(specialObjectsOop) + BaseHeaderSize) + (ClassString << ShiftForWord)));
	l1:	/* end isClassOfNonImm:equalTo: */;
		if (!(successBoolean)) {
			if (GIV(primFailCode) == 0) {

				/* Don't overwrite an error code that has already been set. */

				GIV(primFailCode) = 1;
			}
		}
		if (GIV(primFailCode) == 0) {
			sz = stSizeOf(s);
			imageNamePutLength(s + BaseHeaderSize, sz);
			/* begin pop: */
			GIV(stackPointer) += 1 * BytesPerWord;
		}
	}
	else {
		sz = imageNameSize();
		s = instantiateClassindexableSize(longAt((GIV(specialObjectsOop) + BaseHeaderSize) + (ClassString << ShiftForWord)), sz);
		imageNameGetLength(s + BaseHeaderSize, sz);
		/* begin pop: */
		GIV(stackPointer) += 1 * BytesPerWord;
		/* begin push: */
		longAtput(sp = GIV(stackPointer) - BytesPerWord, s);
		GIV(stackPointer) = sp;
	}
}


/*	Do a quick, incremental garbage collection and return the number of bytes
	immediately available.
	(Note: more space may be made available by doing a full garbage
	collection. 
 */

static void
primitiveIncrementalGC(void)
{   DECL_MAYBE_SQ_GLOBAL_STRUCT
    sqInt integerVal;
    char *sp;

	/* begin externalWriteBackHeadFramePointers */
	assert((GIV(framePointer) - GIV(stackPointer)) < LargeContextSize);
	assert(GIV(stackPage) == (mostRecentlyUsedPage()));
	/* begin setHeadFP:andSP:inPage: */
	assert(GIV(stackPointer) < GIV(framePointer));
	assert((GIV(stackPointer) < ((GIV(stackPage)->baseAddress)))
	 && (GIV(stackPointer) > (((GIV(stackPage)->realStackLimit)) - LargeContextSize)));
	assert((GIV(framePointer) < ((GIV(stackPage)->baseAddress)))
	 && (GIV(framePointer) > (((GIV(stackPage)->realStackLimit)) - (((sqInt) LargeContextSize >> 1)))));
	(GIV(stackPage)->headFP = GIV(framePointer));
	(GIV(stackPage)->headSP = GIV(stackPointer));
	assert(pageListIsWellFormed());
	incrementalGC();
	/* begin pop:thenPushInteger: */
	integerVal = (((((usqInt) GIV(freeStart))) < (((usqInt) GIV(reserveStart)))
	? (((usqInt) GIV(reserveStart))) - (((usqInt) GIV(freeStart)))
	: 0)) + (sqMemoryExtraBytesLeft(0));
	longAtput(sp = GIV(stackPointer) + ((1 - 1) * BytesPerWord), ((integerVal << 1) | 1));
	GIV(stackPointer) = sp;
}


/*	Note: We now have 10 bits of primitive index, but they are in two places
	for temporary backward compatibility. The time to unpack is negligible,
	since the derived primitive function pointer is stored in the method
	cache.  */

sqInt
primitiveIndexOfMethodHeader(sqInt methodHeader)
{
    sqInt primBits;

	primBits = ((usqInt) methodHeader) >> 1;
	return (primBits & 511) + ((((usqInt) primBits) >> 19) & 512);
}


/*	Note: We now have 10 bits of primitive index, but they are in two places
	for temporary backward compatibility. The time to unpack is negligible,
	since the derived primitive function pointer is stored in the method
	cache.  */

sqInt
primitiveIndexOf(sqInt methodPointer)
{
    sqInt primBits;

	primBits = (((usqInt) (headerOf(methodPointer))) >> 1) & 268435967;
	return (primBits & 511) + (((usqInt) primBits) >> 19);
}


/*	Register the input semaphore. If the argument is not a 
	Semaphore, unregister the current input semaphore. */

static void
primitiveInputSemaphore(void)
{   DECL_MAYBE_SQ_GLOBAL_STRUCT
    sqInt arg;
    sqInt top;

	arg = longAt(GIV(stackPointer));
	if ((arg & 1)) {
		ioSetInputSemaphore((arg >> 1));
		if (GIV(primFailCode) == 0) {
			/* begin pop: */
			GIV(stackPointer) += 1 * BytesPerWord;
		}
		return;
	}
	if (TheInputSemaphore == null) {
		/* begin primitiveFail */
		if (GIV(primFailCode) == 0) {
			GIV(primFailCode) = 1;
		}
		return;
	}
	/* begin popStack */
	top = longAt(GIV(stackPointer));
	GIV(stackPointer) += BytesPerWord;
	arg = top;
	if (!((fetchClassOf(arg)) == (longAt((GIV(specialObjectsOop) + BaseHeaderSize) + (ClassSemaphore << ShiftForWord))))) {
		arg = GIV(nilObj);
	}
	/* begin splObj:put: */
	/* begin storePointer:ofObject:withValue: */
	if ((((usqInt) GIV(specialObjectsOop))) < (((usqInt) GIV(youngStart)))) {
		possibleRootStoreIntovalue(GIV(specialObjectsOop), arg);
	}
	longAtput((GIV(specialObjectsOop) + BaseHeaderSize) + (TheInputSemaphore << ShiftForWord), arg);
}


/*	Return an integer indicating the reason for the most recent input
	interrupt. 
 */

static void
primitiveInputWord(void)
{   DECL_MAYBE_SQ_GLOBAL_STRUCT
    char *sp;

	/* begin pop:thenPushInteger: */
	longAtput(sp = GIV(stackPointer) + ((1 - 1) * BytesPerWord), ((0 << 1) | 1));
	GIV(stackPointer) = sp;
}

static void
primitiveInstVarAt(void)
{   DECL_MAYBE_SQ_GLOBAL_STRUCT
    sqInt ccIndex;
    sqInt class;
    sqInt classFormat;
    sqInt fixedFields;
    sqInt fmt;
    sqInt hdr;
    sqInt index;
    sqInt integerPointer;
    sqInt rcvr;
    char *sp;
    sqInt sz;
    sqInt totalLength;
    sqInt value;

	/* begin stackIntegerValue: */
	integerPointer = longAt(GIV(stackPointer) + (0 * BytesPerWord));
	/* begin checkedIntegerValueOf: */
	if ((integerPointer & 1)) {
		index = (integerPointer >> 1);
		goto l3;
	}
	else {
		/* begin primitiveFail */
		if (GIV(primFailCode) == 0) {
			GIV(primFailCode) = 1;
		}
		index = 0;
		goto l3;
	}
l3:	/* end stackIntegerValue: */;
	rcvr = longAt(GIV(stackPointer) + (1 * BytesPerWord));
	if (!(GIV(primFailCode) == 0)) {
		GIV(primFailCode) = PrimErrBadArgument; return;
	}
	hdr = longAt(rcvr);
	fmt = (((usqInt) hdr) >> 8) & 15;
	/* begin lengthOf:baseHeader:format: */
	if ((hdr & TypeMask) == HeaderTypeSizeAndClass) {
		sz = (longAt(rcvr - (BytesPerWord * 2))) & LongSizeMask;
	}
	else {
		sz = hdr & SizeMask;
	}
	sz -= hdr & Size4Bit;
	if (fmt <= 4) {
		totalLength = ((usqInt) (sz - BaseHeaderSize)) >> ShiftForWord;
		goto l1;
	}
	if (fmt < 8) {
		totalLength = ((usqInt) (sz - BaseHeaderSize)) >> 2;
		goto l1;
	}
	else {
		totalLength = (sz - BaseHeaderSize) - (fmt & 3);
		goto l1;
	}
l1:	/* end lengthOf:baseHeader:format: */;
	/* begin fixedFieldsOf:format:length: */
	if ((fmt > 4)
	 || (fmt == 2)) {
		fixedFields = 0;
		goto l5;
	}
	if (fmt < 2) {
		fixedFields = totalLength;
		goto l5;
	}
	/* begin fetchClassOfNonInt: */
	if (((ccIndex = (((usqInt) (longAt(rcvr))) >> 12) & 31)) == 0) {
		class = (longAt(rcvr - BaseHeaderSize)) & AllButTypeMask;
		goto l4;
	}
	else {
		class = longAt(((longAt((GIV(specialObjectsOop) + BaseHeaderSize) + (CompactClasses << ShiftForWord))) + BaseHeaderSize) + ((ccIndex - 1) << ShiftForWord));
		goto l4;
	}
l4:	/* end fetchClassOfNonInt: */;
	classFormat = (longAt((class + BaseHeaderSize) + (InstanceSpecificationIndex << ShiftForWord))) - 1;
	fixedFields = (((((usqInt) classFormat) >> 11) & 192) + ((((usqInt) classFormat) >> 2) & 63)) - 1;
l5:	/* end fixedFieldsOf:format:length: */;
	if (!((index >= 1)
		 && (index <= fixedFields))) {
		GIV(primFailCode) = PrimErrBadIndex; return;
	}
	if ((fmt == 3)
	 && (((((usqInt) hdr) >> 12) & 31) == ClassMethodContextCompactIndex)) {
		value = externalInstVarofContext(index - 1, rcvr);
	}
	else {
		/* begin subscript:with:format: */
		if (fmt <= 4) {
			value = longAt((rcvr + BaseHeaderSize) + ((index - 1) << ShiftForWord));
			goto l2;
		}
		if (fmt < 8) {
			value = positive32BitIntegerFor(long32At((rcvr + BaseHeaderSize) + ((index - 1) << 2)));
			goto l2;
		}
		else {
			value = (((byteAt((rcvr + BaseHeaderSize) + (index - 1))) << 1) | 1);
			goto l2;
		}
	l2:	/* end subscript:with:format: */;
	}
	/* begin pop:thenPush: */
	longAtput(sp = GIV(stackPointer) + (((GIV(argumentCount) + 1) - 1) * BytesPerWord), value);
	GIV(stackPointer) = sp;
}

static void
primitiveInstVarAtPut(void)
{   DECL_MAYBE_SQ_GLOBAL_STRUCT
    sqInt ccIndex;
    sqInt class;
    sqInt classFormat;
    sqInt fixedFields;
    sqInt fmt;
    sqInt hdr;
    sqInt index;
    sqInt integerPointer;
    sqInt newValue;
    sqInt rcvr;
    char *sp;
    sqInt sz;
    sqInt totalLength;
    sqInt valueToStore;

	newValue = longAt(GIV(stackPointer));
	/* begin stackIntegerValue: */
	integerPointer = longAt(GIV(stackPointer) + (1 * BytesPerWord));
	/* begin checkedIntegerValueOf: */
	if ((integerPointer & 1)) {
		index = (integerPointer >> 1);
		goto l2;
	}
	else {
		/* begin primitiveFail */
		if (GIV(primFailCode) == 0) {
			GIV(primFailCode) = 1;
		}
		index = 0;
		goto l2;
	}
l2:	/* end stackIntegerValue: */;
	rcvr = longAt(GIV(stackPointer) + (2 * BytesPerWord));
	if (!(GIV(primFailCode) == 0)) {
		GIV(primFailCode) = PrimErrBadArgument; return;
	}
	hdr = longAt(rcvr);
	fmt = (((usqInt) hdr) >> 8) & 15;
	/* begin lengthOf:baseHeader:format: */
	if ((hdr & TypeMask) == HeaderTypeSizeAndClass) {
		sz = (longAt(rcvr - (BytesPerWord * 2))) & LongSizeMask;
	}
	else {
		sz = hdr & SizeMask;
	}
	sz -= hdr & Size4Bit;
	if (fmt <= 4) {
		totalLength = ((usqInt) (sz - BaseHeaderSize)) >> ShiftForWord;
		goto l1;
	}
	if (fmt < 8) {
		totalLength = ((usqInt) (sz - BaseHeaderSize)) >> 2;
		goto l1;
	}
	else {
		totalLength = (sz - BaseHeaderSize) - (fmt & 3);
		goto l1;
	}
l1:	/* end lengthOf:baseHeader:format: */;
	/* begin fixedFieldsOf:format:length: */
	if ((fmt > 4)
	 || (fmt == 2)) {
		fixedFields = 0;
		goto l4;
	}
	if (fmt < 2) {
		fixedFields = totalLength;
		goto l4;
	}
	/* begin fetchClassOfNonInt: */
	if (((ccIndex = (((usqInt) (longAt(rcvr))) >> 12) & 31)) == 0) {
		class = (longAt(rcvr - BaseHeaderSize)) & AllButTypeMask;
		goto l3;
	}
	else {
		class = longAt(((longAt((GIV(specialObjectsOop) + BaseHeaderSize) + (CompactClasses << ShiftForWord))) + BaseHeaderSize) + ((ccIndex - 1) << ShiftForWord));
		goto l3;
	}
l3:	/* end fetchClassOfNonInt: */;
	classFormat = (longAt((class + BaseHeaderSize) + (InstanceSpecificationIndex << ShiftForWord))) - 1;
	fixedFields = (((((usqInt) classFormat) >> 11) & 192) + ((((usqInt) classFormat) >> 2) & 63)) - 1;
l4:	/* end fixedFieldsOf:format:length: */;
	if (!((index >= 1)
		 && (index <= fixedFields))) {
		GIV(primFailCode) = PrimErrBadIndex; return;
	}
	if ((fmt == 3)
	 && (((((usqInt) hdr) >> 12) & 31) == ClassMethodContextCompactIndex)) {
		externalInstVarofContextput(index - 1, rcvr, newValue);
	}
	else {
		/* begin subscript:with:storing:format: */
		VM_LABEL(1subscriptwithstoringformat);
		if (fmt <= 4) {
			/* begin storePointer:ofObject:withValue: */
			if ((((usqInt) rcvr)) < (((usqInt) GIV(youngStart)))) {
				possibleRootStoreIntovalue(rcvr, newValue);
			}
			longAtput((rcvr + BaseHeaderSize) + ((index - 1) << ShiftForWord), newValue);
		}
		else {
			if (fmt < 8) {

				/* long-word type objects */

				valueToStore = positive32BitValueOf(newValue);
				if (GIV(primFailCode) == 0) {
					long32Atput((rcvr + BaseHeaderSize) + ((index - 1) << 2), valueToStore);
				}
			}
			else {
				if (!((newValue & 1))) {
					/* begin success: */
					if (!(0)) {
						if (GIV(primFailCode) == 0) {

							/* Don't overwrite an error code that has already been set. */

							GIV(primFailCode) = 1;
						}
					}
				}
				valueToStore = (newValue >> 1);
				if (!((valueToStore >= 0)
					 && (valueToStore <= 255))) {
					/* begin success: */
					if (!(0)) {
						if (GIV(primFailCode) == 0) {

							/* Don't overwrite an error code that has already been set. */

							GIV(primFailCode) = 1;
						}
					}
				}
				if (GIV(primFailCode) == 0) {
					byteAtput((rcvr + BaseHeaderSize) + (index - 1), valueToStore);
				}
			}
		}
	}
	/* begin pop:thenPush: */
	longAtput(sp = GIV(stackPointer) + (((GIV(argumentCount) + 1) - 1) * BytesPerWord), newValue);
	GIV(stackPointer) = sp;
}


/*	Return the 32bit signed integer contents of a words receiver */

static void
primitiveIntegerAt(void)
{   DECL_MAYBE_SQ_GLOBAL_STRUCT
    sqInt addr;
    sqInt header;
    sqInt index;
    sqInt integerPointer;
    int intValue;
    sqInt object;
    sqInt rcvr;
    char *sp;
    char *sp1;
    sqInt sz;
    sqInt sz1;
    sqInt value;

	/* begin stackIntegerValue: */
	integerPointer = longAt(GIV(stackPointer) + (0 * BytesPerWord));
	/* begin checkedIntegerValueOf: */
	if ((integerPointer & 1)) {
		index = (integerPointer >> 1);
		goto l2;
	}
	else {
		/* begin primitiveFail */
		if (GIV(primFailCode) == 0) {
			GIV(primFailCode) = 1;
		}
		index = 0;
		goto l2;
	}
l2:	/* end stackIntegerValue: */;
	if (!(GIV(primFailCode) == 0)) {
		GIV(primFailCode) = PrimErrBadArgument; return;
	}
	rcvr = longAt(GIV(stackPointer) + (1 * BytesPerWord));
	if (((rcvr & 1))
	 || (!(((rcvr & 1) == 0)
 && (((((usqInt) (longAt(rcvr))) >> 8) & 15) == 6)))) {
		GIV(primFailCode) = PrimErrInappropriate; return;
	}
	/* begin lengthOf: */
	header = longAt(rcvr);
	/* begin lengthOf:baseHeader:format: */
	if ((header & TypeMask) == HeaderTypeSizeAndClass) {
		sz1 = (longAt(rcvr - (BytesPerWord * 2))) & LongSizeMask;
	}
	else {
		sz1 = header & SizeMask;
	}
	sz1 -= header & Size4Bit;
	if (((((usqInt) header) >> 8) & 15) <= 4) {
		sz = ((usqInt) (sz1 - BaseHeaderSize)) >> ShiftForWord;
		goto l1;
	}
	if (((((usqInt) header) >> 8) & 15) < 8) {
		sz = ((usqInt) (sz1 - BaseHeaderSize)) >> 2;
		goto l1;
	}
	else {
		sz = (sz1 - BaseHeaderSize) - (((((usqInt) header) >> 8) & 15) & 3);
		goto l1;
	}
l1:	/* end lengthOf:baseHeader:format: */;
	if (!((index >= 1)
		 && (index <= sz))) {
		GIV(primFailCode) = PrimErrBadIndex; return;
	}

	/* for zero indexing */

	addr = (rcvr + BaseHeaderSize) + ((index - 1) * BytesPerWord);
	value = intAt(addr);
	/* begin pop: */
	GIV(stackPointer) += 2 * BytesPerWord;
	if ((value ^ (value << 1)) >= 0) {
		/* begin pushInteger: */
		/* begin push: */
		longAtput(sp1 = GIV(stackPointer) - BytesPerWord, ((value << 1) | 1));
		GIV(stackPointer) = sp1;
	}
	else {

		/* 32 bit int may have been stored in 32 or 64 bit sqInt */

		intValue = value;
		/* begin push: */
		object = signed32BitIntegerFor(intValue);
		longAtput(sp = GIV(stackPointer) - BytesPerWord, object);
		GIV(stackPointer) = sp;
	}
}


/*	Return the 32bit signed integer contents of a words receiver */

static void
primitiveIntegerAtPut(void)
{   DECL_MAYBE_SQ_GLOBAL_STRUCT
    sqInt addr;
    sqInt header;
    sqInt index;
    sqInt integerPointer;
    sqInt rcvr;
    char *sp;
    sqInt sz;
    sqInt sz1;
    int value;
    sqInt valueOop;

	valueOop = longAt(GIV(stackPointer) + (0 * BytesPerWord));
	/* begin stackIntegerValue: */
	integerPointer = longAt(GIV(stackPointer) + (1 * BytesPerWord));
	/* begin checkedIntegerValueOf: */
	if ((integerPointer & 1)) {
		index = (integerPointer >> 1);
		goto l2;
	}
	else {
		/* begin primitiveFail */
		if (GIV(primFailCode) == 0) {
			GIV(primFailCode) = 1;
		}
		index = 0;
		goto l2;
	}
l2:	/* end stackIntegerValue: */;
	value = signed32BitValueOf(valueOop);
	if (!(GIV(primFailCode) == 0)) {
		GIV(primFailCode) = PrimErrBadArgument; return;
	}
	rcvr = longAt(GIV(stackPointer) + (2 * BytesPerWord));
	if (((rcvr & 1))
	 || (!(((rcvr & 1) == 0)
 && (((((usqInt) (longAt(rcvr))) >> 8) & 15) == 6)))) {
		GIV(primFailCode) = PrimErrInappropriate; return;
	}
	/* begin lengthOf: */
	header = longAt(rcvr);
	/* begin lengthOf:baseHeader:format: */
	if ((header & TypeMask) == HeaderTypeSizeAndClass) {
		sz1 = (longAt(rcvr - (BytesPerWord * 2))) & LongSizeMask;
	}
	else {
		sz1 = header & SizeMask;
	}
	sz1 -= header & Size4Bit;
	if (((((usqInt) header) >> 8) & 15) <= 4) {
		sz = ((usqInt) (sz1 - BaseHeaderSize)) >> ShiftForWord;
		goto l1;
	}
	if (((((usqInt) header) >> 8) & 15) < 8) {
		sz = ((usqInt) (sz1 - BaseHeaderSize)) >> 2;
		goto l1;
	}
	else {
		sz = (sz1 - BaseHeaderSize) - (((((usqInt) header) >> 8) & 15) & 3);
		goto l1;
	}
l1:	/* end lengthOf:baseHeader:format: */;
	if (!((index >= 1)
		 && (index <= sz))) {
		GIV(primFailCode) = PrimErrBadIndex; return;
	}

	/* for zero indexing */

	addr = (rcvr + BaseHeaderSize) + ((index - 1) * BytesPerWord);
	value = intAtput(addr, value);
	/* begin pop:thenPush: */
	longAtput(sp = GIV(stackPointer) + ((3 - 1) * BytesPerWord), valueOop);
	GIV(stackPointer) = sp;
}


/*	Primitive. Answer the number of interrupt checks per milliseconds that we
	execute on this machine. This can be used to adjust the sub-msecs profiler
	to check (roughly) 
	n times per millisecond.
 */

EXPORT(sqInt)
primitiveInterruptChecksPerMSec(void)
{   DECL_MAYBE_SQ_GLOBAL_STRUCT
    sqInt oop;
    char *sp;

	if (!(GIV(argumentCount) == 0)) {
		/* begin success: */
		if (!(0)) {
			if (GIV(primFailCode) == 0) {

				/* Don't overwrite an error code that has already been set. */

				GIV(primFailCode) = 1;
			}
		}
		return null;
	}
	/* begin pop:thenPush: */
	oop = (((ioHeartbeatMilliseconds()) << 1) | 1);
	longAtput(sp = GIV(stackPointer) + ((1 - 1) * BytesPerWord), oop);
	GIV(stackPointer) = sp;
}


/*	Register the user interrupt semaphore. If the argument is 
	not a Semaphore, unregister the current interrupt 
	semaphore. */

static void
primitiveInterruptSemaphore(void)
{   DECL_MAYBE_SQ_GLOBAL_STRUCT
    sqInt arg;
    sqInt top;

	/* begin popStack */
	top = longAt(GIV(stackPointer));
	GIV(stackPointer) += BytesPerWord;
	arg = top;
	if ((fetchClassOf(arg)) == (longAt((GIV(specialObjectsOop) + BaseHeaderSize) + (ClassSemaphore << ShiftForWord)))) {
		/* begin splObj:put: */
		/* begin storePointer:ofObject:withValue: */
		if ((((usqInt) GIV(specialObjectsOop))) < (((usqInt) GIV(youngStart)))) {
			possibleRootStoreIntovalue(GIV(specialObjectsOop), arg);
		}
		longAtput((GIV(specialObjectsOop) + BaseHeaderSize) + (TheInterruptSemaphore << ShiftForWord), arg);
	}
	else {
		/* begin splObj:put: */
		/* begin storePointer:ofObject:withValue: */
		if ((((usqInt) GIV(specialObjectsOop))) < (((usqInt) GIV(youngStart)))) {
			possibleRootStoreIntovalue(GIV(specialObjectsOop), GIV(nilObj));
		}
		longAtput((GIV(specialObjectsOop) + BaseHeaderSize) + (TheInterruptSemaphore << ShiftForWord), GIV(nilObj));
	}
}


/*	Primitive. 'Invoke' an object like a function, sending the special message
	run: originalSelector with: arguments in: aReceiver.
	 */

static void
primitiveInvokeObjectAsMethod(void)
{   DECL_MAYBE_SQ_GLOBAL_STRUCT
    sqInt ccIndex;
    sqInt i;
    sqInt lookupClass;
    sqInt runArgs;
    sqInt runReceiver;
    char *sp;
    char *sp1;
    char *sp2;
    char *sp3;
    sqInt top;
    sqInt top1;
    sqInt valuePointer;

	runArgs = eeInstantiateClassindexableSize(longAt((GIV(specialObjectsOop) + BaseHeaderSize) + (ClassArray << ShiftForWord)), GIV(argumentCount));
	for (i = (GIV(argumentCount) - 1); i >= 0; i += -1) {
		/* begin storePointerUnchecked:ofObject:withValue: */
		/* begin popStack */
		top1 = longAt(GIV(stackPointer));
		GIV(stackPointer) += BytesPerWord;
		valuePointer = top1;
		longAtput((runArgs + BaseHeaderSize) + (i << ShiftForWord), valuePointer);
	}
	/* begin popStack */
	top = longAt(GIV(stackPointer));
	GIV(stackPointer) += BytesPerWord;
	runReceiver = top;
	/* begin push: */
	longAtput(sp = GIV(stackPointer) - BytesPerWord, GIV(newMethod));
	GIV(stackPointer) = sp;
	/* begin push: */
	longAtput(sp1 = GIV(stackPointer) - BytesPerWord, GIV(messageSelector));
	GIV(stackPointer) = sp1;
	/* begin push: */
	longAtput(sp2 = GIV(stackPointer) - BytesPerWord, runArgs);
	GIV(stackPointer) = sp2;
	/* begin push: */
	longAtput(sp3 = GIV(stackPointer) - BytesPerWord, runReceiver);
	GIV(stackPointer) = sp3;
	GIV(messageSelector) = longAt((GIV(specialObjectsOop) + BaseHeaderSize) + (SelectorRunWithIn << ShiftForWord));
	GIV(argumentCount) = 3;
	/* begin fetchClassOf: */
	if ((GIV(newMethod) & 1)) {
		lookupClass = longAt((GIV(specialObjectsOop) + BaseHeaderSize) + (ClassInteger << ShiftForWord));
		goto l1;
	}
	if (((ccIndex = (((usqInt) (longAt(GIV(newMethod)))) >> 12) & 31)) == 0) {
		lookupClass = (longAt(GIV(newMethod) - BaseHeaderSize)) & AllButTypeMask;
		goto l1;
	}
	else {
		lookupClass = longAt(((longAt((GIV(specialObjectsOop) + BaseHeaderSize) + (CompactClasses << ShiftForWord))) + BaseHeaderSize) + ((ccIndex - 1) << ShiftForWord));
		goto l1;
	}
l1:	/* end fetchClassOf: */;
	findNewMethodInClass(lookupClass);
	executeNewMethod();
	/* begin initPrimCall */
	GIV(primFailCode) = 0;
}


/*	Primitive. Answer whether the argument to the primitive is a root for
	young space
 */

EXPORT(sqInt)
primitiveIsRoot(void)
{   DECL_MAYBE_SQ_GLOBAL_STRUCT
    sqInt oop;
    sqInt oop1;
    char *sp;

	/* begin stackObjectValue: */
	oop1 = longAt(GIV(stackPointer) + (0 * BytesPerWord));
	if ((oop1 & 1)) {
		/* begin primitiveFail */
		if (GIV(primFailCode) == 0) {
			GIV(primFailCode) = 1;
		}
		oop = null;
		goto l1;
	}
	oop = oop1;
l1:	/* end stackObjectValue: */;
	if (GIV(primFailCode) == 0) {
		/* begin pop:thenPushBool: */
		longAtput(sp = GIV(stackPointer) + (((GIV(argumentCount) + 1) - 1) * BytesPerWord), (((longAt(oop)) & RootBit) != 0
			? GIV(trueObj)
			: GIV(falseObj)));
		GIV(stackPointer) = sp;
	}
}


/*	Primitive. Answer whether the OS window is currently partially or fully
	obscured. 
 */

EXPORT(sqInt)
primitiveIsWindowObscured(void)
{   DECL_MAYBE_SQ_GLOBAL_STRUCT
    sqInt object;
    char *sp;
    sqInt trueOrFalse;

	/* begin pop: */
	GIV(stackPointer) += (GIV(argumentCount) + 1) * BytesPerWord;
	/* begin pushBool: */
	trueOrFalse = ioIsWindowObscured();
	/* begin push: */
	object = (trueOrFalse
		? GIV(trueObj)
		: GIV(falseObj));
	longAtput(sp = GIV(stackPointer) - BytesPerWord, object);
	GIV(stackPointer) = sp;
}


/*	Primitive. Answer whether the argument to the primitive resides in young
	space. 
 */

EXPORT(sqInt)
primitiveIsYoung(void)
{   DECL_MAYBE_SQ_GLOBAL_STRUCT
    sqInt oop;
    sqInt oop1;
    sqInt otherOop;
    char *sp;
    sqInt trueOrFalse;

	/* begin stackObjectValue: */
	oop1 = longAt(GIV(stackPointer) + (0 * BytesPerWord));
	if ((oop1 & 1)) {
		/* begin primitiveFail */
		if (GIV(primFailCode) == 0) {
			GIV(primFailCode) = 1;
		}
		oop = null;
		goto l1;
	}
	oop = oop1;
l1:	/* end stackObjectValue: */;
	if (GIV(primFailCode) == 0) {
		/* begin pop:thenPushBool: */
		/* begin oop:isGreaterThanOrEqualTo: */
		otherOop = youngStart();
		trueOrFalse = (((usqInt) oop)) >= (((usqInt) otherOop));
		longAtput(sp = GIV(stackPointer) + (((GIV(argumentCount) + 1) - 1) * BytesPerWord), (trueOrFalse
			? GIV(trueObj)
			: GIV(falseObj)));
		GIV(stackPointer) = sp;
	}
}


/*	Obsolete on virtually all platforms; old style input polling code.
	Return the next keycode and remove it from the input buffer. The low byte
	is the 8-bit ISO character. The next four bits are the Smalltalk modifier
	bits <cmd><option><ctrl><shift>.
 */

static void
primitiveKbdNext(void)
{   DECL_MAYBE_SQ_GLOBAL_STRUCT
    sqInt keystrokeWord;
    char *sp;
    char *sp1;

	/* begin pop: */
	GIV(stackPointer) += 1 * BytesPerWord;
	keystrokeWord = ioGetKeystroke();
	if (keystrokeWord >= 0) {
		/* begin pushInteger: */
		/* begin push: */
		longAtput(sp1 = GIV(stackPointer) - BytesPerWord, ((keystrokeWord << 1) | 1));
		GIV(stackPointer) = sp1;
	}
	else {
		/* begin push: */
		longAtput(sp = GIV(stackPointer) - BytesPerWord, GIV(nilObj));
		GIV(stackPointer) = sp;
	}
}


/*	Obsolete on virtually all platforms; old style input polling code.
	Return the next keycode and without removing it from the input buffer. The
	low byte is the 8-bit ISO character. The next four bits are the Smalltalk
	modifier bits <cmd><option><ctrl><shift>.
 */

static void
primitiveKbdPeek(void)
{   DECL_MAYBE_SQ_GLOBAL_STRUCT
    sqInt keystrokeWord;
    char *sp;
    char *sp1;

	/* begin pop: */
	GIV(stackPointer) += 1 * BytesPerWord;
	keystrokeWord = ioPeekKeystroke();
	if (keystrokeWord >= 0) {
		/* begin pushInteger: */
		/* begin push: */
		longAtput(sp1 = GIV(stackPointer) - BytesPerWord, ((keystrokeWord << 1) | 1));
		GIV(stackPointer) = sp1;
	}
	else {
		/* begin push: */
		longAtput(sp = GIV(stackPointer) - BytesPerWord, GIV(nilObj));
		GIV(stackPointer) = sp;
	}
}

static void
primitiveLessOrEqual(void)
{   DECL_MAYBE_SQ_GLOBAL_STRUCT
    sqInt integerArgument;
    sqInt integerPointer;
    sqInt integerPointer1;
    sqInt integerReceiver;
    sqInt object;
    char *sp;
    sqInt top;
    sqInt top1;

	/* begin popInteger */
	/* begin popStack */
	top = longAt(GIV(stackPointer));
	GIV(stackPointer) += BytesPerWord;
	integerPointer = top;
	/* begin checkedIntegerValueOf: */
	if ((integerPointer & 1)) {
		integerArgument = (integerPointer >> 1);
		goto l1;
	}
	else {
		/* begin primitiveFail */
		if (GIV(primFailCode) == 0) {
			GIV(primFailCode) = 1;
		}
		integerArgument = 0;
		goto l1;
	}
l1:	/* end popInteger */;
	/* begin popInteger */
	/* begin popStack */
	top1 = longAt(GIV(stackPointer));
	GIV(stackPointer) += BytesPerWord;
	integerPointer1 = top1;
	/* begin checkedIntegerValueOf: */
	if ((integerPointer1 & 1)) {
		integerReceiver = (integerPointer1 >> 1);
		goto l2;
	}
	else {
		/* begin primitiveFail */
		if (GIV(primFailCode) == 0) {
			GIV(primFailCode) = 1;
		}
		integerReceiver = 0;
		goto l2;
	}
l2:	/* end popInteger */;
	/* begin checkBooleanResult: */
	if (GIV(primFailCode) == 0) {
		/* begin pushBool: */
		/* begin push: */
		object = (integerReceiver <= integerArgument
			? GIV(trueObj)
			: GIV(falseObj));
		longAtput(sp = GIV(stackPointer) - BytesPerWord, object);
		GIV(stackPointer) = sp;
	}
	else {
		/* begin unPop: */
		GIV(stackPointer) -= 2 * BytesPerWord;
	}
}


/*	Primitive comparison operations for large integers in 64 bit range */

EXPORT(void)
primitiveLessOrEqualLargeIntegers(void)
{   DECL_MAYBE_SQ_GLOBAL_STRUCT
    sqLong integerArg;
    sqLong integerRcvr;
    char *sp;

	integerArg = signed64BitValueOf(longAt(GIV(stackPointer) + (0 * BytesPerWord)));
	integerRcvr = signed64BitValueOf(longAt(GIV(stackPointer) + (1 * BytesPerWord)));
	if (GIV(primFailCode) == 0) {
		/* begin pop:thenPushBool: */
		longAtput(sp = GIV(stackPointer) + ((2 - 1) * BytesPerWord), (integerRcvr <= integerArg
			? GIV(trueObj)
			: GIV(falseObj)));
		GIV(stackPointer) = sp;
	}
}

static void
primitiveLessThan(void)
{   DECL_MAYBE_SQ_GLOBAL_STRUCT
    sqInt integerArgument;
    sqInt integerPointer;
    sqInt integerPointer1;
    sqInt integerReceiver;
    sqInt object;
    char *sp;
    sqInt top;
    sqInt top1;

	/* begin popInteger */
	/* begin popStack */
	top = longAt(GIV(stackPointer));
	GIV(stackPointer) += BytesPerWord;
	integerPointer = top;
	/* begin checkedIntegerValueOf: */
	if ((integerPointer & 1)) {
		integerArgument = (integerPointer >> 1);
		goto l1;
	}
	else {
		/* begin primitiveFail */
		if (GIV(primFailCode) == 0) {
			GIV(primFailCode) = 1;
		}
		integerArgument = 0;
		goto l1;
	}
l1:	/* end popInteger */;
	/* begin popInteger */
	/* begin popStack */
	top1 = longAt(GIV(stackPointer));
	GIV(stackPointer) += BytesPerWord;
	integerPointer1 = top1;
	/* begin checkedIntegerValueOf: */
	if ((integerPointer1 & 1)) {
		integerReceiver = (integerPointer1 >> 1);
		goto l2;
	}
	else {
		/* begin primitiveFail */
		if (GIV(primFailCode) == 0) {
			GIV(primFailCode) = 1;
		}
		integerReceiver = 0;
		goto l2;
	}
l2:	/* end popInteger */;
	/* begin checkBooleanResult: */
	if (GIV(primFailCode) == 0) {
		/* begin pushBool: */
		/* begin push: */
		object = (integerReceiver < integerArgument
			? GIV(trueObj)
			: GIV(falseObj));
		longAtput(sp = GIV(stackPointer) - BytesPerWord, object);
		GIV(stackPointer) = sp;
	}
	else {
		/* begin unPop: */
		GIV(stackPointer) -= 2 * BytesPerWord;
	}
}


/*	Primitive comparison operations for large integers in 64 bit range */

EXPORT(void)
primitiveLessThanLargeIntegers(void)
{   DECL_MAYBE_SQ_GLOBAL_STRUCT
    sqLong integerArg;
    sqLong integerRcvr;
    char *sp;

	integerArg = signed64BitValueOf(longAt(GIV(stackPointer) + (0 * BytesPerWord)));
	integerRcvr = signed64BitValueOf(longAt(GIV(stackPointer) + (1 * BytesPerWord)));
	if (GIV(primFailCode) == 0) {
		/* begin pop:thenPushBool: */
		longAtput(sp = GIV(stackPointer) + ((2 - 1) * BytesPerWord), (integerRcvr < integerArg
			? GIV(trueObj)
			: GIV(falseObj)));
		GIV(stackPointer) = sp;
	}
}


/*	Primitive. Return the n-th builtin module name. */

static void
primitiveListBuiltinModule(void)
{   DECL_MAYBE_SQ_GLOBAL_STRUCT
    sqInt i;
    sqInt index;
    sqInt integerPointer;
    sqInt length;
    char *moduleName;
    sqInt nameOop;
    char *sp;
    char *sp1;

	if (!(GIV(argumentCount) == 1)) {
		/* begin primitiveFail */
		if (GIV(primFailCode) == 0) {
			GIV(primFailCode) = 1;
		}
		return;
	}
	/* begin stackIntegerValue: */
	integerPointer = longAt(GIV(stackPointer) + (0 * BytesPerWord));
	/* begin checkedIntegerValueOf: */
	if ((integerPointer & 1)) {
		index = (integerPointer >> 1);
		goto l1;
	}
	else {
		/* begin primitiveFail */
		if (GIV(primFailCode) == 0) {
			GIV(primFailCode) = 1;
		}
		index = 0;
		goto l1;
	}
l1:	/* end stackIntegerValue: */;
	if (index <= 0) {
		/* begin primitiveFail */
		if (GIV(primFailCode) == 0) {
			GIV(primFailCode) = 1;
		}
		return;
	}
	moduleName = ioListBuiltinModule(index);
	if (moduleName == null) {
		/* begin pop: */
		GIV(stackPointer) += 2 * BytesPerWord;
		/* begin push: */
		longAtput(sp = GIV(stackPointer) - BytesPerWord, GIV(nilObj));
		GIV(stackPointer) = sp;
		return;
	}
	length = strlen(moduleName);
	nameOop = instantiateClassindexableSize(longAt((GIV(specialObjectsOop) + BaseHeaderSize) + (ClassString << ShiftForWord)), length);
	for (i = 0; i <= (length - 1); i += 1) {
		byteAtput((nameOop + BaseHeaderSize) + i, moduleName[i]);
	}
	forceInterruptCheck();
	/* begin pop:thenPush: */
	longAtput(sp1 = GIV(stackPointer) + ((2 - 1) * BytesPerWord), nameOop);
	GIV(stackPointer) = sp1;
}


/*	Primitive. Return the n-th loaded external module name. */

static void
primitiveListExternalModule(void)
{   DECL_MAYBE_SQ_GLOBAL_STRUCT
    sqInt i;
    sqInt index;
    sqInt integerPointer;
    sqInt length;
    char *moduleName;
    sqInt nameOop;
    char *sp;
    char *sp1;

	if (!(GIV(argumentCount) == 1)) {
		/* begin primitiveFail */
		if (GIV(primFailCode) == 0) {
			GIV(primFailCode) = 1;
		}
		return;
	}
	/* begin stackIntegerValue: */
	integerPointer = longAt(GIV(stackPointer) + (0 * BytesPerWord));
	/* begin checkedIntegerValueOf: */
	if ((integerPointer & 1)) {
		index = (integerPointer >> 1);
		goto l1;
	}
	else {
		/* begin primitiveFail */
		if (GIV(primFailCode) == 0) {
			GIV(primFailCode) = 1;
		}
		index = 0;
		goto l1;
	}
l1:	/* end stackIntegerValue: */;
	if (index <= 0) {
		/* begin primitiveFail */
		if (GIV(primFailCode) == 0) {
			GIV(primFailCode) = 1;
		}
		return;
	}
	moduleName = ioListLoadedModule(index);
	if (moduleName == null) {
		/* begin pop: */
		GIV(stackPointer) += 2 * BytesPerWord;
		/* begin push: */
		longAtput(sp = GIV(stackPointer) - BytesPerWord, GIV(nilObj));
		GIV(stackPointer) = sp;
		return;
	}
	length = strlen(moduleName);
	nameOop = instantiateClassindexableSize(longAt((GIV(specialObjectsOop) + BaseHeaderSize) + (ClassString << ShiftForWord)), length);
	for (i = 0; i <= (length - 1); i += 1) {
		byteAtput((nameOop + BaseHeaderSize) + i, moduleName[i]);
	}
	forceInterruptCheck();
	/* begin pop:thenPush: */
	longAtput(sp1 = GIV(stackPointer) + ((2 - 1) * BytesPerWord), nameOop);
	GIV(stackPointer) = sp1;
}


/*	This primitive is called from Squeak as...
	<imageSegment> loadSegmentFrom: aWordArray outPointers: anArray. */
/*	This primitive will load a binary image segment created by
	primitiveStoreImageSegment. It expects the outPointer array to be of the
	proper size, and the wordArray to be well formed. It will return as its
	value the original array of roots, and the erstwhile segmentWordArray will
	have been truncated to a size of zero. If this primitive should fail, the
	segmentWordArray will, sadly, have been reduced to an unrecognizable and
	unusable jumble. But what more could you have done with it anyway?
 */

static void
primitiveLoadImageSegment(void)
{   DECL_MAYBE_SQ_GLOBAL_STRUCT
    sqInt outPointerArray;
    sqInt result;
    sqInt segmentWordArray;
    char *sp;

	outPointerArray = longAt(GIV(stackPointer));

	/* Essential type checks */

	segmentWordArray = longAt(GIV(stackPointer) + (1 * BytesPerWord));
	if (!((((outPointerArray & 1) == 0)
 && (((((usqInt) (longAt(outPointerArray))) >> 8) & 15) == 2))
		 && (((segmentWordArray & 1) == 0)
 && (((((usqInt) (longAt(segmentWordArray))) >> 8) & 15) == 6)))) {
		/* begin primitiveFail */
		if (GIV(primFailCode) == 0) {
			GIV(primFailCode) = 1;
		}
		return;
	}
	result = loadImageSegmentFromoutPointers(segmentWordArray, outPointerArray);
	if (result == 0) {
		/* begin primitiveFail */
		if (GIV(primFailCode) == 0) {
			GIV(primFailCode) = 1;
		}
	}
	else {
		/* begin pop:thenPush: */
		longAtput(sp = GIV(stackPointer) + ((3 - 1) * BytesPerWord), result);
		GIV(stackPointer) = sp;
	}
}


/*	Return the value of the microsecond clock as an integer. The microsecond
	clock is at
	least 60 bits wide which means it'll get to around August 38435 before it
	wraps around. */

static void
primitiveLocalMicrosecondClock(void)
{   DECL_MAYBE_SQ_GLOBAL_STRUCT
    sqInt oop;
    char *sp;

	/* begin pop:thenPush: */
	oop = positive64BitIntegerFor(ioLocalMicroseconds());
	longAtput(sp = GIV(stackPointer) + ((1 - 1) * BytesPerWord), oop);
	GIV(stackPointer) = sp;
}


/*	Natural log. */

static void
primitiveLogN(void)
{   DECL_MAYBE_SQ_GLOBAL_STRUCT
    sqInt ccIndex;
    double f;
    sqInt object;
    double rcvr;
    double result;
    char *sp;
    sqInt successBoolean;
    sqInt top;
    sqInt top1;

	/* begin popFloat */
	VM_LABEL(4popFloat);
	/* begin popStack */
	top1 = longAt(GIV(stackPointer));
	GIV(stackPointer) += BytesPerWord;
	top = top1;
	/* begin assertClassOf:is:compactClassIndex: */
	VM_LABEL(50assertClassOfiscompactClassIndex);
	/* begin success: */
	/* begin is:instanceOf:compactClassIndex: */
	if ((top & 1)) {
		successBoolean = 0;
		goto l1;
	}
	ccIndex = (((usqInt) (longAt(top))) >> 12) & 31;
	if (ClassFloatCompactIndex != 0) {
		successBoolean = ClassFloatCompactIndex == ccIndex;
		goto l1;
	}
	successBoolean = (ccIndex == 0)
	 && (((longAt(top - BaseHeaderSize)) & AllButTypeMask) == (longAt((GIV(specialObjectsOop) + BaseHeaderSize) + (ClassFloat << ShiftForWord))));
l1:	/* end is:instanceOf:compactClassIndex: */;
	if (!(successBoolean)) {
		if (GIV(primFailCode) == 0) {

			/* Don't overwrite an error code that has already been set. */

			GIV(primFailCode) = 1;
		}
	}
	if (GIV(primFailCode) == 0) {
		;
		fetchFloatAtinto(top + BaseHeaderSize, result);
	}
	rcvr = result;
	if (GIV(primFailCode) == 0) {
		/* begin pushFloat: */
		f = log(rcvr);
		/* begin push: */
		object = floatObjectOf(f);
		longAtput(sp = GIV(stackPointer) - BytesPerWord, object);
		GIV(stackPointer) = sp;
	}
	else {
		/* begin unPop: */
		GIV(stackPointer) -= 1 * BytesPerWord;
	}
}


/*	Primitive. Answer an Array with the current long-running primitive method
	identified by
	the heartbeat, the minimum number of milliseconds it was active for, and
	the milliseconds
	of GC activity there-in, or nil if none. Since the
	longRunningPrimitiveCheckMethod is
	sampled at interrupt time be careful to validate it before returning it. */

EXPORT(void)
primitiveLongRunningPrimitive(void)
{   DECL_MAYBE_SQ_GLOBAL_STRUCT
    sqInt gcms;
    sqInt lrpcm;
    sqInt primms;
    sqInt result;
    char *sp;

	if (!(GIV(argumentCount) == 0)) {
		/* begin primitiveFail */
		if (GIV(primFailCode) == 0) {
			GIV(primFailCode) = 1;
		}
		return;
	}
	sqLowLevelMFence();
	if ((GIV(longRunningPrimitiveStopUsecs) > GIV(longRunningPrimitiveStartUsecs))
	 && ((((lrpcm = GIV(longRunningPrimitiveCheckMethod))) != null)
 && ((((lrpcm & 3) == 0)
 && (((((usqInt)lrpcm)) >= heapBase)
 && (((((usqInt)lrpcm)) < GIV(freeStart))
 && (((longAt(lrpcm)) & TypeMask) != HeaderTypeGC))))
 && ((!(((longAt(lrpcm)) & TypeMask) == HeaderTypeFree))
 && (((((usqInt) (longAt(lrpcm))) >> 8) & 15) >= 12))))) {
		result = instantiateClassindexableSize(longAt((GIV(specialObjectsOop) + BaseHeaderSize) + (ClassArray << ShiftForWord)), 3);
		primms = ((GIV(longRunningPrimitiveStopUsecs) - GIV(longRunningPrimitiveStartUsecs)) + 500) / 1000;
		gcms = (GIV(longRunningPrimitiveGCUsecs) + 500) / 1000;
		/* begin storePointer:ofObject:withValue: */
		if ((((usqInt) result)) < (((usqInt) GIV(youngStart)))) {
			possibleRootStoreIntovalue(result, lrpcm);
		}
		longAtput((result + BaseHeaderSize) + (0 << ShiftForWord), lrpcm);
		longAtput((result + BaseHeaderSize) + (1 << ShiftForWord), ((primms << 1) | 1));
		longAtput((result + BaseHeaderSize) + (2 << ShiftForWord), ((gcms << 1) | 1));
	}
	else {
		result = GIV(nilObj);
	}
	/* begin pop:thenPush: */
	longAtput(sp = GIV(stackPointer) + ((1 - 1) * BytesPerWord), result);
	GIV(stackPointer) = sp;
	voidLongRunningPrimitive("get");
}


/*	Primitive. Install the semaphore to be used for collecting long-running
	primitives, 
	or nil if no semaphore should be used. */

EXPORT(void)
primitiveLongRunningPrimitiveSemaphore(void)
{   DECL_MAYBE_SQ_GLOBAL_STRUCT
    sqInt activeContext;
    sqInt activeContext1;
    sqInt aMethodObj;
    sqInt decodedIP;
    sqInt flushState;
    sqInt header;
    StackPage *newPage;
    sqInt oop;
    sqInt sema;
    char *sp;
    sqInt sz;
    char *theFP;
    sqInt top;

	sema = longAt(GIV(stackPointer) + (0 * BytesPerWord));
	if (((sema & 1))
	 || (GIV(argumentCount) != 1)) {
		/* begin primitiveFail */
		if (GIV(primFailCode) == 0) {
			GIV(primFailCode) = 1;
		}
		return;
	}
	if (sema == GIV(nilObj)) {
		flushState = GIV(longRunningPrimitiveCheckSemaphore) != null;
		GIV(longRunningPrimitiveCheckSemaphore) = null;
	}
	else {
		flushState = GIV(longRunningPrimitiveCheckSemaphore) == null;
		if (!((fetchClassOfNonInt(sema)) == (longAt((GIV(specialObjectsOop) + BaseHeaderSize) + (ClassSemaphore << ShiftForWord))))) {
			/* begin primitiveFail */
			if (GIV(primFailCode) == 0) {
				GIV(primFailCode) = 1;
			}
			return;
		}
		GIV(longRunningPrimitiveCheckSemaphore) = sema;
	}
	if (flushState) {
		/* begin push: */
		longAtput(sp = GIV(stackPointer) - BytesPerWord, GIV(instructionPointer));
		GIV(stackPointer) = sp;
		/* begin voidVMStateForSnapshot */

		/* in case of code compactions. */

		GIV(instructionPointer) = 0;
		activeContext1 = divorceAllFrames();
		/* begin ensureAllContextsHaveBytecodePCsOrAreBereaved */
		VM_LABEL(0ensureAllContextsHaveBytecodePCsOrAreBereaved);
		oop = heapBase + (headerTypeBytes[(longAt(heapBase)) & TypeMask]);
		while (oop < GIV(freeStart)) {
			if ((!(((longAt(oop)) & TypeMask) == HeaderTypeFree))
			 && (((((usqInt) (longAt(oop))) >> 12) & 31) == ClassMethodContextCompactIndex)) {
				if (((longAt((oop + BaseHeaderSize) + (SenderIndex << ShiftForWord))) & 1)) {
					/* begin markContextAsDead: */
					assert(isContext(oop));
					longAtput((oop + BaseHeaderSize) + (SenderIndex << ShiftForWord), GIV(nilObj));
					longAtput((oop + BaseHeaderSize) + (InstructionPointerIndex << ShiftForWord), GIV(nilObj));
				}
				else {
					decodedIP = longAt((oop + BaseHeaderSize) + (InstructionPointerIndex << ShiftForWord));
					if (((decodedIP & 1))
					 && ((((sqInt) decodedIP)) < 0)) {
						decodedIP = mustMapMachineCodePCcontext((decodedIP >> 1), oop);
						longAtput((oop + BaseHeaderSize) + (InstructionPointerIndex << ShiftForWord), decodedIP);
					}
				}
			}
			/* begin objectAfter: */
			if (DoAssertionChecks) {
				if ((((usqInt) oop)) >= (((usqInt) GIV(endOfMemory)))) {
					error("no objects after the end of memory");
				}
			}
			if (((longAt(oop)) & TypeMask) == HeaderTypeFree) {
				sz = (longAt(oop)) & AllButTypeMask;
			}
			else {
				/* begin sizeBitsOf: */
				header = longAt(oop);
				sz = ((header & TypeMask) == HeaderTypeSizeAndClass
					? (longAt(oop - (BytesPerWord * 2))) & LongSizeMask
					: header & SizeMask);
			}
			oop = (oop + sz) + (headerTypeBytes[(longAt(oop + sz)) & TypeMask]);
		}
		voidCogCompiledCode();
		activeContext = activeContext1;
		/* begin marryContextInNewStackPageAndInitializeInterpreterRegisters: */
		VM_LABEL(2marryContextInNewStackPageAndInitializeInterpreterRegisters);
		assert(GIV(stackPage) == 0);
		newPage = makeBaseFrameFor(activeContext);
		/* begin setStackPageAndLimit: */
		GIV(stackPage) = newPage;
		if (GIV(stackLimit) != (((char *) (((usqInt) -1))))) {
			GIV(stackLimit) = (GIV(stackPage)->stackLimit);
		}
		markStackPageMostRecentlyUsed(newPage);
		GIV(framePointer) = (GIV(stackPage)->headFP);
		GIV(stackPointer) = (GIV(stackPage)->headSP);
		/* begin setMethod: */
		/* begin iframeMethod: */
		theFP = (GIV(stackPage)->headFP);
		aMethodObj = longAt(theFP + FoxMethod);
		assert((((usqInt)aMethodObj)) >= (startOfMemory()));
		GIV(method) = aMethodObj;
		/* begin popStack */
		top = longAt(GIV(stackPointer));
		GIV(stackPointer) += BytesPerWord;
		GIV(instructionPointer) = ((sqInt) top);
		assert((((stackValue(0)) == (nilObject()))
 && (GIV(longRunningPrimitiveCheckSemaphore) == null))
		 || (((stackValue(0)) == GIV(longRunningPrimitiveCheckSemaphore))
 && ((fetchClassOfNonInt(sema)) == (splObj(ClassSemaphore)))));
	}
	voidLongRunningPrimitive("install");
	/* begin pop: */
	GIV(stackPointer) += 1 * BytesPerWord;
	if (flushState) {
		siglongjmp(reenterInterpreter, ReturnToInterpreter);
	}
}


/*	Register the low-space semaphore. If the argument is not a 
	Semaphore, unregister the current low-space Semaphore. */

static void
primitiveLowSpaceSemaphore(void)
{   DECL_MAYBE_SQ_GLOBAL_STRUCT
    sqInt arg;
    sqInt top;

	/* begin popStack */
	top = longAt(GIV(stackPointer));
	GIV(stackPointer) += BytesPerWord;
	arg = top;
	if ((fetchClassOf(arg)) == (longAt((GIV(specialObjectsOop) + BaseHeaderSize) + (ClassSemaphore << ShiftForWord)))) {
		/* begin splObj:put: */
		/* begin storePointer:ofObject:withValue: */
		if ((((usqInt) GIV(specialObjectsOop))) < (((usqInt) GIV(youngStart)))) {
			possibleRootStoreIntovalue(GIV(specialObjectsOop), arg);
		}
		longAtput((GIV(specialObjectsOop) + BaseHeaderSize) + (TheLowSpaceSemaphore << ShiftForWord), arg);
	}
	else {
		/* begin splObj:put: */
		/* begin storePointer:ofObject:withValue: */
		if ((((usqInt) GIV(specialObjectsOop))) < (((usqInt) GIV(youngStart)))) {
			possibleRootStoreIntovalue(GIV(specialObjectsOop), GIV(nilObj));
		}
		longAtput((GIV(specialObjectsOop) + BaseHeaderSize) + (TheLowSpaceSemaphore << ShiftForWord), GIV(nilObj));
	}
}

static void
primitiveMakePoint(void)
{   DECL_MAYBE_SQ_GLOBAL_STRUCT
    sqInt argument;
    sqInt pointResult;
    sqInt pointResult1;
    sqInt pointResult2;
    sqInt pt;
    sqInt rcvr;
    char *sp;

	argument = longAt(GIV(stackPointer));
	rcvr = longAt(GIV(stackPointer) + (1 * BytesPerWord));
	if ((rcvr & 1)) {
		if ((argument & 1)) {
			/* begin makePointwithxValue:yValue: */
			pointResult = eeInstantiateSmallClasssizeInBytes(longAt((GIV(specialObjectsOop) + BaseHeaderSize) + (ClassPoint << ShiftForWord)), 3 * BytesPerWord);
			longAtput((pointResult + BaseHeaderSize) + (XIndex << ShiftForWord), ((((rcvr >> 1)) << 1) | 1));
			longAtput((pointResult + BaseHeaderSize) + (YIndex << ShiftForWord), ((((argument >> 1)) << 1) | 1));
			pt = pointResult;
		}
		else {
			/* begin makePointwithxValue:yValue: */
			pointResult1 = eeInstantiateSmallClasssizeInBytes(longAt((GIV(specialObjectsOop) + BaseHeaderSize) + (ClassPoint << ShiftForWord)), 3 * BytesPerWord);
			longAtput((pointResult1 + BaseHeaderSize) + (XIndex << ShiftForWord), ((((rcvr >> 1)) << 1) | 1));
			longAtput((pointResult1 + BaseHeaderSize) + (YIndex << ShiftForWord), ((0 << 1) | 1));
			pt = pointResult1;
			/* begin storePointer:ofObject:withValue: */
			if ((((usqInt) pt)) < (((usqInt) GIV(youngStart)))) {
				possibleRootStoreIntovalue(pt, longAt(GIV(stackPointer) + (0 * BytesPerWord)));
			}
			longAtput((pt + BaseHeaderSize) + (1 << ShiftForWord), longAt(GIV(stackPointer) + (0 * BytesPerWord)));
		}
	}
	else {
		if (!(((rcvr & 1) == 0)
			 && ((ClassFloatCompactIndex != 0
	? ((((usqInt) (longAt(rcvr))) >> 12) & 31) == ClassFloatCompactIndex
	: (fetchClassOfNonInt(rcvr)) == (longAt((GIV(specialObjectsOop) + BaseHeaderSize) + (ClassFloat << ShiftForWord))))))) {
			/* begin success: */
			if (!(0)) {
				if (GIV(primFailCode) == 0) {

					/* Don't overwrite an error code that has already been set. */

					GIV(primFailCode) = 1;
				}
			}
			return;
		}
		/* begin makePointwithxValue:yValue: */
		pointResult2 = eeInstantiateSmallClasssizeInBytes(longAt((GIV(specialObjectsOop) + BaseHeaderSize) + (ClassPoint << ShiftForWord)), 3 * BytesPerWord);
		longAtput((pointResult2 + BaseHeaderSize) + (XIndex << ShiftForWord), ((0 << 1) | 1));
		longAtput((pointResult2 + BaseHeaderSize) + (YIndex << ShiftForWord), ((0 << 1) | 1));
		pt = pointResult2;
		/* begin storePointer:ofObject:withValue: */
		if ((((usqInt) pt)) < (((usqInt) GIV(youngStart)))) {
			possibleRootStoreIntovalue(pt, longAt(GIV(stackPointer) + (1 * BytesPerWord)));
		}
		longAtput((pt + BaseHeaderSize) + (0 << ShiftForWord), longAt(GIV(stackPointer) + (1 * BytesPerWord)));
		/* begin storePointer:ofObject:withValue: */
		if ((((usqInt) pt)) < (((usqInt) GIV(youngStart)))) {
			possibleRootStoreIntovalue(pt, longAt(GIV(stackPointer) + (0 * BytesPerWord)));
		}
		longAtput((pt + BaseHeaderSize) + (1 << ShiftForWord), longAt(GIV(stackPointer) + (0 * BytesPerWord)));
	}
	/* begin pop:thenPush: */
	longAtput(sp = GIV(stackPointer) + ((2 - 1) * BytesPerWord), pt);
	GIV(stackPointer) = sp;
}


/*	Primitive. Mark the method for exception handling. The primitive must fail
	after marking the context so that the regular code is run.
 */

static void
primitiveMarkHandlerMethod(void)
{   DECL_MAYBE_SQ_GLOBAL_STRUCT
	/* begin primitiveFail */
	if (GIV(primFailCode) == 0) {
		GIV(primFailCode) = 1;
	}
}


/*	Primitive. Mark the method for exception unwinding. The primitive must
	fail after marking the context so that the regular code is run. It must
	also *not* allow a context switch.
 */

static void
primitiveMarkUnwindMethod(void)
{   DECL_MAYBE_SQ_GLOBAL_STRUCT
	/* begin primitiveFail */
	if (GIV(primFailCode) == 0) {
		GIV(primFailCode) = 1;
	}
	return;
}

static void
primitiveMaxIdentityHash(void)
{   DECL_MAYBE_SQ_GLOBAL_STRUCT
    char *sp;

	/* begin pop:thenPushInteger: */
	longAtput(sp = GIV(stackPointer) + ((1 - 1) * BytesPerWord), ((HashMaskUnshifted << 1) | 1));
	GIV(stackPointer) = sp;
}


/*	Return the method an external primitive was defined in */

sqInt
primitiveMethod(void)
{
	return GIV(newMethod);
}


/*	Return the value of the millisecond clock as an integer. Note that the
	millisecond clock wraps around periodically. On some platforms it can wrap
	daily. The range is limited to SmallInteger maxVal / 2 to allow delays of
	up to that length without overflowing a SmallInteger.
 */

static void
primitiveMillisecondClock(void)
{   DECL_MAYBE_SQ_GLOBAL_STRUCT
    sqInt oop;
    char *sp;

	/* begin pop:thenPush: */
	oop = ((((ioMSecs()) & MillisecondClockMask) << 1) | 1);
	longAtput(sp = GIV(stackPointer) + ((1 - 1) * BytesPerWord), oop);
	GIV(stackPointer) = sp;
}

static void
primitiveMod(void)
{   DECL_MAYBE_SQ_GLOBAL_STRUCT
    sqInt mod;
    char *sp;

	mod = doPrimitiveModby(longAt(GIV(stackPointer) + (1 * BytesPerWord)), longAt(GIV(stackPointer)));
	/* begin pop2AndPushIntegerIfOK: */
	if (GIV(primFailCode) == 0) {
		if ((mod ^ (mod << 1)) >= 0) {
			/* begin pop:thenPush: */
			longAtput(sp = GIV(stackPointer) + ((2 - 1) * BytesPerWord), ((mod << 1) | 1));
			GIV(stackPointer) = sp;
		}
		else {
			/* begin success: */
			if (!(0)) {
				if (GIV(primFailCode) == 0) {

					/* Don't overwrite an error code that has already been set. */

					GIV(primFailCode) = 1;
				}
			}
		}
	}
}


/*	Primitive arithmetic operations for large integers in 64 bit range */

EXPORT(void)
primitiveModLargeIntegers(void)
{   DECL_MAYBE_SQ_GLOBAL_STRUCT
    sqLong integerArg;
    sqLong integerRcvr;
    sqInt oopResult;
    sqLong result;
    char *sp;

	integerArg = signed64BitValueOf(longAt(GIV(stackPointer) + (0 * BytesPerWord)));
	integerRcvr = signed64BitValueOf(longAt(GIV(stackPointer) + (1 * BytesPerWord)));
	if (integerArg == 0) {
		/* begin primitiveFail */
		if (GIV(primFailCode) == 0) {
			GIV(primFailCode) = 1;
		}
	}
	if (!(GIV(primFailCode) == 0)) {
		return;
	}

	/* ensure that the result has the same sign as the integerArg */

	result = integerRcvr % integerArg;
	if (integerArg < 0) {
		if (result > 0) {
			result += integerArg;
		}
	}
	else {
		if (result < 0) {
			result += integerArg;
		}
	}
	oopResult = signed64BitIntegerFor(result);
	if (GIV(primFailCode) == 0) {
		/* begin pop:thenPush: */
		longAtput(sp = GIV(stackPointer) + ((2 - 1) * BytesPerWord), oopResult);
		GIV(stackPointer) = sp;
	}
}


/*	Obsolete on virtually all platforms; old style input polling code.
	Return the mouse button state. The low three bits encode the state of the
	<red><yellow><blue> mouse buttons. The next four bits encode the Smalltalk
	modifier bits <cmd><option><ctrl><shift>.
 */

static void
primitiveMouseButtons(void)
{   DECL_MAYBE_SQ_GLOBAL_STRUCT
    sqInt buttonWord;
    char *sp;

	/* begin pop: */
	GIV(stackPointer) += 1 * BytesPerWord;
	buttonWord = ioGetButtonState();
	/* begin pushInteger: */
	/* begin push: */
	longAtput(sp = GIV(stackPointer) - BytesPerWord, ((buttonWord << 1) | 1));
	GIV(stackPointer) = sp;
}


/*	Obsolete on virtually all platforms; old style input polling code.
	Return a Point indicating current position of the mouse. Note that mouse
	coordinates may be negative if the mouse moves above or to the left of the
	top-left corner of the Smalltalk window.
 */

static void
primitiveMousePoint(void)
{   DECL_MAYBE_SQ_GLOBAL_STRUCT
    sqInt object;
    sqInt pointResult;
    sqInt pointWord;
    char *sp;
    sqInt x;
    sqInt y;

	/* begin pop: */
	GIV(stackPointer) += 1 * BytesPerWord;
	pointWord = ioMousePoint();
	/* begin signExtend16: */
	if ((((((usqInt) pointWord) >> 16) & 65535) & 32768) == 0) {
		x = (((usqInt) pointWord) >> 16) & 65535;
		goto l1;
	}
	else {
		x = ((((usqInt) pointWord) >> 16) & 65535) - 65536;
		goto l1;
	}
l1:	/* end signExtend16: */;
	/* begin signExtend16: */
	if (((pointWord & 65535) & 32768) == 0) {
		y = pointWord & 65535;
		goto l2;
	}
	else {
		y = (pointWord & 65535) - 65536;
		goto l2;
	}
l2:	/* end signExtend16: */;
	/* begin push: */
	/* begin makePointwithxValue:yValue: */
	pointResult = eeInstantiateSmallClasssizeInBytes(longAt((GIV(specialObjectsOop) + BaseHeaderSize) + (ClassPoint << ShiftForWord)), 3 * BytesPerWord);
	longAtput((pointResult + BaseHeaderSize) + (XIndex << ShiftForWord), ((x << 1) | 1));
	longAtput((pointResult + BaseHeaderSize) + (YIndex << ShiftForWord), ((y << 1) | 1));
	object = pointResult;
	longAtput(sp = GIV(stackPointer) - BytesPerWord, object);
	GIV(stackPointer) = sp;
}

static void
primitiveMultiply(void)
{   DECL_MAYBE_SQ_GLOBAL_STRUCT
    sqInt integerArg;
    sqInt integerPointer;
    sqInt integerPointer1;
    sqInt integerRcvr;
    sqInt integerResult;
    char *sp;

	/* begin stackIntegerValue: */
	integerPointer = longAt(GIV(stackPointer) + (1 * BytesPerWord));
	/* begin checkedIntegerValueOf: */
	if ((integerPointer & 1)) {
		integerRcvr = (integerPointer >> 1);
		goto l1;
	}
	else {
		/* begin primitiveFail */
		if (GIV(primFailCode) == 0) {
			GIV(primFailCode) = 1;
		}
		integerRcvr = 0;
		goto l1;
	}
l1:	/* end stackIntegerValue: */;
	/* begin stackIntegerValue: */
	integerPointer1 = longAt(GIV(stackPointer) + (0 * BytesPerWord));
	/* begin checkedIntegerValueOf: */
	if ((integerPointer1 & 1)) {
		integerArg = (integerPointer1 >> 1);
		goto l2;
	}
	else {
		/* begin primitiveFail */
		if (GIV(primFailCode) == 0) {
			GIV(primFailCode) = 1;
		}
		integerArg = 0;
		goto l2;
	}
l2:	/* end stackIntegerValue: */;
	if (GIV(primFailCode) == 0) {

		/* check for C overflow by seeing if computation is reversible */

		integerResult = integerRcvr * integerArg;
		if ((integerArg == 0)
		 || ((integerResult / integerArg) == integerRcvr)) {
			/* begin pop2AndPushIntegerIfOK: */
			if (GIV(primFailCode) == 0) {
				if ((integerResult ^ (integerResult << 1)) >= 0) {
					/* begin pop:thenPush: */
					longAtput(sp = GIV(stackPointer) + ((2 - 1) * BytesPerWord), ((integerResult << 1) | 1));
					GIV(stackPointer) = sp;
				}
				else {
					/* begin success: */
					if (!(0)) {
						if (GIV(primFailCode) == 0) {

							/* Don't overwrite an error code that has already been set. */

							GIV(primFailCode) = 1;
						}
					}
				}
			}
		}
		else {
			/* begin primitiveFail */
			if (GIV(primFailCode) == 0) {
				GIV(primFailCode) = 1;
			}
		}
	}
}


/*	Primitive arithmetic operations for large integers in 64 bit range */

EXPORT(void)
primitiveMultiplyLargeIntegers(void)
{   DECL_MAYBE_SQ_GLOBAL_STRUCT
    sqLong integerArg;
    sqLong integerRcvr;
    sqInt oopResult;
    sqLong result;
    char *sp;

	integerArg = signed64BitValueOf(longAt(GIV(stackPointer) + (0 * BytesPerWord)));
	integerRcvr = signed64BitValueOf(longAt(GIV(stackPointer) + (1 * BytesPerWord)));
	if (!(GIV(primFailCode) == 0)) {
		return;
	}

	/* check for C overflow by seeing if computation is reversible */

	result = integerRcvr * integerArg;
	if ((integerArg == 0)
	 || ((result / integerArg) == integerRcvr)) {
		oopResult = signed64BitIntegerFor(result);
	}
	else {
		/* begin primitiveFail */
		if (GIV(primFailCode) == 0) {
			GIV(primFailCode) = 1;
		}
	}
	if (GIV(primFailCode) == 0) {
		/* begin pop:thenPush: */
		longAtput(sp = GIV(stackPointer) + ((2 - 1) * BytesPerWord), oopResult);
		GIV(stackPointer) = sp;
	}
}


/*	Allocate a new fixed-size instance. Fail if the allocation would leave
	less than lowSpaceThreshold bytes free. May cause a GC
 */

static void
primitiveNew(void)
{   DECL_MAYBE_SQ_GLOBAL_STRUCT
    sqInt atomSize;
    sqInt class;
    sqInt format;
    sqInt minFree;
    sqInt object;
    char *sp;
    sqInt spaceOkay;


	/* The following may cause GC! */

	class = longAt(GIV(stackPointer));
	/* begin sufficientSpaceToInstantiate:indexableSize: */
	VM_LABEL(0sufficientSpaceToInstantiateindexableSize);

	/* fail if attempting to call new: on non-indexable class */

	format = (((usqInt) ((longAt((class + BaseHeaderSize) + (InstanceSpecificationIndex << ShiftForWord))) - 1)) >> 8) & 15;
	if (((((usqInt ) 0)) > 0)
	 && (format < 2)) {
		spaceOkay = 0;
		goto l1;
	}
	if (format < 8) {

		/* indexable fields are words or pointers */

		atomSize = BytesPerWord;
	}
	else {

		/* indexable fields are bytes */

		atomSize = 1;
	}
	/* begin sufficientSpaceToAllocate: */

	/* check for low-space */

	minFree = ((((GIV(lowSpaceThreshold) + (2500 + (0 * atomSize))) + BaseHeaderSize) + BytesPerWord) - 1) & (~(BytesPerWord - 1));
	if ((((usqInt) (GIV(freeStart) + minFree))) <= (((usqInt) GIV(reserveStart)))) {
		spaceOkay = 1;
		goto l1;
	}
	spaceOkay = sufficientSpaceAfterGC(minFree);
l1:	/* end sufficientSpaceToInstantiate:indexableSize: */;
	/* begin success: */
	if (!(spaceOkay)) {
		if (GIV(primFailCode) == 0) {

			/* Don't overwrite an error code that has already been set. */

			GIV(primFailCode) = 1;
		}
	}
	if (GIV(primFailCode) == 0) {
		/* begin push: */
		object = instantiateClassindexableSize(popStack(), 0);
		longAtput(sp = GIV(stackPointer) - BytesPerWord, object);
		GIV(stackPointer) = sp;
	}
}

static void
primitiveNewMethod(void)
{   DECL_MAYBE_SQ_GLOBAL_STRUCT
    sqInt bytecodeCount;
    sqInt class;
    sqInt header;
    sqInt i;
    sqInt integerPointer;
    sqInt literalCount;
    sqInt size;
    char *sp;
    sqInt theMethod;

	header = longAt(GIV(stackPointer));
	/* begin stackIntegerValue: */
	integerPointer = longAt(GIV(stackPointer) + (1 * BytesPerWord));
	/* begin checkedIntegerValueOf: */
	if ((integerPointer & 1)) {
		bytecodeCount = (integerPointer >> 1);
		goto l1;
	}
	else {
		/* begin primitiveFail */
		if (GIV(primFailCode) == 0) {
			GIV(primFailCode) = 1;
		}
		bytecodeCount = 0;
		goto l1;
	}
l1:	/* end stackIntegerValue: */;
	/* begin success: */
	if (!((header & 1))) {
		if (GIV(primFailCode) == 0) {

			/* Don't overwrite an error code that has already been set. */

			GIV(primFailCode) = 1;
		}
	}
	if (!(GIV(primFailCode) == 0)) {
		return;
	}
	class = longAt(GIV(stackPointer) + (2 * BytesPerWord));
	size = ((((((usqInt) header) >> 10) & 255) + 1) * BytesPerWord) + bytecodeCount;
	theMethod = instantiateClassindexableSize(class, size);
	longAtput((theMethod + BaseHeaderSize) + (HeaderIndex << ShiftForWord), header);
	literalCount = (((usqInt) header) >> 10) & 255;
	for (i = 1; i <= literalCount; i += 1) {
		/* begin storePointer:ofObject:withValue: */
		if ((((usqInt) theMethod)) < (((usqInt) GIV(youngStart)))) {
			possibleRootStoreIntovalue(theMethod, GIV(nilObj));
		}
		longAtput((theMethod + BaseHeaderSize) + (i << ShiftForWord), GIV(nilObj));
	}
	/* begin pop:thenPush: */
	longAtput(sp = GIV(stackPointer) + ((3 - 1) * BytesPerWord), theMethod);
	GIV(stackPointer) = sp;
}


/*	Allocate a new indexable instance. Fail if the allocation would leave less
	than lowSpaceThreshold bytes free.
 */

static void
primitiveNewWithArg(void)
{   DECL_MAYBE_SQ_GLOBAL_STRUCT
    sqInt atomSize;
    sqInt class;
    sqInt format;
    sqInt minFree;
    sqInt oop;
    sqInt size;
    char *sp;
    sqInt spaceOkay;

	size = positive32BitValueOf(longAt(GIV(stackPointer)));
	class = longAt(GIV(stackPointer) + (1 * BytesPerWord));
	/* begin success: */
	if (!(size >= 0)) {
		if (GIV(primFailCode) == 0) {

			/* Don't overwrite an error code that has already been set. */

			GIV(primFailCode) = 1;
		}
	}
	if (GIV(primFailCode) == 0) {
		/* begin sufficientSpaceToInstantiate:indexableSize: */
		VM_LABEL(1sufficientSpaceToInstantiateindexableSize);

		/* fail if attempting to call new: on non-indexable class */

		format = (((usqInt) ((longAt((class + BaseHeaderSize) + (InstanceSpecificationIndex << ShiftForWord))) - 1)) >> 8) & 15;
		if (((((usqInt ) size)) > 0)
		 && (format < 2)) {
			spaceOkay = 0;
			goto l1;
		}
		if (format < 8) {

			/* indexable fields are words or pointers */

			atomSize = BytesPerWord;
		}
		else {

			/* indexable fields are bytes */

			atomSize = 1;
		}
		/* begin sufficientSpaceToAllocate: */

		/* check for low-space */

		minFree = ((((GIV(lowSpaceThreshold) + (2500 + (size * atomSize))) + BaseHeaderSize) + BytesPerWord) - 1) & (~(BytesPerWord - 1));
		if ((((usqInt) (GIV(freeStart) + minFree))) <= (((usqInt) GIV(reserveStart)))) {
			spaceOkay = 1;
			goto l1;
		}
		spaceOkay = sufficientSpaceAfterGC(minFree);
	l1:	/* end sufficientSpaceToInstantiate:indexableSize: */;
		/* begin success: */
		if (!(spaceOkay)) {
			if (GIV(primFailCode) == 0) {

				/* Don't overwrite an error code that has already been set. */

				GIV(primFailCode) = 1;
			}
		}
		class = longAt(GIV(stackPointer) + (1 * BytesPerWord));
	}
	if (GIV(primFailCode) == 0) {
		/* begin pop:thenPush: */
		oop = instantiateClassindexableSize(class, size);
		longAtput(sp = GIV(stackPointer) + ((2 - 1) * BytesPerWord), oop);
		GIV(stackPointer) = sp;
	}
}

static void
primitiveNextInstance(void)
{   DECL_MAYBE_SQ_GLOBAL_STRUCT
    sqInt ccIndex;
    sqInt classPointer;
    sqInt header;
    sqInt header1;
    sqInt object;
    char *sp;
    sqInt subsequentObject;
    sqInt sz;
    sqInt sz1;

	object = longAt(GIV(stackPointer));
	if (!((object & 1))) {
		/* begin fetchClassOfNonInt: */
		if (((ccIndex = (((usqInt) (longAt(object))) >> 12) & 31)) == 0) {
			classPointer = (longAt(object - BaseHeaderSize)) & AllButTypeMask;
			goto l1;
		}
		else {
			classPointer = longAt(((longAt((GIV(specialObjectsOop) + BaseHeaderSize) + (CompactClasses << ShiftForWord))) + BaseHeaderSize) + ((ccIndex - 1) << ShiftForWord));
			goto l1;
		}
	l1:	/* end fetchClassOfNonInt: */;
		/* begin objectAfter: */
		if (DoAssertionChecks) {
			if ((((usqInt) object)) >= (((usqInt) GIV(endOfMemory)))) {
				error("no objects after the end of memory");
			}
		}
		if (((longAt(object)) & TypeMask) == HeaderTypeFree) {
			sz1 = (longAt(object)) & AllButTypeMask;
		}
		else {
			/* begin sizeBitsOf: */
			header1 = longAt(object);
			sz1 = ((header1 & TypeMask) == HeaderTypeSizeAndClass
				? (longAt(object - (BytesPerWord * 2))) & LongSizeMask
				: header1 & SizeMask);
		}
		subsequentObject = (object + sz1) + (headerTypeBytes[(longAt(object + sz1)) & TypeMask]);
		while ((((usqInt) subsequentObject)) < (((usqInt) GIV(freeStart)))) {
			if ((!(((longAt(subsequentObject)) & TypeMask) == HeaderTypeFree))
			 && ((fetchClassOfNonInt(subsequentObject)) == classPointer)) {
				/* begin pop:thenPush: */
				longAtput(sp = GIV(stackPointer) + (((GIV(argumentCount) + 1) - 1) * BytesPerWord), subsequentObject);
				GIV(stackPointer) = sp;
				return;
			}
			/* begin objectAfter: */
			if (DoAssertionChecks) {
				if ((((usqInt) subsequentObject)) >= (((usqInt) GIV(endOfMemory)))) {
					error("no objects after the end of memory");
				}
			}
			if (((longAt(subsequentObject)) & TypeMask) == HeaderTypeFree) {
				sz = (longAt(subsequentObject)) & AllButTypeMask;
			}
			else {
				/* begin sizeBitsOf: */
				header = longAt(subsequentObject);
				sz = ((header & TypeMask) == HeaderTypeSizeAndClass
					? (longAt(subsequentObject - (BytesPerWord * 2))) & LongSizeMask
					: header & SizeMask);
			}
			subsequentObject = (subsequentObject + sz) + (headerTypeBytes[(longAt(subsequentObject + sz)) & TypeMask]);
		}
	}
	/* begin primitiveFail */
	if (GIV(primFailCode) == 0) {
		GIV(primFailCode) = 1;
	}
}


/*	Return the object following the receiver in the heap. Return the
	SmallInteger zero when there are no more objects.
 */

static void
primitiveNextObject(void)
{   DECL_MAYBE_SQ_GLOBAL_STRUCT
    sqInt header;
    sqInt header1;
    sqInt instance;
    sqInt obj;
    sqInt object;
    char *sp;
    char *sp1;
    sqInt sz;
    sqInt sz1;

	object = longAt(GIV(stackPointer));
	/* begin accessibleObjectAfter: */
	/* begin objectAfter: */
	if (DoAssertionChecks) {
		if ((((usqInt) object)) >= (((usqInt) GIV(endOfMemory)))) {
			error("no objects after the end of memory");
		}
	}
	if (((longAt(object)) & TypeMask) == HeaderTypeFree) {
		sz1 = (longAt(object)) & AllButTypeMask;
	}
	else {
		/* begin sizeBitsOf: */
		header1 = longAt(object);
		sz1 = ((header1 & TypeMask) == HeaderTypeSizeAndClass
			? (longAt(object - (BytesPerWord * 2))) & LongSizeMask
			: header1 & SizeMask);
	}
	obj = (object + sz1) + (headerTypeBytes[(longAt(object + sz1)) & TypeMask]);
	while ((((usqInt) obj)) < (((usqInt) GIV(freeStart)))) {
		if (!(((longAt(obj)) & TypeMask) == HeaderTypeFree)) {
			instance = obj;
			goto l1;
		}
		/* begin objectAfter: */
		if (DoAssertionChecks) {
			if ((((usqInt) obj)) >= (((usqInt) GIV(endOfMemory)))) {
				error("no objects after the end of memory");
			}
		}
		if (((longAt(obj)) & TypeMask) == HeaderTypeFree) {
			sz = (longAt(obj)) & AllButTypeMask;
		}
		else {
			/* begin sizeBitsOf: */
			header = longAt(obj);
			sz = ((header & TypeMask) == HeaderTypeSizeAndClass
				? (longAt(obj - (BytesPerWord * 2))) & LongSizeMask
				: header & SizeMask);
		}
		obj = (obj + sz) + (headerTypeBytes[(longAt(obj + sz)) & TypeMask]);
	}
	instance = null;
l1:	/* end accessibleObjectAfter: */;
	if (instance == null) {
		/* begin pop:thenPushInteger: */
		longAtput(sp = GIV(stackPointer) + (((GIV(argumentCount) + 1) - 1) * BytesPerWord), ((0 << 1) | 1));
		GIV(stackPointer) = sp;
	}
	else {
		/* begin pop:thenPush: */
		longAtput(sp1 = GIV(stackPointer) + (((GIV(argumentCount) + 1) - 1) * BytesPerWord), instance);
		GIV(stackPointer) = sp1;
	}
}

static void
primitiveNoAtCacheAt(void)
{
	noAtCacheCommonAt(0);
}

static void
primitiveNoAtCacheAtPut(void)
{
	noAtCacheCommonAtPut(0);
}

static void
primitiveNoAtCacheStringAt(void)
{
	noAtCacheCommonAt(1);
}

static void
primitiveNoAtCacheStringAtPut(void)
{
	noAtCacheCommonAtPut(1);
}


/*	A placeholder for primitives that haven't been implemented or are being
	withdrawn gradually. Just absorbs any arguments and returns the receiver.
 */

static void
primitiveNoop(void)
{   DECL_MAYBE_SQ_GLOBAL_STRUCT
	/* begin pop: */
	GIV(stackPointer) += GIV(argumentCount) * BytesPerWord;
}

static void
primitiveNotEqual(void)
{   DECL_MAYBE_SQ_GLOBAL_STRUCT
    sqInt integerArgument;
    sqInt integerReceiver;
    sqInt object;
    sqInt result;
    char *sp;
    sqInt top;
    sqInt top1;

	/* begin popStack */
	top = longAt(GIV(stackPointer));
	GIV(stackPointer) += BytesPerWord;
	integerArgument = top;
	/* begin popStack */
	top1 = longAt(GIV(stackPointer));
	GIV(stackPointer) += BytesPerWord;
	integerReceiver = top1;
	result = !(compare31or32Bitsequal(integerReceiver, integerArgument));
	/* begin checkBooleanResult: */
	if (GIV(primFailCode) == 0) {
		/* begin pushBool: */
		/* begin push: */
		object = (result
			? GIV(trueObj)
			: GIV(falseObj));
		longAtput(sp = GIV(stackPointer) - BytesPerWord, object);
		GIV(stackPointer) = sp;
	}
	else {
		/* begin unPop: */
		GIV(stackPointer) -= 2 * BytesPerWord;
	}
}


/*	Primitive comparison operations for large integers in 64 bit range */

EXPORT(void)
primitiveNotEqualLargeIntegers(void)
{   DECL_MAYBE_SQ_GLOBAL_STRUCT
    sqLong integerArg;
    sqLong integerRcvr;
    char *sp;

	integerArg = signed64BitValueOf(longAt(GIV(stackPointer) + (0 * BytesPerWord)));
	integerRcvr = signed64BitValueOf(longAt(GIV(stackPointer) + (1 * BytesPerWord)));
	if (GIV(primFailCode) == 0) {
		/* begin pop:thenPushBool: */
		longAtput(sp = GIV(stackPointer) + ((2 - 1) * BytesPerWord), (integerRcvr != integerArg
			? GIV(trueObj)
			: GIV(falseObj)));
		GIV(stackPointer) = sp;
	}
}


/*	Defined for CompiledMethods only */

static void
primitiveObjectAt(void)
{   DECL_MAYBE_SQ_GLOBAL_STRUCT
    sqInt index;
    sqInt integerPointer;
    sqInt oop;
    sqInt rawHeader;
    sqInt realHeader;
    char *sp;
    sqInt thisReceiver;

	/* begin stackIntegerValue: */
	integerPointer = longAt(GIV(stackPointer) + (0 * BytesPerWord));
	/* begin checkedIntegerValueOf: */
	if ((integerPointer & 1)) {
		index = (integerPointer >> 1);
		goto l1;
	}
	else {
		/* begin primitiveFail */
		if (GIV(primFailCode) == 0) {
			GIV(primFailCode) = 1;
		}
		index = 0;
		goto l1;
	}
l1:	/* end stackIntegerValue: */;
	if (!(GIV(primFailCode) == 0)) {
		GIV(primFailCode) = PrimErrBadArgument; return;
	}
	thisReceiver = longAt(GIV(stackPointer) + (1 * BytesPerWord));
	rawHeader = longAt((thisReceiver + BaseHeaderSize) + (HeaderIndex << ShiftForWord));
	realHeader = (isCogMethodReference(rawHeader)
		? (((CogMethod *) rawHeader)->methodHeader)
		: rawHeader);
	if (!((index > 0)
		 && (index <= (((((usqInt) realHeader) >> 10) & 255) + LiteralStart)))) {
		GIV(primFailCode) = PrimErrBadIndex; return;
	}
	/* begin pop:thenPush: */
	oop = (index == 1
		? realHeader
		: longAt((thisReceiver + BaseHeaderSize) + ((index - 1) << ShiftForWord)));
	longAtput(sp = GIV(stackPointer) + ((2 - 1) * BytesPerWord), oop);
	GIV(stackPointer) = sp;
}


/*	Defined for CompiledMethods only */

static void
primitiveObjectAtPut(void)
{   DECL_MAYBE_SQ_GLOBAL_STRUCT
    sqInt index;
    sqInt integerPointer;
    sqInt newValue;
    sqInt rawHeader;
    sqInt realHeader;
    char *sp;
    sqInt thisReceiver;

	newValue = longAt(GIV(stackPointer) + (0 * BytesPerWord));
	/* begin stackIntegerValue: */
	integerPointer = longAt(GIV(stackPointer) + (1 * BytesPerWord));
	/* begin checkedIntegerValueOf: */
	if ((integerPointer & 1)) {
		index = (integerPointer >> 1);
		goto l1;
	}
	else {
		/* begin primitiveFail */
		if (GIV(primFailCode) == 0) {
			GIV(primFailCode) = 1;
		}
		index = 0;
		goto l1;
	}
l1:	/* end stackIntegerValue: */;
	if (!(GIV(primFailCode) == 0)) {
		GIV(primFailCode) = PrimErrBadArgument; return;
	}
	thisReceiver = longAt(GIV(stackPointer) + (2 * BytesPerWord));
	rawHeader = longAt((thisReceiver + BaseHeaderSize) + (HeaderIndex << ShiftForWord));
	realHeader = (isCogMethodReference(rawHeader)
		? (((CogMethod *) rawHeader)->methodHeader)
		: rawHeader);
	if (!((index > 0)
		 && (index <= (((((usqInt) realHeader) >> 10) & 255) + LiteralStart)))) {
		GIV(primFailCode) = PrimErrBadIndex; return;
	}
	if ((index == 1)
	 && (isCogMethodReference(rawHeader))) {
		(((CogMethod *) rawHeader)->methodHeader = newValue);
	}
	else {
		/* begin storePointer:ofObject:withValue: */
		if ((((usqInt) thisReceiver)) < (((usqInt) GIV(youngStart)))) {
			possibleRootStoreIntovalue(thisReceiver, newValue);
		}
		longAtput((thisReceiver + BaseHeaderSize) + ((index - 1) << ShiftForWord), newValue);
	}
	/* begin pop:thenPush: */
	longAtput(sp = GIV(stackPointer) + ((3 - 1) * BytesPerWord), newValue);
	GIV(stackPointer) = sp;
}


/*	This primitive is assumed to be fast (see e.g.
	MethodDictionary>>includesKey:) so make it so.
	N.B. Written to use literalHeaderOf: so that in Cog subclasses cogged
	methods (whose headers
	point to the machine code method) are still correctly scanned, for the
	header as well as literals. */

static void
primitiveObjectPointsTo(void)
{   DECL_MAYBE_SQ_GLOBAL_STRUCT
    sqInt fmt;
    sqInt header;
    sqInt i;
    sqInt lastField;
    sqInt methodHeader;
    sqInt methodHeader1;
    sqInt rcvr;
    char *sp;
    char *sp1;
    char *sp2;
    char *sp3;
    char *sp4;
    char *sp5;
    sqInt thang;
    sqInt trueOrFalse;

	thang = longAt(GIV(stackPointer));
	rcvr = longAt(GIV(stackPointer) + (1 * BytesPerWord));
	if ((rcvr & 1)) {
		/* begin pop:thenPushBool: */
		longAtput(sp = GIV(stackPointer) + ((2 - 1) * BytesPerWord), (0
			? GIV(trueObj)
			: GIV(falseObj)));
		GIV(stackPointer) = sp;
		return;
	}
	header = longAt(rcvr);
	fmt = (((usqInt) header) >> 8) & 15;
	if (fmt <= 4) {
		if ((fmt == 3)
		 && (((((usqInt) header) >> 12) & 31) == ClassMethodContextCompactIndex)) {
			if (((longAt((rcvr + BaseHeaderSize) + (SenderIndex << ShiftForWord))) & 1)) {
				/* begin externalWriteBackHeadFramePointers */
				assert((GIV(framePointer) - GIV(stackPointer)) < LargeContextSize);
				assert(GIV(stackPage) == (mostRecentlyUsedPage()));
				/* begin setHeadFP:andSP:inPage: */
				assert(GIV(stackPointer) < GIV(framePointer));
				assert((GIV(stackPointer) < ((GIV(stackPage)->baseAddress)))
				 && (GIV(stackPointer) > (((GIV(stackPage)->realStackLimit)) - LargeContextSize)));
				assert((GIV(framePointer) < ((GIV(stackPage)->baseAddress)))
				 && (GIV(framePointer) > (((GIV(stackPage)->realStackLimit)) - (((sqInt) LargeContextSize >> 1)))));
				(GIV(stackPage)->headFP = GIV(framePointer));
				(GIV(stackPage)->headSP = GIV(stackPointer));
				assert(pageListIsWellFormed());
				if ((((longAt((rcvr + BaseHeaderSize) + (SenderIndex << ShiftForWord))) & 1))
				 && (!(isWidowedContext(rcvr)))) {
					/* begin pop:thenPushBool: */
					trueOrFalse = marriedContextpointsTostackDeltaForCurrentFrame(rcvr, thang, 2);
					longAtput(sp1 = GIV(stackPointer) + ((2 - 1) * BytesPerWord), (trueOrFalse
						? GIV(trueObj)
						: GIV(falseObj)));
					GIV(stackPointer) = sp1;
					return;
				}
			}
			lastField = (CtxtTempFrameStart + (fetchStackPointerOf(rcvr))) * BytesPerWord;
		}
		else {
			lastField = (sizeBitsOfSafe(rcvr)) - BaseHeaderSize;
		}
	}
	else {
		if (fmt < 12) {
			/* begin pop:thenPushBool: */
			longAtput(sp2 = GIV(stackPointer) + ((2 - 1) * BytesPerWord), (0
				? GIV(trueObj)
				: GIV(falseObj)));
			GIV(stackPointer) = sp2;
			return;
		}
		/* begin headerOf: */
		methodHeader1 = longAt((rcvr + BaseHeaderSize) + (HeaderIndex << ShiftForWord));
		methodHeader = (isCogMethodReference(methodHeader1)
			? (((CogMethod *) methodHeader1)->methodHeader)
			: methodHeader1);
		if (methodHeader == thang) {
			/* begin pop:thenPushBool: */
			longAtput(sp3 = GIV(stackPointer) + ((2 - 1) * BytesPerWord), (1
				? GIV(trueObj)
				: GIV(falseObj)));
			GIV(stackPointer) = sp3;
			return;
		}
		lastField = (((((usqInt) methodHeader) >> 10) & 255) + 1) * BytesPerWord;
	}
	for (i = BaseHeaderSize; i <= lastField; i += BytesPerWord) {
		if ((longAt(rcvr + i)) == thang) {
			/* begin pop:thenPushBool: */
			longAtput(sp4 = GIV(stackPointer) + ((2 - 1) * BytesPerWord), (1
				? GIV(trueObj)
				: GIV(falseObj)));
			GIV(stackPointer) = sp4;
			return;
		}
	}
	/* begin pop:thenPushBool: */
	longAtput(sp5 = GIV(stackPointer) + ((2 - 1) * BytesPerWord), (0
		? GIV(trueObj)
		: GIV(falseObj)));
	GIV(stackPointer) = sp5;
}


/*	Common routine used by perform:withArgs:, perform:withArgs:inSuperclass:,
	object:perform:withArgs:inClass: et al. Answer nil on success.
	
	NOTE: The case of doesNotUnderstand: is not a failure to perform.
	The only failures are arg types and consistency of argumentCount.
	
	Since we're in the stack VM we can assume there is space to push the
	arguments provided they are within limits (max argument count is 15). We
	can therefore deal
	with the arbitrary amount of state to remove from the stack (lookup class,
	selector, mirror receiver) and arbitrary argument orders by deferring
	popping anything until
	we know whether the send has succeeded. So on failure we merely have to
	remove the actual receiver and arguments pushed, and on success we have to
	slide the actual
	receiver and arguments down to replace the original ones. */

static sqInt
primitiveObjectperformwithArgumentslookedUpIn(sqInt actualReceiver, sqInt selector, sqInt argumentArray, sqInt lookupClass)
{   DECL_MAYBE_SQ_GLOBAL_STRUCT
    sqInt arraySize;
    sqInt delta;
    sqInt header;
    sqInt index;
    sqInt offset;
    sqInt performArgCount;
    char *sp;
    char *sp1;
    char *sp2;
    sqInt sz;
    sqInt top;

	if (!(((argumentArray & 1) == 0)
		 && (((((usqInt) (longAt(argumentArray))) >> 8) & 15) == 2))) {
		return GIV(primFailCode) = PrimErrBadArgument;
	}
	/* begin fetchWordLengthOf: */
	/* begin sizeBitsOf: */
	header = longAt(argumentArray);
	sz = ((header & TypeMask) == HeaderTypeSizeAndClass
		? (longAt(argumentArray - (BytesPerWord * 2))) & LongSizeMask
		: header & SizeMask);
	arraySize = ((usqInt) (sz - BaseHeaderSize)) >> ShiftForWord;
	if (arraySize > (((sqInt) LargeContextSize >> 2))) {
		return GIV(primFailCode) = PrimErrBadNumArgs;
	}

	/* Push newMethod to save it in case of failure,
	 then push the actual receiver and args out of the array. */

	performArgCount = GIV(argumentCount);
	/* begin push: */
	longAtput(sp1 = GIV(stackPointer) - BytesPerWord, GIV(newMethod));
	GIV(stackPointer) = sp1;
	/* begin push: */
	longAtput(sp2 = GIV(stackPointer) - BytesPerWord, actualReceiver);
	GIV(stackPointer) = sp2;
	for (index = 1; index <= arraySize; index += 1) {
		/* begin push: */
		longAtput(sp = GIV(stackPointer) - BytesPerWord, longAt((argumentArray + BaseHeaderSize) + ((index - 1) << ShiftForWord)));
		GIV(stackPointer) = sp;
	}
	GIV(argumentCount) = arraySize;
	GIV(messageSelector) = selector;
	sendBreakpointreceiver(GIV(messageSelector) + BaseHeaderSize, lengthOf(GIV(messageSelector)), actualReceiver);
	findNewMethodInClass(lookupClass);
	if ((((GIV(newMethod) & 1) == 0)
 && (((((usqInt) (longAt(GIV(newMethod)))) >> 8) & 15) >= 12))
	 && ((argumentCountOf(GIV(newMethod))) != GIV(argumentCount))) {
		/* begin pop: */
		GIV(stackPointer) += (arraySize + 1) * BytesPerWord;
		/* begin popStack */
		top = longAt(GIV(stackPointer));
		GIV(stackPointer) += BytesPerWord;
		GIV(newMethod) = ((sqInt) top);
		return GIV(primFailCode) = PrimErrBadNumArgs;
	}

	/* +2 = receiver + saved newMethod */

	delta = BytesPerWord * (performArgCount + 2);
	for (offset = (GIV(argumentCount) * BytesPerWord); offset >= 0; offset += (-BytesPerWord)) {
		longAtput((GIV(stackPointer) + offset) + delta, longAt(GIV(stackPointer) + offset));
	}
	/* begin pop: */
	GIV(stackPointer) += (performArgCount + 2) * BytesPerWord;
	executeNewMethod();
	/* begin initPrimCall */
	GIV(primFailCode) = 0;
	return null;
}


/*	Return the value of the millisecond clock as an integer, using the old
	method prior to the 64-bit microsecond clock.
 */

EXPORT(sqInt)
primitiveOriginalMillisecondClock(void)
{   DECL_MAYBE_SQ_GLOBAL_STRUCT
    sqInt oop;
    char *sp;

	/* begin pop:thenPush: */
	oop = ((((ioOldMSecs()) & MillisecondClockMask) << 1) | 1);
	longAtput(sp = GIV(stackPointer) + ((1 - 1) * BytesPerWord), oop);
	GIV(stackPointer) = sp;
}

static void
primitivePerform(void)
{   DECL_MAYBE_SQ_GLOBAL_STRUCT
    sqInt ccIndex;
    sqInt i;
    sqInt lookupClass;
    sqInt newReceiver;
    sqInt performMethod;
    sqInt performSelector;

	performSelector = GIV(messageSelector);
	performMethod = GIV(newMethod);
	GIV(messageSelector) = longAt(GIV(stackPointer) + ((GIV(argumentCount) - 1) * BytesPerWord));

	/* NOTE: the following lookup may fail and be converted to #doesNotUnderstand:,
	 so we must adjust argumentCount and slide args now, so that will work. */
	/* Slide arguments down over selector */

	newReceiver = longAt(GIV(stackPointer) + (GIV(argumentCount) * BytesPerWord));
	GIV(argumentCount) -= 1;
	for (i = GIV(argumentCount); i >= 1; i += -1) {
		longAtput(GIV(stackPointer) + (i * BytesPerWord), longAt(GIV(stackPointer) + ((i - 1) * BytesPerWord)));
	}
	/* begin pop: */
	GIV(stackPointer) += 1 * BytesPerWord;
	/* begin fetchClassOf: */
	if ((newReceiver & 1)) {
		lookupClass = longAt((GIV(specialObjectsOop) + BaseHeaderSize) + (ClassInteger << ShiftForWord));
		goto l1;
	}
	if (((ccIndex = (((usqInt) (longAt(newReceiver))) >> 12) & 31)) == 0) {
		lookupClass = (longAt(newReceiver - BaseHeaderSize)) & AllButTypeMask;
		goto l1;
	}
	else {
		lookupClass = longAt(((longAt((GIV(specialObjectsOop) + BaseHeaderSize) + (CompactClasses << ShiftForWord))) + BaseHeaderSize) + ((ccIndex - 1) << ShiftForWord));
		goto l1;
	}
l1:	/* end fetchClassOf: */;
	sendBreakpointreceiver(GIV(messageSelector) + BaseHeaderSize, lengthOf(GIV(messageSelector)), newReceiver);
	findNewMethodInClass(lookupClass);
	if (!((((GIV(newMethod) & 1) == 0)
 && (((((usqInt) (longAt(GIV(newMethod)))) >> 8) & 15) >= 12))
		 && ((argumentCountOf(GIV(newMethod))) == GIV(argumentCount)))) {
		/* begin unPop: */
		GIV(stackPointer) -= 1 * BytesPerWord;
		for (i = 1; i <= GIV(argumentCount); i += 1) {
			longAtput(GIV(stackPointer) + ((i - 1) * BytesPerWord), longAt(GIV(stackPointer) + (i * BytesPerWord)));
		}
		longAtput(GIV(stackPointer) + (GIV(argumentCount) * BytesPerWord), GIV(messageSelector));
		GIV(argumentCount) += 1;
		GIV(newMethod) = performMethod;
		GIV(messageSelector) = performSelector;
		/* begin primitiveFail */
		if (GIV(primFailCode) == 0) {
			GIV(primFailCode) = 1;
		}
		return;
	}
	executeNewMethod();
	/* begin initPrimCall */
	GIV(primFailCode) = 0;
}

static void
primitivePerformInSuperclass(void)
{   DECL_MAYBE_SQ_GLOBAL_STRUCT
    sqInt ccIndex;
    sqInt currentClass;
    sqInt lookupClass;
    sqInt rcvr;

	lookupClass = longAt(GIV(stackPointer));
	rcvr = longAt(GIV(stackPointer) + (3 * BytesPerWord));
	/* begin fetchClassOf: */
	if ((rcvr & 1)) {
		currentClass = longAt((GIV(specialObjectsOop) + BaseHeaderSize) + (ClassInteger << ShiftForWord));
		goto l1;
	}
	if (((ccIndex = (((usqInt) (longAt(rcvr))) >> 12) & 31)) == 0) {
		currentClass = (longAt(rcvr - BaseHeaderSize)) & AllButTypeMask;
		goto l1;
	}
	else {
		currentClass = longAt(((longAt((GIV(specialObjectsOop) + BaseHeaderSize) + (CompactClasses << ShiftForWord))) + BaseHeaderSize) + ((ccIndex - 1) << ShiftForWord));
		goto l1;
	}
l1:	/* end fetchClassOf: */;
	while (currentClass != lookupClass) {
		currentClass = longAt((currentClass + BaseHeaderSize) + (SuperclassIndex << ShiftForWord));
		if (currentClass == GIV(nilObj)) {
			GIV(primFailCode) = PrimErrBadArgument; return;
		}
	}
	primitiveObjectperformwithArgumentslookedUpIn(rcvr, longAt(GIV(stackPointer) + (2 * BytesPerWord)), longAt(GIV(stackPointer) + (1 * BytesPerWord)), lookupClass);
}

static void
primitivePerformWithArgs(void)
{   DECL_MAYBE_SQ_GLOBAL_STRUCT
    sqInt ccIndex;
    sqInt lookupClass;
    sqInt rcvr;

	rcvr = longAt(GIV(stackPointer) + (2 * BytesPerWord));
	/* begin fetchClassOf: */
	if ((rcvr & 1)) {
		lookupClass = longAt((GIV(specialObjectsOop) + BaseHeaderSize) + (ClassInteger << ShiftForWord));
		goto l1;
	}
	if (((ccIndex = (((usqInt) (longAt(rcvr))) >> 12) & 31)) == 0) {
		lookupClass = (longAt(rcvr - BaseHeaderSize)) & AllButTypeMask;
		goto l1;
	}
	else {
		lookupClass = longAt(((longAt((GIV(specialObjectsOop) + BaseHeaderSize) + (CompactClasses << ShiftForWord))) + BaseHeaderSize) + ((ccIndex - 1) << ShiftForWord));
		goto l1;
	}
l1:	/* end fetchClassOf: */;
	primitiveObjectperformwithArgumentslookedUpIn(rcvr, longAt(GIV(stackPointer) + (1 * BytesPerWord)), longAt(GIV(stackPointer)), lookupClass);
}


/*	Primitive. Answer the last primitive method sampled by the profiler. */

EXPORT(sqInt)
primitiveProfilePrimitive(void)
{   DECL_MAYBE_SQ_GLOBAL_STRUCT
    char *sp;

	if (!(GIV(argumentCount) == 0)) {
		/* begin primitiveFail */
		if (GIV(primFailCode) == 0) {
			GIV(primFailCode) = 1;
		}
		return null;
	}
	/* begin pop:thenPush: */
	longAtput(sp = GIV(stackPointer) + ((1 - 1) * BytesPerWord), GIV(profileMethod));
	GIV(stackPointer) = sp;
	GIV(profileMethod) = GIV(nilObj);
}


/*	Primitive. Answer the last sample taken by the profiler, or nil if the
	profiler isn't active.
	See also primitiveProfileStart.
 */

EXPORT(sqInt)
primitiveProfileSample(void)
{   DECL_MAYBE_SQ_GLOBAL_STRUCT
    char *sp;

	if (!(GIV(argumentCount) == 0)) {
		/* begin primitiveFail */
		if (GIV(primFailCode) == 0) {
			GIV(primFailCode) = 1;
		}
		return null;
	}
	/* begin pop:thenPush: */
	longAtput(sp = GIV(stackPointer) + ((1 - 1) * BytesPerWord), GIV(profileProcess));
	GIV(stackPointer) = sp;
	GIV(profileProcess) = GIV(nilObj);
}


/*	Primitive. Install the semaphore to be used for profiling, 
	or nil if no semaphore should be used.
	See also primitiveProfileStart. */

EXPORT(void)
primitiveProfileSemaphore(void)
{   DECL_MAYBE_SQ_GLOBAL_STRUCT
    sqInt activeContext;
    sqInt activeContext1;
    sqInt aMethodObj;
    sqInt decodedIP;
    sqInt flushState;
    sqInt header;
    StackPage *newPage;
    sqInt oop;
    sqInt sema;
    char *sp;
    sqInt sz;
    char *theFP;
    sqInt top;

	sema = longAt(GIV(stackPointer) + (0 * BytesPerWord));
	if (((sema & 1))
	 || (GIV(argumentCount) != 1)) {
		/* begin primitiveFail */
		if (GIV(primFailCode) == 0) {
			GIV(primFailCode) = 1;
		}
		return;
	}
	if (sema == GIV(nilObj)) {
		flushState = GIV(profileSemaphore) != GIV(nilObj);
	}
	else {
		flushState = GIV(profileSemaphore) == GIV(nilObj);
		if (!((fetchClassOfNonInt(sema)) == (longAt((GIV(specialObjectsOop) + BaseHeaderSize) + (ClassSemaphore << ShiftForWord))))) {
			/* begin primitiveFail */
			if (GIV(primFailCode) == 0) {
				GIV(primFailCode) = 1;
			}
			return;
		}
	}

	/* If we've switched profiling on or off we must void machine code
	 (and machine code pcs in contexts) since we will start or stop
	 testing the profile clock in machine code primitive invocations,
	 and so generate slightly different code from here on in. */

	GIV(profileSemaphore) = sema;
	if (flushState) {
		/* begin push: */
		longAtput(sp = GIV(stackPointer) - BytesPerWord, GIV(instructionPointer));
		GIV(stackPointer) = sp;
		/* begin voidVMStateForSnapshot */

		/* in case of code compactions. */

		GIV(instructionPointer) = 0;
		activeContext1 = divorceAllFrames();
		/* begin ensureAllContextsHaveBytecodePCsOrAreBereaved */
		VM_LABEL(1ensureAllContextsHaveBytecodePCsOrAreBereaved);
		oop = heapBase + (headerTypeBytes[(longAt(heapBase)) & TypeMask]);
		while (oop < GIV(freeStart)) {
			if ((!(((longAt(oop)) & TypeMask) == HeaderTypeFree))
			 && (((((usqInt) (longAt(oop))) >> 12) & 31) == ClassMethodContextCompactIndex)) {
				if (((longAt((oop + BaseHeaderSize) + (SenderIndex << ShiftForWord))) & 1)) {
					/* begin markContextAsDead: */
					assert(isContext(oop));
					longAtput((oop + BaseHeaderSize) + (SenderIndex << ShiftForWord), GIV(nilObj));
					longAtput((oop + BaseHeaderSize) + (InstructionPointerIndex << ShiftForWord), GIV(nilObj));
				}
				else {
					decodedIP = longAt((oop + BaseHeaderSize) + (InstructionPointerIndex << ShiftForWord));
					if (((decodedIP & 1))
					 && ((((sqInt) decodedIP)) < 0)) {
						decodedIP = mustMapMachineCodePCcontext((decodedIP >> 1), oop);
						longAtput((oop + BaseHeaderSize) + (InstructionPointerIndex << ShiftForWord), decodedIP);
					}
				}
			}
			/* begin objectAfter: */
			if (DoAssertionChecks) {
				if ((((usqInt) oop)) >= (((usqInt) GIV(endOfMemory)))) {
					error("no objects after the end of memory");
				}
			}
			if (((longAt(oop)) & TypeMask) == HeaderTypeFree) {
				sz = (longAt(oop)) & AllButTypeMask;
			}
			else {
				/* begin sizeBitsOf: */
				header = longAt(oop);
				sz = ((header & TypeMask) == HeaderTypeSizeAndClass
					? (longAt(oop - (BytesPerWord * 2))) & LongSizeMask
					: header & SizeMask);
			}
			oop = (oop + sz) + (headerTypeBytes[(longAt(oop + sz)) & TypeMask]);
		}
		voidCogCompiledCode();
		activeContext = activeContext1;
		/* begin marryContextInNewStackPageAndInitializeInterpreterRegisters: */
		VM_LABEL(3marryContextInNewStackPageAndInitializeInterpreterRegisters);
		assert(GIV(stackPage) == 0);
		newPage = makeBaseFrameFor(activeContext);
		/* begin setStackPageAndLimit: */
		GIV(stackPage) = newPage;
		if (GIV(stackLimit) != (((char *) (((usqInt) -1))))) {
			GIV(stackLimit) = (GIV(stackPage)->stackLimit);
		}
		markStackPageMostRecentlyUsed(newPage);
		GIV(framePointer) = (GIV(stackPage)->headFP);
		GIV(stackPointer) = (GIV(stackPage)->headSP);
		/* begin setMethod: */
		/* begin iframeMethod: */
		theFP = (GIV(stackPage)->headFP);
		aMethodObj = longAt(theFP + FoxMethod);
		assert((((usqInt)aMethodObj)) >= (startOfMemory()));
		GIV(method) = aMethodObj;
		/* begin popStack */
		top = longAt(GIV(stackPointer));
		GIV(stackPointer) += BytesPerWord;
		GIV(instructionPointer) = ((sqInt) top);
		assert((((stackValue(0)) == (nilObject()))
 && (GIV(profileSemaphore) == (nilObject())))
		 || (((stackValue(0)) == GIV(profileSemaphore))
 && ((fetchClassOfNonInt(sema)) == (splObj(ClassSemaphore)))));
	}
	GIV(profileProcess) = GIV(profileMethod) = GIV(nilObj);
	/* begin pop: */
	GIV(stackPointer) += 1 * BytesPerWord;
	if (flushState) {
		siglongjmp(reenterInterpreter, ReturnToInterpreter);
	}
}


/*	Primitive. Begin profiling execution every by using the interrupt
	check-counter instead of a time-based process (which is limited to timing
	resolution and triggers off the same signal that many of the processes
	being profiled trigger off leading to consistently wrong results).
	The argument is the number of interrupt checks (method activations) to let
	go by before taking a sample. The sample is being stored in the
	profileSample iVar which can be retrieved by executing
	primitiveProfileSample. When a sample is taken, it signals the semaphore
	specified in primitiveProfileSemaphore.
	If the argument is less or equal to zero, it disables profiling.
 */

EXPORT(sqInt)
primitiveProfileStart(void)
{   DECL_MAYBE_SQ_GLOBAL_STRUCT
    sqInt deltaTicks;
    sqInt integerPointer;

	if (!(GIV(argumentCount) == 1)) {
		/* begin success: */
		if (!(0)) {
			if (GIV(primFailCode) == 0) {

				/* Don't overwrite an error code that has already been set. */

				GIV(primFailCode) = 1;
			}
		}
		return null;
	}
	/* begin stackIntegerValue: */
	integerPointer = longAt(GIV(stackPointer) + (0 * BytesPerWord));
	/* begin checkedIntegerValueOf: */
	if ((integerPointer & 1)) {
		deltaTicks = (integerPointer >> 1);
		goto l1;
	}
	else {
		/* begin primitiveFail */
		if (GIV(primFailCode) == 0) {
			GIV(primFailCode) = 1;
		}
		deltaTicks = 0;
		goto l1;
	}
l1:	/* end stackIntegerValue: */;
	if (GIV(primFailCode) == 0) {
		GIV(nextProfileTick) = (ioHighResClock()) + deltaTicks;
		/* begin pop: */
		GIV(stackPointer) += 1 * BytesPerWord;
	}
}


/*	Answer any special requirements of the given primitive */

sqInt
primitivePropertyFlags(sqInt primIndex)
{   DECL_MAYBE_SQ_GLOBAL_STRUCT
    sqInt baseFlags;
    void (*functionPointer)(void);

	/* begin functionPointerFor:inClass: */
	functionPointer = ((void (*)(void)) ((primIndex > MaxPrimitiveIndex
	? 0
	: primitiveTable[primIndex])));
	baseFlags = (GIV(profileSemaphore) != GIV(nilObj)
		? PrimCallNeedsNewMethod + PrimCallCollectsProfileSamples
		: 0);
	if (GIV(longRunningPrimitiveCheckSemaphore) != null) {
		baseFlags = baseFlags | PrimCallNeedsNewMethod;
	}
	if ((functionPointer == (primitiveExternalCall))
	 || (functionPointer == (primitiveCalloutToFFI))) {

		/* For callbacks */

		baseFlags = baseFlags | ((PrimCallNeedsNewMethod + PrimCallNeedsPrimitiveFunction) + PrimCallMayCallBack);
	}
	return baseFlags;
}

static void
primitiveQuit(void)
{   DECL_MAYBE_SQ_GLOBAL_STRUCT
	ioExitWithErrorCode((GIV(argumentCount) == 1
		? ((longAt(GIV(stackPointer))) >> 1)
		: 0));
}


/*	Rounds negative results towards zero. */

static void
primitiveQuo(void)
{   DECL_MAYBE_SQ_GLOBAL_STRUCT
    sqInt integerArg;
    sqInt integerPointer;
    sqInt integerPointer1;
    sqInt integerRcvr;
    sqInt integerResult;
    char *sp;

	/* begin stackIntegerValue: */
	integerPointer = longAt(GIV(stackPointer) + (1 * BytesPerWord));
	/* begin checkedIntegerValueOf: */
	if ((integerPointer & 1)) {
		integerRcvr = (integerPointer >> 1);
		goto l1;
	}
	else {
		/* begin primitiveFail */
		if (GIV(primFailCode) == 0) {
			GIV(primFailCode) = 1;
		}
		integerRcvr = 0;
		goto l1;
	}
l1:	/* end stackIntegerValue: */;
	/* begin stackIntegerValue: */
	integerPointer1 = longAt(GIV(stackPointer) + (0 * BytesPerWord));
	/* begin checkedIntegerValueOf: */
	if ((integerPointer1 & 1)) {
		integerArg = (integerPointer1 >> 1);
		goto l2;
	}
	else {
		/* begin primitiveFail */
		if (GIV(primFailCode) == 0) {
			GIV(primFailCode) = 1;
		}
		integerArg = 0;
		goto l2;
	}
l2:	/* end stackIntegerValue: */;
	/* begin success: */
	if (!(integerArg != 0)) {
		if (GIV(primFailCode) == 0) {

			/* Don't overwrite an error code that has already been set. */

			GIV(primFailCode) = 1;
		}
	}
	if (GIV(primFailCode) == 0) {
		if (integerRcvr > 0) {
			if (integerArg > 0) {
				integerResult = integerRcvr / integerArg;
			}
			else {
				integerResult = 0 - (integerRcvr / (0 - integerArg));
			}
		}
		else {
			if (integerArg > 0) {
				integerResult = 0 - ((0 - integerRcvr) / integerArg);
			}
			else {
				integerResult = (0 - integerRcvr) / (0 - integerArg);
			}
		}
	}
	/* begin pop2AndPushIntegerIfOK: */
	if (GIV(primFailCode) == 0) {
		if ((integerResult ^ (integerResult << 1)) >= 0) {
			/* begin pop:thenPush: */
			longAtput(sp = GIV(stackPointer) + ((2 - 1) * BytesPerWord), ((integerResult << 1) | 1));
			GIV(stackPointer) = sp;
		}
		else {
			/* begin success: */
			if (!(0)) {
				if (GIV(primFailCode) == 0) {

					/* Don't overwrite an error code that has already been set. */

					GIV(primFailCode) = 1;
				}
			}
		}
	}
}


/*	Primitive arithmetic operations for large integers in 64 bit range */

EXPORT(void)
primitiveQuoLargeIntegers(void)
{   DECL_MAYBE_SQ_GLOBAL_STRUCT
    sqLong integerArg;
    sqLong integerRcvr;
    sqInt oopResult;
    sqLong result;
    char *sp;

	integerArg = signed64BitValueOf(longAt(GIV(stackPointer) + (0 * BytesPerWord)));
	integerRcvr = signed64BitValueOf(longAt(GIV(stackPointer) + (1 * BytesPerWord)));
	if (integerArg == 0) {
		/* begin primitiveFail */
		if (GIV(primFailCode) == 0) {
			GIV(primFailCode) = 1;
		}
	}
	if (!(GIV(primFailCode) == 0)) {
		return;
	}
	if (integerRcvr > 0) {
		if (integerArg > 0) {
			result = integerRcvr / integerArg;
		}
		else {
			result = 0 - (integerRcvr / (0 - integerArg));
		}
	}
	else {
		if (integerArg > 0) {
			result = 0 - ((0 - integerRcvr) / integerArg);
		}
		else {
			result = (0 - integerRcvr) / (0 - integerArg);
		}
	}
	oopResult = signed64BitIntegerFor(result);
	if (GIV(primFailCode) == 0) {
		/* begin pop:thenPush: */
		longAtput(sp = GIV(stackPointer) + ((2 - 1) * BytesPerWord), oopResult);
		GIV(stackPointer) = sp;
	}
}


/*	Relinquish the processor for up to the given number of microseconds. The
	exact behavior of this primitive is platform dependent.
 */

static void
primitiveRelinquishProcessor(void)
{   DECL_MAYBE_SQ_GLOBAL_STRUCT
    sqInt integerPointer;
    sqInt microSecs;

	/* begin stackIntegerValue: */
	integerPointer = longAt(GIV(stackPointer) + (0 * BytesPerWord));
	/* begin checkedIntegerValueOf: */
	if ((integerPointer & 1)) {
		microSecs = (integerPointer >> 1);
		goto l1;
	}
	else {
		/* begin primitiveFail */
		if (GIV(primFailCode) == 0) {
			GIV(primFailCode) = 1;
		}
		microSecs = 0;
		goto l1;
	}
l1:	/* end stackIntegerValue: */;
	if (GIV(primFailCode) == 0) {
		if (GIV(nextProfileTick) == 0) {
			ioRelinquishProcessorForMicroseconds(microSecs);
		}
		/* begin pop: */
		GIV(stackPointer) += 1 * BytesPerWord;
	}
}


/*	Put this process on the scheduler's lists thus allowing it to proceed next
	time there is
	a chance for processes of it's priority level. It must go to the back of
	its run queue so
	as not to preempt any already running processes at this level. If the
	process's priority
	is higher than the current process, preempt the current process. */

static void
primitiveResume(void)
{   DECL_MAYBE_SQ_GLOBAL_STRUCT
    sqInt inInterpreter;
    sqInt proc;


	/* rcvr */

	proc = longAt(GIV(stackPointer));
	if (!((((longAt((proc + BaseHeaderSize) + (SuspendedContextIndex << ShiftForWord))) & 1) == 0)
		 && (((((usqInt) (longAt(longAt((proc + BaseHeaderSize) + (SuspendedContextIndex << ShiftForWord))))) >> 12) & 31) == ClassMethodContextCompactIndex))) {
		/* begin primitiveFail */
		if (GIV(primFailCode) == 0) {
			GIV(primFailCode) = 1;
		}
		return;
	}
	inInterpreter = GIV(instructionPointer) >= heapBase;
	if (resumepreemptedYieldingIffrom(proc, GIV(preemptionYields), CSResume)) {
		/* begin forProcessPrimitiveReturnToExecutivePostContextSwitch: */
		if (GIV(nextProfileTick) > 0) {
			checkProfileTick(GIV(newMethod));
		}
		returnToExecutivepostContextSwitch(inInterpreter, 1);
	}
}


/*	Primitive. Answer a copy (snapshot) element of the root table.
	The primitive can cause GC itself and if so the return value may
	be inaccurate - in this case one should guard the read operation
	by looking at the gc counter statistics. */

EXPORT(sqInt)
primitiveRootTable(void)
{   DECL_MAYBE_SQ_GLOBAL_STRUCT
    sqInt i;
    sqInt oop;
    char *sp;
    sqInt sz;

	sz = GIV(rootTableCount);

	/* can cause GC */

	oop = instantiateClassindexableSize(longAt((GIV(specialObjectsOop) + BaseHeaderSize) + (ClassArray << ShiftForWord)), sz);
	if (sz > GIV(rootTableCount)) {
		sz = GIV(rootTableCount);
	}
	for (i = 1; i <= sz; i += 1) {
		/* begin storePointer:ofObject:withValue: */
		if ((((usqInt) oop)) < (((usqInt) GIV(youngStart)))) {
			possibleRootStoreIntovalue(oop, GIV(rootTable)[i]);
		}
		longAtput((oop + BaseHeaderSize) + ((i - 1) << ShiftForWord), GIV(rootTable)[i]);
	}
	/* begin pop: */
	GIV(stackPointer) += (GIV(argumentCount) + 1) * BytesPerWord;
	/* begin push: */
	longAtput(sp = GIV(stackPointer) - BytesPerWord, oop);
	GIV(stackPointer) = sp;
}


/*	Primitive. Answer the nth element of the root table.
	This primitive avoids the creation of an extra array;
	it is intended for enumerations of the form:
	index := 1.
	[root := Smalltalk rootTableAt: index.
	root == nil] whileFalse:[index := index + 1].
	 */

EXPORT(sqInt)
primitiveRootTableAt(void)
{   DECL_MAYBE_SQ_GLOBAL_STRUCT
    sqInt index;
    sqInt integerPointer;
    char *sp;
    sqInt successBoolean;

	/* begin stackIntegerValue: */
	integerPointer = longAt(GIV(stackPointer) + (0 * BytesPerWord));
	/* begin checkedIntegerValueOf: */
	if ((integerPointer & 1)) {
		index = (integerPointer >> 1);
		goto l1;
	}
	else {
		/* begin primitiveFail */
		if (GIV(primFailCode) == 0) {
			GIV(primFailCode) = 1;
		}
		index = 0;
		goto l1;
	}
l1:	/* end stackIntegerValue: */;
	/* begin success: */
	successBoolean = (index > 0)
	 && (index <= GIV(rootTableCount));
	if (!(successBoolean)) {
		if (GIV(primFailCode) == 0) {

			/* Don't overwrite an error code that has already been set. */

			GIV(primFailCode) = 1;
		}
	}
	if (GIV(primFailCode) == 0) {
		/* begin pop: */
		GIV(stackPointer) += (GIV(argumentCount) + 1) * BytesPerWord;
		/* begin push: */
		longAtput(sp = GIV(stackPointer) - BytesPerWord, GIV(rootTable)[index]);
		GIV(stackPointer) = sp;
	}
}


/*	The character scanner primitive. */

static void
primitiveScanCharacters(void)
{   DECL_MAYBE_SQ_GLOBAL_STRUCT
    sqInt ascii;
    sqInt glyphIndex;
    sqInt integerPointer;
    sqInt integerPointer1;
    sqInt integerPointer2;
    sqInt integerPointer3;
    sqInt kernDelta;
    sqInt maxGlyph;
    sqInt nextDestX;
    sqInt nilOop;
    sqInt oop;
    sqInt oop1;
    sqInt oop2;
    sqInt rcvr;
    sqInt scanDestX;
    sqInt scanLastIndex;
    sqInt scanMap;
    sqInt scanRightX;
    sqInt scanStartIndex;
    sqInt scanStopIndex;
    sqInt scanXTable;
    sqInt sourceString;
    sqInt sourceX;
    sqInt sourceX2;
    char *sp;
    char *sp1;
    char *sp2;
    sqInt stopReason;
    sqInt stops;

	if (!(GIV(argumentCount) == 6)) {
		/* begin primitiveFail */
		if (GIV(primFailCode) == 0) {
			GIV(primFailCode) = 1;
		}
		return;
	}
	/* begin stackIntegerValue: */
	integerPointer = longAt(GIV(stackPointer) + (0 * BytesPerWord));
	/* begin checkedIntegerValueOf: */
	if ((integerPointer & 1)) {
		kernDelta = (integerPointer >> 1);
		goto l4;
	}
	else {
		/* begin primitiveFail */
		if (GIV(primFailCode) == 0) {
			GIV(primFailCode) = 1;
		}
		kernDelta = 0;
		goto l4;
	}
l4:	/* end stackIntegerValue: */;
	/* begin stackObjectValue: */
	oop = longAt(GIV(stackPointer) + (1 * BytesPerWord));
	if ((oop & 1)) {
		/* begin primitiveFail */
		if (GIV(primFailCode) == 0) {
			GIV(primFailCode) = 1;
		}
		stops = null;
		goto l1;
	}
	stops = oop;
l1:	/* end stackObjectValue: */;
	if (!(((stops & 1) == 0)
		 && (((((usqInt) (longAt(stops))) >> 8) & 15) == 2))) {
		/* begin primitiveFail */
		if (GIV(primFailCode) == 0) {
			GIV(primFailCode) = 1;
		}
		return;
	}
	if (!((slotSizeOf(stops)) >= 258)) {
		/* begin primitiveFail */
		if (GIV(primFailCode) == 0) {
			GIV(primFailCode) = 1;
		}
		return;
	}
	/* begin stackIntegerValue: */
	integerPointer1 = longAt(GIV(stackPointer) + (2 * BytesPerWord));
	/* begin checkedIntegerValueOf: */
	if ((integerPointer1 & 1)) {
		scanRightX = (integerPointer1 >> 1);
		goto l5;
	}
	else {
		/* begin primitiveFail */
		if (GIV(primFailCode) == 0) {
			GIV(primFailCode) = 1;
		}
		scanRightX = 0;
		goto l5;
	}
l5:	/* end stackIntegerValue: */;
	/* begin stackObjectValue: */
	oop1 = longAt(GIV(stackPointer) + (3 * BytesPerWord));
	if ((oop1 & 1)) {
		/* begin primitiveFail */
		if (GIV(primFailCode) == 0) {
			GIV(primFailCode) = 1;
		}
		sourceString = null;
		goto l2;
	}
	sourceString = oop1;
l2:	/* end stackObjectValue: */;
	if (!(((sourceString & 1) == 0)
		 && (((((usqInt) (longAt(sourceString))) >> 8) & 15) >= 8))) {
		/* begin primitiveFail */
		if (GIV(primFailCode) == 0) {
			GIV(primFailCode) = 1;
		}
		return;
	}
	/* begin stackIntegerValue: */
	integerPointer2 = longAt(GIV(stackPointer) + (4 * BytesPerWord));
	/* begin checkedIntegerValueOf: */
	if ((integerPointer2 & 1)) {
		scanStopIndex = (integerPointer2 >> 1);
		goto l6;
	}
	else {
		/* begin primitiveFail */
		if (GIV(primFailCode) == 0) {
			GIV(primFailCode) = 1;
		}
		scanStopIndex = 0;
		goto l6;
	}
l6:	/* end stackIntegerValue: */;
	/* begin stackIntegerValue: */
	integerPointer3 = longAt(GIV(stackPointer) + (5 * BytesPerWord));
	/* begin checkedIntegerValueOf: */
	if ((integerPointer3 & 1)) {
		scanStartIndex = (integerPointer3 >> 1);
		goto l7;
	}
	else {
		/* begin primitiveFail */
		if (GIV(primFailCode) == 0) {
			GIV(primFailCode) = 1;
		}
		scanStartIndex = 0;
		goto l7;
	}
l7:	/* end stackIntegerValue: */;
	if (!((scanStartIndex > 0)
		 && ((scanStopIndex > 0)
 && (scanStopIndex <= (byteSizeOf(sourceString)))))) {
		/* begin primitiveFail */
		if (GIV(primFailCode) == 0) {
			GIV(primFailCode) = 1;
		}
		return;
	}
	/* begin stackObjectValue: */
	oop2 = longAt(GIV(stackPointer) + (6 * BytesPerWord));
	if ((oop2 & 1)) {
		/* begin primitiveFail */
		if (GIV(primFailCode) == 0) {
			GIV(primFailCode) = 1;
		}
		rcvr = null;
		goto l3;
	}
	rcvr = oop2;
l3:	/* end stackObjectValue: */;
	if (!((((rcvr & 1) == 0)
 && (((((usqInt) (longAt(rcvr))) >> 8) & 15) <= 4))
		 && ((slotSizeOf(rcvr)) >= 4))) {
		/* begin primitiveFail */
		if (GIV(primFailCode) == 0) {
			GIV(primFailCode) = 1;
		}
		return;
	}
	scanDestX = fetchIntegerofObject(0, rcvr);
	scanLastIndex = fetchIntegerofObject(1, rcvr);
	scanXTable = longAt((rcvr + BaseHeaderSize) + (2 << ShiftForWord));
	scanMap = longAt((rcvr + BaseHeaderSize) + (3 << ShiftForWord));
	if (!((((scanXTable & 1) == 0)
 && (((((usqInt) (longAt(scanXTable))) >> 8) & 15) == 2))
		 && (((scanMap & 1) == 0)
 && (((((usqInt) (longAt(scanMap))) >> 8) & 15) == 2)))) {
		/* begin primitiveFail */
		if (GIV(primFailCode) == 0) {
			GIV(primFailCode) = 1;
		}
		return;
	}
	if (!((slotSizeOf(scanMap)) == 256)) {
		/* begin primitiveFail */
		if (GIV(primFailCode) == 0) {
			GIV(primFailCode) = 1;
		}
		return;
	}
	if (!(GIV(primFailCode) == 0)) {
		return;
	}

	/* Okay, here we go. We have eliminated nearly all failure 
	conditions, to optimize the inner fetches. */

	maxGlyph = (slotSizeOf(scanXTable)) - 2;
	scanLastIndex = scanStartIndex;
	nilOop = GIV(nilObj);
	while (scanLastIndex <= scanStopIndex) {

		/* Known to be okay since scanStartIndex > 0 and scanStopIndex <= sourceString size */
		/* Known to be okay since stops size >= 258 */

		ascii = byteAt((sourceString + BaseHeaderSize) + (scanLastIndex - 1));
		if (!(((stopReason = longAt((stops + BaseHeaderSize) + (ascii << ShiftForWord)))) == nilOop)) {
			if (!((scanDestX ^ (scanDestX << 1)) >= 0)) {
				/* begin primitiveFail */
				if (GIV(primFailCode) == 0) {
					GIV(primFailCode) = 1;
				}
				return;
			}
			/* begin storeInteger:ofObject:withValue: */
			if ((scanDestX ^ (scanDestX << 1)) >= 0) {
				longAtput((rcvr + BaseHeaderSize) + (0 << ShiftForWord), ((scanDestX << 1) | 1));
			}
			else {
				/* begin primitiveFail */
				if (GIV(primFailCode) == 0) {
					GIV(primFailCode) = 1;
				}
			}
			/* begin storeInteger:ofObject:withValue: */
			if ((scanLastIndex ^ (scanLastIndex << 1)) >= 0) {
				longAtput((rcvr + BaseHeaderSize) + (1 << ShiftForWord), ((scanLastIndex << 1) | 1));
			}
			else {
				/* begin primitiveFail */
				if (GIV(primFailCode) == 0) {
					GIV(primFailCode) = 1;
				}
			}
			/* begin pop: */
			GIV(stackPointer) += 7 * BytesPerWord;
			/* begin push: */
			longAtput(sp = GIV(stackPointer) - BytesPerWord, stopReason);
			GIV(stackPointer) = sp;
			return;
		}

		/* fail if the glyphIndex is out of range */

		glyphIndex = fetchIntegerofObject(ascii, scanMap);
		if ((GIV(primFailCode) != 0)
		 || ((glyphIndex < 0)
 || (glyphIndex > maxGlyph))) {
			/* begin primitiveFail */
			if (GIV(primFailCode) == 0) {
				GIV(primFailCode) = 1;
			}
			return;
		}
		sourceX = fetchIntegerofObject(glyphIndex, scanXTable);

		/* Above may fail if non-integer entries in scanXTable */

		sourceX2 = fetchIntegerofObject(glyphIndex + 1, scanXTable);
		if (GIV(primFailCode) != 0) {
			return;
		}
		nextDestX = (scanDestX + sourceX2) - sourceX;
		if (nextDestX > scanRightX) {
			if (!((scanDestX ^ (scanDestX << 1)) >= 0)) {
				/* begin primitiveFail */
				if (GIV(primFailCode) == 0) {
					GIV(primFailCode) = 1;
				}
				return;
			}
			/* begin storeInteger:ofObject:withValue: */
			if ((scanDestX ^ (scanDestX << 1)) >= 0) {
				longAtput((rcvr + BaseHeaderSize) + (0 << ShiftForWord), ((scanDestX << 1) | 1));
			}
			else {
				/* begin primitiveFail */
				if (GIV(primFailCode) == 0) {
					GIV(primFailCode) = 1;
				}
			}
			/* begin storeInteger:ofObject:withValue: */
			if ((scanLastIndex ^ (scanLastIndex << 1)) >= 0) {
				longAtput((rcvr + BaseHeaderSize) + (1 << ShiftForWord), ((scanLastIndex << 1) | 1));
			}
			else {
				/* begin primitiveFail */
				if (GIV(primFailCode) == 0) {
					GIV(primFailCode) = 1;
				}
			}
			/* begin pop:thenPush: */
			longAtput(sp1 = GIV(stackPointer) + ((7 - 1) * BytesPerWord), longAt((stops + BaseHeaderSize) + ((CrossedX - 1) << ShiftForWord)));
			GIV(stackPointer) = sp1;
			return;
		}
		scanDestX = nextDestX + kernDelta;
		scanLastIndex += 1;
	}
	if (!((scanDestX ^ (scanDestX << 1)) >= 0)) {
		/* begin primitiveFail */
		if (GIV(primFailCode) == 0) {
			GIV(primFailCode) = 1;
		}
		return;
	}
	/* begin storeInteger:ofObject:withValue: */
	if ((scanDestX ^ (scanDestX << 1)) >= 0) {
		longAtput((rcvr + BaseHeaderSize) + (0 << ShiftForWord), ((scanDestX << 1) | 1));
	}
	else {
		/* begin primitiveFail */
		if (GIV(primFailCode) == 0) {
			GIV(primFailCode) = 1;
		}
	}
	/* begin storeInteger:ofObject:withValue: */
	if ((scanStopIndex ^ (scanStopIndex << 1)) >= 0) {
		longAtput((rcvr + BaseHeaderSize) + (1 << ShiftForWord), ((scanStopIndex << 1) | 1));
	}
	else {
		/* begin primitiveFail */
		if (GIV(primFailCode) == 0) {
			GIV(primFailCode) = 1;
		}
	}
	/* begin pop:thenPush: */
	longAtput(sp2 = GIV(stackPointer) + ((7 - 1) * BytesPerWord), longAt((stops + BaseHeaderSize) + ((EndOfRun - 1) << ShiftForWord)));
	GIV(stackPointer) = sp2;
}


/*	Return a SmallInteger indicating the current depth of the OS screen.
	Negative values are used to imply LSB type pixel format an there is some
	support in the VM for handling either MSB or LSB
 */

EXPORT(sqInt)
primitiveScreenDepth(void)
{   DECL_MAYBE_SQ_GLOBAL_STRUCT
    sqInt depth;
    char *sp;

	depth = ioScreenDepth();
	if (GIV(primFailCode) != 0) {
		/* begin primitiveFail */
		if (GIV(primFailCode) == 0) {
			GIV(primFailCode) = 1;
		}
		return null;
	}
	/* begin pop:thenPushInteger: */
	longAtput(sp = GIV(stackPointer) + ((1 - 1) * BytesPerWord), ((depth << 1) | 1));
	GIV(stackPointer) = sp;
}


/*	Return a point indicating the current size of the Smalltalk window.
	Currently there is a limit of 65535 in each direction because the point is
	encoded into a single 32bit value in the image header. This might well
	become a problem one day
 */

static void
primitiveScreenSize(void)
{   DECL_MAYBE_SQ_GLOBAL_STRUCT
    sqInt object;
    sqInt pointResult;
    sqInt pointWord;
    char *sp;

	/* begin pop: */
	GIV(stackPointer) += 1 * BytesPerWord;
	pointWord = ioScreenSize();
	/* begin push: */
	/* begin makePointwithxValue:yValue: */
	pointResult = eeInstantiateSmallClasssizeInBytes(longAt((GIV(specialObjectsOop) + BaseHeaderSize) + (ClassPoint << ShiftForWord)), 3 * BytesPerWord);
	longAtput((pointResult + BaseHeaderSize) + (XIndex << ShiftForWord), ((((((usqInt) pointWord) >> 16) & 65535) << 1) | 1));
	longAtput((pointResult + BaseHeaderSize) + (YIndex << ShiftForWord), (((pointWord & 65535) << 1) | 1));
	object = pointResult;
	longAtput(sp = GIV(stackPointer) - BytesPerWord, object);
	GIV(stackPointer) = sp;
}


/*	Return the number of seconds since January 1, 1901 as an integer. */

static void
primitiveSecondsClock(void)
{   DECL_MAYBE_SQ_GLOBAL_STRUCT
    sqInt oop;
    char *sp;

	/* begin pop:thenPush: */
	oop = positive32BitIntegerFor(ioSeconds());
	longAtput(sp = GIV(stackPointer) + ((1 - 1) * BytesPerWord), oop);
	GIV(stackPointer) = sp;
}


/*	Set to OS to the requested display mode.
	See also DisplayScreen setDisplayDepth:extent:fullscreen: */

static void
primitiveSetDisplayMode(void)
{   DECL_MAYBE_SQ_GLOBAL_STRUCT
    sqInt d;
    sqInt fsFlag;
    sqInt h;
    sqInt integerPointer;
    sqInt integerPointer1;
    sqInt integerPointer2;
    sqInt okay;
    char *sp;
    sqInt w;

	/* begin booleanValueOf: */
	if ((longAt(GIV(stackPointer))) == GIV(trueObj)) {
		fsFlag = 1;
		goto l1;
	}
	if ((longAt(GIV(stackPointer))) == GIV(falseObj)) {
		fsFlag = 0;
		goto l1;
	}
	/* begin success: */
	if (!(0)) {
		if (GIV(primFailCode) == 0) {

			/* Don't overwrite an error code that has already been set. */

			GIV(primFailCode) = 1;
		}
	}
	fsFlag = null;
l1:	/* end booleanValueOf: */;
	/* begin stackIntegerValue: */
	integerPointer = longAt(GIV(stackPointer) + (1 * BytesPerWord));
	/* begin checkedIntegerValueOf: */
	if ((integerPointer & 1)) {
		h = (integerPointer >> 1);
		goto l2;
	}
	else {
		/* begin primitiveFail */
		if (GIV(primFailCode) == 0) {
			GIV(primFailCode) = 1;
		}
		h = 0;
		goto l2;
	}
l2:	/* end stackIntegerValue: */;
	/* begin stackIntegerValue: */
	integerPointer1 = longAt(GIV(stackPointer) + (2 * BytesPerWord));
	/* begin checkedIntegerValueOf: */
	if ((integerPointer1 & 1)) {
		w = (integerPointer1 >> 1);
		goto l3;
	}
	else {
		/* begin primitiveFail */
		if (GIV(primFailCode) == 0) {
			GIV(primFailCode) = 1;
		}
		w = 0;
		goto l3;
	}
l3:	/* end stackIntegerValue: */;
	/* begin stackIntegerValue: */
	integerPointer2 = longAt(GIV(stackPointer) + (3 * BytesPerWord));
	/* begin checkedIntegerValueOf: */
	if ((integerPointer2 & 1)) {
		d = (integerPointer2 >> 1);
		goto l4;
	}
	else {
		/* begin primitiveFail */
		if (GIV(primFailCode) == 0) {
			GIV(primFailCode) = 1;
		}
		d = 0;
		goto l4;
	}
l4:	/* end stackIntegerValue: */;
	if (GIV(primFailCode) == 0) {
		okay = ioSetDisplayMode(w, h, d, fsFlag);
	}
	if (GIV(primFailCode) == 0) {
		/* begin pop:thenPushBool: */
		longAtput(sp = GIV(stackPointer) + ((5 - 1) * BytesPerWord), (okay
			? GIV(trueObj)
			: GIV(falseObj)));
		GIV(stackPointer) = sp;
	}
}


/*	On platforms that support it, set full-screen mode to the value of the
	boolean argument.
 */

static void
primitiveSetFullScreen(void)
{   DECL_MAYBE_SQ_GLOBAL_STRUCT
    sqInt argOop;

	argOop = longAt(GIV(stackPointer));
	if (argOop == GIV(trueObj)) {
		ioSetFullScreen(1);
	}
	else {
		if (argOop == GIV(falseObj)) {
			ioSetFullScreen(0);
		}
		else {
			/* begin primitiveFail */
			if (GIV(primFailCode) == 0) {
				GIV(primFailCode) = 1;
			}
		}
	}
	if (GIV(primFailCode) == 0) {
		/* begin pop: */
		GIV(stackPointer) += 1 * BytesPerWord;
	}
}


/*	Primitive. Indicate if the GC logic should have bias to grow */

EXPORT(sqInt)
primitiveSetGCBiasToGrow(void)
{   DECL_MAYBE_SQ_GLOBAL_STRUCT
    sqInt flag;
    sqInt integerPointer;

	/* begin stackIntegerValue: */
	integerPointer = longAt(GIV(stackPointer) + (0 * BytesPerWord));
	/* begin checkedIntegerValueOf: */
	if ((integerPointer & 1)) {
		flag = (integerPointer >> 1);
		goto l1;
	}
	else {
		/* begin primitiveFail */
		if (GIV(primFailCode) == 0) {
			GIV(primFailCode) = 1;
		}
		flag = 0;
		goto l1;
	}
l1:	/* end stackIntegerValue: */;
	if (GIV(primFailCode) == 0) {
		GIV(gcBiasToGrow) = flag;
		/* begin pop: */
		GIV(stackPointer) += GIV(argumentCount) * BytesPerWord;
	}
}


/*	Primitive. If the GC logic has bias to grow, set growth limit */

EXPORT(sqInt)
primitiveSetGCBiasToGrowGCLimit(void)
{   DECL_MAYBE_SQ_GLOBAL_STRUCT
    sqInt aValue;
    sqInt integerPointer;
    sqInt value;

	/* begin stackIntegerValue: */
	integerPointer = longAt(GIV(stackPointer) + (0 * BytesPerWord));
	/* begin checkedIntegerValueOf: */
	if ((integerPointer & 1)) {
		value = (integerPointer >> 1);
		goto l1;
	}
	else {
		/* begin primitiveFail */
		if (GIV(primFailCode) == 0) {
			GIV(primFailCode) = 1;
		}
		value = 0;
		goto l1;
	}
l1:	/* end stackIntegerValue: */;
	if (GIV(primFailCode) == 0) {
		GIV(gcBiasToGrowGCLimit) = value;
		/* begin gcBiasToGrowThreshold: */
		aValue = (youngStart()) - (((sqInt)heapBase));
		GIV(gcBiasToGrowThreshold) = aValue;
		/* begin pop: */
		GIV(stackPointer) += GIV(argumentCount) * BytesPerWord;
	}
}


/*	Primitive. Indicate the semaphore to be signalled for upon garbage
	collection 
 */

EXPORT(void)
primitiveSetGCSemaphore(void)
{   DECL_MAYBE_SQ_GLOBAL_STRUCT
    sqInt index;
    sqInt integerPointer;

	/* begin stackIntegerValue: */
	integerPointer = longAt(GIV(stackPointer) + (0 * BytesPerWord));
	/* begin checkedIntegerValueOf: */
	if ((integerPointer & 1)) {
		index = (integerPointer >> 1);
		goto l1;
	}
	else {
		/* begin primitiveFail */
		if (GIV(primFailCode) == 0) {
			GIV(primFailCode) = 1;
		}
		index = 0;
		goto l1;
	}
l1:	/* end stackIntegerValue: */;
	if (GIV(primFailCode) == 0) {
		GIV(gcSemaphoreIndex) = index;
		/* begin pop: */
		GIV(stackPointer) += GIV(argumentCount) * BytesPerWord;
	}
}

static void
primitiveSetIdentityHash(void)
{   DECL_MAYBE_SQ_GLOBAL_STRUCT
    sqInt hash;
    sqInt integerPointer;
    sqInt oldHash;
    sqInt oop;
    char *sp;
    sqInt thisReceiver;

	/* begin stackIntegerValue: */
	integerPointer = longAt(GIV(stackPointer) + (0 * BytesPerWord));
	/* begin checkedIntegerValueOf: */
	if ((integerPointer & 1)) {
		hash = (integerPointer >> 1);
		goto l2;
	}
	else {
		/* begin primitiveFail */
		if (GIV(primFailCode) == 0) {
			GIV(primFailCode) = 1;
		}
		hash = 0;
		goto l2;
	}
l2:	/* end stackIntegerValue: */;
	/* begin stackObjectValue: */
	oop = longAt(GIV(stackPointer) + (1 * BytesPerWord));
	if ((oop & 1)) {
		/* begin primitiveFail */
		if (GIV(primFailCode) == 0) {
			GIV(primFailCode) = 1;
		}
		thisReceiver = null;
		goto l1;
	}
	thisReceiver = oop;
l1:	/* end stackObjectValue: */;
	if (GIV(primFailCode) == 0) {
		oldHash = (((usqInt) (longAt(thisReceiver))) >> HashBitsOffset) & HashMaskUnshifted;
		/* begin setHashBitsOf:to: */
		longAtput(thisReceiver, ((longAt(thisReceiver)) & (~HashBits)) | ((hash & HashMaskUnshifted) << HashBitsOffset));
		/* begin pop:thenPushInteger: */
		longAtput(sp = GIV(stackPointer) + (((GIV(argumentCount) + 1) - 1) * BytesPerWord), ((oldHash << 1) | 1));
		GIV(stackPointer) = sp;
	}
}


/*	Set the user interrupt keycode. The keycode is an integer whose encoding
	is described in the comment for primitiveKbdNext.
 */

static void
primitiveSetInterruptKey(void)
{   DECL_MAYBE_SQ_GLOBAL_STRUCT
    sqInt integerPointer;
    sqInt keycode;

	/* begin stackIntegerValue: */
	integerPointer = longAt(GIV(stackPointer) + (0 * BytesPerWord));
	/* begin checkedIntegerValueOf: */
	if ((integerPointer & 1)) {
		keycode = (integerPointer >> 1);
		goto l1;
	}
	else {
		/* begin primitiveFail */
		if (GIV(primFailCode) == 0) {
			GIV(primFailCode) = 1;
		}
		keycode = 0;
		goto l1;
	}
l1:	/* end stackIntegerValue: */;
	if (GIV(primFailCode) == 0) {
		/* begin setInterruptKeycode: */
		GIV(interruptKeycode) = keycode;
		/* begin pop: */
		GIV(stackPointer) += GIV(argumentCount) * BytesPerWord;
	}
}


/*	Primitive. Set the VM's log directory */

EXPORT(sqInt)
primitiveSetLogDirectory(void)
{   DECL_MAYBE_SQ_GLOBAL_STRUCT
    sqInt stringOop;
    sqInt sz;

	stringOop = longAt(GIV(stackPointer));
	if (!(((stringOop & 1) == 0)
		 && (((((usqInt) (longAt(stringOop))) >> 8) & 15) >= 8))) {
		/* begin success: */
		if (!(0)) {
			if (GIV(primFailCode) == 0) {

				/* Don't overwrite an error code that has already been set. */

				GIV(primFailCode) = 1;
			}
		}
		return null;
	}
	sz = byteSizeOf(stringOop);
	ioSetLogDirectoryOfSize(firstIndexableField(stringOop), sz);
	if (GIV(primFailCode) == 0) {
		/* begin pop: */
		GIV(stackPointer) += GIV(argumentCount) * BytesPerWord;
	}
}


/*	Primitive. Set the OS window's label */

EXPORT(sqInt)
primitiveSetWindowLabel(void)
{   DECL_MAYBE_SQ_GLOBAL_STRUCT
    sqInt labelOop;
    sqInt sz;

	labelOop = longAt(GIV(stackPointer));
	if (!(((labelOop & 1) == 0)
		 && (((((usqInt) (longAt(labelOop))) >> 8) & 15) >= 8))) {
		/* begin success: */
		if (!(0)) {
			if (GIV(primFailCode) == 0) {

				/* Don't overwrite an error code that has already been set. */

				GIV(primFailCode) = 1;
			}
		}
		return null;
	}
	sz = byteSizeOf(labelOop);
	ioSetWindowLabelOfSize(firstIndexableField(labelOop), sz);
	if (GIV(primFailCode) == 0) {
		/* begin pop: */
		GIV(stackPointer) += GIV(argumentCount) * BytesPerWord;
	}
}


/*	Primitive. Answer the OS window's size (extent) */

EXPORT(sqInt)
primitiveSetWindowSize(void)
{   DECL_MAYBE_SQ_GLOBAL_STRUCT
    sqInt h;
    sqInt integerPointer;
    sqInt integerPointer1;
    sqInt w;

	/* begin stackIntegerValue: */
	integerPointer = longAt(GIV(stackPointer) + (0 * BytesPerWord));
	/* begin checkedIntegerValueOf: */
	if ((integerPointer & 1)) {
		h = (integerPointer >> 1);
		goto l1;
	}
	else {
		/* begin primitiveFail */
		if (GIV(primFailCode) == 0) {
			GIV(primFailCode) = 1;
		}
		h = 0;
		goto l1;
	}
l1:	/* end stackIntegerValue: */;
	/* begin stackIntegerValue: */
	integerPointer1 = longAt(GIV(stackPointer) + (1 * BytesPerWord));
	/* begin checkedIntegerValueOf: */
	if ((integerPointer1 & 1)) {
		w = (integerPointer1 >> 1);
		goto l2;
	}
	else {
		/* begin primitiveFail */
		if (GIV(primFailCode) == 0) {
			GIV(primFailCode) = 1;
		}
		w = 0;
		goto l2;
	}
l2:	/* end stackIntegerValue: */;
	if (GIV(primFailCode) == 0) {
		ioSetWindowWidthHeight(w, h);
		/* begin pop: */
		GIV(stackPointer) += GIV(argumentCount) * BytesPerWord;
	}
}


/*	Treat the receiver, which can be indexible by either bytes or words, as an
	array of signed 16-bit values. Return the contents of the given index.
	Note that the index specifies the i-th 16-bit entry, not the i-th byte or
	word. 
 */

static void
primitiveShortAt(void)
{   DECL_MAYBE_SQ_GLOBAL_STRUCT
    sqInt addr;
    sqInt index;
    sqInt integerPointer;
    sqInt rcvr;
    char *sp;
    sqInt sz;
    sqInt value;

	/* begin stackIntegerValue: */
	integerPointer = longAt(GIV(stackPointer) + (0 * BytesPerWord));
	/* begin checkedIntegerValueOf: */
	if ((integerPointer & 1)) {
		index = (integerPointer >> 1);
		goto l1;
	}
	else {
		/* begin primitiveFail */
		if (GIV(primFailCode) == 0) {
			GIV(primFailCode) = 1;
		}
		index = 0;
		goto l1;
	}
l1:	/* end stackIntegerValue: */;
	if (!(GIV(primFailCode) == 0)) {
		GIV(primFailCode) = PrimErrBadArgument; return;
	}
	rcvr = longAt(GIV(stackPointer) + (1 * BytesPerWord));
	if (((rcvr & 1))
	 || (!(((rcvr & 1) == 0)
 && (isWordsOrBytesNonInt(rcvr))))) {
		GIV(primFailCode) = PrimErrInappropriate; return;
	}

	/* number of 16-bit fields */

	sz = ((sqInt) ((sizeBitsOf(rcvr)) - BaseHeaderSize) >> 1);
	if (!((index >= 1)
		 && (index <= sz))) {
		GIV(primFailCode) = PrimErrBadIndex; return;
	}
	addr = (rcvr + BaseHeaderSize) + (2 * (index - 1));
	value = shortAt(addr);
	/* begin pop:thenPushInteger: */
	longAtput(sp = GIV(stackPointer) + ((2 - 1) * BytesPerWord), ((value << 1) | 1));
	GIV(stackPointer) = sp;
}


/*	Treat the receiver, which can be indexible by either bytes or words, as an
	array of signed 16-bit values. Set the contents of the given index to the
	given value. Note that the index specifies the i-th 16-bit entry, not the
	i-th byte or word.
 */

static void
primitiveShortAtPut(void)
{   DECL_MAYBE_SQ_GLOBAL_STRUCT
    sqInt addr;
    sqInt index;
    sqInt integerPointer;
    sqInt integerPointer1;
    sqInt rcvr;
    char *sp;
    sqInt sz;
    sqInt value;

	/* begin stackIntegerValue: */
	integerPointer = longAt(GIV(stackPointer) + (0 * BytesPerWord));
	/* begin checkedIntegerValueOf: */
	if ((integerPointer & 1)) {
		value = (integerPointer >> 1);
		goto l1;
	}
	else {
		/* begin primitiveFail */
		if (GIV(primFailCode) == 0) {
			GIV(primFailCode) = 1;
		}
		value = 0;
		goto l1;
	}
l1:	/* end stackIntegerValue: */;
	/* begin stackIntegerValue: */
	integerPointer1 = longAt(GIV(stackPointer) + (1 * BytesPerWord));
	/* begin checkedIntegerValueOf: */
	if ((integerPointer1 & 1)) {
		index = (integerPointer1 >> 1);
		goto l2;
	}
	else {
		/* begin primitiveFail */
		if (GIV(primFailCode) == 0) {
			GIV(primFailCode) = 1;
		}
		index = 0;
		goto l2;
	}
l2:	/* end stackIntegerValue: */;
	if (!((GIV(primFailCode) == 0)
		 && ((value >= -32768)
 && (value <= 32767)))) {
		GIV(primFailCode) = PrimErrBadArgument; return;
	}
	rcvr = longAt(GIV(stackPointer) + (2 * BytesPerWord));
	if (!((!((rcvr & 1)))
		 && (((rcvr & 1) == 0)
 && (isWordsOrBytesNonInt(rcvr))))) {
		GIV(primFailCode) = PrimErrInappropriate; return;
	}

	/* number of 16-bit fields */

	sz = ((sqInt) ((sizeBitsOf(rcvr)) - BaseHeaderSize) >> 1);
	if (!((index >= 1)
		 && (index <= sz))) {
		GIV(primFailCode) = PrimErrBadIndex; return;
	}
	addr = (rcvr + BaseHeaderSize) + (2 * (index - 1));
	shortAtput(addr, value);
	/* begin pop:thenPush: */
	longAtput(sp = GIV(stackPointer) + ((3 - 1) * BytesPerWord), ((value << 1) | 1));
	GIV(stackPointer) = sp;
}


/*	Force the given rectangular section of the Display to be 
	copied to the screen. */

static void
primitiveShowDisplayRect(void)
{   DECL_MAYBE_SQ_GLOBAL_STRUCT
    sqInt bottom;
    sqInt integerPointer;
    sqInt integerPointer1;
    sqInt integerPointer2;
    sqInt integerPointer3;
    sqInt left;
    sqInt right;
    sqInt top;

	/* begin stackIntegerValue: */
	integerPointer = longAt(GIV(stackPointer) + (0 * BytesPerWord));
	/* begin checkedIntegerValueOf: */
	if ((integerPointer & 1)) {
		bottom = (integerPointer >> 1);
		goto l1;
	}
	else {
		/* begin primitiveFail */
		if (GIV(primFailCode) == 0) {
			GIV(primFailCode) = 1;
		}
		bottom = 0;
		goto l1;
	}
l1:	/* end stackIntegerValue: */;
	/* begin stackIntegerValue: */
	integerPointer1 = longAt(GIV(stackPointer) + (1 * BytesPerWord));
	/* begin checkedIntegerValueOf: */
	if ((integerPointer1 & 1)) {
		top = (integerPointer1 >> 1);
		goto l2;
	}
	else {
		/* begin primitiveFail */
		if (GIV(primFailCode) == 0) {
			GIV(primFailCode) = 1;
		}
		top = 0;
		goto l2;
	}
l2:	/* end stackIntegerValue: */;
	/* begin stackIntegerValue: */
	integerPointer2 = longAt(GIV(stackPointer) + (2 * BytesPerWord));
	/* begin checkedIntegerValueOf: */
	if ((integerPointer2 & 1)) {
		right = (integerPointer2 >> 1);
		goto l3;
	}
	else {
		/* begin primitiveFail */
		if (GIV(primFailCode) == 0) {
			GIV(primFailCode) = 1;
		}
		right = 0;
		goto l3;
	}
l3:	/* end stackIntegerValue: */;
	/* begin stackIntegerValue: */
	integerPointer3 = longAt(GIV(stackPointer) + (3 * BytesPerWord));
	/* begin checkedIntegerValueOf: */
	if ((integerPointer3 & 1)) {
		left = (integerPointer3 >> 1);
		goto l4;
	}
	else {
		/* begin primitiveFail */
		if (GIV(primFailCode) == 0) {
			GIV(primFailCode) = 1;
		}
		left = 0;
		goto l4;
	}
l4:	/* end stackIntegerValue: */;
	displayBitsOfLeftTopRightBottom(longAt((GIV(specialObjectsOop) + BaseHeaderSize) + (TheDisplay << ShiftForWord)), left, top, right, bottom);
	if (GIV(primFailCode) == 0) {
		ioForceDisplayUpdate();
		/* begin pop: */
		GIV(stackPointer) += 4 * BytesPerWord;
	}
}


/*	Synchronously signal the semaphore.
	This may change the active process as a result. */
/*	We may be about to switch process, either to an interpreted frame or a
	machine code frame. To know whether to return or enter machine code
	we have to know from whence we came. We could have come from the
	interpreter, either directly or via a machine code primitive. We could
	have come from machine code. The instructionPointer tells us where from: */

static void
primitiveSignal(void)
{   DECL_MAYBE_SQ_GLOBAL_STRUCT
    sqInt inInterpreter;

	inInterpreter = GIV(instructionPointer) >= heapBase;
	if (synchronousSignal(longAt(GIV(stackPointer)))) {
		/* begin forProcessPrimitiveReturnToExecutivePostContextSwitch: */
		if (GIV(nextProfileTick) > 0) {
			checkProfileTick(GIV(newMethod));
		}
		returnToExecutivepostContextSwitch(inInterpreter, 1);
	}
}


/*	Set the low-water mark for free space. When the free space 
	falls below this level, the new and new: primitives fail and 
	system attempts to allocate space (e.g., to create a method 
	context) cause the low-space semaphore (if one is 
	registered) to be signalled. */

static void
primitiveSignalAtBytesLeft(void)
{   DECL_MAYBE_SQ_GLOBAL_STRUCT
    sqInt bytes;
    sqInt integerPointer;
    sqInt top;

	/* begin popInteger */
	/* begin popStack */
	top = longAt(GIV(stackPointer));
	GIV(stackPointer) += BytesPerWord;
	integerPointer = top;
	/* begin checkedIntegerValueOf: */
	if ((integerPointer & 1)) {
		bytes = (integerPointer >> 1);
		goto l1;
	}
	else {
		/* begin primitiveFail */
		if (GIV(primFailCode) == 0) {
			GIV(primFailCode) = 1;
		}
		bytes = 0;
		goto l1;
	}
l1:	/* end popInteger */;
	if (GIV(primFailCode) == 0) {
		GIV(lowSpaceThreshold) = bytes;
	}
	else {
		GIV(lowSpaceThreshold) = 0;
		/* begin unPop: */
		GIV(stackPointer) -= 1 * BytesPerWord;
	}
}


/*	Cause the time semaphore, if one has been registered, to be
	signalled when the microsecond clock is greater than or equal to
	the given tick value. A tick value of zero turns off timer interrupts. */

static void
primitiveSignalAtMilliseconds(void)
{   DECL_MAYBE_SQ_GLOBAL_STRUCT
    sqInt deltaMsecs;
    usqInt msecs;
    sqInt msecsObj;
    sqInt sema;

	msecsObj = longAt(GIV(stackPointer));
	sema = longAt(GIV(stackPointer) + (1 * BytesPerWord));
	msecs = positive32BitValueOf(msecsObj);
	if ((GIV(primFailCode) != 0)
	 || ((sema & 1))) {
		/* begin primitiveFail */
		if (GIV(primFailCode) == 0) {
			GIV(primFailCode) = 1;
		}
		return;
	}
	if ((fetchClassOfNonInt(sema)) == (longAt((GIV(specialObjectsOop) + BaseHeaderSize) + (ClassSemaphore << ShiftForWord)))) {
		/* begin splObj:put: */
		/* begin storePointer:ofObject:withValue: */
		if ((((usqInt) GIV(specialObjectsOop))) < (((usqInt) GIV(youngStart)))) {
			possibleRootStoreIntovalue(GIV(specialObjectsOop), sema);
		}
		longAtput((GIV(specialObjectsOop) + BaseHeaderSize) + (TheTimerSemaphore << ShiftForWord), sema);
		deltaMsecs = msecs - ((ioMSecs()) & MillisecondClockMask);
		if (deltaMsecs < 0) {
			deltaMsecs = (deltaMsecs + MillisecondClockMask) + 1;
		}
		GIV(nextWakeupUsecs) = (ioUTCMicroseconds()) + (deltaMsecs * 1000);
	}
	else {
		/* begin storePointer:ofObject:withValue: */
		if ((((usqInt) GIV(specialObjectsOop))) < (((usqInt) GIV(youngStart)))) {
			possibleRootStoreIntovalue(GIV(specialObjectsOop), GIV(nilObj));
		}
		longAtput((GIV(specialObjectsOop) + BaseHeaderSize) + (TheTimerSemaphore << ShiftForWord), GIV(nilObj));
		GIV(nextWakeupUsecs) = 0;
	}
	/* begin pop: */
	GIV(stackPointer) += 2 * BytesPerWord;
}


/*	Cause the time semaphore, if one has been registered, to be
	signalled when the microsecond clock is greater than or equal to
	the given tick value. A tick value of zero turns off timer interrupts. */

static void
primitiveSignalAtUTCMicroseconds(void)
{   DECL_MAYBE_SQ_GLOBAL_STRUCT
    sqInt sema;
    usqLong usecs;
    sqInt usecsObj;

	usecsObj = longAt(GIV(stackPointer));
	sema = longAt(GIV(stackPointer) + (1 * BytesPerWord));
	usecs = positive64BitValueOf(usecsObj);
	if ((GIV(primFailCode) != 0)
	 || ((sema & 1))) {
		/* begin primitiveFail */
		if (GIV(primFailCode) == 0) {
			GIV(primFailCode) = 1;
		}
		return;
	}
	if ((fetchClassOfNonInt(sema)) == (longAt((GIV(specialObjectsOop) + BaseHeaderSize) + (ClassSemaphore << ShiftForWord)))) {
		/* begin splObj:put: */
		/* begin storePointer:ofObject:withValue: */
		if ((((usqInt) GIV(specialObjectsOop))) < (((usqInt) GIV(youngStart)))) {
			possibleRootStoreIntovalue(GIV(specialObjectsOop), sema);
		}
		longAtput((GIV(specialObjectsOop) + BaseHeaderSize) + (TheTimerSemaphore << ShiftForWord), sema);
		GIV(nextWakeupUsecs) = usecs;
	}
	else {
		/* begin storePointer:ofObject:withValue: */
		if ((((usqInt) GIV(specialObjectsOop))) < (((usqInt) GIV(youngStart)))) {
			possibleRootStoreIntovalue(GIV(specialObjectsOop), GIV(nilObj));
		}
		longAtput((GIV(specialObjectsOop) + BaseHeaderSize) + (TheTimerSemaphore << ShiftForWord), GIV(nilObj));
		GIV(nextWakeupUsecs) = 0;
	}
	/* begin pop: */
	GIV(stackPointer) += 2 * BytesPerWord;
}

static void
primitiveSine(void)
{   DECL_MAYBE_SQ_GLOBAL_STRUCT
    sqInt ccIndex;
    double f;
    sqInt object;
    double rcvr;
    double result;
    char *sp;
    sqInt successBoolean;
    sqInt top;
    sqInt top1;

	/* begin popFloat */
	VM_LABEL(5popFloat);
	/* begin popStack */
	top1 = longAt(GIV(stackPointer));
	GIV(stackPointer) += BytesPerWord;
	top = top1;
	/* begin assertClassOf:is:compactClassIndex: */
	VM_LABEL(51assertClassOfiscompactClassIndex);
	/* begin success: */
	/* begin is:instanceOf:compactClassIndex: */
	if ((top & 1)) {
		successBoolean = 0;
		goto l1;
	}
	ccIndex = (((usqInt) (longAt(top))) >> 12) & 31;
	if (ClassFloatCompactIndex != 0) {
		successBoolean = ClassFloatCompactIndex == ccIndex;
		goto l1;
	}
	successBoolean = (ccIndex == 0)
	 && (((longAt(top - BaseHeaderSize)) & AllButTypeMask) == (longAt((GIV(specialObjectsOop) + BaseHeaderSize) + (ClassFloat << ShiftForWord))));
l1:	/* end is:instanceOf:compactClassIndex: */;
	if (!(successBoolean)) {
		if (GIV(primFailCode) == 0) {

			/* Don't overwrite an error code that has already been set. */

			GIV(primFailCode) = 1;
		}
	}
	if (GIV(primFailCode) == 0) {
		;
		fetchFloatAtinto(top + BaseHeaderSize, result);
	}
	rcvr = result;
	if (GIV(primFailCode) == 0) {
		/* begin pushFloat: */
		f = sin(rcvr);
		/* begin push: */
		object = floatObjectOf(f);
		longAtput(sp = GIV(stackPointer) - BytesPerWord, object);
		GIV(stackPointer) = sp;
	}
	else {
		/* begin unPop: */
		GIV(stackPointer) -= 1 * BytesPerWord;
	}
}

static void
primitiveSize(void)
{   DECL_MAYBE_SQ_GLOBAL_STRUCT
    sqInt rcvr;
    char *sp;
    sqInt sz;

	rcvr = longAt(GIV(stackPointer));
	if ((rcvr & 1)) {
		/* begin primitiveFail */
		if (GIV(primFailCode) == 0) {
			GIV(primFailCode) = 1;
		}
		return;
	}
	if (((((usqInt) (longAt(rcvr))) >> 8) & 15) < 2) {
		/* begin primitiveFail */
		if (GIV(primFailCode) == 0) {
			GIV(primFailCode) = 1;
		}
		return;
	}
	sz = stSizeOf(rcvr);
	if (GIV(primFailCode) == 0) {
		/* begin pop:thenPush: */
		longAtput(sp = GIV(stackPointer) + (((GIV(argumentCount) + 1) - 1) * BytesPerWord), ((sz << 1) | 1));
		GIV(stackPointer) = sp;
	}
}


/*	Save a normal snapshot under the same name as it was loaded
	unless it has been renamed by the last primitiveImageName.
	
	Override to jump to the interpreter because the machine code zone is now
	void. 
 */

static void
primitiveSnapshot(void)
{
	snapshot(0);
	siglongjmp(reenterInterpreter, ReturnToInterpreter);
}


/*	Save an embedded snapshot.
	
	Override to jump to the interpreter because the machine code zone is now
	void. 
 */

static void
primitiveSnapshotEmbedded(void)
{
	snapshot(1);
	siglongjmp(reenterInterpreter, ReturnToInterpreter);
}

static void
primitiveSomeInstance(void)
{   DECL_MAYBE_SQ_GLOBAL_STRUCT
    sqInt ccIndex;
    sqInt class;
    sqInt header;
    sqInt header1;
    sqInt header2;
    sqInt instance;
    sqInt obj;
    sqInt obj1;
    char *sp;
    sqInt sz;
    sqInt sz1;
    sqInt sz2;
    sqInt thisClass;
    sqInt thisObj;

	class = longAt(GIV(stackPointer));
	/* begin initialInstanceOf: */
	/* begin firstAccessibleObject */
	obj1 = heapBase + (headerTypeBytes[(longAt(heapBase)) & TypeMask]);
	while ((((usqInt) obj1)) < (((usqInt) GIV(freeStart)))) {
		if (!(((longAt(obj1)) & TypeMask) == HeaderTypeFree)) {
			thisObj = obj1;
			goto l4;
		}
		/* begin objectAfter: */
		if (DoAssertionChecks) {
			if ((((usqInt) obj1)) >= (((usqInt) GIV(endOfMemory)))) {
				error("no objects after the end of memory");
			}
		}
		if (((longAt(obj1)) & TypeMask) == HeaderTypeFree) {
			sz2 = (longAt(obj1)) & AllButTypeMask;
		}
		else {
			/* begin sizeBitsOf: */
			header2 = longAt(obj1);
			sz2 = ((header2 & TypeMask) == HeaderTypeSizeAndClass
				? (longAt(obj1 - (BytesPerWord * 2))) & LongSizeMask
				: header2 & SizeMask);
		}
		obj1 = (obj1 + sz2) + (headerTypeBytes[(longAt(obj1 + sz2)) & TypeMask]);
	}
	error("heap is empty");
	thisObj = null;
l4:	/* end firstAccessibleObject */;
	while (!(thisObj == null)) {
		/* begin fetchClassOf: */
		if ((thisObj & 1)) {
			thisClass = longAt((GIV(specialObjectsOop) + BaseHeaderSize) + (ClassInteger << ShiftForWord));
			goto l2;
		}
		if (((ccIndex = (((usqInt) (longAt(thisObj))) >> 12) & 31)) == 0) {
			thisClass = (longAt(thisObj - BaseHeaderSize)) & AllButTypeMask;
			goto l2;
		}
		else {
			thisClass = longAt(((longAt((GIV(specialObjectsOop) + BaseHeaderSize) + (CompactClasses << ShiftForWord))) + BaseHeaderSize) + ((ccIndex - 1) << ShiftForWord));
			goto l2;
		}
	l2:	/* end fetchClassOf: */;
		if (thisClass == class) {
			instance = thisObj;
			goto l1;
		}
		/* begin accessibleObjectAfter: */
		/* begin objectAfter: */
		if (DoAssertionChecks) {
			if ((((usqInt) thisObj)) >= (((usqInt) GIV(endOfMemory)))) {
				error("no objects after the end of memory");
			}
		}
		if (((longAt(thisObj)) & TypeMask) == HeaderTypeFree) {
			sz1 = (longAt(thisObj)) & AllButTypeMask;
		}
		else {
			/* begin sizeBitsOf: */
			header1 = longAt(thisObj);
			sz1 = ((header1 & TypeMask) == HeaderTypeSizeAndClass
				? (longAt(thisObj - (BytesPerWord * 2))) & LongSizeMask
				: header1 & SizeMask);
		}
		obj = (thisObj + sz1) + (headerTypeBytes[(longAt(thisObj + sz1)) & TypeMask]);
		while ((((usqInt) obj)) < (((usqInt) GIV(freeStart)))) {
			if (!(((longAt(obj)) & TypeMask) == HeaderTypeFree)) {
				thisObj = obj;
				goto l3;
			}
			/* begin objectAfter: */
			if (DoAssertionChecks) {
				if ((((usqInt) obj)) >= (((usqInt) GIV(endOfMemory)))) {
					error("no objects after the end of memory");
				}
			}
			if (((longAt(obj)) & TypeMask) == HeaderTypeFree) {
				sz = (longAt(obj)) & AllButTypeMask;
			}
			else {
				/* begin sizeBitsOf: */
				header = longAt(obj);
				sz = ((header & TypeMask) == HeaderTypeSizeAndClass
					? (longAt(obj - (BytesPerWord * 2))) & LongSizeMask
					: header & SizeMask);
			}
			obj = (obj + sz) + (headerTypeBytes[(longAt(obj + sz)) & TypeMask]);
		}
		thisObj = null;
	l3:	/* end accessibleObjectAfter: */;
	}
	instance = GIV(nilObj);
l1:	/* end initialInstanceOf: */;
	if (instance == GIV(nilObj)) {
		/* begin primitiveFail */
		if (GIV(primFailCode) == 0) {
			GIV(primFailCode) = 1;
		}
	}
	else {
		/* begin pop:thenPush: */
		longAtput(sp = GIV(stackPointer) + (((GIV(argumentCount) + 1) - 1) * BytesPerWord), instance);
		GIV(stackPointer) = sp;
	}
}


/*	Return the first object in the heap. */

static void
primitiveSomeObject(void)
{   DECL_MAYBE_SQ_GLOBAL_STRUCT
    sqInt header;
    sqInt obj;
    sqInt object;
    char *sp;
    sqInt sz;

	/* begin pop: */
	GIV(stackPointer) += (GIV(argumentCount) + 1) * BytesPerWord;
	/* begin push: */
	/* begin firstAccessibleObject */
	obj = heapBase + (headerTypeBytes[(longAt(heapBase)) & TypeMask]);
	while ((((usqInt) obj)) < (((usqInt) GIV(freeStart)))) {
		if (!(((longAt(obj)) & TypeMask) == HeaderTypeFree)) {
			object = obj;
			goto l1;
		}
		/* begin objectAfter: */
		if (DoAssertionChecks) {
			if ((((usqInt) obj)) >= (((usqInt) GIV(endOfMemory)))) {
				error("no objects after the end of memory");
			}
		}
		if (((longAt(obj)) & TypeMask) == HeaderTypeFree) {
			sz = (longAt(obj)) & AllButTypeMask;
		}
		else {
			/* begin sizeBitsOf: */
			header = longAt(obj);
			sz = ((header & TypeMask) == HeaderTypeSizeAndClass
				? (longAt(obj - (BytesPerWord * 2))) & LongSizeMask
				: header & SizeMask);
		}
		obj = (obj + sz) + (headerTypeBytes[(longAt(obj + sz)) & TypeMask]);
	}
	error("heap is empty");
	object = null;
l1:	/* end firstAccessibleObject */;
	longAtput(sp = GIV(stackPointer) - BytesPerWord, object);
	GIV(stackPointer) = sp;
}


/*	Return the oop of the SpecialObjectsArray. */

static void
primitiveSpecialObjectsOop(void)
{   DECL_MAYBE_SQ_GLOBAL_STRUCT
    char *sp;

	/* begin pop:thenPush: */
	longAtput(sp = GIV(stackPointer) + ((1 - 1) * BytesPerWord), GIV(specialObjectsOop));
	GIV(stackPointer) = sp;
}

static void
primitiveSquareRoot(void)
{   DECL_MAYBE_SQ_GLOBAL_STRUCT
    sqInt ccIndex;
    double f;
    sqInt object;
    double rcvr;
    double result;
    char *sp;
    sqInt successBoolean;
    sqInt top;
    sqInt top1;

	/* begin popFloat */
	VM_LABEL(6popFloat);
	/* begin popStack */
	top1 = longAt(GIV(stackPointer));
	GIV(stackPointer) += BytesPerWord;
	top = top1;
	/* begin assertClassOf:is:compactClassIndex: */
	VM_LABEL(52assertClassOfiscompactClassIndex);
	/* begin success: */
	/* begin is:instanceOf:compactClassIndex: */
	if ((top & 1)) {
		successBoolean = 0;
		goto l1;
	}
	ccIndex = (((usqInt) (longAt(top))) >> 12) & 31;
	if (ClassFloatCompactIndex != 0) {
		successBoolean = ClassFloatCompactIndex == ccIndex;
		goto l1;
	}
	successBoolean = (ccIndex == 0)
	 && (((longAt(top - BaseHeaderSize)) & AllButTypeMask) == (longAt((GIV(specialObjectsOop) + BaseHeaderSize) + (ClassFloat << ShiftForWord))));
l1:	/* end is:instanceOf:compactClassIndex: */;
	if (!(successBoolean)) {
		if (GIV(primFailCode) == 0) {

			/* Don't overwrite an error code that has already been set. */

			GIV(primFailCode) = 1;
		}
	}
	if (GIV(primFailCode) == 0) {
		;
		fetchFloatAtinto(top + BaseHeaderSize, result);
	}
	rcvr = result;
	/* begin success: */
	if (!(rcvr >= 0.0)) {
		if (GIV(primFailCode) == 0) {

			/* Don't overwrite an error code that has already been set. */

			GIV(primFailCode) = 1;
		}
	}
	if (GIV(primFailCode) == 0) {
		/* begin pushFloat: */
		f = sqrt(rcvr);
		/* begin push: */
		object = floatObjectOf(f);
		longAtput(sp = GIV(stackPointer) - BytesPerWord, object);
		GIV(stackPointer) = sp;
	}
	else {
		/* begin unPop: */
		GIV(stackPointer) -= 1 * BytesPerWord;
	}
}


/*	This primitive is called from Squeak as...
	<imageSegment> storeSegmentFor: arrayOfRoots into: aWordArray outPointers:
	anArray. 
 */
/*	This primitive will store a binary image segment (in the same format as
	the Squeak image file) of the receiver and every object in its proper tree
	of subParts (ie, that is not refered to from anywhere else outside the
	tree). All pointers from within the tree to objects outside the tree will
	be copied into the array of outpointers. In their place in the image
	segment will be an oop equal to the offset in the outPointer array (the
	first would be 4). but with the high bit set.
 */
/*	The primitive expects the array and wordArray to be more than adequately
	long. In this case it returns normally, and truncates the two arrays to
	exactly the right size. To simplify truncation, both incoming arrays are
	required to be 256 bytes or more long (ie with 3-word headers). If either
	array is too small, the primitive will fail, but in no other case.
	
	During operation of the primitive, it is necessary to convert from both
	internal and external oops to their mapped values. To make this fast, the
	headers of the original objects in question are replaced by the mapped
	values (and this is noted by adding the forbidden XX header type). Tables
	are kept of both kinds of oops, as well as of the original headers for
	restoration. 
	To be specific, there are two similar two-part tables, the outpointer
	array, and one in the upper fifth of the segmentWordArray. Each grows oops
	from the bottom up, and preserved headers from halfway up.
	
	In case of either success or failure, the headers must be restored. In the
	event of primitive failure, the table of outpointers must also be nilled
	out (since the garbage in the high half will not have been discarded.
 */

static void
primitiveStoreImageSegment(void)
{   DECL_MAYBE_SQ_GLOBAL_STRUCT
    sqInt arrayOfRoots;
    sqInt ecode;
    sqInt outPointerArray;
    sqInt segmentWordArray;

	outPointerArray = longAt(GIV(stackPointer));
	segmentWordArray = longAt(GIV(stackPointer) + (1 * BytesPerWord));

	/* Essential type checks */

	arrayOfRoots = longAt(GIV(stackPointer) + (2 * BytesPerWord));
	if (!((((arrayOfRoots & 1) == 0)
 && (((((usqInt) (longAt(arrayOfRoots))) >> 8) & 15) == 2))
		 && ((((outPointerArray & 1) == 0)
 && (((((usqInt) (longAt(outPointerArray))) >> 8) & 15) == 2))
 && (((segmentWordArray & 1) == 0)
 && (((((usqInt) (longAt(segmentWordArray))) >> 8) & 15) == 6))))) {
		/* begin primitiveFail */
		if (GIV(primFailCode) == 0) {
			GIV(primFailCode) = 1;
		}
		return;
	}
	ecode = storeImageSegmentIntooutPointersroots(segmentWordArray, outPointerArray, arrayOfRoots);
	if (ecode == PrimNoErr) {
		/* begin pop: */
		GIV(stackPointer) += 3 * BytesPerWord;
	}
	else {
		GIV(primFailCode) = ecode;
	}
}


/*	Atomic store into context stackPointer. 
	Also ensures that any newly accessible cells are initialized to nil */

static void
primitiveStoreStackp(void)
{   DECL_MAYBE_SQ_GLOBAL_STRUCT
    sqInt ctxt;
    sqInt i;
    sqInt index;
    sqInt integerPointer;
    sqInt newStackp;
    sqInt onCurrentPage;
    sqInt sp;
    sqInt stackp;
    char *theFP;
    StackPage *thePage;
    sqInt value;

	ctxt = longAt(GIV(stackPointer) + (1 * BytesPerWord));
	/* begin stackIntegerValue: */
	integerPointer = longAt(GIV(stackPointer) + (0 * BytesPerWord));
	/* begin checkedIntegerValueOf: */
	if ((integerPointer & 1)) {
		newStackp = (integerPointer >> 1);
		goto l2;
	}
	else {
		/* begin primitiveFail */
		if (GIV(primFailCode) == 0) {
			GIV(primFailCode) = 1;
		}
		newStackp = 0;
		goto l2;
	}
l2:	/* end stackIntegerValue: */;
	if (!((GIV(primFailCode) == 0)
		 && (((newStackp >= 0) && (newStackp <= (lengthOf(ctxt))))))) {
		/* begin primitiveFail */
		if (GIV(primFailCode) == 0) {
			GIV(primFailCode) = 1;
		}
		return;
	}
	/* begin externalWriteBackHeadFramePointers */
	assert((GIV(framePointer) - GIV(stackPointer)) < LargeContextSize);
	assert(GIV(stackPage) == (mostRecentlyUsedPage()));
	/* begin setHeadFP:andSP:inPage: */
	assert(GIV(stackPointer) < GIV(framePointer));
	assert((GIV(stackPointer) < ((GIV(stackPage)->baseAddress)))
	 && (GIV(stackPointer) > (((GIV(stackPage)->realStackLimit)) - LargeContextSize)));
	assert((GIV(framePointer) < ((GIV(stackPage)->baseAddress)))
	 && (GIV(framePointer) > (((GIV(stackPage)->realStackLimit)) - (((sqInt) LargeContextSize >> 1)))));
	(GIV(stackPage)->headFP = GIV(framePointer));
	(GIV(stackPage)->headSP = GIV(stackPointer));
	assert(pageListIsWellFormed());
	if ((((longAt((ctxt + BaseHeaderSize) + (SenderIndex << ShiftForWord))) & 1))
	 && (!(isWidowedContext(ctxt)))) {
		/* begin frameOfMarriedContext: */
		value = longAt((ctxt + BaseHeaderSize) + (SenderIndex << ShiftForWord));
		/* begin withoutSmallIntegerTags: */
		assert((value & 1));
		theFP = pointerForOop(value - 1);
		/* begin stackPageFor: */
		/* begin stackPageAt: */
		/* begin pageIndexFor: */
		assert((((((char *) theFP)) >= (GIV(stackBasePlus1) - 1)) && ((((char *) theFP)) <= (((char *) GIV(pages))))));
		index = pageIndexForstackBasePlus1bytesPerPage(theFP, GIV(stackBasePlus1), GIV(bytesPerPage));
		thePage = stackPageAtpages(index, GIV(pages));
		if (((onCurrentPage = thePage == GIV(stackPage)))
		 && (theFP == GIV(framePointer))) {
			/* begin primitiveFail */
			if (GIV(primFailCode) == 0) {
				GIV(primFailCode) = 1;
			}
			return;
		}
		externalDivorceFrameandContext(theFP, ctxt);
		if (onCurrentPage) {
			GIV(framePointer) = (GIV(stackPage)->headFP);
			GIV(stackPointer) = (GIV(stackPage)->headSP);
		}
		else {
			assert(GIV(stackPage) == (stackPageFor(GIV(framePointer))));
			markStackPageMostRecentlyUsed(GIV(stackPage));
		}
	}
	/* begin fetchStackPointerOf: */
	sp = longAt((ctxt + BaseHeaderSize) + (StackPointerIndex << ShiftForWord));
	if (!((sp & 1))) {
		stackp = 0;
		goto l1;
	}
	assert((ReceiverIndex + ((sp >> 1))) < (lengthOf(ctxt)));
	stackp = (sp >> 1);
l1:	/* end fetchStackPointerOf: */;
	for (i = (stackp + 1); i <= newStackp; i += 1) {
		longAtput((ctxt + BaseHeaderSize) + (((i + CtxtTempFrameStart) - 1) << ShiftForWord), GIV(nilObj));
	}
	/* begin storeStackPointerValue:inContext: */
	assert((ReceiverIndex + newStackp) < (lengthOf(ctxt)));
	longAtput((ctxt + BaseHeaderSize) + (StackPointerIndex << ShiftForWord), ((newStackp << 1) | 1));
	ensureContextIsExecutionSafeAfterAssignToStackPointer(ctxt);
	/* begin pop: */
	GIV(stackPointer) += 1 * BytesPerWord;
}

static void
primitiveStringAt(void)
{
	commonAt(1);
}

static void
primitiveStringAtPut(void)
{
	commonAtPut(1);
}


/*	
	<array> primReplaceFrom: start to: stop with: replacement 
	startingAt: repStart 
	<primitive: 105>
	 */

static void
primitiveStringReplace(void)
{   DECL_MAYBE_SQ_GLOBAL_STRUCT
    sqInt array;
    sqInt arrayFmt;
    sqInt arrayInstSize;
    sqInt ccIndex;
    sqInt ccIndex1;
    sqInt class;
    sqInt class1;
    sqInt classFormat;
    sqInt classFormat1;
    sqInt hdr;
    sqInt i;
    sqInt integerPointer;
    sqInt integerPointer1;
    sqInt integerPointer2;
    sqInt repl;
    sqInt replFmt;
    sqInt replInstSize;
    sqInt replStart;
    sqInt srcIndex;
    sqInt start;
    sqInt stop;
    sqInt sz;
    sqInt sz1;
    sqInt totalLength;
    sqInt valueWord;

	array = longAt(GIV(stackPointer) + (4 * BytesPerWord));
	/* begin stackIntegerValue: */
	integerPointer = longAt(GIV(stackPointer) + (3 * BytesPerWord));
	/* begin checkedIntegerValueOf: */
	if ((integerPointer & 1)) {
		start = (integerPointer >> 1);
		goto l3;
	}
	else {
		/* begin primitiveFail */
		if (GIV(primFailCode) == 0) {
			GIV(primFailCode) = 1;
		}
		start = 0;
		goto l3;
	}
l3:	/* end stackIntegerValue: */;
	/* begin stackIntegerValue: */
	integerPointer1 = longAt(GIV(stackPointer) + (2 * BytesPerWord));
	/* begin checkedIntegerValueOf: */
	if ((integerPointer1 & 1)) {
		stop = (integerPointer1 >> 1);
		goto l4;
	}
	else {
		/* begin primitiveFail */
		if (GIV(primFailCode) == 0) {
			GIV(primFailCode) = 1;
		}
		stop = 0;
		goto l4;
	}
l4:	/* end stackIntegerValue: */;
	repl = longAt(GIV(stackPointer) + (1 * BytesPerWord));
	/* begin stackIntegerValue: */
	integerPointer2 = longAt(GIV(stackPointer) + (0 * BytesPerWord));
	/* begin checkedIntegerValueOf: */
	if ((integerPointer2 & 1)) {
		replStart = (integerPointer2 >> 1);
		goto l5;
	}
	else {
		/* begin primitiveFail */
		if (GIV(primFailCode) == 0) {
			GIV(primFailCode) = 1;
		}
		replStart = 0;
		goto l5;
	}
l5:	/* end stackIntegerValue: */;
	if (!(GIV(primFailCode) == 0)) {
		/* begin primitiveFail */
		if (GIV(primFailCode) == 0) {
			GIV(primFailCode) = 1;
		}
		return;
	}
	if ((repl & 1)) {
		/* begin primitiveFail */
		if (GIV(primFailCode) == 0) {
			GIV(primFailCode) = 1;
		}
		return;
	}
	hdr = longAt(array);
	arrayFmt = (((usqInt) hdr) >> 8) & 15;
	/* begin lengthOf:baseHeader:format: */
	if ((hdr & TypeMask) == HeaderTypeSizeAndClass) {
		sz = (longAt(array - (BytesPerWord * 2))) & LongSizeMask;
	}
	else {
		sz = hdr & SizeMask;
	}
	sz -= hdr & Size4Bit;
	if (arrayFmt <= 4) {
		totalLength = ((usqInt) (sz - BaseHeaderSize)) >> ShiftForWord;
		goto l1;
	}
	if (arrayFmt < 8) {
		totalLength = ((usqInt) (sz - BaseHeaderSize)) >> 2;
		goto l1;
	}
	else {
		totalLength = (sz - BaseHeaderSize) - (arrayFmt & 3);
		goto l1;
	}
l1:	/* end lengthOf:baseHeader:format: */;
	/* begin fixedFieldsOf:format:length: */
	if ((arrayFmt > 4)
	 || (arrayFmt == 2)) {
		arrayInstSize = 0;
		goto l7;
	}
	if (arrayFmt < 2) {
		arrayInstSize = totalLength;
		goto l7;
	}
	/* begin fetchClassOfNonInt: */
	if (((ccIndex = (((usqInt) (longAt(array))) >> 12) & 31)) == 0) {
		class = (longAt(array - BaseHeaderSize)) & AllButTypeMask;
		goto l6;
	}
	else {
		class = longAt(((longAt((GIV(specialObjectsOop) + BaseHeaderSize) + (CompactClasses << ShiftForWord))) + BaseHeaderSize) + ((ccIndex - 1) << ShiftForWord));
		goto l6;
	}
l6:	/* end fetchClassOfNonInt: */;
	classFormat = (longAt((class + BaseHeaderSize) + (InstanceSpecificationIndex << ShiftForWord))) - 1;
	arrayInstSize = (((((usqInt) classFormat) >> 11) & 192) + ((((usqInt) classFormat) >> 2) & 63)) - 1;
l7:	/* end fixedFieldsOf:format:length: */;
	if (!((start >= 1)
		 && (((start - 1) <= stop)
 && ((stop + arrayInstSize) <= totalLength)))) {
		GIV(primFailCode) = PrimErrBadIndex; return;
	}
	hdr = longAt(repl);
	replFmt = (((usqInt) hdr) >> 8) & 15;
	/* begin lengthOf:baseHeader:format: */
	if ((hdr & TypeMask) == HeaderTypeSizeAndClass) {
		sz1 = (longAt(repl - (BytesPerWord * 2))) & LongSizeMask;
	}
	else {
		sz1 = hdr & SizeMask;
	}
	sz1 -= hdr & Size4Bit;
	if (replFmt <= 4) {
		totalLength = ((usqInt) (sz1 - BaseHeaderSize)) >> ShiftForWord;
		goto l2;
	}
	if (replFmt < 8) {
		totalLength = ((usqInt) (sz1 - BaseHeaderSize)) >> 2;
		goto l2;
	}
	else {
		totalLength = (sz1 - BaseHeaderSize) - (replFmt & 3);
		goto l2;
	}
l2:	/* end lengthOf:baseHeader:format: */;
	/* begin fixedFieldsOf:format:length: */
	if ((replFmt > 4)
	 || (replFmt == 2)) {
		replInstSize = 0;
		goto l9;
	}
	if (replFmt < 2) {
		replInstSize = totalLength;
		goto l9;
	}
	/* begin fetchClassOfNonInt: */
	if (((ccIndex1 = (((usqInt) (longAt(repl))) >> 12) & 31)) == 0) {
		class1 = (longAt(repl - BaseHeaderSize)) & AllButTypeMask;
		goto l8;
	}
	else {
		class1 = longAt(((longAt((GIV(specialObjectsOop) + BaseHeaderSize) + (CompactClasses << ShiftForWord))) + BaseHeaderSize) + ((ccIndex1 - 1) << ShiftForWord));
		goto l8;
	}
l8:	/* end fetchClassOfNonInt: */;
	classFormat1 = (longAt((class1 + BaseHeaderSize) + (InstanceSpecificationIndex << ShiftForWord))) - 1;
	replInstSize = (((((usqInt) classFormat1) >> 11) & 192) + ((((usqInt) classFormat1) >> 2) & 63)) - 1;
l9:	/* end fixedFieldsOf:format:length: */;
	if (!((replStart >= 1)
		 && ((((stop - start) + replStart) + replInstSize) <= totalLength))) {
		GIV(primFailCode) = PrimErrBadIndex; return;
	}
	if (arrayFmt < 8) {
		if (!(arrayFmt == replFmt)) {
			GIV(primFailCode) = PrimErrInappropriate; return;
		}
	}
	else {
		if (!((arrayFmt & 12) == (replFmt & 12))) {
			GIV(primFailCode) = PrimErrInappropriate; return;
		}
	}

	/* - 1 for 0-based access */

	srcIndex = (replStart + replInstSize) - 1;
	if (arrayFmt <= 4) {
		for (i = ((start + arrayInstSize) - 1); i <= ((stop + arrayInstSize) - 1); i += 1) {
			/* begin storePointer:ofObject:withValue: */
			if ((((usqInt) array)) < (((usqInt) GIV(youngStart)))) {
				possibleRootStoreIntovalue(array, longAt((repl + BaseHeaderSize) + (srcIndex << ShiftForWord)));
			}
			longAtput((array + BaseHeaderSize) + (i << ShiftForWord), longAt((repl + BaseHeaderSize) + (srcIndex << ShiftForWord)));
			srcIndex += 1;
		}
	}
	else {
		if (arrayFmt < 8) {
			for (i = ((start + arrayInstSize) - 1); i <= ((stop + arrayInstSize) - 1); i += 1) {
				/* begin storeLong32:ofObject:withValue: */
				valueWord = long32At((repl + BaseHeaderSize) + (srcIndex << 2));
				long32Atput((array + BaseHeaderSize) + (i << 2), valueWord);
				srcIndex += 1;
			}
		}
		else {
			for (i = ((start + arrayInstSize) - 1); i <= ((stop + arrayInstSize) - 1); i += 1) {
				byteAtput((array + BaseHeaderSize) + i, byteAt((repl + BaseHeaderSize) + srcIndex));
				srcIndex += 1;
			}
		}
	}
	/* begin pop: */
	GIV(stackPointer) += GIV(argumentCount) * BytesPerWord;
}

static void
primitiveSubtract(void)
{   DECL_MAYBE_SQ_GLOBAL_STRUCT
    sqInt integerResult;
    char *sp;

	/* begin pop2AndPushIntegerIfOK: */
	integerResult = (stackIntegerValue(1)) - (stackIntegerValue(0));
	if (GIV(primFailCode) == 0) {
		if ((integerResult ^ (integerResult << 1)) >= 0) {
			/* begin pop:thenPush: */
			longAtput(sp = GIV(stackPointer) + ((2 - 1) * BytesPerWord), ((integerResult << 1) | 1));
			GIV(stackPointer) = sp;
		}
		else {
			/* begin success: */
			if (!(0)) {
				if (GIV(primFailCode) == 0) {

					/* Don't overwrite an error code that has already been set. */

					GIV(primFailCode) = 1;
				}
			}
		}
	}
}


/*	Primitive arithmetic operations for large integers in 64 bit range */

EXPORT(void)
primitiveSubtractLargeIntegers(void)
{   DECL_MAYBE_SQ_GLOBAL_STRUCT
    sqLong integerArg;
    sqLong integerArgNegated;
    sqLong integerRcvr;
    sqInt oopResult;
    sqLong result;
    char *sp;

	integerArg = signed64BitValueOf(longAt(GIV(stackPointer) + (0 * BytesPerWord)));
	integerRcvr = signed64BitValueOf(longAt(GIV(stackPointer) + (1 * BytesPerWord)));
	if (!(GIV(primFailCode) == 0)) {
		return;
	}
	if (integerArg == 0) {
		result = integerRcvr;
	}
	else {

		/* Reverse the argument so that we can recycle the overflow code from addition.
			 But the most -ve 64-bit value can overflow, so check; 0 - most -ve = most -ve */

		integerArgNegated = 0 - integerArg;
		if (integerArgNegated == integerArg) {
			/* begin primitiveFail */
			if (GIV(primFailCode) == 0) {
				GIV(primFailCode) = 1;
			}
			return;
		}

		/* Now check overflow conditions. First is whether rcvr and arg are of the same sign.
			 If they are we need to check for overflow more carefully. */

		result = integerRcvr + integerArgNegated;
		if (!((integerRcvr ^ integerArgNegated) < 0)) {
			if ((integerRcvr ^ result) < 0) {
				/* begin primitiveFail */
				if (GIV(primFailCode) == 0) {
					GIV(primFailCode) = 1;
				}
				return;
			}
		}
	}
	oopResult = signed64BitIntegerFor(result);
	if (GIV(primFailCode) == 0) {
		/* begin pop:thenPush: */
		longAtput(sp = GIV(stackPointer) + ((2 - 1) * BytesPerWord), oopResult);
		GIV(stackPointer) = sp;
	}
}


/*	Primitive. Suspend the receiver, aProcess such that it can be executed
	again by sending #resume. If the given process is not currently running,
	take it off
	its corresponding list. The primitive returns the list the receiver was
	previously on.
 */

static void
primitiveSuspend(void)
{   DECL_MAYBE_SQ_GLOBAL_STRUCT
    sqInt firstLink;
    sqInt inInterpreter;
    sqInt lastLink;
    sqInt myList;
    sqInt nextLink;
    sqInt process;
    char *sp;
    char *sp1;
    sqInt tempLink;

	process = longAt(GIV(stackPointer));
	if (process == (longAt(((longAt(((longAt((GIV(specialObjectsOop) + BaseHeaderSize) + (SchedulerAssociation << ShiftForWord))) + BaseHeaderSize) + (ValueIndex << ShiftForWord))) + BaseHeaderSize) + (ActiveProcessIndex << ShiftForWord)))) {
		/* begin pop:thenPush: */
		longAtput(sp = GIV(stackPointer) + ((1 - 1) * BytesPerWord), GIV(nilObj));
		GIV(stackPointer) = sp;
		inInterpreter = GIV(instructionPointer) >= heapBase;
		transferTofrom(wakeHighestPriority(), CSSuspend);
		/* begin forProcessPrimitiveReturnToExecutivePostContextSwitch: */
		if (GIV(nextProfileTick) > 0) {
			checkProfileTick(GIV(newMethod));
		}
		returnToExecutivepostContextSwitch(inInterpreter, 1); return;
	}

	/* XXXX Fixme. We should really check whether myList is a kind of LinkedList or not
	but we can't easily so just do a quick check for nil which is the most common case. */

	myList = longAt((process + BaseHeaderSize) + (MyListIndex << ShiftForWord));
	if (myList == GIV(nilObj)) {
		/* begin primitiveFail */
		if (GIV(primFailCode) == 0) {
			GIV(primFailCode) = 1;
		}
		return;
	}
	/* begin removeProcess:fromList: */
	VM_LABEL(0removeProcessfromList);
	firstLink = longAt((myList + BaseHeaderSize) + (FirstLinkIndex << ShiftForWord));
	lastLink = longAt((myList + BaseHeaderSize) + (LastLinkIndex << ShiftForWord));
	if (process == firstLink) {
		nextLink = longAt((process + BaseHeaderSize) + (NextLinkIndex << ShiftForWord));
		/* begin storePointer:ofObject:withValue: */
		if ((((usqInt) myList)) < (((usqInt) GIV(youngStart)))) {
			possibleRootStoreIntovalue(myList, nextLink);
		}
		longAtput((myList + BaseHeaderSize) + (FirstLinkIndex << ShiftForWord), nextLink);
		if (process == lastLink) {
			/* begin storePointer:ofObject:withValue: */
			if ((((usqInt) myList)) < (((usqInt) GIV(youngStart)))) {
				possibleRootStoreIntovalue(myList, GIV(nilObj));
			}
			longAtput((myList + BaseHeaderSize) + (LastLinkIndex << ShiftForWord), GIV(nilObj));
		}
	}
	else {
		tempLink = firstLink;
			while (1) {
			if (tempLink == GIV(nilObj)) {
				/* begin success: */
				if (!(0)) {
					if (GIV(primFailCode) == 0) {

						/* Don't overwrite an error code that has already been set. */

						GIV(primFailCode) = 1;
					}
				}
				goto l1;
			}
			nextLink = longAt((tempLink + BaseHeaderSize) + (NextLinkIndex << ShiftForWord));
			if (nextLink == process) break;
			tempLink = longAt((tempLink + BaseHeaderSize) + (NextLinkIndex << ShiftForWord));
		}
		nextLink = longAt((process + BaseHeaderSize) + (NextLinkIndex << ShiftForWord));
		/* begin storePointer:ofObject:withValue: */
		if ((((usqInt) tempLink)) < (((usqInt) GIV(youngStart)))) {
			possibleRootStoreIntovalue(tempLink, nextLink);
		}
		longAtput((tempLink + BaseHeaderSize) + (NextLinkIndex << ShiftForWord), nextLink);
		if (process == lastLink) {
			/* begin storePointer:ofObject:withValue: */
			if ((((usqInt) myList)) < (((usqInt) GIV(youngStart)))) {
				possibleRootStoreIntovalue(myList, tempLink);
			}
			longAtput((myList + BaseHeaderSize) + (LastLinkIndex << ShiftForWord), tempLink);
		}
	}
	/* begin storePointer:ofObject:withValue: */
	if ((((usqInt) process)) < (((usqInt) GIV(youngStart)))) {
		possibleRootStoreIntovalue(process, GIV(nilObj));
	}
	longAtput((process + BaseHeaderSize) + (NextLinkIndex << ShiftForWord), GIV(nilObj));
l1:	/* end removeProcess:fromList: */;
	if (GIV(primFailCode) == 0) {
		/* begin storePointer:ofObject:withValue: */
		if ((((usqInt) process)) < (((usqInt) GIV(youngStart)))) {
			possibleRootStoreIntovalue(process, GIV(nilObj));
		}
		longAtput((process + BaseHeaderSize) + (MyListIndex << ShiftForWord), GIV(nilObj));
		/* begin pop:thenPush: */
		longAtput(sp1 = GIV(stackPointer) + ((1 - 1) * BytesPerWord), myList);
		GIV(stackPointer) = sp1;
	}
}


/*	Primitive. Terminate up the context stack from the receiver up to but not
	including the argument, if previousContext is on my Context stack. Make
	previousContext my
	sender. This prim has to shadow the code in ContextPart>terminateTo: to be
	correct. 
	Override to ensure the caller's saved ip is correct, i.e. if an
	interpreter frame it may
	have to move to iframeSavedIP. */

static void
primitiveTerminateTo(void)
{   DECL_MAYBE_SQ_GLOBAL_STRUCT
    sqInt aContextOrNil;
    sqInt callerContextOrNil;
    sqInt callerContextOrNil1;
    char *callerFP;
    char *callerFP1;
    char *callerFP2;
    char *contextsFP;
    usqInt contextsIP;
    char *contextsSP;
    sqInt currentCtx;
    char *fp;
    char *fp1;
    char *fp2;
    char *frameAbove;
    sqInt index;
    sqInt index1;
    sqInt index2;
    sqInt index3;
    sqInt index4;
    sqInt index5;
    char *newFP;
    char *newSP;
    sqInt nextCntx;
    StackPage *pageToStopOn;
    char *source;
    sqInt stackedReceiverOffset;
    char *theFP;
    char *theFP1;
    StackPage *thePage;
    StackPage *thePage1;
    StackPage *thePage2;
    sqInt thisCtx;
    sqInt value;
    sqInt value1;
    sqInt value2;
    sqInt value3;
    sqInt value4;
    sqInt value5;
    sqInt valuePointer;
    sqInt valuePointer1;

	aContextOrNil = longAt(GIV(stackPointer));
	if (!((aContextOrNil == GIV(nilObj))
		 || (((aContextOrNil & 1) == 0)
 && (((((usqInt) (longAt(aContextOrNil))) >> 12) & 31) == ClassMethodContextCompactIndex)))) {
		/* begin primitiveFail */
		if (GIV(primFailCode) == 0) {
			GIV(primFailCode) = 1;
		}
		return;
	}
	thisCtx = longAt(GIV(stackPointer) + (1 * BytesPerWord));
	if (thisCtx == aContextOrNil) {
		/* begin primitiveFail */
		if (GIV(primFailCode) == 0) {
			GIV(primFailCode) = 1;
		}
		return;
	}
	/* begin externalWriteBackHeadFramePointers */
	assert((GIV(framePointer) - GIV(stackPointer)) < LargeContextSize);
	assert(GIV(stackPage) == (mostRecentlyUsedPage()));
	/* begin setHeadFP:andSP:inPage: */
	assert(GIV(stackPointer) < GIV(framePointer));
	assert((GIV(stackPointer) < ((GIV(stackPage)->baseAddress)))
	 && (GIV(stackPointer) > (((GIV(stackPage)->realStackLimit)) - LargeContextSize)));
	assert((GIV(framePointer) < ((GIV(stackPage)->baseAddress)))
	 && (GIV(framePointer) > (((GIV(stackPage)->realStackLimit)) - (((sqInt) LargeContextSize >> 1)))));
	(GIV(stackPage)->headFP = GIV(framePointer));
	(GIV(stackPage)->headSP = GIV(stackPointer));
	assert(pageListIsWellFormed());
	if ((aContextOrNil != GIV(nilObj))
	 && ((((longAt((aContextOrNil + BaseHeaderSize) + (SenderIndex << ShiftForWord))) & 1))
 && (!(isWidowedContext(aContextOrNil))))) {
		/* begin frameOfMarriedContext: */
		value = longAt((aContextOrNil + BaseHeaderSize) + (SenderIndex << ShiftForWord));
		/* begin withoutSmallIntegerTags: */
		assert((value & 1));
		contextsFP = pointerForOop(value - 1);
		/* begin stackPageFor: */
		/* begin stackPageAt: */
		/* begin pageIndexFor: */
		assert((((((char *) contextsFP)) >= (GIV(stackBasePlus1) - 1)) && ((((char *) contextsFP)) <= (((char *) GIV(pages))))));
		index = pageIndexForstackBasePlus1bytesPerPage(contextsFP, GIV(stackBasePlus1), GIV(bytesPerPage));
		pageToStopOn = stackPageAtpages(index, GIV(pages));
	}
	else {
		pageToStopOn = 0;
	}
	if ((((longAt((thisCtx + BaseHeaderSize) + (SenderIndex << ShiftForWord))) & 1))
	 && (!(isWidowedContext(thisCtx)))) {
		/* begin frameOfMarriedContext: */
		value2 = longAt((thisCtx + BaseHeaderSize) + (SenderIndex << ShiftForWord));
		/* begin withoutSmallIntegerTags: */
		assert((value2 & 1));
		theFP = pointerForOop(value2 - 1);
		if ((theFP == GIV(framePointer))
		 && (pageToStopOn == GIV(stackPage))) {
			if ((frameCallerFP(theFP)) != contextsFP) {
				stackedReceiverOffset = (FoxCallerSavedIP + BytesPerWord) + ((((((usqInt)(longAt(theFP + FoxMethod)))) < heapBase
	? (mframeCogMethod(theFP)->cmNumArgs)
	: byteAt((theFP + FoxIFrameFlags) + 1))) << ShiftForWord);
				/* begin findFrameAbove:inPage: */
				fp = (pageToStopOn->headFP);
				if (fp == contextsFP) {
					frameAbove = 0;
					goto l1;
				}
				while (((callerFP = frameCallerFP(fp))) != 0) {
					if (callerFP == contextsFP) {
						frameAbove = fp;
						goto l1;
					}
					fp = callerFP;
				}
				error("did not find theFP in stack page");
				frameAbove = 0;
			l1:	/* end findFrameAbove:inPage: */;
				contextsIP = ((usqInt)(frameCallerSavedIP(frameAbove)));
				assert((((((usqInt)contextsIP)) >= (startOfMemory()))
 || (contextsIP == (ceReturnToInterpreterPC()))) == (!(isMachineCodeFrame(contextsFP))));
				/* begin frameCallerSP: */
				assert(!(isBaseFrame(frameAbove)));
				newSP = (frameAbove + ((FoxCallerSavedIP + BytesPerWord) + ((((((usqInt)(longAt(frameAbove + FoxMethod)))) < heapBase
	? (mframeCogMethod(frameAbove)->cmNumArgs)
	: byteAt((frameAbove + FoxIFrameFlags) + 1))) << ShiftForWord))) + BytesPerWord;
				newFP = (newSP - stackedReceiverOffset) - BytesPerWord;
				for (source = (theFP + stackedReceiverOffset); source >= GIV(stackPointer); source += (-BytesPerWord)) {
					newSP -= BytesPerWord;
					longAtput(newSP, longAt(source));
				}
				longAtput(newFP + FoxSavedFP, contextsFP);
				if (((((usqInt)(longAt(newFP + FoxMethod)))) < heapBase)
				 && (contextsIP >= heapBase)) {
					/* begin iframeSavedIP:put: */
					assert(!(isMachineCodeFrame(contextsFP)));
					longAtput(contextsFP + FoxIFSavedIP, contextsIP);
					contextsIP = ceReturnToInterpreterPC();
				}
				longAtput(newFP + FoxCallerSavedIP, contextsIP);
				assert(isContext(thisCtx));
				/* begin storePointerUnchecked:ofObject:withValue: */
				/* begin withSmallIntegerTags: */
				assert(((oopForPointer(newFP)) & (BytesPerWord - 1)) == 0);
				valuePointer = (oopForPointer(newFP)) + 1;
				longAtput((thisCtx + BaseHeaderSize) + (SenderIndex << ShiftForWord), valuePointer);
				/* begin storePointerUnchecked:ofObject:withValue: */
				/* begin withSmallIntegerTags: */
				assert(((oopForPointer(contextsFP)) & (BytesPerWord - 1)) == 0);
				valuePointer1 = (oopForPointer(contextsFP)) + 1;
				longAtput((thisCtx + BaseHeaderSize) + (InstructionPointerIndex << ShiftForWord), valuePointer1);
				GIV(framePointer) = newFP;
				GIV(stackPointer) = newSP;
			}
			/* begin pop: */
			GIV(stackPointer) += 1 * BytesPerWord;
			assert(GIV(stackPage) == (mostRecentlyUsedPage()));
			return;
		}

		/* May cause a GC!! */

		theFP = externalEnsureIsBaseFrame(theFP);
		/* begin frameCallerContext: */
		assert(isBaseFrame(theFP));
		/* begin stackPageFor: */
		/* begin stackPageAt: */
		/* begin pageIndexFor: */
		assert((((((char *) theFP)) >= (GIV(stackBasePlus1) - 1)) && ((((char *) theFP)) <= (((char *) GIV(pages))))));
		index2 = pageIndexForstackBasePlus1bytesPerPage(theFP, GIV(stackBasePlus1), GIV(bytesPerPage));
		thePage1 = stackPageAtpages(index2, GIV(pages));
		callerContextOrNil = longAt((thePage1->baseAddress));
		assert(addressCouldBeObj(callerContextOrNil));
		assert((callerContextOrNil == (nilObject()))
		 || (isContext(callerContextOrNil)));
		currentCtx = callerContextOrNil;
		if ((aContextOrNil != GIV(nilObj))
		 && ((((longAt((aContextOrNil + BaseHeaderSize) + (SenderIndex << ShiftForWord))) & 1))
 && (!(isWidowedContext(aContextOrNil))))) {
			/* begin frameOfMarriedContext: */
			value1 = longAt((aContextOrNil + BaseHeaderSize) + (SenderIndex << ShiftForWord));
			/* begin withoutSmallIntegerTags: */
			assert((value1 & 1));
			contextsFP = pointerForOop(value1 - 1);
			/* begin stackPageFor: */
			/* begin stackPageAt: */
			/* begin pageIndexFor: */
			assert((((((char *) contextsFP)) >= (GIV(stackBasePlus1) - 1)) && ((((char *) contextsFP)) <= (((char *) GIV(pages))))));
			index1 = pageIndexForstackBasePlus1bytesPerPage(contextsFP, GIV(stackBasePlus1), GIV(bytesPerPage));
			pageToStopOn = stackPageAtpages(index1, GIV(pages));
		}
		else {
			pageToStopOn = 0;
		}
	}
	else {
		currentCtx = longAt((thisCtx + BaseHeaderSize) + (SenderIndex << ShiftForWord));
	}
	if (contexthasSender(thisCtx, aContextOrNil)) {
		while (!((currentCtx == aContextOrNil)
 || (currentCtx == GIV(nilObj)))) {
			assert(isContext(currentCtx));
			if (((longAt((currentCtx + BaseHeaderSize) + (SenderIndex << ShiftForWord))) & 1)) {
				/* begin frameOfMarriedContext: */
				value4 = longAt((currentCtx + BaseHeaderSize) + (SenderIndex << ShiftForWord));
				/* begin withoutSmallIntegerTags: */
				assert((value4 & 1));
				theFP = pointerForOop(value4 - 1);
				/* begin stackPageFor: */
				/* begin stackPageAt: */
				/* begin pageIndexFor: */
				assert((((((char *) theFP)) >= (GIV(stackBasePlus1) - 1)) && ((((char *) theFP)) <= (((char *) GIV(pages))))));
				index5 = pageIndexForstackBasePlus1bytesPerPage(theFP, GIV(stackBasePlus1), GIV(bytesPerPage));
				thePage = stackPageAtpages(index5, GIV(pages));
				if (thePage == GIV(stackPage)) {
					/* begin findFrameAbove:inPage: */
					fp1 = (thePage->headFP);
					if (fp1 == theFP) {
						frameAbove = 0;
						goto l2;
					}
					while (((callerFP1 = frameCallerFP(fp1))) != 0) {
						if (callerFP1 == theFP) {
							frameAbove = fp1;
							goto l2;
						}
						fp1 = callerFP1;
					}
					error("did not find theFP in stack page");
					frameAbove = 0;
				l2:	/* end findFrameAbove:inPage: */;
					assert(frameAbove != 0);

					/* May cause a GC!! May also reclaim aContextOrNil's page, hence... */

					frameAbove = externalEnsureIsBaseFrame(frameAbove);
					if ((aContextOrNil != GIV(nilObj))
					 && ((((longAt((aContextOrNil + BaseHeaderSize) + (SenderIndex << ShiftForWord))) & 1))
 && (!(isWidowedContext(aContextOrNil))))) {
						/* begin frameOfMarriedContext: */
						value3 = longAt((aContextOrNil + BaseHeaderSize) + (SenderIndex << ShiftForWord));
						/* begin withoutSmallIntegerTags: */
						assert((value3 & 1));
						contextsFP = pointerForOop(value3 - 1);
						/* begin stackPageFor: */
						/* begin stackPageAt: */
						/* begin pageIndexFor: */
						assert((((((char *) contextsFP)) >= (GIV(stackBasePlus1) - 1)) && ((((char *) contextsFP)) <= (((char *) GIV(pages))))));
						index3 = pageIndexForstackBasePlus1bytesPerPage(contextsFP, GIV(stackBasePlus1), GIV(bytesPerPage));
						pageToStopOn = stackPageAtpages(index3, GIV(pages));
					}
					else {
						pageToStopOn = 0;
					}
				}
				else {
					if (thePage == pageToStopOn) {
						/* begin findFrameAbove:inPage: */
						fp2 = (thePage->headFP);
						if (fp2 == contextsFP) {
							frameAbove = 0;
							goto l3;
						}
						while (((callerFP2 = frameCallerFP(fp2))) != 0) {
							if (callerFP2 == contextsFP) {
								frameAbove = fp2;
								goto l3;
							}
							fp2 = callerFP2;
						}
						error("did not find theFP in stack page");
						frameAbove = 0;
					l3:	/* end findFrameAbove:inPage: */;
						if (frameAbove != 0) {
							contextsSP = (frameCallerSP(frameAbove)) - BytesPerWord;
							longAtput(contextsSP, frameCallerSavedIP(frameAbove));
							/* begin setHeadFP:andSP:inPage: */
							assert(contextsSP < contextsFP);
							assert((contextsSP < ((thePage->baseAddress)))
							 && (contextsSP > (((thePage->realStackLimit)) - LargeContextSize)));
							assert((contextsFP < ((thePage->baseAddress)))
							 && (contextsFP > (((thePage->realStackLimit)) - (((sqInt) LargeContextSize >> 1)))));
							(thePage->headFP = contextsFP);
							(thePage->headSP = contextsSP);
						}
						currentCtx = aContextOrNil;
					}
					else {
						/* begin frameCallerContext: */
						theFP1 = (thePage->baseFP);
						assert(isBaseFrame(theFP1));
						/* begin stackPageFor: */
						/* begin stackPageAt: */
						/* begin pageIndexFor: */
						assert((((((char *) theFP1)) >= (GIV(stackBasePlus1) - 1)) && ((((char *) theFP1)) <= (((char *) GIV(pages))))));
						index4 = pageIndexForstackBasePlus1bytesPerPage(theFP1, GIV(stackBasePlus1), GIV(bytesPerPage));
						thePage2 = stackPageAtpages(index4, GIV(pages));
						callerContextOrNil1 = longAt((thePage2->baseAddress));
						assert(addressCouldBeObj(callerContextOrNil1));
						assert((callerContextOrNil1 == (nilObject()))
						 || (isContext(callerContextOrNil1)));
						currentCtx = callerContextOrNil1;
						freeStackPageNoAssert(thePage);
					}
				}
			}
			else {
				nextCntx = longAt((currentCtx + BaseHeaderSize) + (SenderIndex << ShiftForWord));
				/* begin markContextAsDead: */
				assert(isContext(currentCtx));
				longAtput((currentCtx + BaseHeaderSize) + (SenderIndex << ShiftForWord), GIV(nilObj));
				longAtput((currentCtx + BaseHeaderSize) + (InstructionPointerIndex << ShiftForWord), GIV(nilObj));
				currentCtx = nextCntx;
			}
		}
	}
	assert(pageListIsWellFormed());
	if (((longAt((thisCtx + BaseHeaderSize) + (SenderIndex << ShiftForWord))) & 1)) {
		assert(checkIsStillMarriedContextcurrentFP(thisCtx, GIV(framePointer)));
		assert(isBaseFrame(frameOfMarriedContext(thisCtx)));
		/* begin frameOfMarriedContext: */
		value5 = longAt((thisCtx + BaseHeaderSize) + (SenderIndex << ShiftForWord));
		/* begin withoutSmallIntegerTags: */
		assert((value5 & 1));
		theFP = pointerForOop(value5 - 1);
		frameCallerContextput(theFP, aContextOrNil);
	}
	else {
		/* begin storePointer:ofObject:withValue: */
		if ((((usqInt) thisCtx)) < (((usqInt) GIV(youngStart)))) {
			possibleRootStoreIntovalue(thisCtx, aContextOrNil);
		}
		longAtput((thisCtx + BaseHeaderSize) + (SenderIndex << ShiftForWord), aContextOrNil);
	}
	/* begin pop: */
	GIV(stackPointer) += 1 * BytesPerWord;
	assert(GIV(stackPage) == (mostRecentlyUsedPage()));
}


/*	Attempt to test-and-set the ownership of the critical section. If not
	owned, set the owner to the current process and answer false. If owned by
	the current process answer true. If owned by some other process answer
	nil. For simulation if there is an argument it is taken to be the
	effective activeProcess
	(see Process>>effectiveProcess). */

static void
primitiveTestAndSetOwnershipOfCriticalSection(void)
{   DECL_MAYBE_SQ_GLOBAL_STRUCT
    sqInt activeProc;
    sqInt criticalSection;
    sqInt owningProcess;
    sqInt owningProcessIndex;
    char *sp;
    char *sp1;
    char *sp2;

	if (GIV(argumentCount) > 0) {

		/* rcvr */

		criticalSection = longAt(GIV(stackPointer) + (1 * BytesPerWord));
		activeProc = longAt(GIV(stackPointer));
	}
	else {

		/* rcvr */

		criticalSection = longAt(GIV(stackPointer));
		activeProc = longAt(((longAt(((longAt((GIV(specialObjectsOop) + BaseHeaderSize) + (SchedulerAssociation << ShiftForWord))) + BaseHeaderSize) + (ValueIndex << ShiftForWord))) + BaseHeaderSize) + (ActiveProcessIndex << ShiftForWord));
	}

	/* CriticalSections are laid out like Semaphores */

	owningProcessIndex = ExcessSignalsIndex;
	owningProcess = longAt((criticalSection + BaseHeaderSize) + (owningProcessIndex << ShiftForWord));
	if (owningProcess == GIV(nilObj)) {
		/* begin storePointer:ofObject:withValue: */
		if ((((usqInt) criticalSection)) < (((usqInt) GIV(youngStart)))) {
			possibleRootStoreIntovalue(criticalSection, activeProc);
		}
		longAtput((criticalSection + BaseHeaderSize) + (owningProcessIndex << ShiftForWord), activeProc);
		/* begin pop:thenPush: */
		longAtput(sp = GIV(stackPointer) + (((GIV(argumentCount) + 1) - 1) * BytesPerWord), GIV(falseObj));
		GIV(stackPointer) = sp;
		return;
	}
	if (owningProcess == activeProc) {
		/* begin pop:thenPush: */
		longAtput(sp1 = GIV(stackPointer) + (((GIV(argumentCount) + 1) - 1) * BytesPerWord), GIV(trueObj));
		GIV(stackPointer) = sp1;
		return;
	}
	/* begin pop:thenPush: */
	longAtput(sp2 = GIV(stackPointer) + (((GIV(argumentCount) + 1) - 1) * BytesPerWord), GIV(nilObj));
	GIV(stackPointer) = sp2;
}


/*	Return true if the host OS does support the given display depth. */

static void
primitiveTestDisplayDepth(void)
{   DECL_MAYBE_SQ_GLOBAL_STRUCT
    sqInt bitsPerPixel;
    sqInt integerPointer;
    sqInt okay;
    char *sp;

	/* begin stackIntegerValue: */
	integerPointer = longAt(GIV(stackPointer) + (0 * BytesPerWord));
	/* begin checkedIntegerValueOf: */
	if ((integerPointer & 1)) {
		bitsPerPixel = (integerPointer >> 1);
		goto l1;
	}
	else {
		/* begin primitiveFail */
		if (GIV(primFailCode) == 0) {
			GIV(primFailCode) = 1;
		}
		bitsPerPixel = 0;
		goto l1;
	}
l1:	/* end stackIntegerValue: */;
	if (GIV(primFailCode) == 0) {
		okay = ioHasDisplayDepth(bitsPerPixel);
	}
	if (GIV(primFailCode) == 0) {
		/* begin pop:thenPushBool: */
		longAtput(sp = GIV(stackPointer) + ((2 - 1) * BytesPerWord), (okay
			? GIV(trueObj)
			: GIV(falseObj)));
		GIV(stackPointer) = sp;
	}
}

static void
primitiveTimesTwoPower(void)
{   DECL_MAYBE_SQ_GLOBAL_STRUCT
    sqInt arg;
    sqInt ccIndex;
    double f;
    sqInt integerPointer;
    sqInt object;
    double rcvr;
    double result;
    char *sp;
    sqInt successBoolean;
    sqInt top;
    sqInt top1;
    sqInt top2;

	/* begin popInteger */
	/* begin popStack */
	top = longAt(GIV(stackPointer));
	GIV(stackPointer) += BytesPerWord;
	integerPointer = top;
	/* begin checkedIntegerValueOf: */
	if ((integerPointer & 1)) {
		arg = (integerPointer >> 1);
		goto l1;
	}
	else {
		/* begin primitiveFail */
		if (GIV(primFailCode) == 0) {
			GIV(primFailCode) = 1;
		}
		arg = 0;
		goto l1;
	}
l1:	/* end popInteger */;
	/* begin popFloat */
	VM_LABEL(7popFloat);
	/* begin popStack */
	top1 = longAt(GIV(stackPointer));
	GIV(stackPointer) += BytesPerWord;
	top2 = top1;
	/* begin assertClassOf:is:compactClassIndex: */
	VM_LABEL(53assertClassOfiscompactClassIndex);
	/* begin success: */
	/* begin is:instanceOf:compactClassIndex: */
	if ((top2 & 1)) {
		successBoolean = 0;
		goto l2;
	}
	ccIndex = (((usqInt) (longAt(top2))) >> 12) & 31;
	if (ClassFloatCompactIndex != 0) {
		successBoolean = ClassFloatCompactIndex == ccIndex;
		goto l2;
	}
	successBoolean = (ccIndex == 0)
	 && (((longAt(top2 - BaseHeaderSize)) & AllButTypeMask) == (longAt((GIV(specialObjectsOop) + BaseHeaderSize) + (ClassFloat << ShiftForWord))));
l2:	/* end is:instanceOf:compactClassIndex: */;
	if (!(successBoolean)) {
		if (GIV(primFailCode) == 0) {

			/* Don't overwrite an error code that has already been set. */

			GIV(primFailCode) = 1;
		}
	}
	if (GIV(primFailCode) == 0) {
		;
		fetchFloatAtinto(top2 + BaseHeaderSize, result);
	}
	rcvr = result;
	if (GIV(primFailCode) == 0) {
		/* begin pushFloat: */
		f = ldexp(rcvr, arg);
		/* begin push: */
		object = floatObjectOf(f);
		longAtput(sp = GIV(stackPointer) - BytesPerWord, object);
		GIV(stackPointer) = sp;
	}
	else {
		/* begin unPop: */
		GIV(stackPointer) -= 2 * BytesPerWord;
	}
}

static void
primitiveTruncated(void)
{   DECL_MAYBE_SQ_GLOBAL_STRUCT
    sqInt ccIndex;
    double frac;
    double rcvr;
    double result;
    sqInt successBoolean;
    sqInt top;
    sqInt top1;
    double trunc;

	/* begin popFloat */
	VM_LABEL(8popFloat);
	/* begin popStack */
	top1 = longAt(GIV(stackPointer));
	GIV(stackPointer) += BytesPerWord;
	top = top1;
	/* begin assertClassOf:is:compactClassIndex: */
	VM_LABEL(54assertClassOfiscompactClassIndex);
	/* begin success: */
	/* begin is:instanceOf:compactClassIndex: */
	if ((top & 1)) {
		successBoolean = 0;
		goto l1;
	}
	ccIndex = (((usqInt) (longAt(top))) >> 12) & 31;
	if (ClassFloatCompactIndex != 0) {
		successBoolean = ClassFloatCompactIndex == ccIndex;
		goto l1;
	}
	successBoolean = (ccIndex == 0)
	 && (((longAt(top - BaseHeaderSize)) & AllButTypeMask) == (longAt((GIV(specialObjectsOop) + BaseHeaderSize) + (ClassFloat << ShiftForWord))));
l1:	/* end is:instanceOf:compactClassIndex: */;
	if (!(successBoolean)) {
		if (GIV(primFailCode) == 0) {

			/* Don't overwrite an error code that has already been set. */

			GIV(primFailCode) = 1;
		}
	}
	if (GIV(primFailCode) == 0) {
		;
		fetchFloatAtinto(top + BaseHeaderSize, result);
	}
	rcvr = result;
	if (GIV(primFailCode) == 0) {
		frac = modf(rcvr, &trunc);
		flag("Dan");
		success((-1073741824.0 <= trunc) && (trunc <= 1073741823.0));
	}
	if (GIV(primFailCode) == 0) {
		pushInteger((sqInt) trunc);
	}
	else {
		/* begin unPop: */
		GIV(stackPointer) -= 1 * BytesPerWord;
	}
}


/*	Primitive. Unload the module with the given name. */
/*	Reloading of the module will happen *later* automatically, when a 
	function from it is called. This is ensured by invalidating current
	sessionID. 
 */

static void
primitiveUnloadModule(void)
{   DECL_MAYBE_SQ_GLOBAL_STRUCT
    sqInt moduleName;

	if (!(GIV(argumentCount) == 1)) {
		/* begin primitiveFail */
		if (GIV(primFailCode) == 0) {
			GIV(primFailCode) = 1;
		}
		return;
	}
	moduleName = longAt(GIV(stackPointer));
	if ((moduleName & 1)) {
		/* begin primitiveFail */
		if (GIV(primFailCode) == 0) {
			GIV(primFailCode) = 1;
		}
		return;
	}
	if (!(((moduleName & 1) == 0)
		 && (((((usqInt) (longAt(moduleName))) >> 8) & 15) >= 8))) {
		/* begin primitiveFail */
		if (GIV(primFailCode) == 0) {
			GIV(primFailCode) = 1;
		}
		return;
	}
	if (!(ioUnloadModuleOfLength(oopForPointer(firstIndexableField(moduleName)), byteSizeOf(moduleName)))) {
		/* begin primitiveFail */
		if (GIV(primFailCode) == 0) {
			GIV(primFailCode) = 1;
		}
		return;
	}
	flushExternalPrimitives();
	forceInterruptCheck();
	/* begin pop: */
	GIV(stackPointer) += 1 * BytesPerWord;
}


/*	Update the VMs notion of the current timezone. The VM sets its notion
	of the timezone once at start-up. If one wants the VM to keep its notion
	up-to-date arrange to invoke this primitive periodically. */

static void
primitiveUpdateTimezone(void)
{
	ioUpdateVMTimezone();
}


/*	Return the value of the microsecond clock as an integer. The microsecond
	clock is at
	least 60 bits wide which means it'll get to around August 38435 before it
	wraps around. */

static void
primitiveUTCMicrosecondClock(void)
{   DECL_MAYBE_SQ_GLOBAL_STRUCT
    sqInt oop;
    char *sp;

	/* begin pop:thenPush: */
	oop = positive64BitIntegerFor(ioUTCMicroseconds());
	longAtput(sp = GIV(stackPointer) + ((1 - 1) * BytesPerWord), oop);
	GIV(stackPointer) = sp;
}


/*	Behaviour depends on argument count:
	0 args:	return an Array of VM parameter values;
	1 arg:	return the indicated VM parameter;
	2 args:	set the VM indicated parameter.
	VM parameters are numbered as follows:
	1	end of old-space (0-based, read-only)
	2	end of young-space (read-only)
	3	end of memory (read-only)
	4	nil (was allocationCount (read-only))
	5	nil (was allocations between GCs (read-write)
	6	survivor count tenuring threshold (read-write)
	7	full GCs since startup (read-only)
	8	total milliseconds in full GCs since startup (read-only)
	9	incremental GCs since startup (read-only)
	10	total milliseconds in incremental GCs since startup (read-only)
	11	tenures of surving objects since startup (read-only)
	12-20 specific to the translating VM
	21	root table size (read-only)
	22	root table overflows since startup (read-only)
	23	bytes of extra memory to reserve for VM buffers, plugins, etc.
	24	memory threshold above which shrinking object memory (rw)
	25	memory headroom when growing object memory (rw)
	26 interruptChecksEveryNms - force an ioProcessEvents every N milliseconds
	(rw) 27	number of times mark loop iterated for current IGC/FGC (read-only)
	includes ALL marking
	28	number of times sweep loop iterated for current IGC/FGC (read-only)
	29	number of times make forward loop iterated for current IGC/FGC
	(read-only) 30	number of times compact move loop iterated for current
	IGC/FGC (read-only)
	31	number of grow memory requests (read-only)
	32	number of shrink memory requests (read-only)
	33	number of root table entries used for current IGC/FGC (read-only)
	34	number of allocations done before current IGC/FGC (read-only)
	35	number of survivor objects after current IGC/FGC (read-only)
	36 millisecond clock when current IGC/FGC completed (read-only)
	37 number of marked objects for Roots of the world, not including Root
	Table entries for current IGC/FGC (read-only)
	38 milliseconds taken by current IGC (read-only)
	39 Number of finalization signals for Weak Objects pending when current
	IGC/FGC completed (read-only)
	40 BytesPerWord for this image
	41 imageFormatVersion for the VM
	42	number of stack pages in use
	43	desired number of stack pages (stored in image file header, max 65535)
	44	size of eden, in bytes
	45	desired size of eden, in bytes (stored in image file header)
	46	machine code zone size, in bytes (Cog only; otherwise nil)
	47	desired machine code zone size (Cog only; otherwise nil)
	48	various header flags. See getCogVMFlags.
	49	max size the image promises to grow the external semaphore table to (0
	sets to default, which is 256 as of writing)
	50-55 nil; reserved for VM parameters that persist in the image (such as
	eden above)
	56	number of process switches since startup (read-only)
	57	number of ioProcessEvents calls since startup (read-only)
	58	number of ForceInterruptCheck calls since startup (read-only)
	59	number of check event calls since startup (read-only)
	60	number of stack page overflows since startup (read-only)
	61	number of stack page divorces since startup (read-only)
	62	compiled code compactions since startup (read-only; Cog only; otherwise
	nil) 63	total milliseconds in compiled code compactions since startup
	(read-only; Cog only; otherwise nil)
	64	the number of methods that currently have jitted machine-code
	
	Note: Thanks to Ian Piumarta for this primitive. */

static void
primitiveVMParameter(void)
{   DECL_MAYBE_SQ_GLOBAL_STRUCT
    sqInt arg;
    sqInt i;
    sqInt index;
    sqInt mem;
    sqInt paramsArraySize;
    sqInt result;
    char *sp;
    char *sp1;
    char *sp2;
    sqInt valuePointer;
    sqInt valuePointer1;
    sqInt valuePointer2;
    sqInt valuePointer3;
    sqInt valuePointer4;
    sqInt valuePointer5;
    sqInt valuePointer6;
    sqInt valuePointer7;
    sqInt valuePointer8;
    sqInt valuePointer9;

	mem = heapBase;
	paramsArraySize = 64;
	if (GIV(argumentCount) == 0) {
		result = instantiateClassindexableSize(longAt((GIV(specialObjectsOop) + BaseHeaderSize) + (ClassArray << ShiftForWord)), paramsArraySize);
		/* begin storePointerUnchecked:ofObject:withValue: */
		valuePointer = ((((youngStart()) - mem) << 1) | 1);
		longAtput((result + BaseHeaderSize) + (0 << ShiftForWord), valuePointer);
		longAtput((result + BaseHeaderSize) + (1 << ShiftForWord), (((GIV(freeStart) - mem) << 1) | 1));
		longAtput((result + BaseHeaderSize) + (2 << ShiftForWord), (((GIV(endOfMemory) - mem) << 1) | 1));
		longAtput((result + BaseHeaderSize) + (3 << ShiftForWord), GIV(nilObj));
		longAtput((result + BaseHeaderSize) + (4 << ShiftForWord), GIV(nilObj));
		longAtput((result + BaseHeaderSize) + (5 << ShiftForWord), ((GIV(tenuringThreshold) << 1) | 1));
		longAtput((result + BaseHeaderSize) + (6 << ShiftForWord), ((GIV(statFullGCs) << 1) | 1));
		longAtput((result + BaseHeaderSize) + (7 << ShiftForWord), ((((GIV(statFullGCUsecs) + 500) / 1000) << 1) | 1));
		longAtput((result + BaseHeaderSize) + (8 << ShiftForWord), ((GIV(statIncrGCs) << 1) | 1));
		longAtput((result + BaseHeaderSize) + (9 << ShiftForWord), ((((GIV(statIncrGCUsecs) + 500) / 1000) << 1) | 1));
		longAtput((result + BaseHeaderSize) + (10 << ShiftForWord), ((GIV(statTenures) << 1) | 1));
		for (i = 11; i <= 19; i += 1) {
			longAtput((result + BaseHeaderSize) + (i << ShiftForWord), ConstZero);
		}
		longAtput((result + BaseHeaderSize) + (20 << ShiftForWord), ((GIV(rootTableCount) << 1) | 1));
		longAtput((result + BaseHeaderSize) + (21 << ShiftForWord), ((GIV(statRootTableOverflows) << 1) | 1));
		longAtput((result + BaseHeaderSize) + (22 << ShiftForWord), ((extraVMMemory << 1) | 1));
		longAtput((result + BaseHeaderSize) + (23 << ShiftForWord), ((GIV(shrinkThreshold) << 1) | 1));
		longAtput((result + BaseHeaderSize) + (24 << ShiftForWord), ((GIV(growHeadroom) << 1) | 1));
		/* begin storePointerUnchecked:ofObject:withValue: */
		valuePointer1 = (((ioHeartbeatMilliseconds()) << 1) | 1);
		longAtput((result + BaseHeaderSize) + (25 << ShiftForWord), valuePointer1);
		longAtput((result + BaseHeaderSize) + (26 << ShiftForWord), ((GIV(statMarkCount) << 1) | 1));
		longAtput((result + BaseHeaderSize) + (27 << ShiftForWord), ((GIV(statSweepCount) << 1) | 1));
		longAtput((result + BaseHeaderSize) + (28 << ShiftForWord), ((GIV(statMkFwdCount) << 1) | 1));
		longAtput((result + BaseHeaderSize) + (29 << ShiftForWord), ((GIV(statCompMoveCount) << 1) | 1));
		longAtput((result + BaseHeaderSize) + (30 << ShiftForWord), ((GIV(statGrowMemory) << 1) | 1));
		longAtput((result + BaseHeaderSize) + (31 << ShiftForWord), ((GIV(statShrinkMemory) << 1) | 1));
		longAtput((result + BaseHeaderSize) + (32 << ShiftForWord), ((GIV(statRootTableCount) << 1) | 1));
		longAtput((result + BaseHeaderSize) + (33 << ShiftForWord), GIV(nilObj));
		longAtput((result + BaseHeaderSize) + (34 << ShiftForWord), ((GIV(statSurvivorCount) << 1) | 1));
		longAtput((result + BaseHeaderSize) + (35 << ShiftForWord), ((((GIV(statGCEndUsecs) / 1000) & MillisecondClockMask) << 1) | 1));
		longAtput((result + BaseHeaderSize) + (36 << ShiftForWord), ((GIV(statSpecialMarkCount) << 1) | 1));
		longAtput((result + BaseHeaderSize) + (37 << ShiftForWord), ((((GIV(statIGCDeltaUsecs) + 500) / 1000) << 1) | 1));
		longAtput((result + BaseHeaderSize) + (38 << ShiftForWord), ((GIV(statPendingFinalizationSignals) << 1) | 1));
		longAtput((result + BaseHeaderSize) + (39 << ShiftForWord), ((BytesPerWord << 1) | 1));
		/* begin storePointerUnchecked:ofObject:withValue: */
		valuePointer2 = ((((BytesPerWord == 4
	? 6505
	: 68003)) << 1) | 1);
		longAtput((result + BaseHeaderSize) + (40 << ShiftForWord), valuePointer2);
		longAtput((result + BaseHeaderSize) + (41 << ShiftForWord), ((GIV(numStackPages) << 1) | 1));
		longAtput((result + BaseHeaderSize) + (42 << ShiftForWord), ((desiredNumStackPages << 1) | 1));
		longAtput((result + BaseHeaderSize) + (43 << ShiftForWord), ((GIV(edenBytes) << 1) | 1));
		longAtput((result + BaseHeaderSize) + (44 << ShiftForWord), ((desiredEdenBytes << 1) | 1));
		/* begin storePointerUnchecked:ofObject:withValue: */
		valuePointer3 = getCogCodeSize();
		longAtput((result + BaseHeaderSize) + (45 << ShiftForWord), valuePointer3);
		/* begin storePointerUnchecked:ofObject:withValue: */
		valuePointer4 = getDesiredCogCodeSize();
		longAtput((result + BaseHeaderSize) + (46 << ShiftForWord), valuePointer4);
		/* begin storePointerUnchecked:ofObject:withValue: */
		valuePointer5 = (((((((GIV(processHasThreadId)
	? 1
	: 0)) + ((GIV(flagInterpretedMethods)
	? 2
	: 0))) + ((GIV(preemptionYields)
	? 0
	: 4))) + ((GIV(noThreadingOfGUIThread)
	? 8
	: 0))) << 1) | 1);
		longAtput((result + BaseHeaderSize) + (47 << ShiftForWord), valuePointer5);
		/* begin storePointerUnchecked:ofObject:withValue: */
		valuePointer6 = (((ioGetMaxExtSemTableSize()) << 1) | 1);
		longAtput((result + BaseHeaderSize) + (48 << ShiftForWord), valuePointer6);
		for (i = 49; i <= 54; i += 1) {
			longAtput((result + BaseHeaderSize) + (i << ShiftForWord), GIV(nilObj));
		}
		longAtput((result + BaseHeaderSize) + (55 << ShiftForWord), ((GIV(statProcessSwitch) << 1) | 1));
		longAtput((result + BaseHeaderSize) + (56 << ShiftForWord), ((GIV(statIOProcessEvents) << 1) | 1));
		longAtput((result + BaseHeaderSize) + (57 << ShiftForWord), ((GIV(statForceInterruptCheck) << 1) | 1));
		longAtput((result + BaseHeaderSize) + (58 << ShiftForWord), ((GIV(statCheckForEvents) << 1) | 1));
		longAtput((result + BaseHeaderSize) + (59 << ShiftForWord), ((GIV(statStackOverflow) << 1) | 1));
		longAtput((result + BaseHeaderSize) + (60 << ShiftForWord), ((GIV(statStackPageDivorce) << 1) | 1));
		/* begin storePointerUnchecked:ofObject:withValue: */
		valuePointer7 = getCodeCompactionCount();
		longAtput((result + BaseHeaderSize) + (61 << ShiftForWord), valuePointer7);
		/* begin storePointerUnchecked:ofObject:withValue: */
		valuePointer8 = getCodeCompactionMSecs();
		longAtput((result + BaseHeaderSize) + (62 << ShiftForWord), valuePointer8);
		/* begin storePointerUnchecked:ofObject:withValue: */
		valuePointer9 = (((numMethodsOfType(CMMethod)) << 1) | 1);
		longAtput((result + BaseHeaderSize) + (63 << ShiftForWord), valuePointer9);
		/* begin pop:thenPush: */
		longAtput(sp = GIV(stackPointer) + ((1 - 1) * BytesPerWord), result);
		GIV(stackPointer) = sp;
		return;
	}
	arg = longAt(GIV(stackPointer));
	if (!((arg & 1))) {
		GIV(primFailCode) = PrimErrBadArgument; return;
	}
	arg = (arg >> 1);
	if (GIV(argumentCount) == 1) {
		if ((arg < 1)
		 || (arg > paramsArraySize)) {
			GIV(primFailCode) = PrimErrBadIndex; return;
		}
		result = GIV(nilObj);
		if (arg == 1) {
			result = ((((youngStart()) - mem) << 1) | 1);
		}
		if (arg == 2) {
			result = (((GIV(freeStart) - mem) << 1) | 1);
		}
		if (arg == 3) {
			result = (((GIV(endOfMemory) - mem) << 1) | 1);
		}
		if (arg == 4) {

			/* was allocationCount */

			result = GIV(nilObj);
		}
		if (arg == 5) {

			/* was allocationsBetweenGCs */

			result = GIV(nilObj);
		}
		if (arg == 6) {
			result = ((GIV(tenuringThreshold) << 1) | 1);
		}
		if (arg == 7) {
			result = ((GIV(statFullGCs) << 1) | 1);
		}
		if (arg == 8) {
			result = ((((GIV(statFullGCUsecs) + 500) / 1000) << 1) | 1);
		}
		if (arg == 9) {
			result = ((GIV(statIncrGCs) << 1) | 1);
		}
		if (arg == 10) {
			result = ((((GIV(statIncrGCUsecs) + 500) / 1000) << 1) | 1);
		}
		if (arg == 11) {
			result = ((GIV(statTenures) << 1) | 1);
		}
		if (((arg >= 12) && (arg <= 20))) {
			result = ConstZero;
		}
		if (arg == 21) {
			result = ((GIV(rootTableCount) << 1) | 1);
		}
		if (arg == 22) {
			result = ((GIV(statRootTableOverflows) << 1) | 1);
		}
		if (arg == 23) {
			result = ((extraVMMemory << 1) | 1);
		}
		if (arg == 24) {
			result = ((GIV(shrinkThreshold) << 1) | 1);
		}
		if (arg == 25) {
			result = ((GIV(growHeadroom) << 1) | 1);
		}
		if (arg == 26) {
			result = (((ioHeartbeatMilliseconds()) << 1) | 1);
		}
		if (arg == 27) {
			result = ((GIV(statMarkCount) << 1) | 1);
		}
		if (arg == 28) {
			result = ((GIV(statSweepCount) << 1) | 1);
		}
		if (arg == 29) {
			result = ((GIV(statMkFwdCount) << 1) | 1);
		}
		if (arg == 30) {
			result = ((GIV(statCompMoveCount) << 1) | 1);
		}
		if (arg == 31) {
			result = ((GIV(statGrowMemory) << 1) | 1);
		}
		if (arg == 32) {
			result = ((GIV(statShrinkMemory) << 1) | 1);
		}
		if (arg == 33) {
			result = ((GIV(statRootTableCount) << 1) | 1);
		}
		if (arg == 34) {

			/* was statAllocationCount */

			result = GIV(nilObj);
		}
		if (arg == 35) {
			result = ((GIV(statSurvivorCount) << 1) | 1);
		}
		if (arg == 36) {
			result = ((((GIV(statGCEndUsecs) / 1000) & MillisecondClockMask) << 1) | 1);
		}
		if (arg == 37) {
			result = ((GIV(statSpecialMarkCount) << 1) | 1);
		}
		if (arg == 38) {
			result = ((((GIV(statIGCDeltaUsecs) + 500) / 1000) << 1) | 1);
		}
		if (arg == 39) {
			result = ((GIV(statPendingFinalizationSignals) << 1) | 1);
		}
		if (arg == 40) {
			result = ((BytesPerWord << 1) | 1);
		}
		if (arg == 41) {
			result = ((((BytesPerWord == 4
	? 6505
	: 68003)) << 1) | 1);
		}
		if (arg == 42) {
			result = ((GIV(numStackPages) << 1) | 1);
		}
		if (arg == 43) {
			result = ((desiredNumStackPages << 1) | 1);
		}
		if (arg == 44) {
			result = ((GIV(edenBytes) << 1) | 1);
		}
		if (arg == 45) {
			result = ((desiredEdenBytes << 1) | 1);
		}
		if (arg == 46) {
			result = getCogCodeSize();
		}
		if (arg == 47) {
			result = getDesiredCogCodeSize();
		}
		if (arg == 48) {
			result = (((((((GIV(processHasThreadId)
	? 1
	: 0)) + ((GIV(flagInterpretedMethods)
	? 2
	: 0))) + ((GIV(preemptionYields)
	? 0
	: 4))) + ((GIV(noThreadingOfGUIThread)
	? 8
	: 0))) << 1) | 1);
		}
		if (arg == 49) {
			result = (((ioGetMaxExtSemTableSize()) << 1) | 1);
		}
		if (((arg >= 50) && (arg <= 55))) {
			result = GIV(nilObj);
		}
		if (arg == 56) {
			result = ((GIV(statProcessSwitch) << 1) | 1);
		}
		if (arg == 57) {
			result = ((GIV(statIOProcessEvents) << 1) | 1);
		}
		if (arg == 58) {
			result = ((GIV(statForceInterruptCheck) << 1) | 1);
		}
		if (arg == 59) {
			result = ((GIV(statCheckForEvents) << 1) | 1);
		}
		if (arg == 60) {
			result = ((GIV(statStackOverflow) << 1) | 1);
		}
		if (arg == 61) {
			result = ((GIV(statStackPageDivorce) << 1) | 1);
		}
		if (arg == 62) {
			result = getCodeCompactionCount();
		}
		if (arg == 63) {
			result = getCodeCompactionMSecs();
		}
		if (arg == 64) {
			result = (((numMethodsOfType(CMMethod)) << 1) | 1);
		}
		/* begin pop:thenPush: */
		longAtput(sp1 = GIV(stackPointer) + ((2 - 1) * BytesPerWord), result);
		GIV(stackPointer) = sp1;
		return;
	}
	if (!(GIV(argumentCount) == 2)) {
		GIV(primFailCode) = PrimErrBadNumArgs; return;
	}
	index = longAt(GIV(stackPointer) + (1 * BytesPerWord));
	if (!((index & 1))) {
		GIV(primFailCode) = PrimErrBadArgument; return;
	}
	index = (index >> 1);
	if ((index <= 0)
	 || (index > 63)) {
		GIV(primFailCode) = PrimErrBadIndex; return;
	}
	/* begin success: */
	if (!(0)) {
		if (GIV(primFailCode) == 0) {

			/* Don't overwrite an error code that has already been set. */

			GIV(primFailCode) = 1;
		}
	}
	if (index == 5) {

		/* Was:
		result := allocationsBetweenGCs.
		allocationsBetweenGCs := arg. */
		/* Ignore for now, because old images won't start up otherwise.
		 See 44 & 45 for eden size setting. */

		result = GIV(nilObj);
		/* begin initPrimCall */
		GIV(primFailCode) = 0;
	}
	if (index == 6) {
		result = GIV(tenuringThreshold);
		GIV(tenuringThreshold) = arg;
		/* begin initPrimCall */
		GIV(primFailCode) = 0;
	}
	if (index == 23) {
		result = extraVMMemory;
		extraVMMemory = arg;
		/* begin initPrimCall */
		GIV(primFailCode) = 0;
	}
	if (index == 24) {
		result = GIV(shrinkThreshold);
		if (arg > 0) {
			GIV(shrinkThreshold) = arg;
			/* begin initPrimCall */
			GIV(primFailCode) = 0;
		}
	}
	if (index == 25) {
		result = GIV(growHeadroom);
		if (arg > 0) {
			GIV(growHeadroom) = arg;
			/* begin initPrimCall */
			GIV(primFailCode) = 0;
		}
	}
	if (index == 26) {
		if (arg > 1) {
			result = ioHeartbeatMilliseconds();
			ioSetHeartbeatMilliseconds(arg);
			/* begin initPrimCall */
			GIV(primFailCode) = 0;
		}
	}
	if (index == 43) {
		if ((arg >= 0)
		 && (arg <= 65535)) {
			result = desiredNumStackPages;
			desiredNumStackPages = arg;
			/* begin initPrimCall */
			GIV(primFailCode) = 0;
		}
	}
	if (index == 45) {
		if (arg >= 0) {
			result = desiredEdenBytes;
			desiredEdenBytes = arg;
			/* begin initPrimCall */
			GIV(primFailCode) = 0;
		}
	}
	if ((index == 47)
	 && (1)) {
		if (arg >= 0) {
			result = getDesiredCogCodeSize();
			setDesiredCogCodeSize(arg);
			/* begin initPrimCall */
			GIV(primFailCode) = 0;
		}
	}
	if ((index == 48)
	 && (1)) {
		if (arg >= 0) {
			result = (((((((GIV(processHasThreadId)
	? 1
	: 0)) + ((GIV(flagInterpretedMethods)
	? 2
	: 0))) + ((GIV(preemptionYields)
	? 0
	: 4))) + ((GIV(noThreadingOfGUIThread)
	? 8
	: 0))) << 1) | 1);
			/* begin initPrimCall */
			GIV(primFailCode) = 0;
			/* begin setCogVMFlags: */
			if ((((usqInt)arg)) > 15) {
				GIV(primFailCode) = PrimErrUnsupported;
				goto l1;
			}
			GIV(processHasThreadId) = (arg & 1) != 0;
			GIV(flagInterpretedMethods) = (arg & 2) != 0;
			GIV(preemptionYields) = (arg & 4) == 0;
			GIV(noThreadingOfGUIThread) = (arg & 8) != 0;
		l1:	/* end setCogVMFlags: */;
		}
	}
	if (index == 49) {
		if ((arg >= 0)
		 && (arg <= 65535)) {
			result = ioGetMaxExtSemTableSize();
			/* begin initPrimCall */
			GIV(primFailCode) = 0;
			/* begin setMaxExtSemSizeTo: */
			GIV(maxExtSemTabSizeSet) = 1;
			ioSetMaxExtSemTableSize(arg);
		}
	}
	if (GIV(primFailCode) == 0) {
		/* begin pop:thenPush: */
		longAtput(sp2 = GIV(stackPointer) + ((3 - 1) * BytesPerWord), ((result << 1) | 1));
		GIV(stackPointer) = sp2;
		return;
	}
	GIV(primFailCode) = PrimErrInappropriate;
}


/*	Return a string containing the path name of VM's directory. */

static void
primitiveVMPath(void)
{   DECL_MAYBE_SQ_GLOBAL_STRUCT
    sqInt s;
    char *sp;
    sqInt sz;

	sz = vmPathSize();
	s = instantiateClassindexableSize(longAt((GIV(specialObjectsOop) + BaseHeaderSize) + (ClassString << ShiftForWord)), sz);
	vmPathGetLength(s + BaseHeaderSize, sz);
	/* begin pop:thenPush: */
	longAtput(sp = GIV(stackPointer) + ((1 - 1) * BytesPerWord), s);
	GIV(stackPointer) = sp;
}


/*	Primitive.
	0 args: Answer whether the VM Profiler is running or not.
	1 arg:	Copy the sample data into the supplied argument, which must be a
	Bitmap of suitable size. Answer the number of samples copied into the
	buffer.  */

static void
primitiveVMProfileSamplesInto(void)
{   DECL_MAYBE_SQ_GLOBAL_STRUCT
    long bufferSize;
    sqInt ccIndex;
    sqInt cl;
    sqInt numSamples;
    sqInt oop;
    sqInt running;
    sqInt sampleBuffer;
    unsigned long *sampleBufferAddress;
    char *sp;
    char *sp1;
    sqInt successBoolean;
    sqInt successBoolean1;

	ioNewProfileStatus(&running,&bufferSize);
	if (GIV(argumentCount) == 0) {
		/* begin pop:thenPushBool: */
		longAtput(sp = GIV(stackPointer) + ((1 - 1) * BytesPerWord), (running
			? GIV(trueObj)
			: GIV(falseObj)));
		GIV(stackPointer) = sp;
		return;
	}
	/* begin success: */
	if (!(GIV(argumentCount) == 1)) {
		if (GIV(primFailCode) == 0) {

			/* Don't overwrite an error code that has already been set. */

			GIV(primFailCode) = 1;
		}
	}
	if (GIV(primFailCode) == 0) {
		/* begin stackObjectValue: */
		oop = longAt(GIV(stackPointer) + (0 * BytesPerWord));
		if ((oop & 1)) {
			/* begin primitiveFail */
			if (GIV(primFailCode) == 0) {
				GIV(primFailCode) = 1;
			}
			sampleBuffer = null;
			goto l1;
		}
		sampleBuffer = oop;
	l1:	/* end stackObjectValue: */;
		/* begin assertClassOf:is: */
		/* begin success: */
		/* begin isClassOfNonImm:equalTo: */
		if ((sampleBuffer & 1)) {
			successBoolean = 0;
			goto l2;
		}
		cl = (((ccIndex = (((usqInt) (longAt(sampleBuffer))) >> 12) & 31)) == 0
			? (longAt(sampleBuffer - BaseHeaderSize)) & AllButTypeMask
			: longAt(((longAt((GIV(specialObjectsOop) + BaseHeaderSize) + (CompactClasses << ShiftForWord))) + BaseHeaderSize) + ((ccIndex - 1) << ShiftForWord)));
		successBoolean = cl == (longAt((GIV(specialObjectsOop) + BaseHeaderSize) + (ClassBitmap << ShiftForWord)));
	l2:	/* end isClassOfNonImm:equalTo: */;
		if (!(successBoolean)) {
			if (GIV(primFailCode) == 0) {

				/* Don't overwrite an error code that has already been set. */

				GIV(primFailCode) = 1;
			}
		}
		/* begin success: */
		successBoolean1 = (fetchWordLengthOf(sampleBuffer)) >= bufferSize;
		if (!(successBoolean1)) {
			if (GIV(primFailCode) == 0) {

				/* Don't overwrite an error code that has already been set. */

				GIV(primFailCode) = 1;
			}
		}
	}
	if (!(GIV(primFailCode) == 0)) {
		return;
	}
	/* begin firstFixedField: */
	sampleBufferAddress = ((void *) (pointerForOop(sampleBuffer + BaseHeaderSize)));
	numSamples = ioNewProfileSamplesInto(sampleBufferAddress);
	/* begin pop:thenPushInteger: */
	longAtput(sp1 = GIV(stackPointer) + (((GIV(argumentCount) + 1) - 1) * BytesPerWord), ((numSamples << 1) | 1));
	GIV(stackPointer) = sp1;
}


/*	Potentially crash the VM by voiding the receiver. A subsequent inst var
	access in the caller's frame should indirect through a null pointer. */

EXPORT(void)
primitiveVoidReceiver(void)
{   DECL_MAYBE_SQ_GLOBAL_STRUCT
	longAtput(((((usqInt)(longAt(GIV(framePointer) + FoxMethod)))) < heapBase
		? GIV(framePointer) + FoxMFReceiver
		: GIV(framePointer) + FoxIFReceiver), 0);
}


/*	Void all internal VM state in the stack and machine code zones
	
	Override to jump to the interpreter because the machine code zone is now
	void. 
 */

static void
primitiveVoidVMState(void)
{   DECL_MAYBE_SQ_GLOBAL_STRUCT
    sqInt activeContext;
    sqInt activeContext1;
    sqInt aMethodObj;
    sqInt decodedIP;
    sqInt header;
    StackPage *newPage;
    sqInt oop;
    char *sp;
    sqInt sz;
    char *theFP;
    sqInt top;

	/* begin push: */
	longAtput(sp = GIV(stackPointer) - BytesPerWord, GIV(instructionPointer));
	GIV(stackPointer) = sp;
	/* begin voidVMStateForSnapshot */

	/* in case of code compactions. */

	GIV(instructionPointer) = 0;
	activeContext1 = divorceAllFrames();
	/* begin ensureAllContextsHaveBytecodePCsOrAreBereaved */
	VM_LABEL(2ensureAllContextsHaveBytecodePCsOrAreBereaved);
	oop = heapBase + (headerTypeBytes[(longAt(heapBase)) & TypeMask]);
	while (oop < GIV(freeStart)) {
		if ((!(((longAt(oop)) & TypeMask) == HeaderTypeFree))
		 && (((((usqInt) (longAt(oop))) >> 12) & 31) == ClassMethodContextCompactIndex)) {
			if (((longAt((oop + BaseHeaderSize) + (SenderIndex << ShiftForWord))) & 1)) {
				/* begin markContextAsDead: */
				assert(isContext(oop));
				longAtput((oop + BaseHeaderSize) + (SenderIndex << ShiftForWord), GIV(nilObj));
				longAtput((oop + BaseHeaderSize) + (InstructionPointerIndex << ShiftForWord), GIV(nilObj));
			}
			else {
				decodedIP = longAt((oop + BaseHeaderSize) + (InstructionPointerIndex << ShiftForWord));
				if (((decodedIP & 1))
				 && ((((sqInt) decodedIP)) < 0)) {
					decodedIP = mustMapMachineCodePCcontext((decodedIP >> 1), oop);
					longAtput((oop + BaseHeaderSize) + (InstructionPointerIndex << ShiftForWord), decodedIP);
				}
			}
		}
		/* begin objectAfter: */
		if (DoAssertionChecks) {
			if ((((usqInt) oop)) >= (((usqInt) GIV(endOfMemory)))) {
				error("no objects after the end of memory");
			}
		}
		if (((longAt(oop)) & TypeMask) == HeaderTypeFree) {
			sz = (longAt(oop)) & AllButTypeMask;
		}
		else {
			/* begin sizeBitsOf: */
			header = longAt(oop);
			sz = ((header & TypeMask) == HeaderTypeSizeAndClass
				? (longAt(oop - (BytesPerWord * 2))) & LongSizeMask
				: header & SizeMask);
		}
		oop = (oop + sz) + (headerTypeBytes[(longAt(oop + sz)) & TypeMask]);
	}
	voidCogCompiledCode();
	activeContext = activeContext1;
	/* begin marryContextInNewStackPageAndInitializeInterpreterRegisters: */
	assert(GIV(stackPage) == 0);
	newPage = makeBaseFrameFor(activeContext);
	/* begin setStackPageAndLimit: */
	GIV(stackPage) = newPage;
	if (GIV(stackLimit) != (((char *) (((usqInt) -1))))) {
		GIV(stackLimit) = (GIV(stackPage)->stackLimit);
	}
	markStackPageMostRecentlyUsed(newPage);
	GIV(framePointer) = (GIV(stackPage)->headFP);
	GIV(stackPointer) = (GIV(stackPage)->headSP);
	/* begin setMethod: */
	/* begin iframeMethod: */
	theFP = (GIV(stackPage)->headFP);
	aMethodObj = longAt(theFP + FoxMethod);
	assert((((usqInt)aMethodObj)) >= (startOfMemory()));
	GIV(method) = aMethodObj;
	/* begin popStack */
	top = longAt(GIV(stackPointer));
	GIV(stackPointer) += BytesPerWord;
	GIV(instructionPointer) = ((sqInt) top);
	siglongjmp(reenterInterpreter, ReturnToInterpreter);
}

static void
primitiveWait(void)
{   DECL_MAYBE_SQ_GLOBAL_STRUCT
    sqInt activeProc;
    sqInt excessSignals;
    sqInt inInterpreter;
    sqInt sema;


	/* rcvr */

	sema = longAt(GIV(stackPointer));
	excessSignals = fetchIntegerofObject(ExcessSignalsIndex, sema);
	if (excessSignals > 0) {
		/* begin storeInteger:ofObject:withValue: */
		if (((excessSignals - 1) ^ ((excessSignals - 1) << 1)) >= 0) {
			longAtput((sema + BaseHeaderSize) + (ExcessSignalsIndex << ShiftForWord), (((excessSignals - 1) << 1) | 1));
		}
		else {
			/* begin primitiveFail */
			if (GIV(primFailCode) == 0) {
				GIV(primFailCode) = 1;
			}
		}
	}
	else {

		/* We're going to switch process, either to an interpreted frame or a machine
			  code frame. To know whether to return or enter machine code we have to
			  know from whence we came.  We could have come from the interpreter,
			  either directly or via a machine code primitive.  We could have come from
			  machine code.  The instructionPointer tells us where from: */

		inInterpreter = GIV(instructionPointer) >= heapBase;
		activeProc = longAt(((longAt(((longAt((GIV(specialObjectsOop) + BaseHeaderSize) + (SchedulerAssociation << ShiftForWord))) + BaseHeaderSize) + (ValueIndex << ShiftForWord))) + BaseHeaderSize) + (ActiveProcessIndex << ShiftForWord));
		addLastLinktoList(activeProc, sema);
		transferTofrom(wakeHighestPriority(), CSWait);
		/* begin forProcessPrimitiveReturnToExecutivePostContextSwitch: */
		if (GIV(nextProfileTick) > 0) {
			checkProfileTick(GIV(newMethod));
		}
		returnToExecutivepostContextSwitch(inInterpreter, 1);
	}
}


/*	primitively do the equivalent of Process>yield */

static void
primitiveYield(void)
{   DECL_MAYBE_SQ_GLOBAL_STRUCT
    sqInt activeProc;
    sqInt inInterpreter;
    sqInt oop;
    sqInt priority;
    sqInt processList;
    sqInt processLists;

	activeProc = longAt(((longAt(((longAt((GIV(specialObjectsOop) + BaseHeaderSize) + (SchedulerAssociation << ShiftForWord))) + BaseHeaderSize) + (ValueIndex << ShiftForWord))) + BaseHeaderSize) + (ActiveProcessIndex << ShiftForWord));
	/* begin quickFetchInteger:ofObject: */
	oop = longAt((activeProc + BaseHeaderSize) + (PriorityIndex << ShiftForWord));
	assert((oop & 1));
	priority = (oop >> 1);
	processLists = longAt(((longAt(((longAt((GIV(specialObjectsOop) + BaseHeaderSize) + (SchedulerAssociation << ShiftForWord))) + BaseHeaderSize) + (ValueIndex << ShiftForWord))) + BaseHeaderSize) + (ProcessListsIndex << ShiftForWord));
	processList = longAt((processLists + BaseHeaderSize) + ((priority - 1) << ShiftForWord));
	if ((longAt((processList + BaseHeaderSize) + (FirstLinkIndex << ShiftForWord))) == GIV(nilObj)) {
		return;
	}
	inInterpreter = GIV(instructionPointer) >= heapBase;
	addLastLinktoList(activeProc, processList);
	transferTofrom(wakeHighestPriority(), CSYield);
	/* begin forProcessPrimitiveReturnToExecutivePostContextSwitch: */
	if (GIV(nextProfileTick) > 0) {
		checkProfileTick(GIV(newMethod));
	}
	returnToExecutivepostContextSwitch(inInterpreter, 1);
}

void *
primTraceLogAddress(void)
{
	return GIV(primTraceLog);
}


/*	N.B. primTraceLogIndex is 8-bits */

usqInt
primTraceLogIndexAddress(void)
{
	return ((usqInt)((&GIV(primTraceLogIndex))));
}

static void
printActivationNameForreceiverisBlockfirstTemporary(sqInt aMethod, sqInt anObject, sqInt isBlock, sqInt maybeMessage)
{   DECL_MAYBE_SQ_GLOBAL_STRUCT
    sqInt ccIndex;
    sqInt ccIndex1;
    sqInt classDict;
    sqInt classDictSize;
    sqInt currClass;
    sqInt header;
    sqInt i;
    sqInt methClass;
    sqInt methodArray;
    sqInt methodSel;
    sqInt sz;

	if (isBlock) {
		print("[] in ");
	}
	/* begin findClassOfMethod:forReceiver: */
	VM_LABEL(0findClassOfMethodforReceiver);
	/* begin fetchClassOf: */
	if ((anObject & 1)) {
		currClass = longAt((GIV(specialObjectsOop) + BaseHeaderSize) + (ClassInteger << ShiftForWord));
		goto l1;
	}
	if (((ccIndex = (((usqInt) (longAt(anObject))) >> 12) & 31)) == 0) {
		currClass = (longAt(anObject - BaseHeaderSize)) & AllButTypeMask;
		goto l1;
	}
	else {
		currClass = longAt(((longAt((GIV(specialObjectsOop) + BaseHeaderSize) + (CompactClasses << ShiftForWord))) + BaseHeaderSize) + ((ccIndex - 1) << ShiftForWord));
		goto l1;
	}
l1:	/* end fetchClassOf: */;
	do {
		classDict = longAt((currClass + BaseHeaderSize) + (MethodDictionaryIndex << ShiftForWord));
		/* begin fetchWordLengthOf: */
		/* begin sizeBitsOf: */
		header = longAt(classDict);
		sz = ((header & TypeMask) == HeaderTypeSizeAndClass
			? (longAt(classDict - (BytesPerWord * 2))) & LongSizeMask
			: header & SizeMask);
		classDictSize = ((usqInt) (sz - BaseHeaderSize)) >> ShiftForWord;
		methodArray = longAt((classDict + BaseHeaderSize) + (MethodArrayIndex << ShiftForWord));
		i = 0;
		while (i < (classDictSize - SelectorStart)) {
			if (aMethod == (longAt((methodArray + BaseHeaderSize) + (i << ShiftForWord)))) {
				methClass = currClass;
				goto l2;
			}
			i += 1;
		}
		currClass = longAt((currClass + BaseHeaderSize) + (SuperclassIndex << ShiftForWord));
	} while(!(currClass == GIV(nilObj)));
	/* begin fetchClassOf: */
	if ((anObject & 1)) {
		methClass = longAt((GIV(specialObjectsOop) + BaseHeaderSize) + (ClassInteger << ShiftForWord));
		goto l2;
	}
	if (((ccIndex1 = (((usqInt) (longAt(anObject))) >> 12) & 31)) == 0) {
		methClass = (longAt(anObject - BaseHeaderSize)) & AllButTypeMask;
		goto l2;
	}
	else {
		methClass = longAt(((longAt((GIV(specialObjectsOop) + BaseHeaderSize) + (CompactClasses << ShiftForWord))) + BaseHeaderSize) + ((ccIndex1 - 1) << ShiftForWord));
		goto l2;
	}
l2:	/* end findClassOfMethod:forReceiver: */;
	methodSel = findSelectorOfMethodforReceiver(aMethod, anObject);
	if (((anObject & 1))
	 || (((anObject & 3) == 0)
 && (((((usqInt)anObject)) >= heapBase)
 && (((((usqInt)anObject)) < GIV(freeStart))
 && (((longAt(anObject)) & TypeMask) != HeaderTypeGC))))) {
		if ((fetchClassOf(anObject)) == methClass) {
			printNameOfClasscount(methClass, 5);
		}
		else {
			printNameOfClasscount(fetchClassOf(anObject), 5);
			print("(");
			printNameOfClasscount(methClass, 5);
			print(")");
		}
	}
	else {
		print("INVALID RECEIVER");
	}
	print(">");
	if (((methodSel & 1))
	 || (((methodSel & 3) == 0)
 && (((((usqInt)methodSel)) >= heapBase)
 && (((((usqInt)methodSel)) < GIV(freeStart))
 && (((longAt(methodSel)) & TypeMask) != HeaderTypeGC))))) {
		if (methodSel == GIV(nilObj)) {
			print("?");
		}
		else {
			printStringOf(methodSel);
		}
	}
	else {
		print("INVALID SELECTOR");
	}
	if ((methodSel == (longAt((GIV(specialObjectsOop) + BaseHeaderSize) + (SelectorDoesNotUnderstand << ShiftForWord))))
	 && ((((maybeMessage & 3) == 0)
 && (((((usqInt)maybeMessage)) >= heapBase)
 && (((((usqInt)maybeMessage)) < GIV(freeStart))
 && (((longAt(maybeMessage)) & TypeMask) != HeaderTypeGC))))
 && ((fetchClassOf(maybeMessage)) == (longAt((GIV(specialObjectsOop) + BaseHeaderSize) + (ClassMessage << ShiftForWord)))))) {

		/* print arg message selector */

		methodSel = longAt((maybeMessage + BaseHeaderSize) + (MessageSelectorIndex << ShiftForWord));
		print(" ");
		printStringOf(methodSel);
	}
}


/*	Print all the stacks of all running processes, including those that are
	currently suspended.
 */

void
printAllStacks(void)
{   DECL_MAYBE_SQ_GLOBAL_STRUCT
    sqInt ccIndex;
    sqInt classObj;
    sqInt header;
    sqInt header1;
    sqInt mutexClass;
    sqInt oop;
    sqInt p;
    sqInt pri;
    sqInt proc;
    sqInt processList;
    sqInt schedLists;
    sqInt semaphoreClass;
    sqInt sz;
    sqInt sz1;

	proc = longAt(((longAt(((longAt((GIV(specialObjectsOop) + BaseHeaderSize) + (SchedulerAssociation << ShiftForWord))) + BaseHeaderSize) + (ValueIndex << ShiftForWord))) + BaseHeaderSize) + (ActiveProcessIndex << ShiftForWord));
	printNameOfClasscount(fetchClassOf(proc), 5);
	/* begin space */
	/* begin printChar: */
	putchar(' ');
	printHex(proc);
	print(" priority ");
	printNum(quickFetchIntegerofObject(PriorityIndex, proc));
	/* begin cr */
	printf("\n");
	printCallStackFP(GIV(framePointer));
	semaphoreClass = longAt((GIV(specialObjectsOop) + BaseHeaderSize) + (ClassSemaphore << ShiftForWord));
	mutexClass = longAt((GIV(specialObjectsOop) + BaseHeaderSize) + (ClassMutex << ShiftForWord));
	oop = heapBase + (headerTypeBytes[(longAt(heapBase)) & TypeMask]);
	while ((((usqInt) oop)) < (((usqInt) GIV(freeStart)))) {
		/* begin fetchClassOfNonInt: */
		if (((ccIndex = (((usqInt) (longAt(oop))) >> 12) & 31)) == 0) {
			classObj = (longAt(oop - BaseHeaderSize)) & AllButTypeMask;
			goto l1;
		}
		else {
			classObj = longAt(((longAt((GIV(specialObjectsOop) + BaseHeaderSize) + (CompactClasses << ShiftForWord))) + BaseHeaderSize) + ((ccIndex - 1) << ShiftForWord));
			goto l1;
		}
	l1:	/* end fetchClassOfNonInt: */;
		if ((classObj == semaphoreClass)
		 || (classObj == mutexClass)) {
			printProcsOnList(oop);
		}
		/* begin objectAfter: */
		if (DoAssertionChecks) {
			if ((((usqInt) oop)) >= (((usqInt) GIV(endOfMemory)))) {
				error("no objects after the end of memory");
			}
		}
		if (((longAt(oop)) & TypeMask) == HeaderTypeFree) {
			sz = (longAt(oop)) & AllButTypeMask;
		}
		else {
			/* begin sizeBitsOf: */
			header = longAt(oop);
			sz = ((header & TypeMask) == HeaderTypeSizeAndClass
				? (longAt(oop - (BytesPerWord * 2))) & LongSizeMask
				: header & SizeMask);
		}
		oop = (oop + sz) + (headerTypeBytes[(longAt(oop + sz)) & TypeMask]);
	}
	schedLists = longAt(((longAt(((longAt((GIV(specialObjectsOop) + BaseHeaderSize) + (SchedulerAssociation << ShiftForWord))) + BaseHeaderSize) + (ValueIndex << ShiftForWord))) + BaseHeaderSize) + (ProcessListsIndex << ShiftForWord));
	p = (GIV(highestRunnableProcessPriority) == 0
		? /* begin fetchWordLengthOf: *//* begin sizeBitsOf: */header1 = longAt(schedLists),sz1 = ((header1 & TypeMask) == HeaderTypeSizeAndClass
	? (longAt(schedLists - (BytesPerWord * 2))) & LongSizeMask
	: header1 & SizeMask),((usqInt) (sz1 - BaseHeaderSize)) >> ShiftForWord
		: GIV(highestRunnableProcessPriority));
	for (pri = (p - 1); pri >= 0; pri += -1) {
		processList = longAt((schedLists + BaseHeaderSize) + (pri << ShiftForWord));
		if (!((longAt((processList + BaseHeaderSize) + (FirstLinkIndex << ShiftForWord))) == GIV(nilObj))) {
			/* begin cr */
			printf("\n");
			print("processes at priority ");
			printNum(pri + 1);
			printProcsOnList(processList);
		}
	}
}

void
printCallStack(void)
{
	printCallStackFP(GIV(framePointer));
}

static void
printCallStackFP(char *theFP)
{   DECL_MAYBE_SQ_GLOBAL_STRUCT
    sqInt context;

	context = shortReversePrintFrameAndCallers(theFP);
	while (!(context == GIV(nilObj))) {
		if (((longAt((context + BaseHeaderSize) + (SenderIndex << ShiftForWord))) & 1)) {
			if (!(checkIsStillMarriedContextcurrentFP(context, GIV(framePointer)))) {
				shortPrintContext(context);
				return;
			}
			context = shortReversePrintFrameAndCallers(frameOfMarriedContext(context));
		}
		else {
			context = printContextCallStackOf(context);
		}
	}
}

void
printCallStackOfContext(sqInt aContext)
{   DECL_MAYBE_SQ_GLOBAL_STRUCT
    sqInt context;

	context = aContext;
	while (!(context == GIV(nilObj))) {
		if (((longAt((context + BaseHeaderSize) + (SenderIndex << ShiftForWord))) & 1)) {
			if (!(checkIsStillMarriedContextcurrentFP(context, GIV(framePointer)))) {
				shortPrintContext(context);
				return;
			}
			context = shortReversePrintFrameAndCallers(frameOfMarriedContext(context));
		}
		else {
			context = printContextCallStackOf(context);
		}
	}
}

static void
printCallStackOfcurrentFP(sqInt aContext, char *currFP)
{   DECL_MAYBE_SQ_GLOBAL_STRUCT
    sqInt callerContextOrNil;
    sqInt ctxt;
    sqInt index;
    sqInt index1;
    char *theFP;
    StackPage *thePage;
    StackPage *thePage1;
    sqInt value;

	ctxt = aContext;
	while (!(ctxt == GIV(nilObj))) {
		if (((longAt((ctxt + BaseHeaderSize) + (SenderIndex << ShiftForWord))) & 1)) {
			/* begin frameOfMarriedContext: */
			value = longAt((ctxt + BaseHeaderSize) + (SenderIndex << ShiftForWord));
			/* begin withoutSmallIntegerTags: */
			assert((value & 1));
			theFP = pointerForOop(value - 1);
			if (checkIsStillMarriedContextcurrentFP(ctxt, currFP)) {
				/* begin stackPageFor: */
				/* begin stackPageAt: */
				/* begin pageIndexFor: */
				assert((((((char *) theFP)) >= (GIV(stackBasePlus1) - 1)) && ((((char *) theFP)) <= (((char *) GIV(pages))))));
				index = pageIndexForstackBasePlus1bytesPerPage(theFP, GIV(stackBasePlus1), GIV(bytesPerPage));
				thePage = stackPageAtpages(index, GIV(pages));
				if (isFree(thePage)) {
					/* begin printHexPtr: */
					printHex(oopForPointer(theFP));
					print(" is on a free page?!");
					/* begin cr */
					printf("\n");
					return;
				}
				shortPrintFrameAndCallers(theFP);
				theFP = (thePage->baseFP);
				/* begin frameCallerContext: */
				assert(isBaseFrame(theFP));
				/* begin stackPageFor: */
				/* begin stackPageAt: */
				/* begin pageIndexFor: */
				assert((((((char *) theFP)) >= (GIV(stackBasePlus1) - 1)) && ((((char *) theFP)) <= (((char *) GIV(pages))))));
				index1 = pageIndexForstackBasePlus1bytesPerPage(theFP, GIV(stackBasePlus1), GIV(bytesPerPage));
				thePage1 = stackPageAtpages(index1, GIV(pages));
				callerContextOrNil = longAt((thePage1->baseAddress));
				assert(addressCouldBeObj(callerContextOrNil));
				assert((callerContextOrNil == (nilObject()))
				 || (isContext(callerContextOrNil)));
				ctxt = callerContextOrNil;
			}
			else {
				print("widowed caller frame ");
				print(theFP);
				/* begin cr */
				printf("\n");
				return;
			}
		}
		else {
			shortPrintContext(ctxt);
			ctxt = longAt((ctxt + BaseHeaderSize) + (SenderIndex << ShiftForWord));
		}
	}
}


/*	For testing in Smalltalk, this method should be overridden in a subclass. */

void
printChar(sqInt aByte)
{
	putchar(aByte);
}

void
printCogMethod(CogMethod *cogMethod)
{
    sqInt address;

	;
	address = ((sqInt)cogMethod);
	printHex(address);
	print(" <-> ");
	printHex(address + ((cogMethod->blockSize)));
	if (((cogMethod->cmType)) == CMMethod) {
		print(": method: ");
		printHex((cogMethod->methodObject));
	}
	if (((cogMethod->cmType)) == CMBlock) {
		print(": block home: ");
		printHex(((usqInt)(cmHomeMethod(((CogBlockMethod *) cogMethod)))));
	}
	if (((cogMethod->cmType)) == CMClosedPIC) {
		print(": Closed PIC N: ");
		printHex((cogMethod->cPICNumCases));
	}
	if (((cogMethod->cmType)) == CMOpenPIC) {
		print(": Open PIC ");
	}
	print(" selector: ");
	printHex((cogMethod->selector));
	print(" ");
	printStringOf((cogMethod->selector));
	/* begin cr */
	printf("\n");
}


/*	Print the call stack of aContext until it links to a frame. */

static sqInt
printContextCallStackOf(sqInt aContext)
{
    sqInt ctxt;

	ctxt = aContext;
	while (!((ctxt == GIV(nilObj))
 || (((longAt((ctxt + BaseHeaderSize) + (SenderIndex << ShiftForWord))) & 1)))) {
		shortPrintContext(ctxt);
		ctxt = longAt((ctxt + BaseHeaderSize) + (SenderIndex << ShiftForWord));
	}
	return ctxt;
}

void
printContext(sqInt aContext)
{
    sqInt i;
    sqInt ip;
    void *p;
    void *p1;
    sqInt sender;
    sqInt sp;

	shortPrintContext(aContext);
	sender = longAt((aContext + BaseHeaderSize) + (SenderIndex << ShiftForWord));
	ip = longAt((aContext + BaseHeaderSize) + (InstructionPointerIndex << ShiftForWord));
	if ((sender & 1)) {
		if (checkIsStillMarriedContextcurrentFP(aContext, GIV(framePointer))) {
			print("married (assuming framePointer valid)");
			/* begin cr */
			printf("\n");
		}
		else {
			print("widdowed (assuming framePointer valid)");
			/* begin cr */
			printf("\n");
		}
		print("sender   ");
		printNum(sender);
		print(" (");
		/* begin printHexPtr: */
		/* begin withoutSmallIntegerTags: */
		assert((sender & 1));
		p = ((char *) (pointerForOop(sender - 1)));
		printHex(oopForPointer(p));
		/* begin printChar: */
		putchar(')');
		/* begin cr */
		printf("\n");
		print("ip       ");
		printNum(ip);
		print(" (");
		/* begin printHexPtr: */
		/* begin withoutSmallIntegerTags: */
		assert((ip & 1));
		p1 = ((char *) (pointerForOop(ip - 1)));
		printHex(oopForPointer(p1));
		/* begin printChar: */
		putchar(')');
		/* begin cr */
		printf("\n");
	}
	else {
		print("sender   ");
		shortPrintOop(sender);
		print("ip       ");
		printNum(ip);
		print(" (");
		printNum((ip >> 1));
		printHex((ip >> 1));
		/* begin printChar: */
		putchar(')');
		/* begin cr */
		printf("\n");
	}
	sp = longAt((aContext + BaseHeaderSize) + (StackPointerIndex << ShiftForWord));
	sp = ((sp < ((lengthOf(aContext)) - ReceiverIndex)) ? sp : ((lengthOf(aContext)) - ReceiverIndex));
	print("sp       ");
	printNum(sp);
	print(" (");
	printNum((sp >> 1));
	/* begin printChar: */
	putchar(')');
	/* begin cr */
	printf("\n");
	print("method   ");
	shortPrintOop(longAt((aContext + BaseHeaderSize) + (MethodIndex << ShiftForWord)));
	print("closure  ");
	shortPrintOop(longAt((aContext + BaseHeaderSize) + (ClosureIndex << ShiftForWord)));
	print("receiver ");
	shortPrintOop(longAt((aContext + BaseHeaderSize) + (ReceiverIndex << ShiftForWord)));
	sp = (sp >> 1);
	for (i = 1; i <= sp; i += 1) {
		print("       ");
		printNum(i);
		/* begin space */
		/* begin printChar: */
		putchar(' ');
		shortPrintOop(longAt((aContext + BaseHeaderSize) + ((ReceiverIndex + i) << ShiftForWord)));
	}
}

void
printExternalHeadFrame(void)
{   DECL_MAYBE_SQ_GLOBAL_STRUCT
	printFrameWithSP(GIV(framePointer), GIV(stackPointer));
}

static void
printFrameAndCallersSP(char *theFP, char *theSP)
{   DECL_MAYBE_SQ_GLOBAL_STRUCT
	if (!((((((usqInt)theFP)) & (BytesPerWord - 1)) == 0)
		 && ((((((usqInt)theFP)) >= (((usqInt)(GIV(stackBasePlus1) - 1)))) && ((((usqInt)theFP)) <= (((usqInt)GIV(pages)))))))) {
		return;
	}
	if (!((longAt(theFP + FoxSavedFP)) == 0)) {
		printFrameAndCallersSP(frameCallerFP(theFP), frameCallerSP(theFP));
	}
	/* begin cr */
	printf("\n");
	printFrameWithSP(theFP, theSP);
}

static void
printFrameFlagsForFP(char *theFP)
{
    char *address;
    sqInt it;

	if ((((usqInt)(longAt(theFP + FoxMethod)))) < heapBase) {
		address = theFP + FoxMethod;
		it = (longAt(address)) & 7;
	}
	else {
		address = theFP + FoxIFrameFlags;
		it = longAt(address);
	}
	/* begin printHexPtr: */
	printHex(oopForPointer(address));
	print(((((usqInt)(longAt(theFP + FoxMethod)))) < heapBase
		? ": mcfrm flags: "
		: ":intfrm flags: "));
	printHex(it);
	if (it != 0) {
		/* begin printChar: */
		putchar('=');
		printNum(it);
	}
	print("  numArgs: ");
	printNum(((((usqInt)(longAt(theFP + FoxMethod)))) < heapBase
		? (mframeCogMethod(theFP)->cmNumArgs)
		: byteAt((theFP + FoxIFrameFlags) + 1)));
	print("  hasContext: ");
	printNum(((((usqInt)(longAt(theFP + FoxMethod)))) < heapBase
		? ((longAt(theFP + FoxMethod)) & MFMethodFlagHasContextFlag) != 0
		: (byteAt((theFP + FoxIFrameFlags) + 2)) != 0));
	print("  isBlock: ");
	printNum(((((usqInt)(longAt(theFP + FoxMethod)))) < heapBase
		? ((longAt(theFP + FoxMethod)) & MFMethodFlagIsBlockFlag) != 0
		: (byteAt((theFP + FoxIFrameFlags) + 3)) != 0));
	/* begin cr */
	printf("\n");
}

static void
printFrameMethodFor(char *theFP)
{
    char *address;
    CogMethod *homeMethod;
    sqInt it;
    sqInt methodField;
    sqInt obj;

	address = theFP + FoxMethod;
	it = longAt(address);
	printHex(((sqInt)address));
	/* begin printChar: */
	putchar(':');
	print("      method: ");
	printHex(it);
	/* begin tab */
	/* begin printChar: */
	putchar('	');
	if (((((usqInt)(longAt(theFP + FoxMethod)))) < heapBase)
	 && (((longAt(theFP + FoxMethod)) & MFMethodFlagIsBlockFlag) != 0)) {
		/* begin mframeHomeMethod: */
		methodField = longAt(theFP + FoxMethod);
		if ((methodField & MFMethodFlagIsBlockFlag) != 0) {
			homeMethod = cmHomeMethod(((CogBlockMethod *) (methodField & MFMethodMask)));
			goto l1;
		}
		homeMethod = ((CogMethod *) (methodField & MFMethodMask));
	l1:	/* end mframeHomeMethod: */;
		print("hm: ");
		printHex(((sqInt)homeMethod));
		/* begin tab */
		/* begin printChar: */
		putchar('	');
	}
	obj = ((((usqInt)(longAt(theFP + FoxMethod)))) < heapBase
		? (mframeHomeMethod(theFP)->methodObject)
		: longAt(theFP + FoxMethod));
	printHex(obj);
	/* begin space */
	/* begin printChar: */
	putchar(' ');
	shortPrintOop(obj);
}

static void
printFrameOopat(char *name, char *address)
{
    sqInt i;
    sqInt it;

	it = longAt(address);
	/* begin printHexPtr: */
	printHex(oopForPointer(address));
	/* begin printChar: */
	putchar(':');
	for (i = 1; i <= (12 - (strlen(name))); i += 1) {
		/* begin printChar: */
		putchar(' ');
	}
	print(name);
	print(": ");
	printHex(it);
	/* begin tab */
	/* begin printChar: */
	putchar('	');
	printOopShort(it);
	/* begin cr */
	printf("\n");
}

static void
printFrameOopindexat(char *name, sqInt idx, char *address)
{
    sqInt i;
    sqInt it;

	it = longAt(address);
	/* begin printHexPtr: */
	printHex(oopForPointer(address));
	/* begin printChar: */
	putchar(':');
	for (i = 1; i <= ((11 - (strlen(name))) - (floor(log10(((idx < 1) ? 1 : idx))))); i += 1) {
		/* begin printChar: */
		putchar(' ');
	}
	print(name);
	printNum(idx);
	print(": ");
	printHex(it);
	/* begin tab */
	/* begin printChar: */
	putchar('	');
	printOopShort(it);
	/* begin cr */
	printf("\n");
}

void
printFramesInPage(StackPage *thePage)
{
	printFrameAndCallersSP((thePage->headFP), (thePage->headSP));
}

static void
printFrameThingat(char *name, char *address)
{
    sqInt i;
    sqInt it;
    sqInt len;

	it = longAt(address);
	/* begin printHexPtr: */
	printHex(oopForPointer(address));
	/* begin printChar: */
	putchar(':');
	len = strlen(name);
	for (i = 1; i <= (12 - len); i += 1) {
		/* begin space */
		/* begin printChar: */
		putchar(' ');
	}
	print(name);
	print(": ");
	printHex(it);
	if (it != 0) {
		/* begin printChar: */
		putchar('=');
		if (it == GIV(nilObj)) {
			print("nil");
		}
		else {
			printNum(it);
		}
	}
	/* begin cr */
	printf("\n");
}

static void
printFrameThingatextra(char *name, char *address, sqInt extraValue)
{
    sqInt i;
    sqInt it;
    sqInt len;

	it = longAt(address);
	/* begin printHexPtr: */
	printHex(oopForPointer(address));
	/* begin printChar: */
	putchar(':');
	len = strlen(name);
	for (i = 1; i <= (12 - len); i += 1) {
		/* begin space */
		/* begin printChar: */
		putchar(' ');
	}
	print(name);
	print(": ");
	printHex(it);
	if (it != 0) {
		/* begin printChar: */
		putchar('=');
		if (it == GIV(nilObj)) {
			print("nil");
		}
		else {
			printNum(it);
		}
	}
	/* begin space */
	/* begin printChar: */
	putchar(' ');
	printNum(extraValue);
	/* begin cr */
	printf("\n");
}

void
printFrame(char *theFP)
{   DECL_MAYBE_SQ_GLOBAL_STRUCT
    char *aFrame;
    sqInt index;
    char *startFrame;
    StackPage *thePage;
    char *theSP;
    char *theSP1;

	if (theFP == GIV(framePointer)) {
		theSP = GIV(stackPointer);
	}
	else {
		/* begin stackPageFor: */
		/* begin stackPageAt: */
		/* begin pageIndexFor: */
		assert((((((char *) theFP)) >= (GIV(stackBasePlus1) - 1)) && ((((char *) theFP)) <= (((char *) GIV(pages))))));
		index = pageIndexForstackBasePlus1bytesPerPage(theFP, GIV(stackBasePlus1), GIV(bytesPerPage));
		thePage = stackPageAtpages(index, GIV(pages));
		if (isFree(thePage)) {
			/* begin printHexPtr: */
			printHex(oopForPointer(theFP));
			print(" is on a free page?!");
			/* begin cr */
			printf("\n");
			return;
		}
		if ((thePage != GIV(stackPage))
		 && (theFP == ((thePage->headFP)))) {
			theSP = (thePage->headSP);
		}
		else {
			/* begin findSPOrNilOf:on:startingFrom: */
			startFrame = ((thePage == GIV(stackPage))
			 && (((GIV(framePointer) >= ((thePage->realStackLimit))) && (GIV(framePointer) <= ((thePage->baseAddress)))))
				? GIV(framePointer)
				: (thePage->headFP));
			assert(!(isFree(thePage)));
			aFrame = startFrame;
			theSP1 = (thePage->headSP);
			if (aFrame == theFP) {
				if (theSP1 >= aFrame) {
					theSP = ((((usqInt)(longAt(aFrame + FoxMethod)))) < heapBase
						? aFrame + FoxMFReceiver
						: aFrame + FoxIFReceiver);
					goto l1;
				}
				theSP = (thePage == GIV(stackPage)
					? theSP1
					: theSP1 + BytesPerWord);
				goto l1;
			}
					while (1) {
				/* begin frameCallerSP: */
				assert(!(isBaseFrame(aFrame)));
				theSP1 = (aFrame + ((FoxCallerSavedIP + BytesPerWord) + ((((((usqInt)(longAt(aFrame + FoxMethod)))) < heapBase
	? (mframeCogMethod(aFrame)->cmNumArgs)
	: byteAt((aFrame + FoxIFrameFlags) + 1))) << ShiftForWord))) + BytesPerWord;
				/* begin frameCallerFP: */
				aFrame = pointerForOop(longAt(aFrame + FoxSavedFP));
				if (!(aFrame != 0)) break;
				if (theFP == aFrame) {
					theSP = theSP1;
					goto l1;
				}
			}
			theSP = null;
		l1:	/* end findSPOrNilOf:on:startingFrom: */;
		}
	}
	if (theSP == null) {
		print("could not find sp; using bogus value");
		/* begin cr */
		printf("\n");
		theSP = theFP + (((((usqInt)(longAt(theFP + FoxMethod)))) < heapBase
	? FoxMFReceiver
	: FoxIFReceiver));
	}
	printFrameWithSP(theFP, theSP);
}

static void
printFrameWithSP(char *theFP, char *theSP)
{   DECL_MAYBE_SQ_GLOBAL_STRUCT
    char *addr;
    CogBlockMethod *cogMethod;
    sqInt header;
    sqInt header1;
    CogMethod *homeMethod;
    sqInt i;
    sqInt index;
    sqInt methodField;
    sqInt methodHeader;
    sqInt numArgs;
    sqInt numTemps;
    char *rcvrAddress;
    sqInt rcvrOrClosure;
    sqInt theMethod;
    sqInt theMethodEnd;
    sqInt topThing;

	;
	if ((((usqInt)(longAt(theFP + FoxMethod)))) < heapBase) {
		/* begin mframeCogMethod: */
		cogMethod = ((CogBlockMethod *) ((longAt(theFP + FoxMethod)) & MFMethodMask));
		/* begin mframeHomeMethod: */
		methodField = longAt(theFP + FoxMethod);
		if ((methodField & MFMethodFlagIsBlockFlag) != 0) {
			homeMethod = cmHomeMethod(((CogBlockMethod *) (methodField & MFMethodMask)));
			goto l1;
		}
		homeMethod = ((CogMethod *) (methodField & MFMethodMask));
	l1:	/* end mframeHomeMethod: */;
		theMethod = ((sqInt)homeMethod);
		theMethodEnd = (((sqInt)homeMethod)) + ((homeMethod->blockSize));
		numArgs = (cogMethod->cmNumArgs);
		/* begin tempCountOfMethodHeader: */
		header = (homeMethod->methodHeader);
		numTemps = (((usqInt) header) >> 19) & 63;
	}
	else {
		theMethod = ((((usqInt)(longAt(theFP + FoxMethod)))) < heapBase
			? (mframeHomeMethod(theFP)->methodObject)
			: longAt(theFP + FoxMethod));
		theMethodEnd = theMethod + (sizeBitsOfSafe(theMethod));
		numArgs = byteAt((theFP + FoxIFrameFlags) + 1);
		/* begin tempCountOfMethodHeader: */
		/* begin headerOf: */
		methodHeader = longAt((theMethod + BaseHeaderSize) + (HeaderIndex << ShiftForWord));
		header1 = (isCogMethodReference(methodHeader)
			? (((CogMethod *) methodHeader)->methodHeader)
			: methodHeader);
		numTemps = (((usqInt) header1) >> 19) & 63;
	}
	if (((((usqInt)(longAt(theFP + FoxMethod)))) < heapBase
		? ((longAt(theFP + FoxMethod)) & MFMethodFlagIsBlockFlag) != 0
		: (byteAt((theFP + FoxIFrameFlags) + 3)) != 0)) {
		rcvrOrClosure = longAt(theFP + ((FoxCallerSavedIP + BytesPerWord) + ((((((usqInt)(longAt(theFP + FoxMethod)))) < heapBase
	? (mframeCogMethod(theFP)->cmNumArgs)
	: byteAt((theFP + FoxIFrameFlags) + 1))) << ShiftForWord)));
		if (((rcvrOrClosure & 1) == 0)
		 && ((((rcvrOrClosure & 3) == 0)
 && (((((usqInt)rcvrOrClosure)) >= heapBase)
 && (((((usqInt)rcvrOrClosure)) < GIV(freeStart))
 && (((longAt(rcvrOrClosure)) & TypeMask) != HeaderTypeGC))))
 && ((fetchClassOfNonInt(rcvrOrClosure)) == (longAt((GIV(specialObjectsOop) + BaseHeaderSize) + (ClassBlockClosure << ShiftForWord)))))) {
			numTemps = numArgs + (stSizeOf(rcvrOrClosure));
		}
		else {
			numTemps = 0;
		}
	}
	shortPrintFrame(theFP);
	if ((longAt(theFP + FoxSavedFP)) == 0) {
		printFrameOopat("(caller ctxt", (theFP + ((FoxCallerSavedIP + BytesPerWord) + ((((((usqInt)(longAt(theFP + FoxMethod)))) < heapBase
	? (mframeCogMethod(theFP)->cmNumArgs)
	: byteAt((theFP + FoxIFrameFlags) + 1))) << ShiftForWord))) + (2 * BytesPerWord));
		printFrameOopat("(saved ctxt", (theFP + ((FoxCallerSavedIP + BytesPerWord) + ((((((usqInt)(longAt(theFP + FoxMethod)))) < heapBase
	? (mframeCogMethod(theFP)->cmNumArgs)
	: byteAt((theFP + FoxIFrameFlags) + 1))) << ShiftForWord))) + (1 * BytesPerWord));
	}
	printFrameOopat("rcvr/clsr", (theFP + FoxCallerSavedIP) + ((numArgs + 1) * BytesPerWord));
	for (i = numArgs; i >= 1; i += -1) {
		printFrameOopindexat("arg", numArgs - i, (theFP + FoxCallerSavedIP) + (i * BytesPerWord));
	}
	printFrameThingat("caller ip", theFP + FoxCallerSavedIP);
	printFrameThingat("saved fp", theFP + FoxSavedFP);
	printFrameMethodFor(theFP);
	if (!((((usqInt)(longAt(theFP + FoxMethod)))) < heapBase)) {
		printFrameFlagsForFP(theFP);
	}
	printFrameOopat("context", theFP + FoxThisContext);
	if ((((usqInt)(longAt(theFP + FoxMethod)))) < heapBase) {
		printFrameFlagsForFP(theFP);
	}
	if ((((usqInt)(longAt(theFP + FoxMethod)))) < heapBase) {
		rcvrAddress = theFP + FoxMFReceiver;
	}
	else {
		printFrameThingatextra("saved ip", theFP + FoxIFSavedIP, ((longAt(theFP + FoxIFSavedIP)) == 0
			? 0
			: (((longAt(theFP + FoxIFSavedIP)) - theMethod) + 2) - BaseHeaderSize));
		rcvrAddress = theFP + FoxIFReceiver;
	}
	printFrameOopat("receiver", rcvrAddress);
	topThing = longAt(theSP);
	if (((topThing >= theMethod) && (topThing <= theMethodEnd))) {
		for (addr = (rcvrAddress - BytesPerWord); addr >= (theSP + BytesPerWord); addr += (-BytesPerWord)) {
			index = (((sqInt) (rcvrAddress - addr) >> 2)) + numArgs;
			if (index <= numTemps) {
				printFrameOopindexat("temp", index - 1, addr);
			}
			else {
				printFrameOopat("stck", addr);
			}
		}
		printFrameThingatextra("frame ip", theSP, ((((usqInt)(longAt(theFP + FoxMethod)))) < heapBase
			? topThing - theMethod
			: ((topThing - theMethod) + 2) - BaseHeaderSize));
	}
	else {
		for (addr = (rcvrAddress - BytesPerWord); addr >= theSP; addr += (-BytesPerWord)) {
			index = (((sqInt) (rcvrAddress - addr) >> 2)) + numArgs;
			if (index <= numTemps) {
				printFrameOopindexat("temp", index - 1, addr);
			}
			else {
				printFrameOopat("stck", addr);
			}
		}
	}
}


/*	Print n in hex, in the form ' 0x1234', padded to a width of 10 characters
	in 32-bits ('0x' + 8 nibbles) or 18 characters in 64-bits ('0x' + 16
	nibbles)  */

void
printHex(sqInt n)
{
    char buf[35];
    sqInt len;

	memset(buf,' ',34);
	len = sprintf(buf + 2 + 2 * BytesPerWord, "0x%lx", (unsigned long)(n));
	printf("%s", buf + len);
	;
}


/*	Scan the heap printing the oops of any and all objects that are instances
	of aClassOop
 */

void
printInstancesOf(sqInt aClassOop)
{   DECL_MAYBE_SQ_GLOBAL_STRUCT
    sqInt header;
    sqInt header1;
    sqInt header2;
    sqInt obj;
    sqInt obj1;
    sqInt oop;
    sqInt sz;
    sqInt sz1;
    sqInt sz2;

	/* begin firstAccessibleObject */
	obj1 = heapBase + (headerTypeBytes[(longAt(heapBase)) & TypeMask]);
	while ((((usqInt) obj1)) < (((usqInt) GIV(freeStart)))) {
		if (!(((longAt(obj1)) & TypeMask) == HeaderTypeFree)) {
			oop = obj1;
			goto l2;
		}
		/* begin objectAfter: */
		if (DoAssertionChecks) {
			if ((((usqInt) obj1)) >= (((usqInt) GIV(endOfMemory)))) {
				error("no objects after the end of memory");
			}
		}
		if (((longAt(obj1)) & TypeMask) == HeaderTypeFree) {
			sz2 = (longAt(obj1)) & AllButTypeMask;
		}
		else {
			/* begin sizeBitsOf: */
			header2 = longAt(obj1);
			sz2 = ((header2 & TypeMask) == HeaderTypeSizeAndClass
				? (longAt(obj1 - (BytesPerWord * 2))) & LongSizeMask
				: header2 & SizeMask);
		}
		obj1 = (obj1 + sz2) + (headerTypeBytes[(longAt(obj1 + sz2)) & TypeMask]);
	}
	error("heap is empty");
	oop = null;
l2:	/* end firstAccessibleObject */;
	while (!(oop == null)) {
		if ((fetchClassOfNonInt(oop)) == aClassOop) {
			printHex(oop);
			/* begin cr */
			printf("\n");
		}
		/* begin accessibleObjectAfter: */
		/* begin objectAfter: */
		if (DoAssertionChecks) {
			if ((((usqInt) oop)) >= (((usqInt) GIV(endOfMemory)))) {
				error("no objects after the end of memory");
			}
		}
		if (((longAt(oop)) & TypeMask) == HeaderTypeFree) {
			sz1 = (longAt(oop)) & AllButTypeMask;
		}
		else {
			/* begin sizeBitsOf: */
			header1 = longAt(oop);
			sz1 = ((header1 & TypeMask) == HeaderTypeSizeAndClass
				? (longAt(oop - (BytesPerWord * 2))) & LongSizeMask
				: header1 & SizeMask);
		}
		obj = (oop + sz1) + (headerTypeBytes[(longAt(oop + sz1)) & TypeMask]);
		while ((((usqInt) obj)) < (((usqInt) GIV(freeStart)))) {
			if (!(((longAt(obj)) & TypeMask) == HeaderTypeFree)) {
				oop = obj;
				goto l1;
			}
			/* begin objectAfter: */
			if (DoAssertionChecks) {
				if ((((usqInt) obj)) >= (((usqInt) GIV(endOfMemory)))) {
					error("no objects after the end of memory");
				}
			}
			if (((longAt(obj)) & TypeMask) == HeaderTypeFree) {
				sz = (longAt(obj)) & AllButTypeMask;
			}
			else {
				/* begin sizeBitsOf: */
				header = longAt(obj);
				sz = ((header & TypeMask) == HeaderTypeSizeAndClass
					? (longAt(obj - (BytesPerWord * 2))) & LongSizeMask
					: header & SizeMask);
			}
			obj = (obj + sz) + (headerTypeBytes[(longAt(obj + sz)) & TypeMask]);
		}
		oop = null;
	l1:	/* end accessibleObjectAfter: */;
	}
}

static void
printLogEntryAt(sqInt i)
{   DECL_MAYBE_SQ_GLOBAL_STRUCT
    sqInt intOrClass;
    sqInt selectorOrMethod;
    sqInt source;
    static char *traceSources[] = {
		"?"
		,"m"
		,"i"
		,"callbackEnter"
		,"callbackLeave"
		,"enterCritical"
		,"exitCritical"
		,"resume"
		,"signal"
		,"suspend"
		,"wait"
		,"yield"
		,"eventcheck"
		,"threadsched"
		,"ownVM"
		,"bindToThread"
		,"switchIfNecessary"
	}
;

	intOrClass = GIV(traceLog)[i];
	selectorOrMethod = GIV(traceLog)[i + 1];
	source = GIV(traceLog)[i + 2];
	if (source <= TraceIsFromInterpreter) {
		print(traceSources[source]);
		/* begin space */
		/* begin printChar: */
		putchar(' ');
	}
	if ((intOrClass & 1)) {
		if (intOrClass == TraceContextSwitch) {
			print("context switch");
		}
		if (intOrClass == TraceBlockActivation) {
			print(" [] in ");
			printHex(selectorOrMethod);
		}
		if (intOrClass == TraceBlockCreation) {
			print("create [] ");
			printHex(selectorOrMethod);
		}
		if (intOrClass == TraceIncrementalGC) {
			print("incrementalGC");
		}
		if (intOrClass == TraceFullGC) {
			print("fullGC");
		}
		if (intOrClass == TraceCodeCompaction) {
			print("compactCode");
		}
		if (intOrClass == TraceVMCallback) {
			print("callback");
		}
		if (intOrClass == TraceVMCallbackReturn) {
			print("return from callback");
		}
	}
	else {
		/* begin space */
		/* begin printChar: */
		putchar(' ');
		printNameOfClasscount(intOrClass, 5);
		print(">>");
		printStringOf(selectorOrMethod);
	}
	if (source > TraceIsFromInterpreter) {
		/* begin space */
		/* begin printChar: */
		putchar(' ');
		print(traceSources[source]);
	}
	/* begin cr */
	printf("\n");
}

void
printMemory(void)
{   DECL_MAYBE_SQ_GLOBAL_STRUCT
	/* begin printMemField:name:size: */
	print("memory      ");
	/* begin tab */
	/* begin printChar: */
	putchar('	');
	/* begin printHexPtr: */
	printHex(oopForPointer(heapBase));
	/* begin printChar: */
	putchar('/');
	printNum(oopForPointer(heapBase));
	print(" sz: ");
	printHex(GIV(youngStart) - heapBase);
	if ((GIV(youngStart) - heapBase) != 0) {
		/* begin printChar: */
		putchar('/');
		printNum(GIV(youngStart) - heapBase);
	}
	/* begin cr */
	printf("\n");
	/* begin printMemField:name:size: */
	print("youngStart  ");
	/* begin tab */
	/* begin printChar: */
	putchar('	');
	/* begin printHexPtr: */
	printHex(oopForPointer(GIV(youngStart)));
	/* begin printChar: */
	putchar('/');
	printNum(oopForPointer(GIV(youngStart)));
	print(" sz: ");
	printHex(GIV(freeStart) - GIV(youngStart));
	if ((GIV(freeStart) - GIV(youngStart)) != 0) {
		/* begin printChar: */
		putchar('/');
		printNum(GIV(freeStart) - GIV(youngStart));
	}
	/* begin cr */
	printf("\n");
	if (GIV(freeStart) <= GIV(scavengeThreshold)) {
		/* begin printMemField:name:size: */
		print("freeStart   ");
		/* begin tab */
		/* begin printChar: */
		putchar('	');
		/* begin printHexPtr: */
		printHex(oopForPointer(GIV(freeStart)));
		/* begin printChar: */
		putchar('/');
		printNum(oopForPointer(GIV(freeStart)));
		print(" sz: ");
		printHex(GIV(reserveStart) - GIV(freeStart));
		if ((GIV(reserveStart) - GIV(freeStart)) != 0) {
			/* begin printChar: */
			putchar('/');
			printNum(GIV(reserveStart) - GIV(freeStart));
		}
		/* begin cr */
		printf("\n");
		/* begin printMemField:name:size: */
		print("scavenge@   ");
		/* begin tab */
		/* begin printChar: */
		putchar('	');
		/* begin printHexPtr: */
		printHex(oopForPointer(GIV(scavengeThreshold)));
		/* begin printChar: */
		putchar('/');
		printNum(oopForPointer(GIV(scavengeThreshold)));
		print(" sz: ");
		printHex(GIV(scavengeThreshold) - GIV(freeStart));
		if ((GIV(scavengeThreshold) - GIV(freeStart)) != 0) {
			/* begin printChar: */
			putchar('/');
			printNum(GIV(scavengeThreshold) - GIV(freeStart));
		}
		/* begin cr */
		printf("\n");
	}
	else {
		/* begin printMemField:name:size: */
		print("scavenge@   ");
		/* begin tab */
		/* begin printChar: */
		putchar('	');
		/* begin printHexPtr: */
		printHex(oopForPointer(GIV(scavengeThreshold)));
		/* begin printChar: */
		putchar('/');
		printNum(oopForPointer(GIV(scavengeThreshold)));
		print(" sz: ");
		printHex(GIV(scavengeThreshold) - GIV(freeStart));
		if ((GIV(scavengeThreshold) - GIV(freeStart)) != 0) {
			/* begin printChar: */
			putchar('/');
			printNum(GIV(scavengeThreshold) - GIV(freeStart));
		}
		/* begin cr */
		printf("\n");
		/* begin printMemField:name:size: */
		print("freeStart   ");
		/* begin tab */
		/* begin printChar: */
		putchar('	');
		/* begin printHexPtr: */
		printHex(oopForPointer(GIV(freeStart)));
		/* begin printChar: */
		putchar('/');
		printNum(oopForPointer(GIV(freeStart)));
		print(" sz: ");
		printHex(GIV(reserveStart) - GIV(freeStart));
		if ((GIV(reserveStart) - GIV(freeStart)) != 0) {
			/* begin printChar: */
			putchar('/');
			printNum(GIV(reserveStart) - GIV(freeStart));
		}
		/* begin cr */
		printf("\n");
	}
	/* begin printMemField:name:size: */
	print("reserveStart");
	/* begin tab */
	/* begin printChar: */
	putchar('	');
	/* begin printHexPtr: */
	printHex(oopForPointer(GIV(reserveStart)));
	/* begin printChar: */
	putchar('/');
	printNum(oopForPointer(GIV(reserveStart)));
	print(" sz: ");
	printHex(GIV(endOfMemory) - GIV(reserveStart));
	if ((GIV(endOfMemory) - GIV(reserveStart)) != 0) {
		/* begin printChar: */
		putchar('/');
		printNum(GIV(endOfMemory) - GIV(reserveStart));
	}
	/* begin cr */
	printf("\n");
	/* begin printMemField:name:size: */
	print("endOfMemory ");
	/* begin tab */
	/* begin printChar: */
	putchar('	');
	/* begin printHexPtr: */
	printHex(oopForPointer(GIV(endOfMemory)));
	/* begin printChar: */
	putchar('/');
	printNum(oopForPointer(GIV(endOfMemory)));
	print(" sz: ");
	printHex(GIV(memoryLimit) - GIV(endOfMemory));
	if ((GIV(memoryLimit) - GIV(endOfMemory)) != 0) {
		/* begin printChar: */
		putchar('/');
		printNum(GIV(memoryLimit) - GIV(endOfMemory));
	}
	/* begin cr */
	printf("\n");
	/* begin printMemField:name:size: */
	print("memoryLimit ");
	/* begin tab */
	/* begin printChar: */
	putchar('	');
	/* begin printHexPtr: */
	printHex(oopForPointer(GIV(memoryLimit)));
	/* begin printChar: */
	putchar('/');
	printNum(oopForPointer(GIV(memoryLimit)));
	print(" sz: ");
	printHex(0);
	if (0 != 0) {
		/* begin printChar: */
		putchar('/');
		printNum(0);
	}
	/* begin cr */
	printf("\n");
}


/*	Scan the heap printing the oops of any and all objects that refer to anOop */

void
printMethodReferencesTo(sqInt anOop)
{   DECL_MAYBE_SQ_GLOBAL_STRUCT
    sqInt header;
    sqInt header1;
    sqInt header2;
    sqInt i;
    sqInt obj;
    sqInt obj1;
    sqInt oop;
    sqInt sz;
    sqInt sz1;
    sqInt sz2;

	/* begin firstAccessibleObject */
	obj1 = heapBase + (headerTypeBytes[(longAt(heapBase)) & TypeMask]);
	while ((((usqInt) obj1)) < (((usqInt) GIV(freeStart)))) {
		if (!(((longAt(obj1)) & TypeMask) == HeaderTypeFree)) {
			oop = obj1;
			goto l2;
		}
		/* begin objectAfter: */
		if (DoAssertionChecks) {
			if ((((usqInt) obj1)) >= (((usqInt) GIV(endOfMemory)))) {
				error("no objects after the end of memory");
			}
		}
		if (((longAt(obj1)) & TypeMask) == HeaderTypeFree) {
			sz2 = (longAt(obj1)) & AllButTypeMask;
		}
		else {
			/* begin sizeBitsOf: */
			header2 = longAt(obj1);
			sz2 = ((header2 & TypeMask) == HeaderTypeSizeAndClass
				? (longAt(obj1 - (BytesPerWord * 2))) & LongSizeMask
				: header2 & SizeMask);
		}
		obj1 = (obj1 + sz2) + (headerTypeBytes[(longAt(obj1 + sz2)) & TypeMask]);
	}
	error("heap is empty");
	oop = null;
l2:	/* end firstAccessibleObject */;
	while (!(oop == null)) {
		if (((((usqInt) (longAt(oop))) >> 8) & 15) >= 12) {
			i = (literalCountOf(oop)) - 1;
			while (i >= 0) {
				if (anOop == (longAt((oop + BaseHeaderSize) + (i << ShiftForWord)))) {
					printHex(oop);
					print(" @ ");
					printNum(i);
					/* begin cr */
					printf("\n");
					i = 0;
				}
				i -= 1;
			}
		}
		/* begin accessibleObjectAfter: */
		/* begin objectAfter: */
		if (DoAssertionChecks) {
			if ((((usqInt) oop)) >= (((usqInt) GIV(endOfMemory)))) {
				error("no objects after the end of memory");
			}
		}
		if (((longAt(oop)) & TypeMask) == HeaderTypeFree) {
			sz1 = (longAt(oop)) & AllButTypeMask;
		}
		else {
			/* begin sizeBitsOf: */
			header1 = longAt(oop);
			sz1 = ((header1 & TypeMask) == HeaderTypeSizeAndClass
				? (longAt(oop - (BytesPerWord * 2))) & LongSizeMask
				: header1 & SizeMask);
		}
		obj = (oop + sz1) + (headerTypeBytes[(longAt(oop + sz1)) & TypeMask]);
		while ((((usqInt) obj)) < (((usqInt) GIV(freeStart)))) {
			if (!(((longAt(obj)) & TypeMask) == HeaderTypeFree)) {
				oop = obj;
				goto l1;
			}
			/* begin objectAfter: */
			if (DoAssertionChecks) {
				if ((((usqInt) obj)) >= (((usqInt) GIV(endOfMemory)))) {
					error("no objects after the end of memory");
				}
			}
			if (((longAt(obj)) & TypeMask) == HeaderTypeFree) {
				sz = (longAt(obj)) & AllButTypeMask;
			}
			else {
				/* begin sizeBitsOf: */
				header = longAt(obj);
				sz = ((header & TypeMask) == HeaderTypeSizeAndClass
					? (longAt(obj - (BytesPerWord * 2))) & LongSizeMask
					: header & SizeMask);
			}
			obj = (obj + sz) + (headerTypeBytes[(longAt(obj + sz)) & TypeMask]);
		}
		oop = null;
	l1:	/* end accessibleObjectAfter: */;
	}
}


/*	Details: The count argument is used to avoid a possible infinite recursion
	if classOop is a corrupted object.
 */

static void
printNameOfClasscount(sqInt classOop, sqInt cnt)
{   DECL_MAYBE_SQ_GLOBAL_STRUCT
	if ((classOop == 0)
	 || (cnt <= 0)) {
		print("bad class"); return;
	}
	if (((sizeBitsOf(classOop)) == GIV(metaclassSizeBytes))
	 && (GIV(metaclassSizeBytes) > (GIV(thisClassIndex) * BytesPerWord))) {
		printNameOfClasscount(longAt((classOop + BaseHeaderSize) + (GIV(thisClassIndex) << ShiftForWord)), cnt - 1);
		print(" class");
	}
	else {
		printStringOf(longAt((classOop + BaseHeaderSize) + (GIV(classNameIndex) << ShiftForWord)));
	}
}


/*	For testing in Smalltalk, this method should be overridden in a subclass. */

static void
printNum(sqInt n)
{
	printf("%ld", (long) n);
}

void
printObjectsFromto(sqInt startAddress, sqInt endAddress)
{
    sqInt header;
    sqInt oop;
    sqInt sz;

	oop = startAddress;
	while (oop < endAddress) {
		if (!(((longAt(oop)) & TypeMask) == HeaderTypeFree)) {
			printOop(oop);
		}
		/* begin objectAfter: */
		if (DoAssertionChecks) {
			if ((((usqInt) oop)) >= (((usqInt) GIV(endOfMemory)))) {
				error("no objects after the end of memory");
			}
		}
		if (((longAt(oop)) & TypeMask) == HeaderTypeFree) {
			sz = (longAt(oop)) & AllButTypeMask;
		}
		else {
			/* begin sizeBitsOf: */
			header = longAt(oop);
			sz = ((header & TypeMask) == HeaderTypeSizeAndClass
				? (longAt(oop - (BytesPerWord * 2))) & LongSizeMask
				: header & SizeMask);
		}
		oop = (oop + sz) + (headerTypeBytes[(longAt(oop + sz)) & TypeMask]);
	}
}

static void
printOopShort(sqInt oop)
{   DECL_MAYBE_SQ_GLOBAL_STRUCT
    sqInt ccIndex;
    sqInt classOop;
    char *name;
    sqInt nameLen;

	/* begin printOopShortInner: */
	VM_LABEL(0printOopShortInner);
	/* begin printChar: */
	putchar('=');
	if ((oop & 1)) {
		printNum((oop >> 1));
		/* begin printChar: */
		putchar('(');
		printHex((oop >> 1));
		/* begin printChar: */
		putchar(')');
		goto l2;
	}
	if (!(((oop >= heapBase) && (oop <= GIV(freeStart))))) {
		printHex(oop);
		print(" is not on the heap");
		goto l2;
	}
	if ((oop & (BytesPerWord - 1)) != 0) {
		printHex(oop);
		print(" is misaligned");
		goto l2;
	}
	if (((oop & 1) == 0)
	 && ((ClassFloatCompactIndex != 0
	? ((((usqInt) (longAt(oop))) >> 12) & 31) == ClassFloatCompactIndex
	: (fetchClassOfNonInt(oop)) == (longAt((GIV(specialObjectsOop) + BaseHeaderSize) + (ClassFloat << ShiftForWord)))))) {
		printFloat(dbgFloatValueOf(oop));
		goto l2;
	}
	/* begin fetchClassOf: */
	if ((oop & 1)) {
		classOop = longAt((GIV(specialObjectsOop) + BaseHeaderSize) + (ClassInteger << ShiftForWord));
		goto l1;
	}
	if (((ccIndex = (((usqInt) (longAt(oop))) >> 12) & 31)) == 0) {
		classOop = (longAt(oop - BaseHeaderSize)) & AllButTypeMask;
		goto l1;
	}
	else {
		classOop = longAt(((longAt((GIV(specialObjectsOop) + BaseHeaderSize) + (CompactClasses << ShiftForWord))) + BaseHeaderSize) + ((ccIndex - 1) << ShiftForWord));
		goto l1;
	}
l1:	/* end fetchClassOf: */;
	if ((sizeBitsOf(classOop)) == GIV(metaclassSizeBytes)) {
		printNameOfClasscount(oop, 5);
		goto l2;
	}
	if (oop == GIV(nilObj)) {
		print("nil");
		goto l2;
	}
	if (oop == GIV(trueObj)) {
		print("true");
		goto l2;
	}
	if (oop == GIV(falseObj)) {
		print("false");
		goto l2;
	}
	nameLen = lengthOfNameOfClass(classOop);
	if (nameLen == 0) {
		print("a ??");
		goto l2;
	}
	name = nameOfClass(classOop);
	if (nameLen == 10) {
		if (!(strncmp(name, "ByteString", 10))) {
			/* begin printChar: */
			putchar('"');
			printStringOf(oop);
			/* begin printChar: */
			putchar('"');
			goto l2;
		}
		if (!(strncmp(name, "ByteSymbol", 10))) {
			/* begin printChar: */
			putchar('#');
			printStringOf(oop);
			goto l2;
		}
	}
	if ((nameLen == 9)
	 && (!(strncmp(name, "Character", 9)))) {
		/* begin printChar: */
		putchar('$');
		/* begin printChar: */
		putchar(((longAt((oop + BaseHeaderSize) + (0 << ShiftForWord))) >> 1));
		goto l2;
	}
	printf("a(n) %.*s", nameLen, name);
l2:	/* end printOopShortInner: */;
	flush();
}

void
printOop(sqInt oop)
{   DECL_MAYBE_SQ_GLOBAL_STRUCT
    sqInt byte;
    sqInt bytecodesPerLine;
    sqInt cls;
    sqInt fmt;
    sqInt header;
    sqInt index;
    sqInt lastIndex;
    sqInt startIP;
    sqInt sz;

	printHex(oop);
	if ((oop & 1)) {
		printf("=%ld\n", integerValueOf(oop)); return;
	}
	if (!(((oop >= heapBase) && (oop <= GIV(freeStart))))) {
		printHex(oop);
		print(" is not on the heap");
		/* begin cr */
		printf("\n");
		return;
	}
	if ((oop & (BytesPerWord - 1)) != 0) {
		printHex(oop);
		print(" is misaligned");
		/* begin cr */
		printf("\n");
		return;
	}
	if (((longAt(oop)) & TypeMask) == HeaderTypeFree) {
		print(" free chunk of size ");
		printNum((longAt(oop)) & AllButTypeMask);
		/* begin cr */
		printf("\n");
		return;
	}
	print(": a(n) ");
	printNameOfClasscount(cls = fetchClassOfNonInt(oop), 5);
	if (cls == (longAt((GIV(specialObjectsOop) + BaseHeaderSize) + (ClassFloat << ShiftForWord)))) {
		/* begin cr */
		printf("\n");
		printFloat(dbgFloatValueOf(oop));
		/* begin cr */
		printf("\n");
		return;
	}
	fmt = (((usqInt) (longAt(oop))) >> 8) & 15;
	if (fmt > 4) {
		print(" nbytes ");
		printNum(byteSizeOf(oop));
	}
	/* begin cr */
	printf("\n");
	if ((fmt > 4)
	 && (fmt < 12)) {
		if (((oop & 1) == 0)
		 && (((((usqInt) (longAt(oop))) >> 8) & 15) == 6)) {
			lastIndex = ((64 < (((sqInt) (byteSizeOf(oop)) >> 2))) ? 64 : (((sqInt) (byteSizeOf(oop)) >> 2)));
			if (lastIndex > 0) {
				for (index = 1; index <= lastIndex; index += 1) {
					/* begin space */
					/* begin printChar: */
					putchar(' ');
					printHex(long32At((oop + BaseHeaderSize) + ((index - 1) << 2)));
					if ((index % 5) == 0) {
						/* begin cr */
						printf("\n");
					}
				}
				if (!((lastIndex % 5) == 0)) {
					/* begin cr */
					printf("\n");
				}
			}
			return;
		}
		printStringOf(oop),/* begin cr */printf("\n"); return;
	}
	lastIndex = ((64 < ((startIP = ((sqInt) (lastPointerOf(oop)) >> 2)))) ? 64 : ((startIP = ((sqInt) (lastPointerOf(oop)) >> 2))));
	if (lastIndex > 0) {
		for (index = 1; index <= lastIndex; index += 1) {
			printHex(fetchPointerofObject(index - 1, oop)); putchar(' ');
			if ((index % 5) == 0) {
				/* begin cr */
				printf("\n");
			}
		}
		if (!((lastIndex % 5) == 0)) {
			/* begin cr */
			printf("\n");
		}
	}
	if (((((usqInt) (longAt(oop))) >> 8) & 15) >= 12) {
		startIP = (startIP * BytesPerWord) + 1;
		/* begin lengthOf: */
		header = longAt(oop);
		/* begin lengthOf:baseHeader:format: */
		if ((header & TypeMask) == HeaderTypeSizeAndClass) {
			sz = (longAt(oop - (BytesPerWord * 2))) & LongSizeMask;
		}
		else {
			sz = header & SizeMask;
		}
		sz -= header & Size4Bit;
		if (((((usqInt) header) >> 8) & 15) <= 4) {
			lastIndex = ((usqInt) (sz - BaseHeaderSize)) >> ShiftForWord;
			goto l1;
		}
		if (((((usqInt) header) >> 8) & 15) < 8) {
			lastIndex = ((usqInt) (sz - BaseHeaderSize)) >> 2;
			goto l1;
		}
		else {
			lastIndex = (sz - BaseHeaderSize) - (((((usqInt) header) >> 8) & 15) & 3);
			goto l1;
		}
	l1:	/* end lengthOf: */;
		if ((lastIndex - startIP) > 100) {
			lastIndex = startIP + 100;
		}
		bytecodesPerLine = 10;
		for (index = startIP; index <= lastIndex; index += 1) {
			byte = byteAt((oop + BaseHeaderSize) + (index - 1));
			printf(" %02x/%-3d", byte,byte);
			if ((((index - startIP) + 1) % bytecodesPerLine) == 0) {
				/* begin cr */
				printf("\n");
			}
		}
		if (!((((lastIndex - startIP) + 1) % bytecodesPerLine) == 0)) {
			/* begin cr */
			printf("\n");
		}
	}
	else {
		if (startIP > 64) {
			print("...");
			/* begin cr */
			printf("\n");
		}
	}
}

static void
printProcessStack(sqInt aProcess)
{   DECL_MAYBE_SQ_GLOBAL_STRUCT
    sqInt ctx;

	/* begin cr */
	printf("\n");
	printNameOfClasscount(fetchClassOf(aProcess), 5);
	/* begin space */
	/* begin printChar: */
	putchar(' ');
	printHex(aProcess);
	print(" priority ");
	printNum(quickFetchIntegerofObject(PriorityIndex, aProcess));
	/* begin cr */
	printf("\n");
	ctx = longAt((aProcess + BaseHeaderSize) + (SuspendedContextIndex << ShiftForWord));
	if (!(ctx == GIV(nilObj))) {
		printCallStackOfcurrentFP(ctx, GIV(framePointer));
	}
}

static void
printProcsOnList(sqInt procList)
{
    sqInt firstProc;
    sqInt proc;

	proc = firstProc = longAt((procList + BaseHeaderSize) + (FirstLinkIndex << ShiftForWord));
	while (!(proc == GIV(nilObj))) {
		printProcessStack(proc);
		proc = longAt((proc + BaseHeaderSize) + (NextLinkIndex << ShiftForWord));
		if (proc == firstProc) {
			warning("circular process list!!");
			return;
		}
	}
}


/*	Scan the heap printing the oops of any and all objects that refer to anOop */

void
printReferencesTo(sqInt anOop)
{   DECL_MAYBE_SQ_GLOBAL_STRUCT
    sqInt header;
    sqInt header1;
    sqInt header2;
    sqInt i;
    sqInt obj;
    sqInt obj1;
    sqInt oop;
    sqInt sz;
    sqInt sz1;
    sqInt sz2;

	/* begin firstAccessibleObject */
	obj1 = heapBase + (headerTypeBytes[(longAt(heapBase)) & TypeMask]);
	while ((((usqInt) obj1)) < (((usqInt) GIV(freeStart)))) {
		if (!(((longAt(obj1)) & TypeMask) == HeaderTypeFree)) {
			oop = obj1;
			goto l2;
		}
		/* begin objectAfter: */
		if (DoAssertionChecks) {
			if ((((usqInt) obj1)) >= (((usqInt) GIV(endOfMemory)))) {
				error("no objects after the end of memory");
			}
		}
		if (((longAt(obj1)) & TypeMask) == HeaderTypeFree) {
			sz2 = (longAt(obj1)) & AllButTypeMask;
		}
		else {
			/* begin sizeBitsOf: */
			header2 = longAt(obj1);
			sz2 = ((header2 & TypeMask) == HeaderTypeSizeAndClass
				? (longAt(obj1 - (BytesPerWord * 2))) & LongSizeMask
				: header2 & SizeMask);
		}
		obj1 = (obj1 + sz2) + (headerTypeBytes[(longAt(obj1 + sz2)) & TypeMask]);
	}
	error("heap is empty");
	oop = null;
l2:	/* end firstAccessibleObject */;
	while (!(oop == null)) {
		if ((((oop & 1) == 0)
 && (((((usqInt) (longAt(oop))) >> 8) & 15) <= 4))
		 || (((((usqInt) (longAt(oop))) >> 8) & 15) >= 12)) {
			if (((((usqInt) (longAt(oop))) >> 8) & 15) >= 12) {
				i = (literalCountOf(oop)) - 1;
			}
			else {
				if (((oop & 1) == 0)
				 && (((((usqInt) (longAt(oop))) >> 12) & 31) == ClassMethodContextCompactIndex)) {
					i = (CtxtTempFrameStart + (fetchStackPointerOf(oop))) - 1;
				}
				else {
					i = (lengthOf(oop)) - 1;
				}
			}
			while (i >= 0) {
				if (anOop == (longAt((oop + BaseHeaderSize) + (i << ShiftForWord)))) {
					printHex(oop);
					print(" @ ");
					printNum(i);
					/* begin cr */
					printf("\n");
					i = 0;
				}
				i -= 1;
			}
		}
		/* begin accessibleObjectAfter: */
		/* begin objectAfter: */
		if (DoAssertionChecks) {
			if ((((usqInt) oop)) >= (((usqInt) GIV(endOfMemory)))) {
				error("no objects after the end of memory");
			}
		}
		if (((longAt(oop)) & TypeMask) == HeaderTypeFree) {
			sz1 = (longAt(oop)) & AllButTypeMask;
		}
		else {
			/* begin sizeBitsOf: */
			header1 = longAt(oop);
			sz1 = ((header1 & TypeMask) == HeaderTypeSizeAndClass
				? (longAt(oop - (BytesPerWord * 2))) & LongSizeMask
				: header1 & SizeMask);
		}
		obj = (oop + sz1) + (headerTypeBytes[(longAt(oop + sz1)) & TypeMask]);
		while ((((usqInt) obj)) < (((usqInt) GIV(freeStart)))) {
			if (!(((longAt(obj)) & TypeMask) == HeaderTypeFree)) {
				oop = obj;
				goto l1;
			}
			/* begin objectAfter: */
			if (DoAssertionChecks) {
				if ((((usqInt) obj)) >= (((usqInt) GIV(endOfMemory)))) {
					error("no objects after the end of memory");
				}
			}
			if (((longAt(obj)) & TypeMask) == HeaderTypeFree) {
				sz = (longAt(obj)) & AllButTypeMask;
			}
			else {
				/* begin sizeBitsOf: */
				header = longAt(obj);
				sz = ((header & TypeMask) == HeaderTypeSizeAndClass
					? (longAt(obj - (BytesPerWord * 2))) & LongSizeMask
					: header & SizeMask);
			}
			obj = (obj + sz) + (headerTypeBytes[(longAt(obj + sz)) & TypeMask]);
		}
		oop = null;
	l1:	/* end accessibleObjectAfter: */;
	}
}

void
printStackPageList(void)
{
    StackPage *page;

	page = mostRecentlyUsedPage();
	do {
		printStackPage(page);
		/* begin cr */
		printf("\n");
	} while(((page = (page->prevPage))) != (mostRecentlyUsedPage()));
}

void
printStackPageListInUse(void)
{
    StackPage *page;

	page = mostRecentlyUsedPage();
	do {
		if (!(isFree(page))) {
			printStackPage(page);
			/* begin cr */
			printf("\n");
		}
	} while(((page = (page->prevPage))) != (mostRecentlyUsedPage()));
}

void
printStackPages(void)
{
    sqInt i;

	for (i = 0; i <= (GIV(numStackPages) - 1); i += 1) {
		printStackPage(stackPageAt(i));
		/* begin cr */
		printf("\n");
	}
}

void
printStackPagesInUse(void)
{
    sqInt i;

	for (i = 0; i <= (GIV(numStackPages) - 1); i += 1) {
		if (!(isFree(stackPageAt(i)))) {
			printStackPage(stackPageAt(i));
			/* begin cr */
			printf("\n");
		}
	}
}

static void
printStackPage(StackPage *page)
{
    void *p;
    void *p1;
    void *p2;
    void *p3;
    void *p4;
    void *p5;
    void *p6;
    void *p7;

	print("page ");
	/* begin printHexPtr: */
	printHex(oopForPointer(page));
	print(" (");
	printNum(pageIndexFor((page->realStackLimit)));
	print(")  (trace: ");
	printNum((page->trace));
	/* begin printChar: */
	putchar(')');
	if (isFree(page)) {
		print(" (free)");
	}
	if (page == (mostRecentlyUsedPage())) {
		print(" (MRU)");
	}
	/* begin cr */
	printf("\n");
	/* begin tab */
	/* begin printChar: */
	putchar('	');
	/* begin printHexPtr: */
	p3 = (page->baseAddress);
	printHex(oopForPointer(p3));
	print(" - ");
	/* begin printHexPtr: */
	p4 = (page->realStackLimit);
	printHex(oopForPointer(p4));
	print(" - ");
	/* begin printHexPtr: */
	p5 = (page->lastAddress);
	printHex(oopForPointer(p5));
	if (!(isFree(page))) {
		/* begin cr */
		printf("\n");
		/* begin tab */
		/* begin printChar: */
		putchar('	');
		print("baseFP ");
		/* begin printHexPtr: */
		p = (page->baseFP);
		printHex(oopForPointer(p));
		/* begin tab */
		/* begin printChar: */
		putchar('	');
		print("headFP ");
		/* begin printHexPtr: */
		p1 = (page->headFP);
		printHex(oopForPointer(p1));
		/* begin tab */
		/* begin printChar: */
		putchar('	');
		print("headSP ");
		/* begin printHexPtr: */
		p2 = (page->headSP);
		printHex(oopForPointer(p2));
	}
	/* begin cr */
	printf("\n");
	/* begin tab */
	/* begin printChar: */
	putchar('	');
	print("prev ");
	/* begin printHexPtr: */
	p6 = page->prevPage;
	printHex(oopForPointer(p6));
	print(" (");
	printNum(pageIndexFor(((page->prevPage)->realStackLimit)));
	/* begin printChar: */
	putchar(')');
	/* begin tab */
	/* begin printChar: */
	putchar('	');
	print("next ");
	/* begin printHexPtr: */
	p7 = page->nextPage;
	printHex(oopForPointer(p7));
	print(" (");
	printNum(pageIndexFor(((page->nextPage)->realStackLimit)));
	/* begin printChar: */
	putchar(')');
	/* begin cr */
	printf("\n");
}

static void
printStringOf(sqInt oop)
{   DECL_MAYBE_SQ_GLOBAL_STRUCT
    sqInt cnt;
    sqInt fmt;
    sqInt i;

	if ((oop & 1)) {
		return;
	}
	if (!(((oop >= heapBase) && (oop <= GIV(freeStart))))) {
		return;
	}
	if ((oop & (BytesPerWord - 1)) != 0) {
		return;
	}
	fmt = (((usqInt) (longAt(oop))) >> 8) & 15;
	if (fmt < 8) {
		return;
	}
	cnt = ((100 < (lengthOf(oop))) ? 100 : (lengthOf(oop)));
	i = 0;
	if ((isinstanceOfcompactClassIndex(oop, longAt((GIV(specialObjectsOop) + BaseHeaderSize) + (ClassByteArray << ShiftForWord)), GIV(classByteArrayCompactIndex)))
	 || ((isinstanceOfcompactClassIndex(oop, longAt((GIV(specialObjectsOop) + BaseHeaderSize) + (ClassLargePositiveInteger << ShiftForWord)), ClassLargePositiveIntegerCompactIndex))
 || (isinstanceOfcompactClassIndex(oop, longAt((GIV(specialObjectsOop) + BaseHeaderSize) + (ClassLargeNegativeInteger << ShiftForWord)), ClassLargeNegativeIntegerCompactIndex)))) {
		while (i < cnt) {
			printHex(byteAt((oop + BaseHeaderSize) + i));
			i += 1;
		}
	}
	else {
		while (i < cnt) {
			/* begin printChar: */
			putchar(byteAt((oop + BaseHeaderSize) + i));
			i += 1;
		}
	}
	flush();
}


/*	For testing in Smalltalk, this method should be overridden in a subclass. */

void
print(char *s)
{
	printf("%s", s);
}

void
pushBool(sqInt trueOrFalse)
{   DECL_MAYBE_SQ_GLOBAL_STRUCT
    sqInt object;
    char *sp;

	/* begin push: */
	object = (trueOrFalse
		? GIV(trueObj)
		: GIV(falseObj));
	longAtput(sp = GIV(stackPointer) - BytesPerWord, object);
	GIV(stackPointer) = sp;
}


/*	The receiver of a message send or the closure of a block activation is
	always on the stack above any arguments and the frame itself. See the
	diagram in StackInterpreter class>>initializeFrameIndices. */

static sqInt
pushedReceiverOrClosureOfFrame(char *theFP)
{
	return longAt(theFP + ((FoxCallerSavedIP + BytesPerWord) + ((((((usqInt)(longAt(theFP + FoxMethod)))) < heapBase
	? (mframeCogMethod(theFP)->cmNumArgs)
	: byteAt((theFP + FoxIFrameFlags) + 1))) << ShiftForWord)));
}

void
pushFloat(double f)
{   DECL_MAYBE_SQ_GLOBAL_STRUCT
    sqInt object;
    char *sp;

	/* begin push: */
	object = floatObjectOf(f);
	longAtput(sp = GIV(stackPointer) - BytesPerWord, object);
	GIV(stackPointer) = sp;
}

sqInt
pushInteger(sqInt integerValue)
{   DECL_MAYBE_SQ_GLOBAL_STRUCT
    char *sp;

	/* begin push: */
	longAtput(sp = GIV(stackPointer) - BytesPerWord, ((integerValue << 1) | 1));
	GIV(stackPointer) = sp;
	return null;
}


/*	Record the given object in a the remap buffer. Objects in this buffer are
	remapped when a compaction occurs. This facility is used by the
	interpreter to ensure that objects in temporary variables are properly
	remapped. 
 */

void
pushRemappableOop(sqInt oop)
{   DECL_MAYBE_SQ_GLOBAL_STRUCT
	assert(addressCouldBeOop(oop));
	GIV(remapBuffer)[(GIV(remapBufferCount) += 1)] = oop;
}


/*	In the StackInterpreter stacks grow down. */

void
push(sqInt object)
{   DECL_MAYBE_SQ_GLOBAL_STRUCT
    char *sp;

	longAtput(sp = GIV(stackPointer) - BytesPerWord, object);
	GIV(stackPointer) = sp;
}


/*	Append aWord to aFile in this platforms 'natural' byte order. (Bytes will
	be swapped, if
	necessary, when the image is read on a different platform.) Set
	successFlag to false if
	the write fails.
 */

static void
putLongtoFile(sqInt aWord, sqImageFile  aFile)
{   DECL_MAYBE_SQ_GLOBAL_STRUCT
    sqInt objectsWritten;

	objectsWritten = sqImageFileWrite(&aWord, sizeof(aWord), 1, aFile);
	/* begin success: */
	if (!(objectsWritten == 1)) {
		if (GIV(primFailCode) == 0) {

			/* Don't overwrite an error code that has already been set. */

			GIV(primFailCode) = 1;
		}
	}
}


/*	Append the 16-bit aShort to aFile in this platforms 'natural' byte order.
	(Bytes will be swapped, if necessary, when the image is read on a
	different platform.) Set successFlag to false if the write fails. */

static void
putShorttoFile(sqInt aShort, sqImageFile  aFile)
{   DECL_MAYBE_SQ_GLOBAL_STRUCT
    sqInt objectsWritten;

	objectsWritten = sqImageFileWrite(&aShort, sizeof(short), 1, aFile);
	/* begin success: */
	if (!(objectsWritten == 1)) {
		if (GIV(primFailCode) == 0) {

			/* Don't overwrite an error code that has already been set. */

			GIV(primFailCode) = 1;
		}
	}
}


/*	Save the given process on the scheduler process list for its priority,
	adding to the back if yieldImplicitly or to the front if not
	yieldImplicitly. 
 */

static void
putToSleepyieldingIf(sqInt aProcess, sqInt yieldImplicitly)
{   DECL_MAYBE_SQ_GLOBAL_STRUCT
    sqInt firstLink;
    sqInt oop;
    sqInt priority;
    sqInt processList;
    sqInt processLists;

	assert((GIV(framePointer) - GIV(stackPointer)) < LargeContextSize);
	/* begin quickFetchInteger:ofObject: */
	oop = longAt((aProcess + BaseHeaderSize) + (PriorityIndex << ShiftForWord));
	assert((oop & 1));
	priority = (oop >> 1);
	if ((GIV(highestRunnableProcessPriority) != 0)
	 && (priority > GIV(highestRunnableProcessPriority))) {
		GIV(highestRunnableProcessPriority) = priority;
	}
	processLists = longAt(((longAt(((longAt((GIV(specialObjectsOop) + BaseHeaderSize) + (SchedulerAssociation << ShiftForWord))) + BaseHeaderSize) + (ValueIndex << ShiftForWord))) + BaseHeaderSize) + (ProcessListsIndex << ShiftForWord));
	processList = longAt((processLists + BaseHeaderSize) + ((priority - 1) << ShiftForWord));
	if (yieldImplicitly) {
		addLastLinktoList(aProcess, processList);
	}
	else {
		/* begin addFirstLink:toList: */
		VM_LABEL(0addFirstLinktoList);
		assert((fetchPointerofObject(NextLinkIndex, aProcess)) == (nilObject()));
		firstLink = longAt((processList + BaseHeaderSize) + (FirstLinkIndex << ShiftForWord));
		assert(firstLink != aProcess);
		/* begin storePointer:ofObject:withValue: */
		if ((((usqInt) processList)) < (((usqInt) GIV(youngStart)))) {
			possibleRootStoreIntovalue(processList, aProcess);
		}
		longAtput((processList + BaseHeaderSize) + (FirstLinkIndex << ShiftForWord), aProcess);
		if (firstLink == GIV(nilObj)) {
			/* begin storePointer:ofObject:withValue: */
			if ((((usqInt) processList)) < (((usqInt) GIV(youngStart)))) {
				possibleRootStoreIntovalue(processList, aProcess);
			}
			longAtput((processList + BaseHeaderSize) + (LastLinkIndex << ShiftForWord), aProcess);
		}
		else {
			/* begin storePointer:ofObject:withValue: */
			if ((((usqInt) aProcess)) < (((usqInt) GIV(youngStart)))) {
				possibleRootStoreIntovalue(aProcess, firstLink);
			}
			longAtput((aProcess + BaseHeaderSize) + (NextLinkIndex << ShiftForWord), firstLink);
		}
		/* begin storePointer:ofObject:withValue: */
		if ((((usqInt) aProcess)) < (((usqInt) GIV(youngStart)))) {
			possibleRootStoreIntovalue(aProcess, processList);
		}
		longAtput((aProcess + BaseHeaderSize) + (MyListIndex << ShiftForWord), processList);
	}
}


/*	Return the integer value of the field without verifying that it is an
	integer value! For use in time-critical places where the integer-ness of
	the field can be guaranteed.
 */

static sqInt
quickFetchIntegerofObject(sqInt fieldIndex, sqInt objectPointer)
{
    sqInt oop;

	oop = longAt((objectPointer + BaseHeaderSize) + (fieldIndex << ShiftForWord));
	assert((oop & 1));
	return (oop >> 1);
}

sqInt
quickPrimitiveConstantFor(sqInt aQuickPrimitiveIndex)
{   DECL_MAYBE_SQ_GLOBAL_STRUCT
	
	switch (aQuickPrimitiveIndex) {
	case 257:
				return GIV(trueObj);

	case 258:
				return GIV(falseObj);

	case 259:
				return GIV(nilObj);

	case 260:
				return ConstMinusOne;

	case 261:
				return ConstZero;

	case 262:
				return ConstOne;

	case 263:
				return ConstTwo;

	default:
		error("Case not found and no otherwise clause");
		return -1;
	}
}

int (*quickPrimitiveGeneratorFor(sqInt aQuickPrimitiveIndex))(void)

{
	
	switch (aQuickPrimitiveIndex) {
	case 256:
				return genQuickReturnSelf;

	case 257:
	case 258:
	case 259:
	case 260:
	case 261:
	case 262:
	case 263:
				return genQuickReturnConst;

	default:
				return genQuickReturnInstVar;

	}
}

sqInt
quickPrimitiveInstVarIndexFor(sqInt primIndex)
{
	return primIndex - 264;
}

sqInt
rawHeaderOf(sqInt methodPointer)
{
	return longAt((methodPointer + BaseHeaderSize) + (HeaderIndex << ShiftForWord));
}

void
rawHeaderOfput(sqInt methodOop, void *cogMethod)
{
	longAtput((methodOop + BaseHeaderSize) + (HeaderIndex << ShiftForWord), ((sqInt)cogMethod));
}


/*	Anwer true if images of the given format are readable by this interpreter.
	Allows a virtual machine to accept selected older image formats. */

sqInt
readableFormat(sqInt imageVersion)
{
	return (imageVersion == ((BytesPerWord == 4
	? 6505
	: 68003)))
	 || (imageVersion == ((BytesPerWord == 4
	? 6504
	: 68002)));
}


/*	Read an image from the given file stream, allocating the given amount of
	memory to its object heap. Fail if the image has an unknown format or
	requires more than the given amount of memory.
 */
/*	Details: This method detects when the image was stored on a machine with
	the opposite byte ordering from this machine and swaps the bytes
	automatically. Furthermore, it allows the header information to start 512
	bytes into the file, since some file transfer programs for the Macintosh
	apparently prepend a Mac-specific header of this size. Note that this same
	512 bytes of prefix area could also be used to store an exec command on
	Unix systems, allowing one to launch Smalltalk by invoking the image name
	as a command.
 */
/*	This code is based on C code by Ian Piumarta and Smalltalk code by Tim
	Rowledge. Many thanks to both of you!!
 */

sqInt
readImageFromFileHeapSizeStartingAt(sqImageFile  f, usqInt desiredHeapSize, squeakFileOffsetType  imageOffset)
{   DECL_MAYBE_SQ_GLOBAL_STRUCT
    sqInt anObject;
    sqInt aValue;
    sqInt aValue1;
    sqInt bytesRead;
    sqInt bytesToShift;
    size_t  dataSize;
    sqInt firstVersion;
    sqInt hdrCogCodeSize;
    sqInt hdrEdenBytes;
    sqInt hdrMaxExtSemTabSize;
    sqInt hdrNumStackPages;
    sqInt headerFlags;
    sqInt headerSize;
    squeakFileOffsetType  headerStart;
    sqInt heapSize;
    sqInt lastHash;
    sqInt minimumMemory;
    sqInt newMemoryLimit;
    sqInt oldBaseAddr;
    sqInt swapBytes;
    sqInt version;


	/* guess (Metaclass instSize * BPW) */

	GIV(metaclassSizeBytes) = 6 * BytesPerWord;
	/* begin checkImageVersionFrom:startingAt: */
	VM_LABEL(0checkImageVersionFromstartingAt);
	sqImageFileSeek(f, imageOffset);
	version = firstVersion = getLongFromFileswap(f, 0);
	if ((version == ((BytesPerWord == 4
	? 6505
	: 68003)))
	 || (version == ((BytesPerWord == 4
	? 6504
	: 68002)))) {
		swapBytes = 0;
		goto l1;
	}
	sqImageFileSeek(f, imageOffset);
	version = getLongFromFileswap(f, 1);
	if ((version == ((BytesPerWord == 4
	? 6505
	: 68003)))
	 || (version == ((BytesPerWord == 4
	? 6504
	: 68002)))) {
		swapBytes = 1;
		goto l1;
	}
	if (imageOffset == 0) {
		sqImageFileSeek(f, 512);
		version = getLongFromFileswap(f, 0);
		if ((version == ((BytesPerWord == 4
	? 6505
	: 68003)))
		 || (version == ((BytesPerWord == 4
	? 6504
	: 68002)))) {
			swapBytes = 0;
			goto l1;
		}
		sqImageFileSeek(f, 512);
		version = getLongFromFileswap(f, 1);
		if ((version == ((BytesPerWord == 4
	? 6505
	: 68003)))
		 || (version == ((BytesPerWord == 4
	? 6504
	: 68002)))) {
			swapBytes = 1;
			goto l1;
		}
	}
	print("This interpreter (vers. ");
	printNum((BytesPerWord == 4
		? 6505
		: 68003));
	print(") cannot read image file (vers. ");
	printNum(firstVersion);
	print(").");
	/* begin cr */
	printf("\n");
	print("Press CR to quit...");
	getchar();
	ioExitWithErrorCode(1);
	swapBytes = 0;
l1:	/* end checkImageVersionFrom:startingAt: */;

	/* record header start position */

	headerStart = (sqImageFilePosition(f)) - BytesPerWord;
	headerSize = getLongFromFileswap(f, swapBytes);
	dataSize = getLongFromFileswap(f, swapBytes);
	oldBaseAddr = getLongFromFileswap(f, swapBytes);
	/* begin specialObjectsOop: */
	anObject = getLongFromFileswap(f, swapBytes);
	GIV(specialObjectsOop) = anObject;
	/* begin lastHash: */
	aValue = getLongFromFileswap(f, swapBytes);
	lastHash = aValue;
	GIV(savedWindowSize) = getLongFromFileswap(f, swapBytes);
	headerFlags = getLongFromFileswap(f, swapBytes);
	/* begin setImageHeaderFlagsFrom: */

	/* so as to preserve unrecognised flags. */

	GIV(imageHeaderFlags) = headerFlags;
	GIV(fullScreenFlag) = headerFlags & 1;
	GIV(imageFloatsBigEndian) = ((headerFlags & 2) == 0
		? 1
		: 0);
	GIV(processHasThreadId) = (headerFlags & 4) != 0;
	GIV(flagInterpretedMethods) = (headerFlags & 8) != 0;
	GIV(preemptionYields) = (headerFlags & 16) == 0;
	GIV(noThreadingOfGUIThread) = (headerFlags & 32) != 0;

	/* N.B.  not used. */

	extraVMMemory = getLongFromFileswap(f, swapBytes);

	/* 4 stack pages is small.  Should be able to run with as few as
	 three. 4 should be comfortable but slow.  8 is a reasonable
	 default.  Can be changed via vmParameterAt: 43 put: n.
	 Can be set as a preference (Info.plist, VM.ini, command line etc).
	 If desiredNumStackPages is already non-zero then it has been
	 set as a preference.  Ignore (but preserve) the header's default. */

	hdrNumStackPages = getShortFromFileswap(f, swapBytes);
	GIV(numStackPages) = (desiredNumStackPages != 0
		? desiredNumStackPages
		: (hdrNumStackPages == 0
	? defaultNumStackPages()
	: hdrNumStackPages));

	/* This slot holds the size of the native method zone in 1k units. (pad to word boundary). */

	desiredNumStackPages = hdrNumStackPages;
	hdrCogCodeSize = (getShortFromFileswap(f, swapBytes)) * 1024;
	GIV(cogCodeSize) = (desiredCogCodeSize != 0
		? desiredCogCodeSize
		: (hdrCogCodeSize == 0
	? defaultCogCodeSize()
	: hdrCogCodeSize));
	hdrEdenBytes = getLongFromFileswap(f, swapBytes);
	/* begin edenBytes: */
	aValue1 = (desiredEdenBytes != 0
		? desiredEdenBytes
		: (hdrEdenBytes == 0
	? defaultEdenBytes()
	: hdrEdenBytes));
	GIV(edenBytes) = aValue1;
	desiredEdenBytes = hdrEdenBytes;
	hdrMaxExtSemTabSize = getShortFromFileswap(f, swapBytes);
	if (hdrMaxExtSemTabSize != 0) {
		/* begin setMaxExtSemSizeTo: */
		GIV(maxExtSemTabSizeSet) = 1;
		ioSetMaxExtSemTableSize(hdrMaxExtSemTabSize);
	}

	/* no need to include the stackZone; this is alloca'ed */

	minimumMemory = ((GIV(cogCodeSize) + dataSize) + GIV(edenBytes)) + (interpreterAllocationReserveBytes());

	/* no need to include the stackZone; this is alloca'ed */
	/* + edenBytes */
	/* don't include edenBytes; this is part of the heap and so part of desiredHeapSize */

	heapSize = (GIV(cogCodeSize) + desiredHeapSize) + (interpreterAllocationReserveBytes());
	if (heapSize < minimumMemory) {
		insufficientMemorySpecifiedError();
	}
	memory = sqAllocateMemory(minimumMemory, heapSize);
	if ((memory()) == null) {
		insufficientMemoryAvailableError();
	}
	heapBase = (memory()) + GIV(cogCodeSize);
	assert((startOfMemory()) == heapBase);
	/* begin setMemoryLimit: */
	newMemoryLimit = ((memory()) + heapSize) - 24;
	assert((newMemoryLimit & (BytesPerWord - 1)) == 0);
	GIV(memoryLimit) = newMemoryLimit;
	/* begin setEndOfMemory: */
	assert(((heapBase + dataSize) & (BytesPerWord - 1)) == 0);
	GIV(endOfMemory) = heapBase + dataSize;
	sqImageFileSeek(f, headerStart + headerSize);
	bytesRead = sqImageFileRead(pointerForOop(heapBase), sizeof(unsigned char), dataSize, f);
	if (bytesRead != dataSize) {
		unableToReadImageError();
	}
	ensureImageFormatIsUpToDate(swapBytes);
	bytesToShift = heapBase - oldBaseAddr;
	initializeInterpreter(bytesToShift);
	/* begin initializeCodeGenerator */
	GIV(linkSends) = 1;
	initializeCodeZoneFromupTo(memory(), (memory()) + GIV(cogCodeSize));
	return dataSize;
}


/*	callbackContext is an activation of
	invokeCallback:[stack:registers:jmpbuf:]. Its sender is the VM's state
	prior to the callback. Reestablish that state,
	and mark calloutContext as dead. */

EXPORT(sqInt)
reestablishContextPriorToCallback(sqInt callbackContext)
{   DECL_MAYBE_SQ_GLOBAL_STRUCT
    StackPage *aPage;
    sqInt calloutContext;
    sqInt index;
    char *theFP;
    char *theFP1;
    StackPage *thePage;
    sqInt top;
    sqInt value;
    sqInt value1;

	flag("obsolete");
	if (!(isLiveContext(callbackContext))) {
		return 0;
	}
	calloutContext = externalInstVarofContext(SenderIndex, callbackContext);
	if (!(isLiveContext(calloutContext))) {
		return 0;
	}
	if (((longAt((callbackContext + BaseHeaderSize) + (SenderIndex << ShiftForWord))) & 1) == 0) {
		/* begin markContextAsDead: */
		assert(isContext(callbackContext));
		longAtput((callbackContext + BaseHeaderSize) + (SenderIndex << ShiftForWord), GIV(nilObj));
		longAtput((callbackContext + BaseHeaderSize) + (InstructionPointerIndex << ShiftForWord), GIV(nilObj));
	}
	else {
		/* begin frameOfMarriedContext: */
		value = longAt((callbackContext + BaseHeaderSize) + (SenderIndex << ShiftForWord));
		/* begin withoutSmallIntegerTags: */
		assert((value & 1));
		theFP = pointerForOop(value - 1);
		if (GIV(framePointer) == theFP) {
			if ((longAt(theFP + FoxSavedFP)) == 0) {
				/* begin freeStackPage: */
				aPage = GIV(stackPage);
				freeStackPageNoAssert(aPage);
				assert(pageListIsWellFormed());
			}
			else {

				/* calloutContext is immediately below on the same page.  Make it current. */

				GIV(instructionPointer) = ((usqInt)(frameCallerSavedIP(GIV(framePointer))));
				GIV(stackPointer) = (GIV(framePointer) + ((FoxCallerSavedIP + BytesPerWord) + ((((((usqInt)(longAt(GIV(framePointer) + FoxMethod)))) < heapBase
	? (mframeCogMethod(GIV(framePointer))->cmNumArgs)
	: byteAt((GIV(framePointer) + FoxIFrameFlags) + 1))) << ShiftForWord))) + BytesPerWord;
				/* begin frameCallerFP: */
				theFP1 = GIV(framePointer);
				GIV(framePointer) = pointerForOop(longAt(theFP1 + FoxSavedFP));
				return 1;
			}
		}
		else {
			externalDivorceFrameandContext(theFP, callbackContext);
			/* begin markContextAsDead: */
			assert(isContext(callbackContext));
			longAtput((callbackContext + BaseHeaderSize) + (SenderIndex << ShiftForWord), GIV(nilObj));
			longAtput((callbackContext + BaseHeaderSize) + (InstructionPointerIndex << ShiftForWord), GIV(nilObj));
		}
	}
	if ((((longAt((calloutContext + BaseHeaderSize) + (SenderIndex << ShiftForWord))) & 1))
	 && (!(isWidowedContext(calloutContext)))) {
		/* begin frameOfMarriedContext: */
		value1 = longAt((calloutContext + BaseHeaderSize) + (SenderIndex << ShiftForWord));
		/* begin withoutSmallIntegerTags: */
		assert((value1 & 1));
		theFP = pointerForOop(value1 - 1);
		/* begin stackPageFor: */
		/* begin stackPageAt: */
		/* begin pageIndexFor: */
		assert((((((char *) theFP)) >= (GIV(stackBasePlus1) - 1)) && ((((char *) theFP)) <= (((char *) GIV(pages))))));
		index = pageIndexForstackBasePlus1bytesPerPage(theFP, GIV(stackBasePlus1), GIV(bytesPerPage));
		thePage = stackPageAtpages(index, GIV(pages));
		assert(thePage != GIV(stackPage));
		GIV(stackPointer) = (findSPOfon(theFP, thePage)) - BytesPerWord;
		GIV(framePointer) = theFP;
	}
	else {
		thePage = makeBaseFrameFor(calloutContext);
		GIV(framePointer) = (thePage->headFP);
		GIV(stackPointer) = (thePage->headSP);
	}
	/* begin popStack */
	top = longAt(GIV(stackPointer));
	GIV(stackPointer) += BytesPerWord;
	GIV(instructionPointer) = ((sqInt) top);
	/* begin setStackPageAndLimit: */
	GIV(stackPage) = thePage;
	if (GIV(stackLimit) != (((char *) (((usqInt) -1))))) {
		GIV(stackLimit) = (GIV(stackPage)->stackLimit);
	}
	markStackPageMostRecentlyUsed(thePage);
	return 1;
}


/*	Map the given oop to its new value during a compaction or 
	become: operation. If it has no forwarding table entry, 
	return the oop itself. */

sqInt
remap(sqInt oop)
{
    sqInt fwdBlock;
    sqInt targetObj;

	if (((oop & 1) == 0)
	 && (((longAt(oop)) & MarkBit) != 0)) {
		/* begin remappedObj: */
		fwdBlock = ((longAt(oop)) & AllButMarkBitAndTypeMask) << 1;
		assert(fwdBlockValid(fwdBlock));
		targetObj = longAt(fwdBlock);
		assert(addressCouldBeObjWhileForwarding(targetObj));
		return targetObj;
	}
	return oop;
}


/*	Remove the first process from the given linked list. */

static sqInt
removeFirstLinkOfList(sqInt aList)
{   DECL_MAYBE_SQ_GLOBAL_STRUCT
    sqInt first;
    sqInt last;
    sqInt next;

	first = longAt((aList + BaseHeaderSize) + (FirstLinkIndex << ShiftForWord));
	last = longAt((aList + BaseHeaderSize) + (LastLinkIndex << ShiftForWord));
	if (first == last) {
		/* begin storePointer:ofObject:withValue: */
		if ((((usqInt) aList)) < (((usqInt) GIV(youngStart)))) {
			possibleRootStoreIntovalue(aList, GIV(nilObj));
		}
		longAtput((aList + BaseHeaderSize) + (FirstLinkIndex << ShiftForWord), GIV(nilObj));
		/* begin storePointer:ofObject:withValue: */
		if ((((usqInt) aList)) < (((usqInt) GIV(youngStart)))) {
			possibleRootStoreIntovalue(aList, GIV(nilObj));
		}
		longAtput((aList + BaseHeaderSize) + (LastLinkIndex << ShiftForWord), GIV(nilObj));
	}
	else {
		next = longAt((first + BaseHeaderSize) + (NextLinkIndex << ShiftForWord));
		/* begin storePointer:ofObject:withValue: */
		if ((((usqInt) aList)) < (((usqInt) GIV(youngStart)))) {
			possibleRootStoreIntovalue(aList, next);
		}
		longAtput((aList + BaseHeaderSize) + (FirstLinkIndex << ShiftForWord), next);
	}
	/* begin storePointer:ofObject:withValue: */
	if ((((usqInt) first)) < (((usqInt) GIV(youngStart)))) {
		possibleRootStoreIntovalue(first, GIV(nilObj));
	}
	longAtput((first + BaseHeaderSize) + (NextLinkIndex << ShiftForWord), GIV(nilObj));
	return first;
}


/*	Remove the given variable location to the extra roots table */

EXPORT(sqInt)
removeGCRoot(sqInt *varLoc)
{   DECL_MAYBE_SQ_GLOBAL_STRUCT
    sqInt i;
    sqInt *root;

	for (i = 1; i <= GIV(extraRootCount); i++) {
		root = GIV(extraRoots)[i];
		if (root == varLoc) {
			GIV(extraRoots)[i] = (GIV(extraRoots)[GIV(extraRootCount)]);
			GIV(extraRootCount) -= 1;
			return 1;
		}
	}
	return 0;
}


/*	Restore headers smashed by forwarding links */

static void
restoreHeadersFromtofromandtofrom(sqInt firstIn, sqInt lastIn, sqInt hdrBaseIn, sqInt firstOut, sqInt lastOut, sqInt hdrBaseOut)
{   DECL_MAYBE_SQ_GLOBAL_STRUCT
    sqInt header;
    sqInt header1;
    sqInt oop;
    sqInt sz;
    sqInt tablePtr;

	tablePtr = firstIn;
	while ((((usqInt) tablePtr)) <= (((usqInt) lastIn))) {
		oop = longAt(tablePtr);
		header = longAt(hdrBaseIn + (tablePtr - firstIn));
		longAtput(oop, header);
		tablePtr += BytesPerWord;
	}
	tablePtr = firstOut;
	while ((((usqInt) tablePtr)) <= (((usqInt) lastOut))) {
		oop = longAt(tablePtr);
		header = longAt(hdrBaseOut + (tablePtr - firstOut));
		longAtput(oop, header);
		tablePtr += BytesPerWord;
	}
	oop = heapBase + (headerTypeBytes[(longAt(heapBase)) & TypeMask]);
	while ((((usqInt) oop)) < (((usqInt) GIV(freeStart)))) {
		if (!(((longAt(oop)) & TypeMask) == HeaderTypeFree)) {
			longAtput(oop, (longAt(oop)) & AllButMarkBit);
		}
		/* begin objectAfter: */
		if (DoAssertionChecks) {
			if ((((usqInt) oop)) >= (((usqInt) GIV(endOfMemory)))) {
				error("no objects after the end of memory");
			}
		}
		if (((longAt(oop)) & TypeMask) == HeaderTypeFree) {
			sz = (longAt(oop)) & AllButTypeMask;
		}
		else {
			/* begin sizeBitsOf: */
			header1 = longAt(oop);
			sz = ((header1 & TypeMask) == HeaderTypeSizeAndClass
				? (longAt(oop - (BytesPerWord * 2))) & LongSizeMask
				: header1 & SizeMask);
		}
		oop = (oop + sz) + (headerTypeBytes[(longAt(oop + sz)) & TypeMask]);
	}
}


/*	Make aProcess runnable and if its priority is higher than that of the
	current process, preempt the current process. Answer if the current
	process was preempted. If the current process was preempted then if
	yieldImplicitly add the current process to the back of its run queue,
	causing an implicit yeild to other processes on the run queue, otherwise
	add the current process to the front of its run queue, hence not yielding.
	Blue book behaviour is to yield implicitly but is arguably incorrect.
	Override to add tracing info. */

static sqInt
resumepreemptedYieldingIffrom(sqInt aProcess, sqInt yieldImplicitly, sqInt sourceCode)
{
    sqInt activePriority;
    sqInt activeProc;
    sqInt newPriority;
    sqInt oop;
    sqInt oop1;

	activeProc = longAt(((longAt(((longAt((GIV(specialObjectsOop) + BaseHeaderSize) + (SchedulerAssociation << ShiftForWord))) + BaseHeaderSize) + (ValueIndex << ShiftForWord))) + BaseHeaderSize) + (ActiveProcessIndex << ShiftForWord));
	/* begin quickFetchInteger:ofObject: */
	oop = longAt((activeProc + BaseHeaderSize) + (PriorityIndex << ShiftForWord));
	assert((oop & 1));
	activePriority = (oop >> 1);
	/* begin quickFetchInteger:ofObject: */
	oop1 = longAt((aProcess + BaseHeaderSize) + (PriorityIndex << ShiftForWord));
	assert((oop1 & 1));
	newPriority = (oop1 >> 1);
	if (newPriority <= activePriority) {
		putToSleepyieldingIf(aProcess, 1);
		return 0;
	}
	putToSleepyieldingIf(activeProc, yieldImplicitly);
	transferTofrom(aProcess, sourceCode);
	return 1;
}


/*	callbackMethodContext is an activation of
	invokeCallback:[stack:registers:jmpbuf:]. Its sender is the VM's state
	prior to the callback. Reestablish that state (via longjmp),
	and mark callbackMethodContext as dead. */

EXPORT(sqInt)
returnAsThroughCallbackContext(sqInt returnTypeOop, VMCallbackContext *vmCallbackContext, sqInt callbackMethodContext)
{   DECL_MAYBE_SQ_GLOBAL_STRUCT
    StackPage *aPage;
    sqInt calloutMethodContext;
    sqInt index;
    char *theFP;
    char *theFP1;
    StackPage *thePage;
    sqInt top;
    sqInt value;
    sqInt value1;

	if (!(((returnTypeOop & 1))
		 && (isLiveContext(callbackMethodContext)))) {
		return 0;
	}
	calloutMethodContext = externalInstVarofContext(SenderIndex, callbackMethodContext);
	if (!(isLiveContext(calloutMethodContext))) {
		return 0;
	}
	if (((longAt((callbackMethodContext + BaseHeaderSize) + (SenderIndex << ShiftForWord))) & 1) == 0) {
		/* begin markContextAsDead: */
		assert(isContext(callbackMethodContext));
		longAtput((callbackMethodContext + BaseHeaderSize) + (SenderIndex << ShiftForWord), GIV(nilObj));
		longAtput((callbackMethodContext + BaseHeaderSize) + (InstructionPointerIndex << ShiftForWord), GIV(nilObj));
	}
	else {
		/* begin frameOfMarriedContext: */
		value = longAt((callbackMethodContext + BaseHeaderSize) + (SenderIndex << ShiftForWord));
		/* begin withoutSmallIntegerTags: */
		assert((value & 1));
		theFP = pointerForOop(value - 1);
		if (GIV(framePointer) == theFP) {
			if ((longAt(theFP + FoxSavedFP)) == 0) {
				/* begin freeStackPage: */
				aPage = GIV(stackPage);
				freeStackPageNoAssert(aPage);
				assert(pageListIsWellFormed());
			}
			else {

				/* calloutMethodContext is immediately below on the same page.  Make it current. */

				GIV(instructionPointer) = ((usqInt)(frameCallerSavedIP(GIV(framePointer))));
				GIV(stackPointer) = (GIV(framePointer) + ((FoxCallerSavedIP + BytesPerWord) + ((((((usqInt)(longAt(GIV(framePointer) + FoxMethod)))) < heapBase
	? (mframeCogMethod(GIV(framePointer))->cmNumArgs)
	: byteAt((GIV(framePointer) + FoxIFrameFlags) + 1))) << ShiftForWord))) + BytesPerWord;
				/* begin frameCallerFP: */
				theFP1 = GIV(framePointer);
				GIV(framePointer) = pointerForOop(longAt(theFP1 + FoxSavedFP));
				/* begin restoreCStackStateForCallbackContext: */
				setCStackPointer((vmCallbackContext->savedCStackPointer));
				setCFramePointer((vmCallbackContext->savedCFramePointer));
				memcpy(reenterInterpreter, ((void *) ((vmCallbackContext->savedReenterInterpreter))), sizeof(jmp_buf));
				siglongjmp((vmCallbackContext->trampoline), (returnTypeOop >> 1));
				return 1;
			}
		}
		else {
			externalDivorceFrameandContext(theFP, callbackMethodContext);
			/* begin markContextAsDead: */
			assert(isContext(callbackMethodContext));
			longAtput((callbackMethodContext + BaseHeaderSize) + (SenderIndex << ShiftForWord), GIV(nilObj));
			longAtput((callbackMethodContext + BaseHeaderSize) + (InstructionPointerIndex << ShiftForWord), GIV(nilObj));
		}
	}
	if ((((longAt((calloutMethodContext + BaseHeaderSize) + (SenderIndex << ShiftForWord))) & 1))
	 && (!(isWidowedContext(calloutMethodContext)))) {
		/* begin frameOfMarriedContext: */
		value1 = longAt((calloutMethodContext + BaseHeaderSize) + (SenderIndex << ShiftForWord));
		/* begin withoutSmallIntegerTags: */
		assert((value1 & 1));
		theFP = pointerForOop(value1 - 1);
		/* begin stackPageFor: */
		/* begin stackPageAt: */
		/* begin pageIndexFor: */
		assert((((((char *) theFP)) >= (GIV(stackBasePlus1) - 1)) && ((((char *) theFP)) <= (((char *) GIV(pages))))));
		index = pageIndexForstackBasePlus1bytesPerPage(theFP, GIV(stackBasePlus1), GIV(bytesPerPage));
		thePage = stackPageAtpages(index, GIV(pages));
		assert(thePage != GIV(stackPage));
		GIV(stackPointer) = (findSPOfon(theFP, thePage)) - BytesPerWord;
		GIV(framePointer) = theFP;
	}
	else {
		thePage = makeBaseFrameFor(calloutMethodContext);
		GIV(framePointer) = (thePage->headFP);
		GIV(stackPointer) = (thePage->headSP);
	}
	/* begin popStack */
	top = longAt(GIV(stackPointer));
	GIV(stackPointer) += BytesPerWord;
	GIV(instructionPointer) = ((sqInt) top);
	/* begin setStackPageAndLimit: */
	GIV(stackPage) = thePage;
	if (GIV(stackLimit) != (((char *) (((usqInt) -1))))) {
		GIV(stackLimit) = (GIV(stackPage)->stackLimit);
	}
	markStackPageMostRecentlyUsed(thePage);
	/* begin restoreCStackStateForCallbackContext: */
	setCStackPointer((vmCallbackContext->savedCStackPointer));
	setCFramePointer((vmCallbackContext->savedCFramePointer));
	memcpy(reenterInterpreter, ((void *) ((vmCallbackContext->savedReenterInterpreter))), sizeof(jmp_buf));
	siglongjmp((vmCallbackContext->trampoline), (returnTypeOop >> 1));
	return 1;
}


/*	Return to the current frame, either by entering machine code, or
	longjmp-ing back to the
	interpreter or simply returning, depending on where we are. To know
	whether to return or
	enter machine code we have to know from whence we came. We could have come
	from the interpreter, either directly or via a machine code primitive. We
	could have come from
	machine code. The instructionPointer tells us where from. If it is above
	startOfMemory we're
	in the interpreter. If it is below, then we are in machine-code unless it
	is ceReturnToInterpreterPC,
	in which case we're in a machine-code primitive called from the
	interpreter.  */

static sqInt
returnToExecutivepostContextSwitch(sqInt inInterpreter, sqInt switchedContext)
{   DECL_MAYBE_SQ_GLOBAL_STRUCT
    CogBlockMethod *cogMethod;
    sqInt fullyInInterpreter;
    sqInt retValue;
    char *sp;
    char *sp1;
    sqInt top;

	assertCStackWellAligned();
	if ((((usqInt)(longAt(GIV(framePointer) + FoxMethod)))) < heapBase) {
		assertValidExecutionPointersimbar(GIV(instructionPointer), GIV(framePointer), GIV(stackPointer), 0);
		if (switchedContext) {
			/* begin mframeCogMethod: */
			cogMethod = ((CogBlockMethod *) ((longAt(GIV(framePointer) + FoxMethod)) & MFMethodMask));
			if ((GIV(instructionPointer) != ((((sqInt)cogMethod)) + ((cogMethod->stackCheckOffset))))
			 && (isSendReturnPC(GIV(instructionPointer)))) {
				assert((((stackTop()) & 1))
				 || (addressCouldBeObj(stackTop())));
				/* begin popStack */
				top = longAt(GIV(stackPointer));
				GIV(stackPointer) += BytesPerWord;
				retValue = top;
			}
			else {
				retValue = longAt(GIV(framePointer) + FoxMFReceiver);
			}
		}
		else {
			retValue = longAt(GIV(framePointer) + FoxMFReceiver);
		}
		/* begin push: */
		longAtput(sp = GIV(stackPointer) - BytesPerWord, GIV(instructionPointer));
		GIV(stackPointer) = sp;
		/* begin push: */
		longAtput(sp1 = GIV(stackPointer) - BytesPerWord, retValue);
		GIV(stackPointer) = sp1;
		ceEnterCogCodePopReceiverReg();
	}
	/* begin setMethod: */
	assert((((usqInt)(longAt(GIV(framePointer) + FoxMethod)))) >= (startOfMemory()));
	GIV(method) = longAt(GIV(framePointer) + FoxMethod);
	fullyInInterpreter = inInterpreter;
	if (GIV(instructionPointer) == (ceReturnToInterpreterPC())) {
		GIV(instructionPointer) = ((usqInt)(longAt(GIV(framePointer) + FoxIFSavedIP)));
		fullyInInterpreter = 0;
	}
	assertValidExecutionPointersimbar(GIV(instructionPointer), GIV(framePointer), GIV(stackPointer), 1);
	if (!(fullyInInterpreter)) {
		siglongjmp(reenterInterpreter, ReturnToInterpreter);
	}
	return null;
}


/*	We have made a context switch, either when interpreting or from machine
	code. Effectively return to the current frame, either by entering machine
	code, or
	longjmp-ing back to the interpreter or simply returning, depending on
	where we are. */

static sqInt
returntoExecutive(sqInt returnValue, sqInt inInterpreter)
{   DECL_MAYBE_SQ_GLOBAL_STRUCT
    char *sp;
    char *sp1;
    char *sp2;

	assertCStackWellAligned();
	if ((((usqInt)(longAt(GIV(framePointer) + FoxMethod)))) < heapBase) {
		assertValidExecutionPointersimbar(GIV(instructionPointer), GIV(framePointer), GIV(stackPointer), 0);
		/* begin push: */
		longAtput(sp = GIV(stackPointer) - BytesPerWord, GIV(instructionPointer));
		GIV(stackPointer) = sp;
		/* begin push: */
		longAtput(sp1 = GIV(stackPointer) - BytesPerWord, returnValue);
		GIV(stackPointer) = sp1;
		ceEnterCogCodePopReceiverReg();
	}
	/* begin push: */
	longAtput(sp2 = GIV(stackPointer) - BytesPerWord, returnValue);
	GIV(stackPointer) = sp2;
	/* begin setMethod: */
	assert((((usqInt)(longAt(GIV(framePointer) + FoxMethod)))) >= (startOfMemory()));
	GIV(method) = longAt(GIV(framePointer) + FoxMethod);
	assertValidExecutionPointersimbar(GIV(instructionPointer), GIV(framePointer), GIV(stackPointer), 1);
	if (GIV(instructionPointer) == (ceReturnToInterpreterPC())) {
		GIV(instructionPointer) = longAt(GIV(framePointer) + FoxIFSavedIP);
	}
	if (inInterpreter) {
		return null;
	}
	siglongjmp(reenterInterpreter, ReturnToInterpreter);
	return null;
}


/*	Reverse the given range of Display words (at different bit 
	depths, this will reverse different numbers of pixels). Used to 
	give feedback during VM activities such as garbage 
	collection when debugging. It is assumed that the given 
	word range falls entirely within the first line of the Display. */

static void
reverseDisplayFromto(sqInt startIndex, sqInt endIndex)
{   DECL_MAYBE_SQ_GLOBAL_STRUCT
    sqInt displayBits;
    sqInt displayObj;
    sqInt primFailCodeValue;
    sqInt ptr;
    sqInt reversed;
    sqInt w;
    sqInt wordEndIndex;
    sqInt wordStartIndex;

	displayObj = longAt((GIV(specialObjectsOop) + BaseHeaderSize) + (TheDisplay << ShiftForWord));
	if (!((((displayObj & 1) == 0)
 && (((((usqInt) (longAt(displayObj))) >> 8) & 15) <= 4))
		 && ((lengthOf(displayObj)) >= 4))) {
		return;
	}
	w = longAt((displayObj + BaseHeaderSize) + (1 << ShiftForWord));
	displayBits = longAt((displayObj + BaseHeaderSize) + (0 << ShiftForWord));
	if (((displayBits & 1))
	 || (((w & 1) == 0)
 || (((((usqInt) (longAt(displayBits))) >> 8) & 15) <= 4))) {
		return;
	}
	wordStartIndex = startIndex * 4;
	wordEndIndex = (((endIndex * 4) < (sizeBitsOf(displayBits))) ? (endIndex * 4) : (sizeBitsOf(displayBits)));
	displayBits += BaseHeaderSize;
	for (ptr = (displayBits + wordStartIndex); ptr <= (displayBits + wordEndIndex); ptr += 4) {
		reversed = (long32At(ptr)) ^ 4294967295UL;
		longAtput(ptr, reversed);
	}
	primFailCodeValue = GIV(primFailCode);
	/* begin initPrimCall */
	GIV(primFailCode) = 0;
	displayBitsOfLeftTopRightBottom(displayObj, 0, 0, (w >> 1), 1);
	ioForceDisplayUpdate();
	GIV(primFailCode) = primFailCodeValue;
}


/*	Rewrite an existing entry in the method cache with a new primitive
	function address.
	Used by primitiveExternalCall to make direct calls to found external
	prims, or quickly
	fail not found external prims.
	Override to do the same to the machine code call. If methodObj has a
	cogged dual
	rewrite the primitive call in it to call localPrimAddress. Used to update
	calls through
	primitiveExternalCall to directly call the target function or to revert to
	calling primitiveExternalCall after a flush. */

static void
rewriteMethodCacheEntryForExternalPrimitiveToFunction(void (*localPrimAddress)(void))
{   DECL_MAYBE_SQ_GLOBAL_STRUCT
	if (methodHasCogMethod(GIV(newMethod))) {
		rewritePrimInvocationInto(cogMethodOf(GIV(newMethod)), (localPrimAddress == 0
			? ((void (*)(void)) (primitiveFail))
			: localPrimAddress));
	}
	if ((GIV(methodCache)[GIV(lastMethodCacheProbeWrite) + MethodCacheMethod]) == GIV(newMethod)) {
		GIV(methodCache)[GIV(lastMethodCacheProbeWrite) + MethodCachePrimFunction] = (((long) localPrimAddress));
	}
}


/*	Answer if there is room to push n arguments onto the current stack.
	There may be room in this stackPage but there may not be room if
	the frame were converted into a context. */

static sqInt
roomToPushNArgs(sqInt n)
{   DECL_MAYBE_SQ_GLOBAL_STRUCT
    sqInt cntxSize;
    sqInt methodHeader;
    sqInt methodHeader1;

	if ((((usqInt)(longAt(GIV(framePointer) + FoxMethod)))) < heapBase) {
		methodHeader = (mframeHomeMethod(GIV(framePointer))->methodHeader);
	}
	else {
		/* begin headerOf: */
		methodHeader1 = longAt(((longAt(GIV(framePointer) + FoxMethod)) + BaseHeaderSize) + (HeaderIndex << ShiftForWord));
		methodHeader = (isCogMethodReference(methodHeader1)
			? (((CogMethod *) methodHeader1)->methodHeader)
			: methodHeader1);
	}
	cntxSize = ((methodHeader & LargeContextBit) != 0
		? (((sqInt) LargeContextSize >> 2)) - ReceiverIndex
		: (((sqInt) SmallContextSize >> 2)) - ReceiverIndex);
	return ((((((usqInt)(longAt(GIV(framePointer) + FoxMethod)))) < heapBase
	? (((usqInt) ((GIV(framePointer) + FoxMFReceiver) - GIV(stackPointer))) >> ShiftForWord) + ((mframeCogMethod(GIV(framePointer))->cmNumArgs))
	: (((usqInt) ((GIV(framePointer) + FoxIFReceiver) - GIV(stackPointer))) >> ShiftForWord) + (byteAt((GIV(framePointer) + FoxIFrameFlags) + 1)))) + n) <= cntxSize;
}

static void
runLeakCheckerForFullGC(sqInt fullGCFlag)
{
	if ((fullGCFlag
		? (checkForLeaks & 1) != 0
		: (checkForLeaks & 2) != 0)) {
		if (fullGCFlag) {
			reverseDisplayFromto(0, 7);
		}
		else {
			reverseDisplayFromto(8, 15);
		}
		clearLeakMapAndMapAccessibleObjects();
		assert(checkHeapIntegrity());
		assert(checkInterpreterIntegrity());
		assert(checkStackIntegrity());
		assert(checkCodeIntegrity(fullGCFlag));
		validate();
	}
}


/*	Return the object or start of free space immediately following the 
	given object or free chunk in memory. Return freeStart when
	enumeration is complete. This is for assertion checking only. */

static sqInt
safeObjectAfter(sqInt oop)
{   DECL_MAYBE_SQ_GLOBAL_STRUCT
    sqInt header;
    sqInt sz;

	if (((longAt(oop)) & TypeMask) == HeaderTypeFree) {
		sz = (longAt(oop)) & AllButTypeMask;
	}
	else {
		/* begin sizeBitsOf: */
		header = longAt(oop);
		sz = ((header & TypeMask) == HeaderTypeSizeAndClass
			? (longAt(oop - (BytesPerWord * 2))) & LongSizeMask
			: header & SizeMask);
	}
	return ((oop + sz) >= GIV(freeStart)
		? GIV(freeStart)
		: (oop + sz) + (headerTypeBytes[(longAt(oop + sz)) & TypeMask]));
}


/*	Version of printStringOf: that copes with forwarding during garbage
	collection. 
 */

static sqInt
safePrintStringOf(sqInt oop)
{
    sqInt cnt;
    sqInt fmt;
    sqInt fwdBlock;
    sqInt header;
    sqInt header1;
    sqInt i;

	if ((oop & 1)) {
		return null;
	}
	if (!(((oop >= heapBase) && (oop <= GIV(freeStart))))) {
		return null;
	}
	if ((oop & (BytesPerWord - 1)) != 0) {
		return null;
	}
	/* begin headerWhileForwardingOf: */
	header1 = longAt(oop);
	if ((header1 & MarkBit) != 0) {

		/* oop is forwarded; get its real header from its forwarding table entry */

		fwdBlock = (header1 & AllButMarkBitAndTypeMask) << 1;
		assert(fwdBlockValid(fwdBlock));
		header1 = longAt(fwdBlock + BytesPerWord);
	}
	header = header1;
	fmt = (((usqInt) header) >> 8) & 15;
	if (fmt < 8) {
		return null;
	}
	cnt = ((100 < (lengthOfbaseHeaderformat(oop, header, fmt))) ? 100 : (lengthOfbaseHeaderformat(oop, header, fmt)));
	i = 0;
	while (i < cnt) {
		/* begin printChar: */
		putchar(byteAt((oop + BaseHeaderSize) + i));
		i += 1;
	}
	flush();
	return oop;
}

usqInt
scavengeThresholdAddress(void)
{
	return ((usqInt)((&GIV(scavengeThreshold))));
}

void
scheduleIncrementalGC(void)
{
	GIV(needGCFlag) = 1;
	forceInterruptCheck();
}


/*	Send the calllback message to Alien class with the supplied arg(s). Use
	either the
	1 arg invokeCallbackContext: or the 4 arg
	invokeCallback:stack:registers:jmpbuf: message, depending on what selector
	is installed in the specialObjectsArray.
	Note that if invoking the legacy invokeCallback:stack:registers:jmpbuf: we
	pass the
	vmCallbackContext as the jmpbuf argument (see
	reestablishContextPriorToCallback:). The arguments are raw C addresses and
	are converted to integer objects on the way. */
/*	Override to log. Since this is an implicit send we need to log it
	explicitly. The return side is done via a primitive so that gets logged
	normally.  */

EXPORT(sqInt)
sendInvokeCallbackContext(VMCallbackContext *vmCallbackContext)
{   DECL_MAYBE_SQ_GLOBAL_STRUCT
    sqInt activateCog;
    sqInt ccIndex;
    CogMethod *cogMethod;
    CogMethod *cogMethod1;
    sqInt errorCode;
    sqInt i;
    usqInt initialIP;
    sqInt methodHeader;
    sqInt methodHeader1;
    sqInt numArgs;
    sqInt numTemps;
    sqInt object;
    sqInt object1;
    sqInt object2;
    sqInt object3;
    sqInt object4;
    sqInt object5;
    sqInt object6;
    sqInt object7;
    sqInt object8;
    sqInt rcvr;
    char *sp;
    char *sp1;
    char *sp10;
    char *sp11;
    char *sp2;
    char *sp21;
    char *sp3;
    char *sp31;
    char *sp4;
    char *sp41;
    char *sp5;
    char *sp51;
    char *sp6;
    char *sp61;
    char *sp7;
    char *sp71;
    char *sp8;
    char *sp81;
    char *sp9;
    sqInt table;

	if (recordPrimTrace()) {
		/* begin fastLogPrim: */
		GIV(primTraceLog)[GIV(primTraceLogIndex)] = (longAt((GIV(specialObjectsOop) + BaseHeaderSize) + (SelectorInvokeCallback << ShiftForWord)));
		primTraceLogIndex(GIV(primTraceLogIndex) + 1);
	}
	/* begin fetchClassOfNonInt: */
	if (((ccIndex = (((usqInt) (longAt(longAt((GIV(specialObjectsOop) + BaseHeaderSize) + (ClassAlien << ShiftForWord))))) >> 12) & 31)) == 0) {
		GIV(lkupClass) = (longAt((longAt((GIV(specialObjectsOop) + BaseHeaderSize) + (ClassAlien << ShiftForWord))) - BaseHeaderSize)) & AllButTypeMask;
		goto l1;
	}
	else {
		GIV(lkupClass) = longAt(((longAt((GIV(specialObjectsOop) + BaseHeaderSize) + (CompactClasses << ShiftForWord))) + BaseHeaderSize) + ((ccIndex - 1) << ShiftForWord));
		goto l1;
	}
l1:	/* end fetchClassOfNonInt: */;
	GIV(messageSelector) = longAt((GIV(specialObjectsOop) + BaseHeaderSize) + (SelectorInvokeCallback << ShiftForWord));
	if (!(lookupInMethodCacheSelclass(GIV(messageSelector), GIV(lkupClass)))) {
		if ((lookupMethodNoMNUEtcInClass(GIV(lkupClass))) != 0) {
			return 0;
		}
	}
	if (primitiveFunctionPointer != 0) {
		return 0;
	}
	/* begin saveCStackStateForCallbackContext: */
	(vmCallbackContext->savedCStackPointer = getCStackPointer());
	(vmCallbackContext->savedCFramePointer = getCFramePointer());
	memcpy(((void *) ((vmCallbackContext->savedReenterInterpreter))), reenterInterpreter, sizeof(jmp_buf));
	/* begin push: */
	longAtput(sp8 = GIV(stackPointer) - BytesPerWord, longAt((GIV(specialObjectsOop) + BaseHeaderSize) + (ClassAlien << ShiftForWord)));
	GIV(stackPointer) = sp8;
	
#  if BytesPerWord == 8
	if ((argumentCountOf(GIV(newMethod))) == 4) {
		/* begin push: */
		object = positive64BitIntegerFor(((usqInt)((vmCallbackContext->thunkp))));
		longAtput(sp = GIV(stackPointer) - BytesPerWord, object);
		GIV(stackPointer) = sp;
		/* begin push: */
		object1 = positive64BitIntegerFor(((usqInt)((vmCallbackContext->stackp))));
		longAtput(sp1 = GIV(stackPointer) - BytesPerWord, object1);
		GIV(stackPointer) = sp1;
		/* begin push: */
		object2 = positive64BitIntegerFor(((usqInt)((vmCallbackContext->intregargsp))));
		longAtput(sp2 = GIV(stackPointer) - BytesPerWord, object2);
		GIV(stackPointer) = sp2;
	}
	/* begin push: */
	object3 = positive64BitIntegerFor(((usqInt)vmCallbackContext));
	longAtput(sp3 = GIV(stackPointer) - BytesPerWord, object3);
	GIV(stackPointer) = sp3;

#  else /* BytesPerWord == 8 */
	if ((argumentCountOf(GIV(newMethod))) == 4) {
		/* begin push: */
		object4 = positive32BitIntegerFor(((usqInt)((vmCallbackContext->thunkp))));
		longAtput(sp4 = GIV(stackPointer) - BytesPerWord, object4);
		GIV(stackPointer) = sp4;
		/* begin push: */
		object5 = positive32BitIntegerFor(((usqInt)((vmCallbackContext->stackp))));
		longAtput(sp5 = GIV(stackPointer) - BytesPerWord, object5);
		GIV(stackPointer) = sp5;
		/* begin push: */
		object6 = positive32BitIntegerFor(((usqInt)((vmCallbackContext->intregargsp))));
		longAtput(sp6 = GIV(stackPointer) - BytesPerWord, object6);
		GIV(stackPointer) = sp6;
	}
	/* begin push: */
	object7 = positive32BitIntegerFor(((usqInt)vmCallbackContext));
	longAtput(sp7 = GIV(stackPointer) - BytesPerWord, object7);
	GIV(stackPointer) = sp7;

#  endif /* BytesPerWord == 8 */

	/* begin ifAppropriateCompileToNativeCode:selector: */
	methodHeader = longAt((GIV(newMethod) + BaseHeaderSize) + (HeaderIndex << ShiftForWord));
	if (isCogMethodReference(methodHeader)) {

		/* makeBaseFrame: can create cog methods with nil selectors. */

		cogMethod = ((CogMethod *) methodHeader);
		if (((cogMethod->selector)) == GIV(nilObj)) {
			setSelectorOfto(cogMethod, GIV(messageSelector));
		}
	}
	else {
		if (((((usqInt) methodHeader) >> 10) & 255) <= maxLiteralCountForCompile) {
			cogselector(GIV(newMethod), GIV(messageSelector));
		}
		else {
			maybeFlagMethodAsInterpreted(GIV(newMethod));
		}
	}
	/* begin justActivateNewMethod */
	VM_LABEL(0justActivateNewMethod);
	methodHeader1 = longAt((GIV(newMethod) + BaseHeaderSize) + (HeaderIndex << ShiftForWord));
	if ((activateCog = isCogMethodReference(methodHeader1))) {
		cogMethod1 = ((CogMethod *) methodHeader1);
		methodHeader1 = (cogMethod1->methodHeader);
	}
	numTemps = (((usqInt) methodHeader1) >> 19) & 63;
	numArgs = (((usqInt) methodHeader1) >> 25) & 15;

	/* could new rcvr be set at point of send? */

	rcvr = longAt(GIV(stackPointer) + (numArgs * BytesPerWord));
	if (activateCog
	 && (GIV(instructionPointer) >= heapBase)) {
		/* begin iframeSavedIP:put: */
		assert(!(isMachineCodeFrame(GIV(framePointer))));
		longAtput(GIV(framePointer) + FoxIFSavedIP, GIV(instructionPointer));
		GIV(instructionPointer) = ceReturnToInterpreterPC();
	}
	/* begin push: */
	longAtput(sp71 = GIV(stackPointer) - BytesPerWord, GIV(instructionPointer));
	GIV(stackPointer) = sp71;
	/* begin push: */
	longAtput(sp81 = GIV(stackPointer) - BytesPerWord, GIV(framePointer));
	GIV(stackPointer) = sp81;
	GIV(framePointer) = GIV(stackPointer);
	initialIP = (GIV(newMethod) + ((LiteralStart + ((((usqInt) methodHeader1) >> 10) & 255)) * BytesPerWord)) + BaseHeaderSize;
	if (activateCog) {
		/* begin push: */
		longAtput(sp10 = GIV(stackPointer) - BytesPerWord, ((usqInt)cogMethod1));
		GIV(stackPointer) = sp10;
		/* begin push: */
		longAtput(sp11 = GIV(stackPointer) - BytesPerWord, GIV(nilObj));
		GIV(stackPointer) = sp11;
		GIV(instructionPointer) = (((usqInt)cogMethod1)) + ((cogMethod1->stackCheckOffset));
	}
	else {
		/* begin push: */
		longAtput(sp21 = GIV(stackPointer) - BytesPerWord, GIV(newMethod));
		GIV(stackPointer) = sp21;
		/* begin setMethod: */
		assert((((usqInt)GIV(newMethod))) >= (startOfMemory()));
		GIV(method) = GIV(newMethod);
		/* begin push: */
		longAtput(sp31 = GIV(stackPointer) - BytesPerWord, GIV(nilObj));
		GIV(stackPointer) = sp31;
		/* begin push: */
		object8 = (VMBIGENDIAN
			? ((1 + (numArgs << ((BytesPerWord * 8) - 8))) + ((0
	? 1 << ((BytesPerWord * 8) - 16)
	: 0))) + ((0
	? 1 << ((BytesPerWord * 8) - 24)
	: 0))
			: ((1 + (numArgs << 8)) + ((0
	? 1 << 16
	: 0))) + ((0
	? 1 << 24
	: 0)));
		longAtput(sp41 = GIV(stackPointer) - BytesPerWord, object8);
		GIV(stackPointer) = sp41;
		/* begin push: */
		longAtput(sp51 = GIV(stackPointer) - BytesPerWord, 0);
		GIV(stackPointer) = sp51;
		GIV(instructionPointer) = initialIP - 1;
	}
	/* begin push: */
	longAtput(sp9 = GIV(stackPointer) - BytesPerWord, rcvr);
	GIV(stackPointer) = sp9;
	for (i = (numArgs + 1); i <= numTemps; i += 1) {
		/* begin push: */
		longAtput(sp61 = GIV(stackPointer) - BytesPerWord, GIV(nilObj));
		GIV(stackPointer) = sp61;
	}
	if (GIV(primFailCode) != 0) {
		if ((byteAtPointer(initialIP)) == 129) {
			/* begin getErrorObjectFromPrimFailCode */
			if (GIV(primFailCode) > 0) {
				table = longAt((GIV(specialObjectsOop) + BaseHeaderSize) + (PrimErrTableIndex << ShiftForWord));
				if (GIV(primFailCode) <= (((sqInt) (lastPointerOf(table)) >> 2))) {
					errorCode = longAt((table + BaseHeaderSize) + ((GIV(primFailCode) - 1) << ShiftForWord));
					goto l2;
				}
			}
			errorCode = ((GIV(primFailCode) << 1) | 1);
		l2:	/* end getErrorObjectFromPrimFailCode */;
			longAtPointerput(GIV(stackPointer), errorCode);
		}
		GIV(primFailCode) = 0;
	}
	if (!((((usqInt)(longAt(GIV(framePointer) + FoxMethod)))) < heapBase)) {
		maybeFlagMethodAsInterpreted(GIV(newMethod));
	}
	/* begin externalWriteBackHeadFramePointers */
	assert((GIV(framePointer) - GIV(stackPointer)) < LargeContextSize);
	assert(GIV(stackPage) == (mostRecentlyUsedPage()));
	/* begin setHeadFP:andSP:inPage: */
	assert(GIV(stackPointer) < GIV(framePointer));
	assert((GIV(stackPointer) < ((GIV(stackPage)->baseAddress)))
	 && (GIV(stackPointer) > (((GIV(stackPage)->realStackLimit)) - LargeContextSize)));
	assert((GIV(framePointer) < ((GIV(stackPage)->baseAddress)))
	 && (GIV(framePointer) > (((GIV(stackPage)->realStackLimit)) - (((sqInt) LargeContextSize >> 1)))));
	(GIV(stackPage)->headFP = GIV(framePointer));
	(GIV(stackPage)->headSP = GIV(stackPointer));
	assert(pageListIsWellFormed());
	handleStackOverflow();
	/* begin enterSmalltalkExecutiveFromCallback */
	enterSmalltalkExecutive();
	return 1;
}


/*	Send the 4 argument callback message
	invokeCallback:stack:registers:jmpbuf: to Alien class with the supplied
	args. The arguments are raw C addresses
	and are converted to integer objects on the way. */

EXPORT(sqInt)
sendInvokeCallbackStackRegistersJmpbuf(sqInt thunkPtr, sqInt stackPtr, sqInt regsPtr, sqInt jmpBufPtr)
{   DECL_MAYBE_SQ_GLOBAL_STRUCT
    sqInt activateCog;
    sqInt ccIndex;
    CogMethod *cogMethod;
    CogMethod *cogMethod1;
    sqInt errorCode;
    sqInt i;
    usqInt initialIP;
    sqInt methodHeader;
    sqInt methodHeader1;
    sqInt numArgs;
    sqInt numTemps;
    sqInt object;
    sqInt object1;
    sqInt object2;
    sqInt object3;
    sqInt object4;
    sqInt rcvr;
    char *sp;
    char *sp1;
    char *sp10;
    char *sp11;
    char *sp2;
    char *sp21;
    char *sp3;
    char *sp31;
    char *sp4;
    char *sp41;
    char *sp5;
    char *sp6;
    char *sp7;
    char *sp8;
    char *sp9;
    sqInt table;

	flag("obsolete");
	/* begin fetchClassOfNonInt: */
	if (((ccIndex = (((usqInt) (longAt(longAt((GIV(specialObjectsOop) + BaseHeaderSize) + (ClassAlien << ShiftForWord))))) >> 12) & 31)) == 0) {
		GIV(lkupClass) = (longAt((longAt((GIV(specialObjectsOop) + BaseHeaderSize) + (ClassAlien << ShiftForWord))) - BaseHeaderSize)) & AllButTypeMask;
		goto l1;
	}
	else {
		GIV(lkupClass) = longAt(((longAt((GIV(specialObjectsOop) + BaseHeaderSize) + (CompactClasses << ShiftForWord))) + BaseHeaderSize) + ((ccIndex - 1) << ShiftForWord));
		goto l1;
	}
l1:	/* end fetchClassOfNonInt: */;
	GIV(messageSelector) = longAt((GIV(specialObjectsOop) + BaseHeaderSize) + (SelectorInvokeCallback << ShiftForWord));
	GIV(argumentCount) = 4;
	if (!(lookupInMethodCacheSelclass(GIV(messageSelector), GIV(lkupClass)))) {
		if ((lookupMethodNoMNUEtcInClass(GIV(lkupClass))) != 0) {
			return 0;
		}
	}
	if (!(((argumentCountOf(GIV(newMethod))) == 4)
		 && (primitiveFunctionPointer == 0))) {
		return 0;
	}
	/* begin push: */
	longAtput(sp = GIV(stackPointer) - BytesPerWord, longAt((GIV(specialObjectsOop) + BaseHeaderSize) + (ClassAlien << ShiftForWord)));
	GIV(stackPointer) = sp;
	/* begin push: */
	object = positive32BitIntegerFor(thunkPtr);
	longAtput(sp1 = GIV(stackPointer) - BytesPerWord, object);
	GIV(stackPointer) = sp1;
	/* begin push: */
	object1 = positive32BitIntegerFor(stackPtr);
	longAtput(sp2 = GIV(stackPointer) - BytesPerWord, object1);
	GIV(stackPointer) = sp2;
	/* begin push: */
	object2 = positive32BitIntegerFor(regsPtr);
	longAtput(sp3 = GIV(stackPointer) - BytesPerWord, object2);
	GIV(stackPointer) = sp3;
	/* begin push: */
	object3 = positive32BitIntegerFor(jmpBufPtr);
	longAtput(sp4 = GIV(stackPointer) - BytesPerWord, object3);
	GIV(stackPointer) = sp4;
	/* begin ifAppropriateCompileToNativeCode:selector: */
	methodHeader = longAt((GIV(newMethod) + BaseHeaderSize) + (HeaderIndex << ShiftForWord));
	if (isCogMethodReference(methodHeader)) {

		/* makeBaseFrame: can create cog methods with nil selectors. */

		cogMethod = ((CogMethod *) methodHeader);
		if (((cogMethod->selector)) == GIV(nilObj)) {
			setSelectorOfto(cogMethod, GIV(messageSelector));
		}
	}
	else {
		if (((((usqInt) methodHeader) >> 10) & 255) <= maxLiteralCountForCompile) {
			cogselector(GIV(newMethod), GIV(messageSelector));
		}
		else {
			maybeFlagMethodAsInterpreted(GIV(newMethod));
		}
	}
	/* begin justActivateNewMethod */
	VM_LABEL(1justActivateNewMethod);
	methodHeader1 = longAt((GIV(newMethod) + BaseHeaderSize) + (HeaderIndex << ShiftForWord));
	if ((activateCog = isCogMethodReference(methodHeader1))) {
		cogMethod1 = ((CogMethod *) methodHeader1);
		methodHeader1 = (cogMethod1->methodHeader);
	}
	numTemps = (((usqInt) methodHeader1) >> 19) & 63;
	numArgs = (((usqInt) methodHeader1) >> 25) & 15;

	/* could new rcvr be set at point of send? */

	rcvr = longAt(GIV(stackPointer) + (numArgs * BytesPerWord));
	if (activateCog
	 && (GIV(instructionPointer) >= heapBase)) {
		/* begin iframeSavedIP:put: */
		assert(!(isMachineCodeFrame(GIV(framePointer))));
		longAtput(GIV(framePointer) + FoxIFSavedIP, GIV(instructionPointer));
		GIV(instructionPointer) = ceReturnToInterpreterPC();
	}
	/* begin push: */
	longAtput(sp7 = GIV(stackPointer) - BytesPerWord, GIV(instructionPointer));
	GIV(stackPointer) = sp7;
	/* begin push: */
	longAtput(sp8 = GIV(stackPointer) - BytesPerWord, GIV(framePointer));
	GIV(stackPointer) = sp8;
	GIV(framePointer) = GIV(stackPointer);
	initialIP = (GIV(newMethod) + ((LiteralStart + ((((usqInt) methodHeader1) >> 10) & 255)) * BytesPerWord)) + BaseHeaderSize;
	if (activateCog) {
		/* begin push: */
		longAtput(sp10 = GIV(stackPointer) - BytesPerWord, ((usqInt)cogMethod1));
		GIV(stackPointer) = sp10;
		/* begin push: */
		longAtput(sp11 = GIV(stackPointer) - BytesPerWord, GIV(nilObj));
		GIV(stackPointer) = sp11;
		GIV(instructionPointer) = (((usqInt)cogMethod1)) + ((cogMethod1->stackCheckOffset));
	}
	else {
		/* begin push: */
		longAtput(sp21 = GIV(stackPointer) - BytesPerWord, GIV(newMethod));
		GIV(stackPointer) = sp21;
		/* begin setMethod: */
		assert((((usqInt)GIV(newMethod))) >= (startOfMemory()));
		GIV(method) = GIV(newMethod);
		/* begin push: */
		longAtput(sp31 = GIV(stackPointer) - BytesPerWord, GIV(nilObj));
		GIV(stackPointer) = sp31;
		/* begin push: */
		object4 = (VMBIGENDIAN
			? ((1 + (numArgs << ((BytesPerWord * 8) - 8))) + ((0
	? 1 << ((BytesPerWord * 8) - 16)
	: 0))) + ((0
	? 1 << ((BytesPerWord * 8) - 24)
	: 0))
			: ((1 + (numArgs << 8)) + ((0
	? 1 << 16
	: 0))) + ((0
	? 1 << 24
	: 0)));
		longAtput(sp41 = GIV(stackPointer) - BytesPerWord, object4);
		GIV(stackPointer) = sp41;
		/* begin push: */
		longAtput(sp5 = GIV(stackPointer) - BytesPerWord, 0);
		GIV(stackPointer) = sp5;
		GIV(instructionPointer) = initialIP - 1;
	}
	/* begin push: */
	longAtput(sp9 = GIV(stackPointer) - BytesPerWord, rcvr);
	GIV(stackPointer) = sp9;
	for (i = (numArgs + 1); i <= numTemps; i += 1) {
		/* begin push: */
		longAtput(sp6 = GIV(stackPointer) - BytesPerWord, GIV(nilObj));
		GIV(stackPointer) = sp6;
	}
	if (GIV(primFailCode) != 0) {
		if ((byteAtPointer(initialIP)) == 129) {
			/* begin getErrorObjectFromPrimFailCode */
			if (GIV(primFailCode) > 0) {
				table = longAt((GIV(specialObjectsOop) + BaseHeaderSize) + (PrimErrTableIndex << ShiftForWord));
				if (GIV(primFailCode) <= (((sqInt) (lastPointerOf(table)) >> 2))) {
					errorCode = longAt((table + BaseHeaderSize) + ((GIV(primFailCode) - 1) << ShiftForWord));
					goto l2;
				}
			}
			errorCode = ((GIV(primFailCode) << 1) | 1);
		l2:	/* end getErrorObjectFromPrimFailCode */;
			longAtPointerput(GIV(stackPointer), errorCode);
		}
		GIV(primFailCode) = 0;
	}
	if (!((((usqInt)(longAt(GIV(framePointer) + FoxMethod)))) < heapBase)) {
		maybeFlagMethodAsInterpreted(GIV(newMethod));
	}
	/* begin externalWriteBackHeadFramePointers */
	assert((GIV(framePointer) - GIV(stackPointer)) < LargeContextSize);
	assert(GIV(stackPage) == (mostRecentlyUsedPage()));
	/* begin setHeadFP:andSP:inPage: */
	assert(GIV(stackPointer) < GIV(framePointer));
	assert((GIV(stackPointer) < ((GIV(stackPage)->baseAddress)))
	 && (GIV(stackPointer) > (((GIV(stackPage)->realStackLimit)) - LargeContextSize)));
	assert((GIV(framePointer) < ((GIV(stackPage)->baseAddress)))
	 && (GIV(framePointer) > (((GIV(stackPage)->realStackLimit)) - (((sqInt) LargeContextSize >> 1)))));
	(GIV(stackPage)->headFP = GIV(framePointer));
	(GIV(stackPage)->headSP = GIV(stackPointer));
	assert(pageListIsWellFormed());
	handleStackOverflow();
	/* begin enterSmalltalkExecutiveFromCallback */
	enterSmalltalkExecutive();
	return 1;
}

void
setBreakSelector(char *aString)
{
	if (aString == null) {

		/* nil's effective length is zero */

		breakSelectorLength = -1;
		breakSelector = null;
	}
	else {
		breakSelectorLength = strlen(aString);
		breakSelector = aString;
	}
}

void
setFullScreenFlag(sqInt value)
{
	GIV(fullScreenFlag) = value;
}

EXPORT(void (*setInterruptCheckChain(void (*aFunction)(void)))())

{
    void (*prevFunction)();

	prevFunction = interruptCheckChain;
	interruptCheckChain = aFunction;
	return prevFunction;
}

void
setInterruptKeycode(sqInt value)
{
	GIV(interruptKeycode) = value;
}

void
setInterruptPending(sqInt value)
{
	forceInterruptCheck();
	GIV(interruptPending) = value;
}

void
setNextWakeupUsecs(usqLong value)
{
	GIV(nextWakeupUsecs) = value;
}

void
setSavedWindowSize(sqInt value)
{
	GIV(savedWindowSize) = value;
}


/*	The low space semaphore is about to be signaled. Set the signalLowSpace
	flag, and force an interrupt check. Save the currently active process in
	the special
	objects array so that the low space handler will be able to determine the
	process that first triggered a low space condition. The image's low space
	handler is expected
	to nil out the special objects array slot when it handles the low space
	condition.  */

static void
setSignalLowSpaceFlagAndSaveProcess(void)
{   DECL_MAYBE_SQ_GLOBAL_STRUCT
    sqInt activeProc;
    sqInt lastSavedProcess;

	if (DumpStackOnLowSpace != 0) {
		printCallStack();
		printAllStacks();
	}
	GIV(signalLowSpace) = 1;
	GIV(lowSpaceThreshold) = 0;
	lastSavedProcess = longAt((GIV(specialObjectsOop) + BaseHeaderSize) + (ProcessSignalingLowSpace << ShiftForWord));
	if (lastSavedProcess == GIV(nilObj)) {
		activeProc = longAt(((longAt(((longAt((GIV(specialObjectsOop) + BaseHeaderSize) + (SchedulerAssociation << ShiftForWord))) + BaseHeaderSize) + (ValueIndex << ShiftForWord))) + BaseHeaderSize) + (ActiveProcessIndex << ShiftForWord));
		/* begin splObj:put: */
		/* begin storePointer:ofObject:withValue: */
		if ((((usqInt) GIV(specialObjectsOop))) < (((usqInt) GIV(youngStart)))) {
			possibleRootStoreIntovalue(GIV(specialObjectsOop), activeProc);
		}
		longAtput((GIV(specialObjectsOop) + BaseHeaderSize) + (ProcessSignalingLowSpace << ShiftForWord), activeProc);
	}
	forceInterruptCheck();
}

static void
shortPrintContext(sqInt aContext)
{
    sqInt home;

	if (!(((aContext & 1) == 0)
		 && (((((usqInt) (longAt(aContext))) >> 12) & 31) == ClassMethodContextCompactIndex))) {
		printHex(aContext);
		print(" is not a context");
		/* begin cr */
		printf("\n");
		return;
	}
	home = findHomeForContext(aContext);
	printNum(aContext);
	if (((longAt((aContext + BaseHeaderSize) + (SenderIndex << ShiftForWord))) & 1)) {
		if ((checkIsStillMarriedContextcurrentFP(aContext, GIV(framePointer)))
		 && (isMachineCodeFrame(frameOfMarriedContext(aContext)))) {
			print(" m ");
		}
		else {
			print(" i ");
		}
	}
	else {
		print(" s ");
	}
	printActivationNameForreceiverisBlockfirstTemporary(longAt((home + BaseHeaderSize) + (MethodIndex << ShiftForWord)), longAt((home + BaseHeaderSize) + (ReceiverIndex << ShiftForWord)), home != aContext, longAt((home + BaseHeaderSize) + ((0 + CtxtTempFrameStart) << ShiftForWord)));
	/* begin cr */
	printf("\n");
}

static void
shortPrintFrameAndCallers(char *theFP)
{   DECL_MAYBE_SQ_GLOBAL_STRUCT
	if (!((((((usqInt)theFP)) & (BytesPerWord - 1)) == 0)
		 && ((((((usqInt)theFP)) >= (((usqInt)(GIV(stackBasePlus1) - 1)))) && ((((usqInt)theFP)) <= (((usqInt)GIV(pages)))))))) {
		return;
	}
	shortPrintFrame(theFP);
	shortPrintFrameAndCallers(frameCallerFP(theFP));
}

static void
shortPrintFrame(char *theFP)
{   DECL_MAYBE_SQ_GLOBAL_STRUCT
    sqInt aByte;
    sqInt frameNumArgs;
    sqInt frameNumArgs1;
    sqInt mthd;
    sqInt rcvr;

	if (!((((((usqInt)theFP)) & (BytesPerWord - 1)) == 0)
		 && ((((((usqInt)theFP)) >= (((usqInt)(GIV(stackBasePlus1) - 1)))) && ((((usqInt)theFP)) <= (((usqInt)GIV(pages)))))))) {
		print("invalid frame pointer");
		/* begin cr */
		printf("\n");
		return;
	}
	rcvr = ((((usqInt)(longAt(theFP + FoxMethod)))) < heapBase
		? longAt(theFP + FoxMFReceiver)
		: longAt(theFP + FoxIFReceiver));
	mthd = ((((usqInt)(longAt(theFP + FoxMethod)))) < heapBase
		? (mframeHomeMethod(theFP)->methodObject)
		: longAt(theFP + FoxMethod));
	/* begin printHexPtr: */
	printHex(oopForPointer(theFP));
	/* begin space */
	/* begin printChar: */
	putchar(' ');
	/* begin printChar: */
	aByte = ((((usqInt)(longAt(theFP + FoxMethod)))) < heapBase
		? 'M'
		: 'I');
	putchar(aByte);
	/* begin space */
	/* begin printChar: */
	putchar(' ');
	printActivationNameForreceiverisBlockfirstTemporary(mthd, rcvr, ((((usqInt)(longAt(theFP + FoxMethod)))) < heapBase
		? ((longAt(theFP + FoxMethod)) & MFMethodFlagIsBlockFlag) != 0
		: (byteAt((theFP + FoxIFrameFlags) + 3)) != 0), ((((usqInt)(longAt(theFP + FoxMethod)))) < heapBase
		? (0 < ((frameNumArgs = (mframeCogMethod(theFP)->cmNumArgs)))
	? longAt((theFP + FoxCallerSavedIP) + ((frameNumArgs - 0) * BytesPerWord))
	: longAt(((theFP + FoxMFReceiver) - BytesPerWord) + ((frameNumArgs - 0) * BytesPerWord)))
		: (0 < ((frameNumArgs1 = byteAt((theFP + FoxIFrameFlags) + 1)))
	? longAt((theFP + FoxCallerSavedIP) + ((frameNumArgs1 - 0) * BytesPerWord))
	: longAt(((theFP + FoxIFReceiver) - BytesPerWord) + ((frameNumArgs1 - 0) * BytesPerWord)))));
	/* begin space */
	/* begin printChar: */
	putchar(' ');
	shortPrintOop(rcvr);
}

static void
shortPrintOop(sqInt oop)
{
	printNum(oop);
	if ((oop & 1)) {
		printf("=%ld\n", integerValueOf(oop)); return;
	}
	if (!(((oop >= heapBase) && (oop <= GIV(freeStart))))) {
		printHex(oop);
		print(" is not on the heap");
		/* begin cr */
		printf("\n");
		return;
	}
	if ((oop & (BytesPerWord - 1)) != 0) {
		printHex(oop);
		print(" is misaligned");
		/* begin cr */
		printf("\n");
		return;
	}
	print(": a(n) ");
	printNameOfClasscount(fetchClassOf(oop), 5);
	/* begin cr */
	printf("\n");
}

static sqInt
shortReversePrintFrameAndCallers(char *aFramePointer)
{   DECL_MAYBE_SQ_GLOBAL_STRUCT
    sqInt callerContextOrNil;
    char *callerFP;
    sqInt index;
    char *theFP;
    StackPage *thePage;

	theFP = aFramePointer;
	while (1) {
		shortPrintFrame(theFP);
		/* begin frameCallerFP: */
		callerFP = pointerForOop(longAt(theFP + FoxSavedFP));
		if (!(callerFP != 0)) break;
		theFP = callerFP;
	}
	/* begin frameCallerContext: */
	assert(isBaseFrame(theFP));
	/* begin stackPageFor: */
	/* begin stackPageAt: */
	/* begin pageIndexFor: */
	assert((((((char *) theFP)) >= (GIV(stackBasePlus1) - 1)) && ((((char *) theFP)) <= (((char *) GIV(pages))))));
	index = pageIndexForstackBasePlus1bytesPerPage(theFP, GIV(stackBasePlus1), GIV(bytesPerPage));
	thePage = stackPageAtpages(index, GIV(pages));
	callerContextOrNil = longAt((thePage->baseAddress));
	assert(addressCouldBeObj(callerContextOrNil));
	assert((callerContextOrNil == (nilObject()))
	 || (isContext(callerContextOrNil)));
	return callerContextOrNil;
}


/*	Repaint the portion of the Smalltalk screen bounded by the affected
	rectangle. Used to synchronize the screen after a Bitblt to the Smalltalk
	Display object.
 */

void
showDisplayBitsLeftTopRightBottom(sqInt aForm, sqInt l, sqInt t, sqInt r, sqInt b)
{
	if (deferDisplayUpdates) {
		return;
	}
	displayBitsOfLeftTopRightBottom(aForm, l, t, r, b);
}


/*	Signal all requested semaphores. Answer if a context switch has occurred. */

static sqInt
signalExternalSemaphores(void)
{
    sqInt xArray;

	xArray = longAt((GIV(specialObjectsOop) + BaseHeaderSize) + (ExternalObjectsArray << ShiftForWord));
	return doSignalExternalSemaphores(stSizeOf(xArray));
}


/*	Return a full 32 bit integer object for the given integer value */

sqInt
signed32BitIntegerFor(sqInt integerValue)
{   DECL_MAYBE_SQ_GLOBAL_STRUCT
    sqInt largeClass;
    sqInt newLargeInteger;
    sqInt value;

	if ((integerValue ^ (integerValue << 1)) >= 0) {
		return ((integerValue << 1) | 1);
	}
	if (integerValue < 0) {
		largeClass = longAt((GIV(specialObjectsOop) + BaseHeaderSize) + (ClassLargeNegativeInteger << ShiftForWord));
		value = 0 - integerValue;
	}
	else {
		largeClass = longAt((GIV(specialObjectsOop) + BaseHeaderSize) + (ClassLargePositiveInteger << ShiftForWord));
		value = integerValue;
	}
	newLargeInteger = eeInstantiateClassindexableSize(largeClass, 4);
	byteAtput((newLargeInteger + BaseHeaderSize) + 3, (((usqInt) value) >> 24) & 255);
	byteAtput((newLargeInteger + BaseHeaderSize) + 2, (((usqInt) value) >> 16) & 255);
	byteAtput((newLargeInteger + BaseHeaderSize) + 1, (((usqInt) value) >> 8) & 255);
	byteAtput((newLargeInteger + BaseHeaderSize) + 0, value & 255);
	return newLargeInteger;
}


/*	Convert the given object into an integer value.
	The object may be either a positive SmallInteger or a four-byte
	LargeInteger. 
 */

int
signed32BitValueOf(sqInt oop)
{   DECL_MAYBE_SQ_GLOBAL_STRUCT
    sqInt ccIndex;
    sqInt ccIndex1;
    sqInt negative;
    sqInt ok;
    int value;

	if ((oop & 1)) {
		return (oop >> 1);
	}
	/* begin isClassOfNonImm:equalTo:compactClassIndex: */
	assert(!((oop & 1)));
	ccIndex1 = (((usqInt) (longAt(oop))) >> 12) & 31;
	ok = (ClassLargePositiveIntegerCompactIndex == 0
		? (ccIndex1 == 0
	? ((longAt(oop - BaseHeaderSize)) & AllButTypeMask) == (longAt((GIV(specialObjectsOop) + BaseHeaderSize) + (ClassLargePositiveInteger << ShiftForWord)))
	: 0)
		: ClassLargePositiveIntegerCompactIndex == ccIndex1);
	if (ok) {
		negative = 0;
	}
	else {
		negative = 1;
		/* begin isClassOfNonImm:equalTo:compactClassIndex: */
		assert(!((oop & 1)));
		ccIndex = (((usqInt) (longAt(oop))) >> 12) & 31;
		ok = (ClassLargeNegativeIntegerCompactIndex == 0
			? (ccIndex == 0
	? ((longAt(oop - BaseHeaderSize)) & AllButTypeMask) == (longAt((GIV(specialObjectsOop) + BaseHeaderSize) + (ClassLargeNegativeInteger << ShiftForWord)))
	: 0)
			: ClassLargeNegativeIntegerCompactIndex == ccIndex);
		if (!(ok)) {
			/* begin primitiveFail */
			if (GIV(primFailCode) == 0) {
				GIV(primFailCode) = 1;
			}
			return null;
		}
	}
	if ((lengthOf(oop)) > 4) {
		/* begin primitiveFail */
		if (GIV(primFailCode) == 0) {
			GIV(primFailCode) = 1;
		}
		return null;
	}
	value = (((byteAt((oop + BaseHeaderSize) + 0)) + ((byteAt((oop + BaseHeaderSize) + 1)) << 8)) + ((byteAt((oop + BaseHeaderSize) + 2)) << 16)) + ((byteAt((oop + BaseHeaderSize) + 3)) << 24);
	null;
	if (value < 0) {
		assert((sizeof(value)) == 4);
		if (negative
		 && ((value - 1) > 0)) {
			return value;
		}
		/* begin primitiveFail */
		if (GIV(primFailCode) == 0) {
			GIV(primFailCode) = 1;
		}
		return null;
	}
	return (negative
		? 0 - value
		: value);
}


/*	Return a Large Integer object for the given integer value */

sqInt
signed64BitIntegerFor(sqLong integerValue)
{   DECL_MAYBE_SQ_GLOBAL_STRUCT
    usqInt highWord;
    sqInt i;
    sqInt intValue;
    sqInt largeClass;
    sqLong magnitude;
    sqInt newLargeInteger;
    sqInt sz;

	if (integerValue < 0) {
		largeClass = longAt((GIV(specialObjectsOop) + BaseHeaderSize) + (ClassLargeNegativeInteger << ShiftForWord));
		magnitude = 0 - integerValue;
	}
	else {
		largeClass = longAt((GIV(specialObjectsOop) + BaseHeaderSize) + (ClassLargePositiveInteger << ShiftForWord));
		magnitude = integerValue;
	}
	if ((magnitude <= 2147483647UL)
	 && ((integerValue >= 0)
 || (0 != (integerValue << 1)))) {
		return signed32BitIntegerFor(integerValue);
	}

	/* shift is coerced to usqInt otherwise */

	highWord = magnitude >> 32;
	if (highWord == 0) {
		sz = 4;
	}
	else {
		sz = 5;
		if (!(((highWord = ((usqInt) highWord) >> 8)) == 0)) {
			sz += 1;
		}
		if (!(((highWord = ((usqInt) highWord) >> 8)) == 0)) {
			sz += 1;
		}
		if (!(((highWord = ((usqInt) highWord) >> 8)) == 0)) {
			sz += 1;
		}
	}
	newLargeInteger = instantiateClassindexableSize(largeClass, sz);
	for (i = 0; i <= (sz - 1); i += 1) {
		intValue = (magnitude >> (i * 8)) & 255;
		byteAtput((newLargeInteger + BaseHeaderSize) + i, intValue);
	}
	return newLargeInteger;
}


/*	Convert the given object into an integer value.
	The object may be either a positive SmallInteger or a eight-byte
	LargeInteger. 
 */

sqLong
signed64BitValueOf(sqInt oop)
{   DECL_MAYBE_SQ_GLOBAL_STRUCT
    sqInt ccIndex;
    sqInt ccIndex1;
    sqInt header;
    sqInt i;
    sqInt negative;
    sqInt ok;
    sqInt sz;
    sqInt sz1;
    sqLong value;

	if ((oop & 1)) {
		return ((sqLong) ((oop >> 1)));
	}
	/* begin isClassOfNonImm:equalTo:compactClassIndex: */
	assert(!((oop & 1)));
	ccIndex1 = (((usqInt) (longAt(oop))) >> 12) & 31;
	ok = (ClassLargePositiveIntegerCompactIndex == 0
		? (ccIndex1 == 0
	? ((longAt(oop - BaseHeaderSize)) & AllButTypeMask) == (longAt((GIV(specialObjectsOop) + BaseHeaderSize) + (ClassLargePositiveInteger << ShiftForWord)))
	: 0)
		: ClassLargePositiveIntegerCompactIndex == ccIndex1);
	if (ok) {
		negative = 0;
	}
	else {
		negative = 1;
		/* begin isClassOfNonImm:equalTo:compactClassIndex: */
		assert(!((oop & 1)));
		ccIndex = (((usqInt) (longAt(oop))) >> 12) & 31;
		ok = (ClassLargeNegativeIntegerCompactIndex == 0
			? (ccIndex == 0
	? ((longAt(oop - BaseHeaderSize)) & AllButTypeMask) == (longAt((GIV(specialObjectsOop) + BaseHeaderSize) + (ClassLargeNegativeInteger << ShiftForWord)))
	: 0)
			: ClassLargeNegativeIntegerCompactIndex == ccIndex);
		if (!(ok)) {
			/* begin primitiveFail */
			if (GIV(primFailCode) == 0) {
				GIV(primFailCode) = 1;
			}
			return null;
		}
	}
	/* begin lengthOf: */
	header = longAt(oop);
	/* begin lengthOf:baseHeader:format: */
	if ((header & TypeMask) == HeaderTypeSizeAndClass) {
		sz1 = (longAt(oop - (BytesPerWord * 2))) & LongSizeMask;
	}
	else {
		sz1 = header & SizeMask;
	}
	sz1 -= header & Size4Bit;
	if (((((usqInt) header) >> 8) & 15) <= 4) {
		sz = ((usqInt) (sz1 - BaseHeaderSize)) >> ShiftForWord;
		goto l1;
	}
	if (((((usqInt) header) >> 8) & 15) < 8) {
		sz = ((usqInt) (sz1 - BaseHeaderSize)) >> 2;
		goto l1;
	}
	else {
		sz = (sz1 - BaseHeaderSize) - (((((usqInt) header) >> 8) & 15) & 3);
		goto l1;
	}
l1:	/* end lengthOf: */;
	if (sz > (sizeof(sqLong))) {
		/* begin primitiveFail */
		if (GIV(primFailCode) == 0) {
			GIV(primFailCode) = 1;
		}
		return null;
	}
	value = 0;
	for (i = 0; i <= (sz - 1); i += 1) {
		value += (((sqLong) (byteAt((oop + BaseHeaderSize) + i)))) << (i * 8);
	}
	null;
	if (value < 0) {
				assert((sizeof(value)) == 8);
		assert((sizeof(value << 1)) == 8);
;
		if (negative
		 && (0 == (value << 1))) {
			return value;
		}
		/* begin primitiveFail */
		if (GIV(primFailCode) == 0) {
			GIV(primFailCode) = 1;
		}
		return null;
	}
	return (negative
		? 0 - value
		: value);
}


/*	Answer a signed value of an integer up to the size of a machine word.
	The object may be either a positive SmallInteger or a LargeInteger of size
	<= word size.
 */

long
signedMachineIntegerValueOf(sqInt oop)
{   DECL_MAYBE_SQ_GLOBAL_STRUCT
    sqInt bs;
    sqInt ccIndex;
    sqInt ccIndex1;
    sqInt negative;
    sqInt ok;
    long value;

	if ((oop & 1)) {
		return (oop >> 1);
	}
	/* begin isClassOfNonImm:equalTo:compactClassIndex: */
	assert(!((oop & 1)));
	ccIndex1 = (((usqInt) (longAt(oop))) >> 12) & 31;
	ok = (ClassLargePositiveIntegerCompactIndex == 0
		? (ccIndex1 == 0
	? ((longAt(oop - BaseHeaderSize)) & AllButTypeMask) == (longAt((GIV(specialObjectsOop) + BaseHeaderSize) + (ClassLargePositiveInteger << ShiftForWord)))
	: 0)
		: ClassLargePositiveIntegerCompactIndex == ccIndex1);
	if (ok) {
		negative = 0;
	}
	else {
		negative = 1;
		/* begin isClassOfNonImm:equalTo:compactClassIndex: */
		assert(!((oop & 1)));
		ccIndex = (((usqInt) (longAt(oop))) >> 12) & 31;
		ok = (ClassLargeNegativeIntegerCompactIndex == 0
			? (ccIndex == 0
	? ((longAt(oop - BaseHeaderSize)) & AllButTypeMask) == (longAt((GIV(specialObjectsOop) + BaseHeaderSize) + (ClassLargeNegativeInteger << ShiftForWord)))
	: 0)
			: ClassLargeNegativeIntegerCompactIndex == ccIndex);
		if (!(ok)) {
			/* begin primitiveFail */
			if (GIV(primFailCode) == 0) {
				GIV(primFailCode) = 1;
			}
			return null;
		}
	}
	if (((bs = lengthOf(oop))) > (sizeof(unsigned long))) {
		/* begin primitiveFail */
		if (GIV(primFailCode) == 0) {
			GIV(primFailCode) = 1;
		}
		return null;
	}
	if (((sizeof(unsigned long)) == 8)
	 && (bs > 4)) {
		value = (((((((byteAt((oop + BaseHeaderSize) + 0)) + ((byteAt((oop + BaseHeaderSize) + 1)) << 8)) + ((byteAt((oop + BaseHeaderSize) + 2)) << 16)) + ((byteAt((oop + BaseHeaderSize) + 3)) << 24)) + ((byteAt((oop + BaseHeaderSize) + 4)) << 32)) + ((byteAt((oop + BaseHeaderSize) + 5)) << 40)) + ((byteAt((oop + BaseHeaderSize) + 6)) << 48)) + ((byteAt((oop + BaseHeaderSize) + 7)) << 56);
	}
	else {
		value = (((byteAt((oop + BaseHeaderSize) + 0)) + ((byteAt((oop + BaseHeaderSize) + 1)) << 8)) + ((byteAt((oop + BaseHeaderSize) + 2)) << 16)) + ((byteAt((oop + BaseHeaderSize) + 3)) << 24);
	}
	null;
	if (value < 0) {
		if (negative
		 && (0 == (value << 1))) {
			return value;
		}
		/* begin primitiveFail */
		if (GIV(primFailCode) == 0) {
			GIV(primFailCode) = 1;
		}
		return null;
	}
	return (negative
		? 0 - value
		: value);
}


/*	Compute the size of the given object from the cc and size fields in its
	header. This works even if its type bits are not correct. */

static sqInt
sizeBitsOfSafe(sqInt oop)
{
    sqInt header;
    sqInt type;

	header = longAt(oop);
	type = ((header & SizeMask) == 0
		? HeaderTypeSizeAndClass
		: ((header & CompactClassMask) == 0
	? HeaderTypeClass
	: HeaderTypeShort));
	return (type == HeaderTypeSizeAndClass
		? (longAt(oop - (BytesPerWord * 2))) & AllButTypeMask
		: header & SizeMask);
}


/*	Answer the number of bytes in the given object, including its base header,
	rounded up to an integral number of words.
 */
/*	Note: byte indexable objects need to have low bits subtracted from this
	size. 
 */

static sqInt
sizeBitsOf(sqInt oop)
{
    sqInt header;

	header = longAt(oop);
	return ((header & TypeMask) == HeaderTypeSizeAndClass
		? (longAt(oop - (BytesPerWord * 2))) & LongSizeMask
		: header & SizeMask);
}


/*	Answer the start of the Alien's data or fail if oop is not an Alien. */

usqInt
sizeOfAlienData(sqInt oop)
{   DECL_MAYBE_SQ_GLOBAL_STRUCT
    sqInt size;

	if (!(isKindOfClass(oop, longAt((GIV(specialObjectsOop) + BaseHeaderSize) + (ClassAlien << ShiftForWord))))) {
		GIV(primFailCode) = PrimErrBadArgument;
		return 0;
	}
	size = longAt(oop + BaseHeaderSize);
	return abs(size);
}


/*	Return the size of the given chunk in bytes. Argument MUST be a free
	chunk. 
 */

static sqInt
sizeOfFree(sqInt oop)
{
	return (longAt(oop)) & AllButTypeMask;
}


/*	Return the number of indexable fields of the given object. This method is
	to be called from an automatically generated C primitive. The argument is
	assumed to be a pointer to the first indexable field of a words or bytes
	object; the object header starts 4 bytes before that.
 */
/*	Note: Only called by translated primitive code. */

sqInt
sizeOfSTArrayFromCPrimitive(void *cPtr)
{   DECL_MAYBE_SQ_GLOBAL_STRUCT
    sqInt header;
    sqInt oop;
    sqInt sz;

	oop = (oopForPointer(cPtr)) - BaseHeaderSize;
	if (!(((oop & 1) == 0)
		 && (isWordsOrBytesNonInt(oop)))) {
		/* begin primitiveFail */
		if (GIV(primFailCode) == 0) {
			GIV(primFailCode) = 1;
		}
		return 0;
	}
	/* begin lengthOf: */
	header = longAt(oop);
	/* begin lengthOf:baseHeader:format: */
	if ((header & TypeMask) == HeaderTypeSizeAndClass) {
		sz = (longAt(oop - (BytesPerWord * 2))) & LongSizeMask;
	}
	else {
		sz = header & SizeMask;
	}
	sz -= header & Size4Bit;
	if (((((usqInt) header) >> 8) & 15) <= 4) {
		return ((usqInt) (sz - BaseHeaderSize)) >> ShiftForWord;
	}
	if (((((usqInt) header) >> 8) & 15) < 8) {
		return ((usqInt) (sz - BaseHeaderSize)) >> 2;
	}
	else {
		return (sz - BaseHeaderSize) - (((((usqInt) header) >> 8) & 15) & 3);
	}
}


/*	Returns the number of slots in the receiver.
	If the receiver is a byte object, return the number of bytes.
	Otherwise return the number of words. */

sqInt
slotSizeOf(sqInt oop)
{
    sqInt header;
    sqInt sz;

	if ((oop & 1)) {
		return 0;
	}
	/* begin lengthOf: */
	header = longAt(oop);
	/* begin lengthOf:baseHeader:format: */
	if ((header & TypeMask) == HeaderTypeSizeAndClass) {
		sz = (longAt(oop - (BytesPerWord * 2))) & LongSizeMask;
	}
	else {
		sz = header & SizeMask;
	}
	sz -= header & Size4Bit;
	if (((((usqInt) header) >> 8) & 15) <= 4) {
		return ((usqInt) (sz - BaseHeaderSize)) >> ShiftForWord;
	}
	if (((((usqInt) header) >> 8) & 15) < 8) {
		return ((usqInt) (sz - BaseHeaderSize)) >> 2;
	}
	else {
		return (sz - BaseHeaderSize) - (((((usqInt) header) >> 8) & 15) & 3);
	}
}


/*	Called under the assumption that primFunctionPtr has been preloaded */

static sqInt
slowPrimitiveResponse(void)
{   DECL_MAYBE_SQ_GLOBAL_STRUCT
    sqInt nArgs;
    char *savedFramePointer;
    char *savedStackPointer;

	if (recordPrimTrace()) {
		/* begin fastLogPrim: */
		GIV(primTraceLog)[GIV(primTraceLogIndex)] = GIV(messageSelector);
		primTraceLogIndex(GIV(primTraceLogIndex) + 1);
	}
	if (FailImbalancedPrimitives) {
		nArgs = GIV(argumentCount);
		savedStackPointer = GIV(stackPointer);
		savedFramePointer = GIV(framePointer);
	}
	/* begin initPrimCall */
	GIV(primFailCode) = 0;
	dispatchFunctionPointer(primitiveFunctionPointer);
	if (FailImbalancedPrimitives
	 && ((GIV(primFailCode) == 0)
 && ((GIV(framePointer) == savedFramePointer)
 && (!((((usqInt)(longAt(GIV(framePointer) + FoxMethod)))) < heapBase))))) {
		if (GIV(stackPointer) != (savedStackPointer + (nArgs * BytesPerWord))) {
			flag("Would be nice to make this a message send of e.g. unbalancedPrimitive to the current process or context");
			GIV(stackPointer) = savedStackPointer;
			failUnbalancedPrimitive();
		}
	}
	if (GIV(nextProfileTick) > 0) {
		checkProfileTick(GIV(newMethod));
	}
	return GIV(primFailCode) == 0;
}


/*	update state of active context */

static void
snapshot(sqInt embedded)
{   DECL_MAYBE_SQ_GLOBAL_STRUCT
    sqInt activeContext;
    sqInt activeContext1;
    sqInt activeProc;
    sqInt aMethodObj;
    sqInt dataSize;
    sqInt decodedIP;
    sqInt fmt;
    sqInt header;
    sqInt header1;
    sqInt header2;
    sqInt header3;
    sqInt i;
    sqInt i1;
    StackPage *newPage;
    sqInt object;
    sqInt object1;
    sqInt oop;
    sqInt oop1;
    sqInt oop2;
    sqInt oop3;
    sqInt oop4;
    sqInt rcvr;
    void *setMacType;
    char *sp;
    char *sp1;
    char *sp2;
    sqInt stackIndex;
    sqInt sz;
    sqInt sz1;
    sqInt sz2;
    char *theFP;
    sqInt top;

	/* begin push: */
	object1 = GIV(instructionPointer);
	longAtput(sp2 = GIV(stackPointer) - BytesPerWord, object1);
	GIV(stackPointer) = sp2;
	/* begin voidVMStateForSnapshot */

	/* in case of code compactions. */

	GIV(instructionPointer) = 0;
	activeContext1 = divorceAllFrames();
	/* begin ensureAllContextsHaveBytecodePCsOrAreBereaved */
	VM_LABEL(3ensureAllContextsHaveBytecodePCsOrAreBereaved);
	oop4 = heapBase + (headerTypeBytes[(longAt(heapBase)) & TypeMask]);
	while (oop4 < GIV(freeStart)) {
		if ((!(((longAt(oop4)) & TypeMask) == HeaderTypeFree))
		 && (((((usqInt) (longAt(oop4))) >> 12) & 31) == ClassMethodContextCompactIndex)) {
			if (((longAt((oop4 + BaseHeaderSize) + (SenderIndex << ShiftForWord))) & 1)) {
				/* begin markContextAsDead: */
				assert(isContext(oop4));
				longAtput((oop4 + BaseHeaderSize) + (SenderIndex << ShiftForWord), GIV(nilObj));
				longAtput((oop4 + BaseHeaderSize) + (InstructionPointerIndex << ShiftForWord), GIV(nilObj));
			}
			else {
				decodedIP = longAt((oop4 + BaseHeaderSize) + (InstructionPointerIndex << ShiftForWord));
				if (((decodedIP & 1))
				 && ((((sqInt) decodedIP)) < 0)) {
					decodedIP = mustMapMachineCodePCcontext((decodedIP >> 1), oop4);
					longAtput((oop4 + BaseHeaderSize) + (InstructionPointerIndex << ShiftForWord), decodedIP);
				}
			}
		}
		/* begin objectAfter: */
		if (DoAssertionChecks) {
			if ((((usqInt) oop4)) >= (((usqInt) GIV(endOfMemory)))) {
				error("no objects after the end of memory");
			}
		}
		if (((longAt(oop4)) & TypeMask) == HeaderTypeFree) {
			sz2 = (longAt(oop4)) & AllButTypeMask;
		}
		else {
			/* begin sizeBitsOf: */
			header3 = longAt(oop4);
			sz2 = ((header3 & TypeMask) == HeaderTypeSizeAndClass
				? (longAt(oop4 - (BytesPerWord * 2))) & LongSizeMask
				: header3 & SizeMask);
		}
		oop4 = (oop4 + sz2) + (headerTypeBytes[(longAt(oop4 + sz2)) & TypeMask]);
	}
	voidCogCompiledCode();
	activeContext = activeContext1;
	/* begin pushRemappableOop: */
	assert(addressCouldBeOop(activeContext));
	GIV(remapBuffer)[(GIV(remapBufferCount) += 1)] = activeContext;
	activeProc = longAt(((longAt(((longAt((GIV(specialObjectsOop) + BaseHeaderSize) + (SchedulerAssociation << ShiftForWord))) + BaseHeaderSize) + (ValueIndex << ShiftForWord))) + BaseHeaderSize) + (ActiveProcessIndex << ShiftForWord));
	/* begin storePointer:ofObject:withValue: */
	if ((((usqInt) activeProc)) < (((usqInt) GIV(youngStart)))) {
		possibleRootStoreIntovalue(activeProc, activeContext);
	}
	longAtput((activeProc + BaseHeaderSize) + (SuspendedContextIndex << ShiftForWord), activeContext);
	incrementalGC();
	fullGC();
	/* begin snapshotCleanUp */
	VM_LABEL(0snapshotCleanUp);
	oop2 = heapBase + (headerTypeBytes[(longAt(heapBase)) & TypeMask]);
	while ((((usqInt) oop2)) < (((usqInt) GIV(freeStart)))) {
		if (!(((longAt(oop2)) & TypeMask) == HeaderTypeFree)) {
			header = longAt(oop2);

			/* Clean out context */

			fmt = (((usqInt) header) >> 8) & 15;
			if ((fmt == 3)
			 && (((((usqInt) header) >> 12) & 31) == ClassMethodContextCompactIndex)) {
				if (((longAt((oop2 + BaseHeaderSize) + (SenderIndex << ShiftForWord))) & 1)) {
					/* begin markContextAsDead: */
					assert(isContext(oop2));
					longAtput((oop2 + BaseHeaderSize) + (SenderIndex << ShiftForWord), GIV(nilObj));
					longAtput((oop2 + BaseHeaderSize) + (InstructionPointerIndex << ShiftForWord), GIV(nilObj));
				}
				/* begin sizeBitsOf: */
				header1 = longAt(oop2);
				sz = ((header1 & TypeMask) == HeaderTypeSizeAndClass
					? (longAt(oop2 - (BytesPerWord * 2))) & LongSizeMask
					: header1 & SizeMask);
				for (i = ((lastPointerOf(oop2)) + BytesPerWord); i <= (sz - BaseHeaderSize); i += BytesPerWord) {
					longAtput(oop2 + i, GIV(nilObj));
				}
			}
			if (fmt >= 12) {
				if ((primitiveIndexOf(oop2)) == PrimitiveExternalCallIndex) {
					flushExternalPrimitiveOf(oop2);
				}
			}
		}
		/* begin objectAfter: */
		if (DoAssertionChecks) {
			if ((((usqInt) oop2)) >= (((usqInt) GIV(endOfMemory)))) {
				error("no objects after the end of memory");
			}
		}
		if (((longAt(oop2)) & TypeMask) == HeaderTypeFree) {
			sz1 = (longAt(oop2)) & AllButTypeMask;
		}
		else {
			/* begin sizeBitsOf: */
			header2 = longAt(oop2);
			sz1 = ((header2 & TypeMask) == HeaderTypeSizeAndClass
				? (longAt(oop2 - (BytesPerWord * 2))) & LongSizeMask
				: header2 & SizeMask);
		}
		oop2 = (oop2 + sz1) + (headerTypeBytes[(longAt(oop2 + sz1)) & TypeMask]);
	}
	/* begin clearRootsTable */
	for (i1 = 1; i1 <= GIV(rootTableCount); i1 += 1) {

		/* clear root bits of current root table entries */

		oop1 = GIV(rootTable)[i1];
		longAtput(oop1, (longAt(oop1)) & AllButRootBit);
		GIV(rootTable)[i1] = 0;
	}
	GIV(rootTableCount) = 0;
	/* begin popRemappableOop */
	oop3 = GIV(remapBuffer)[GIV(remapBufferCount)];
	GIV(remapBufferCount) -= 1;
	activeContext = oop3;

	/* Assume all objects are below the start of the free block */

	dataSize = GIV(freeStart) - heapBase;
	if (GIV(primFailCode) == 0) {
		/* begin quickFetchInteger:ofObject: */
		oop = longAt((activeContext + BaseHeaderSize) + (StackPointerIndex << ShiftForWord));
		assert((oop & 1));
		stackIndex = (oop >> 1);
		rcvr = longAt((activeContext + BaseHeaderSize) + (((stackIndex + CtxtTempFrameStart) - 1) << ShiftForWord));
		longAtput((activeContext + BaseHeaderSize) + (((stackIndex + CtxtTempFrameStart) - 1) << ShiftForWord), GIV(trueObj));
		writeImageFile(dataSize);
		if (!(embedded)) {

			/* set Mac file type and creator; this is a noop on other platforms */

			setMacType = ioLoadFunctionFrom("setMacFileTypeAndCreator", "FilePlugin");
			if (!(setMacType == 0)) {
				((sqInt (*)(char *, char *, char *))setMacType)(imageName, "STim", "FAST");
			}
		}
		longAtput((activeContext + BaseHeaderSize) + (StackPointerIndex << ShiftForWord), (((stackIndex - 1) << 1) | 1));
	}
	/* begin marryContextInNewStackPageAndInitializeInterpreterRegisters: */
	VM_LABEL(4marryContextInNewStackPageAndInitializeInterpreterRegisters);
	assert(GIV(stackPage) == 0);
	newPage = makeBaseFrameFor(activeContext);
	/* begin setStackPageAndLimit: */
	GIV(stackPage) = newPage;
	if (GIV(stackLimit) != (((char *) (((usqInt) -1))))) {
		GIV(stackLimit) = (GIV(stackPage)->stackLimit);
	}
	markStackPageMostRecentlyUsed(newPage);
	GIV(framePointer) = (GIV(stackPage)->headFP);
	GIV(stackPointer) = (GIV(stackPage)->headSP);
	/* begin setMethod: */
	/* begin iframeMethod: */
	theFP = (GIV(stackPage)->headFP);
	aMethodObj = longAt(theFP + FoxMethod);
	assert((((usqInt)aMethodObj)) >= (startOfMemory()));
	GIV(method) = aMethodObj;
	/* begin popStack */
	top = longAt(GIV(stackPointer));
	GIV(stackPointer) += BytesPerWord;
	GIV(instructionPointer) = ((sqInt) top);
	if (GIV(primFailCode) == 0) {
		/* begin push: */
		object = GIV(falseObj);
		longAtput(sp = GIV(stackPointer) - BytesPerWord, object);
		GIV(stackPointer) = sp;
	}
	else {
		/* begin push: */
		longAtput(sp1 = GIV(stackPointer) - BytesPerWord, rcvr);
		GIV(stackPointer) = sp1;
	}
}

static void
space(void)
{
	/* begin printChar: */
	putchar(' ');
}


/*	<SmallInteger> */

sqInt
specialSelectorNumArgs(sqInt index)
{
	return ((longAt(((longAt((GIV(specialObjectsOop) + BaseHeaderSize) + (SpecialSelectors << ShiftForWord))) + BaseHeaderSize) + (((index * 2) + 1) << ShiftForWord))) >> 1);
}

sqInt
specialSelector(sqInt index)
{
	return longAt(((longAt((GIV(specialObjectsOop) + BaseHeaderSize) + (SpecialSelectors << ShiftForWord))) + BaseHeaderSize) + ((index * 2) << ShiftForWord));
}


/*	Return one of the objects in the SpecialObjectsArray */

sqInt
splObj(sqInt index)
{
	return longAt((GIV(specialObjectsOop) + BaseHeaderSize) + (index << ShiftForWord));
}


/*	In the StackInterpreter stacks grow down. */

double
stackFloatValue(sqInt offset)
{   DECL_MAYBE_SQ_GLOBAL_STRUCT
    sqInt ccIndex;
    sqInt floatPointer;
    double result;
    sqInt successBoolean;


	/* N.B.  Because Slang always inlines assertClassOf:is:compactClassIndex:
	 (because assertClassOf:is:compactClassIndex: has an inline: pragma) the
	 phrase (self splObj: ClassArray) is expanded in-place and is _not_
	 evaluated if ClassArrayCompactIndex is non-zero. */

	floatPointer = longAt(GIV(stackPointer) + (offset * BytesPerWord));
	/* begin assertClassOf:is:compactClassIndex: */
	/* begin success: */
	/* begin is:instanceOf:compactClassIndex: */
	if ((floatPointer & 1)) {
		successBoolean = 0;
		goto l1;
	}
	ccIndex = (((usqInt) (longAt(floatPointer))) >> 12) & 31;
	if (ClassFloatCompactIndex != 0) {
		successBoolean = ClassFloatCompactIndex == ccIndex;
		goto l1;
	}
	successBoolean = (ccIndex == 0)
	 && (((longAt(floatPointer - BaseHeaderSize)) & AllButTypeMask) == (longAt((GIV(specialObjectsOop) + BaseHeaderSize) + (ClassFloat << ShiftForWord))));
l1:	/* end is:instanceOf:compactClassIndex: */;
	if (!(successBoolean)) {
		if (GIV(primFailCode) == 0) {

			/* Don't overwrite an error code that has already been set. */

			GIV(primFailCode) = 1;
		}
	}
	if (GIV(primFailCode) == 0) {
		;
		fetchFloatAtinto(floatPointer + BaseHeaderSize, result);
		return result;
	}
	else {
		return 0.0;
	}
}


/*	In the StackInterpreter stacks grow down. */

sqInt
stackIntegerValue(sqInt offset)
{   DECL_MAYBE_SQ_GLOBAL_STRUCT
    sqInt integerPointer;

	integerPointer = longAt(GIV(stackPointer) + (offset * BytesPerWord));
	/* begin checkedIntegerValueOf: */
	if ((integerPointer & 1)) {
		return (integerPointer >> 1);
	}
	else {
		/* begin primitiveFail */
		if (GIV(primFailCode) == 0) {
			GIV(primFailCode) = 1;
		}
		return 0;
	}
}

usqInt
stackLimitAddress(void)
{
	return (usqInt)&GIV(stackLimit);
}


/*	Answer the amount of slots needed to fit a new frame at the point the
	stack limit is checked. A frame looks like this at the point the stack
	limit is checked:
	stacked receiver/closure
	arg0
	...
	argN
	caller's method ip/base frame's sender context
	fp->	saved fp
	method
	context (uninitialized?)
	method header fields (interpreter only)
	saved method ip (uninitialized?; interpreter only)
	receiver
	first temp
	...
	sp->	Nth temp
	So the amount of headroom is
	the maximum number of arguments + 1 (for stacked receiver and arguments)
	+ the frame size
	+ the max number of temps.
	Since a method's number of temps includes its arguments the actual offset
	is:  */

static sqInt
stackLimitOffset(void)
{
	return (IFrameSlots + 64) * BytesPerWord;
}


/*	Ensures that the given object is a real object, not a SmallInteger. */
/*	In the StackInterpreter stacks grow down. */

sqInt
stackObjectValue(sqInt offset)
{   DECL_MAYBE_SQ_GLOBAL_STRUCT
    sqInt oop;

	oop = longAt(GIV(stackPointer) + (offset * BytesPerWord));
	if ((oop & 1)) {
		/* begin primitiveFail */
		if (GIV(primFailCode) == 0) {
			GIV(primFailCode) = 1;
		}
		return null;
	}
	return oop;
}


/*	Answer the page for a page index.
	N.B. This is a zero-relative index. */

static StackPage *
stackPageAt(sqInt index)
{
	return stackPageAtpages(index, GIV(pages));
}


/*	Room for 512 bytes of frames gives around 40 frames a page which is a
	good compromise between overflow rate and latency in divorcing a page. */

static sqInt
stackPageByteSize(void)
{
	return (((highBit(((512 + ((IFrameSlots + 64) * BytesPerWord)) + ((stackPageHeadroomBytes()) + 1024)) - 1)) < 0) ? ((usqInt) 1 >> -(highBit(((512 + ((IFrameSlots + 64) * BytesPerWord)) + ((stackPageHeadroomBytes()) + 1024)) - 1))) : ((usqInt) 1 << (highBit(((512 + ((IFrameSlots + 64) * BytesPerWord)) + ((stackPageHeadroomBytes()) + 1024)) - 1))));
}


/*	<Integer> */

static StackPage *
stackPageFor(void *pointer)
{   DECL_MAYBE_SQ_GLOBAL_STRUCT
    sqInt index;

	/* begin stackPageAt: */
	/* begin pageIndexFor: */
	assert((((((char *) pointer)) >= (GIV(stackBasePlus1) - 1)) && ((((char *) pointer)) <= (((char *) GIV(pages))))));
	index = pageIndexForstackBasePlus1bytesPerPage(pointer, GIV(stackBasePlus1), GIV(bytesPerPage));
	return stackPageAtpages(index, GIV(pages));
}

usqInt
stackPointerAddress(void)
{
	return ((usqInt)((&GIV(stackPointer))));
}


/*	Return the 0-based index rel to the given frame.
	(This is what stackPointer used to be before conversion to pointer) */
/*	In the StackInterpreter stacks grow down. */

static sqInt
stackPointerIndexForFrame(char *theFP)
{   DECL_MAYBE_SQ_GLOBAL_STRUCT
    sqInt index;
    StackPage *thePage;
    char *theSP;

	/* begin stackPageFor: */
	/* begin stackPageAt: */
	/* begin pageIndexFor: */
	assert((((((char *) theFP)) >= (GIV(stackBasePlus1) - 1)) && ((((char *) theFP)) <= (((char *) GIV(pages))))));
	index = pageIndexForstackBasePlus1bytesPerPage(theFP, GIV(stackBasePlus1), GIV(bytesPerPage));
	thePage = stackPageAtpages(index, GIV(pages));
	theSP = findSPOfon(theFP, thePage);
	return ((((usqInt)(longAt(theFP + FoxMethod)))) < heapBase
		? (((usqInt) ((theFP + FoxMFReceiver) - theSP)) >> ShiftForWord) + ((mframeCogMethod(theFP)->cmNumArgs))
		: (((usqInt) ((theFP + FoxIFReceiver) - theSP)) >> ShiftForWord) + (byteAt((theFP + FoxIFrameFlags) + 1)));
}


/*	In the StackInterpreter stacks grow down. */

sqInt
stackPositiveMachineIntegerValue(sqInt offset)
{   DECL_MAYBE_SQ_GLOBAL_STRUCT
    sqInt bs;
    sqInt ccIndex;
    sqInt integerPointer;
    sqInt ok;
    sqInt value;

	integerPointer = longAt(GIV(stackPointer) + (offset * BytesPerWord));
	/* begin positiveMachineIntegerValueOf: */
	VM_LABEL(0positiveMachineIntegerValueOf);
	if ((integerPointer & 1)) {
		value = (integerPointer >> 1);
		if (value < 0) {
			/* begin primitiveFail */
			if (GIV(primFailCode) == 0) {
				GIV(primFailCode) = 1;
			}
			return ((unsigned long) null);
		}
		return ((unsigned long) value);
	}
	/* begin isClassOfNonImm:equalTo:compactClassIndex: */
	assert(!((integerPointer & 1)));
	ccIndex = (((usqInt) (longAt(integerPointer))) >> 12) & 31;
	ok = (ClassLargePositiveIntegerCompactIndex == 0
		? (ccIndex == 0
	? ((longAt(integerPointer - BaseHeaderSize)) & AllButTypeMask) == (longAt((GIV(specialObjectsOop) + BaseHeaderSize) + (ClassLargePositiveInteger << ShiftForWord)))
	: 0)
		: ClassLargePositiveIntegerCompactIndex == ccIndex);
	if (!(ok
		 && (((bs = lengthOf(integerPointer))) <= (sizeof(unsigned long))))) {
		/* begin primitiveFail */
		if (GIV(primFailCode) == 0) {
			GIV(primFailCode) = 1;
		}
		return ((unsigned long) null);
	}
	if (((sizeof(unsigned long)) == 8)
	 && (bs > 4)) {
		return ((unsigned long) ((((((((byteAt((integerPointer + BaseHeaderSize) + 0)) + ((byteAt((integerPointer + BaseHeaderSize) + 1)) << 8)) + ((byteAt((integerPointer + BaseHeaderSize) + 2)) << 16)) + ((byteAt((integerPointer + BaseHeaderSize) + 3)) << 24)) + ((byteAt((integerPointer + BaseHeaderSize) + 4)) << 32)) + ((byteAt((integerPointer + BaseHeaderSize) + 5)) << 40)) + ((byteAt((integerPointer + BaseHeaderSize) + 6)) << 48)) + ((byteAt((integerPointer + BaseHeaderSize) + 7)) << 56)));
	}
	return ((unsigned long) ((((byteAt((integerPointer + BaseHeaderSize) + 0)) + ((byteAt((integerPointer + BaseHeaderSize) + 1)) << 8)) + ((byteAt((integerPointer + BaseHeaderSize) + 2)) << 16)) + ((byteAt((integerPointer + BaseHeaderSize) + 3)) << 24)));
}


/*	In the StackInterpreter stacks grow down. */

sqInt
stackSignedMachineIntegerValue(sqInt offset)
{   DECL_MAYBE_SQ_GLOBAL_STRUCT
    sqInt bs;
    sqInt ccIndex;
    sqInt ccIndex1;
    sqInt integerPointer;
    sqInt negative;
    sqInt ok;
    long value;

	integerPointer = longAt(GIV(stackPointer) + (offset * BytesPerWord));
	/* begin signedMachineIntegerValueOf: */
	VM_LABEL(0signedMachineIntegerValueOf);
	if ((integerPointer & 1)) {
		return ((long) ((integerPointer >> 1)));
	}
	/* begin isClassOfNonImm:equalTo:compactClassIndex: */
	assert(!((integerPointer & 1)));
	ccIndex1 = (((usqInt) (longAt(integerPointer))) >> 12) & 31;
	ok = (ClassLargePositiveIntegerCompactIndex == 0
		? (ccIndex1 == 0
	? ((longAt(integerPointer - BaseHeaderSize)) & AllButTypeMask) == (longAt((GIV(specialObjectsOop) + BaseHeaderSize) + (ClassLargePositiveInteger << ShiftForWord)))
	: 0)
		: ClassLargePositiveIntegerCompactIndex == ccIndex1);
	if (ok) {
		negative = 0;
	}
	else {
		negative = 1;
		/* begin isClassOfNonImm:equalTo:compactClassIndex: */
		assert(!((integerPointer & 1)));
		ccIndex = (((usqInt) (longAt(integerPointer))) >> 12) & 31;
		ok = (ClassLargeNegativeIntegerCompactIndex == 0
			? (ccIndex == 0
	? ((longAt(integerPointer - BaseHeaderSize)) & AllButTypeMask) == (longAt((GIV(specialObjectsOop) + BaseHeaderSize) + (ClassLargeNegativeInteger << ShiftForWord)))
	: 0)
			: ClassLargeNegativeIntegerCompactIndex == ccIndex);
		if (!(ok)) {
			/* begin primitiveFail */
			if (GIV(primFailCode) == 0) {
				GIV(primFailCode) = 1;
			}
			return ((long) null);
		}
	}
	if (((bs = lengthOf(integerPointer))) > (sizeof(unsigned long))) {
		/* begin primitiveFail */
		if (GIV(primFailCode) == 0) {
			GIV(primFailCode) = 1;
		}
		return ((long) null);
	}
	if (((sizeof(unsigned long)) == 8)
	 && (bs > 4)) {
		value = (((((((byteAt((integerPointer + BaseHeaderSize) + 0)) + ((byteAt((integerPointer + BaseHeaderSize) + 1)) << 8)) + ((byteAt((integerPointer + BaseHeaderSize) + 2)) << 16)) + ((byteAt((integerPointer + BaseHeaderSize) + 3)) << 24)) + ((byteAt((integerPointer + BaseHeaderSize) + 4)) << 32)) + ((byteAt((integerPointer + BaseHeaderSize) + 5)) << 40)) + ((byteAt((integerPointer + BaseHeaderSize) + 6)) << 48)) + ((byteAt((integerPointer + BaseHeaderSize) + 7)) << 56);
	}
	else {
		value = (((byteAt((integerPointer + BaseHeaderSize) + 0)) + ((byteAt((integerPointer + BaseHeaderSize) + 1)) << 8)) + ((byteAt((integerPointer + BaseHeaderSize) + 2)) << 16)) + ((byteAt((integerPointer + BaseHeaderSize) + 3)) << 24);
	}
	null;
	if (value < 0) {
		if (negative
		 && (0 == (value << 1))) {
			return ((long) value);
		}
		/* begin primitiveFail */
		if (GIV(primFailCode) == 0) {
			GIV(primFailCode) = 1;
		}
		return ((long) null);
	}
	return ((long) ((negative
	? 0 - value
	: value)));
}

sqInt
stackTop(void)
{
	return longAt(GIV(stackPointer));
}


/*	In the StackInterpreter stacks grow down. */

sqInt
stackValue(sqInt offset)
{
	return longAt(GIV(stackPointer) + (offset * BytesPerWord));
}


/*	Answer the start of the Alien's data or fail if oop is not an Alien. */

void *
startOfAlienData(sqInt oop)
{   DECL_MAYBE_SQ_GLOBAL_STRUCT
	if (!(isKindOfClass(oop, longAt((GIV(specialObjectsOop) + BaseHeaderSize) + (ClassAlien << ShiftForWord))))) {
		GIV(primFailCode) = PrimErrBadArgument;
		return 0;
	}
	return ((void *) (((longAt(oop + BaseHeaderSize)) > 0
	? (oop + BaseHeaderSize) + BytesPerOop
	: longAt((oop + BaseHeaderSize) + BytesPerOop))));
}


/*	Return the start of object memory. This is immediately after the native
	code zone.
	N.B. the stack zone is alloca'ed. */

sqInt
startOfMemory(void)
{
	return heapBase;
}


/*	Zero-relative version of CompiledMethod>>startpc. */

sqInt
startPCOfMethodHeader(sqInt aCompiledMethodHeader)
{
	return (((((usqInt) aCompiledMethodHeader) >> 10) & 255) * BytesPerWord) + BaseHeaderSize;
}


/*	Zero-relative version of CompiledMethod>>startpc. */

sqInt
startPCOfMethod(sqInt aCompiledMethod)
{
    sqInt contextSize;
    sqInt fmt;
    sqInt header;
    sqInt methodHeader;
    sqInt sp;

	/* begin lastPointerOf: */
	header = longAt(aCompiledMethod);
	fmt = (((usqInt) header) >> 8) & 15;
	if (fmt <= 4) {
		if ((fmt == 3)
		 && (((((usqInt) header) >> 12) & 31) == ClassMethodContextCompactIndex)) {
			/* begin fetchStackPointerOf: */
			sp = longAt((aCompiledMethod + BaseHeaderSize) + (StackPointerIndex << ShiftForWord));
			if (!((sp & 1))) {
				contextSize = 0;
				goto l1;
			}
			assert((ReceiverIndex + ((sp >> 1))) < (lengthOf(aCompiledMethod)));
			contextSize = (sp >> 1);
		l1:	/* end fetchStackPointerOf: */;
			return (CtxtTempFrameStart + contextSize) * BytesPerWord;
		}
		return (sizeBitsOfSafe(aCompiledMethod)) - BaseHeaderSize;
	}
	if (fmt < 12) {
		return 0;
	}
	methodHeader = longAt(aCompiledMethod + BaseHeaderSize);
	if (isCogMethodReference(methodHeader)) {
		assert(((((CogMethod *) methodHeader)->cmType)) == CMMethod);
		methodHeader = (((CogMethod *) methodHeader)->methodHeader);
	}
	return (((((usqInt) methodHeader) >> 10) & 255) * BytesPerWord) + BaseHeaderSize;
}


/*	Return what ST would return for <obj> at: index. */

sqInt
stObjectat(sqInt array, sqInt index)
{   DECL_MAYBE_SQ_GLOBAL_STRUCT
    sqInt ccIndex;
    sqInt class;
    sqInt classFormat;
    sqInt fixedFields;
    sqInt fmt;
    sqInt hdr;
    sqInt stSize;
    sqInt sz;
    sqInt totalLength;

	hdr = longAt(array);
	fmt = (((usqInt) hdr) >> 8) & 15;
	/* begin lengthOf:baseHeader:format: */
	if ((hdr & TypeMask) == HeaderTypeSizeAndClass) {
		sz = (longAt(array - (BytesPerWord * 2))) & LongSizeMask;
	}
	else {
		sz = hdr & SizeMask;
	}
	sz -= hdr & Size4Bit;
	if (fmt <= 4) {
		totalLength = ((usqInt) (sz - BaseHeaderSize)) >> ShiftForWord;
		goto l1;
	}
	if (fmt < 8) {
		totalLength = ((usqInt) (sz - BaseHeaderSize)) >> 2;
		goto l1;
	}
	else {
		totalLength = (sz - BaseHeaderSize) - (fmt & 3);
		goto l1;
	}
l1:	/* end lengthOf:baseHeader:format: */;
	/* begin fixedFieldsOf:format:length: */
	if ((fmt > 4)
	 || (fmt == 2)) {
		fixedFields = 0;
		goto l3;
	}
	if (fmt < 2) {
		fixedFields = totalLength;
		goto l3;
	}
	/* begin fetchClassOfNonInt: */
	if (((ccIndex = (((usqInt) (longAt(array))) >> 12) & 31)) == 0) {
		class = (longAt(array - BaseHeaderSize)) & AllButTypeMask;
		goto l2;
	}
	else {
		class = longAt(((longAt((GIV(specialObjectsOop) + BaseHeaderSize) + (CompactClasses << ShiftForWord))) + BaseHeaderSize) + ((ccIndex - 1) << ShiftForWord));
		goto l2;
	}
l2:	/* end fetchClassOfNonInt: */;
	classFormat = (longAt((class + BaseHeaderSize) + (InstanceSpecificationIndex << ShiftForWord))) - 1;
	fixedFields = (((((usqInt) classFormat) >> 11) & 192) + ((((usqInt) classFormat) >> 2) & 63)) - 1;
l3:	/* end fixedFieldsOf:format:length: */;
	if (fmt == 3) {
		assert(!(isContextHeader(hdr)));
	}
	stSize = totalLength - fixedFields;
	if (((((usqInt) index)) >= (((usqInt) 1)))
	 && ((((usqInt) index)) <= (((usqInt) stSize)))) {
		/* begin subscript:with:format: */
		if (fmt <= 4) {
			return longAt((array + BaseHeaderSize) + (((index + fixedFields) - 1) << ShiftForWord));
		}
		if (fmt < 8) {
			return positive32BitIntegerFor(long32At((array + BaseHeaderSize) + (((index + fixedFields) - 1) << 2)));
		}
		else {
			return (((byteAt((array + BaseHeaderSize) + ((index + fixedFields) - 1))) << 1) | 1);
		}
	}
	else {
		GIV(primFailCode) = PrimErrBadIndex;
		return 0;
	}
}


/*	Do what ST would return for <obj> at: index put: value. */

void
stObjectatput(sqInt array, sqInt index, sqInt value)
{   DECL_MAYBE_SQ_GLOBAL_STRUCT
    sqInt ccIndex;
    sqInt class;
    sqInt classFormat;
    sqInt fixedFields;
    sqInt fmt;
    sqInt hdr;
    sqInt stSize;
    sqInt sz;
    sqInt totalLength;
    sqInt valueToStore;

	hdr = longAt(array);
	fmt = (((usqInt) hdr) >> 8) & 15;
	/* begin lengthOf:baseHeader:format: */
	if ((hdr & TypeMask) == HeaderTypeSizeAndClass) {
		sz = (longAt(array - (BytesPerWord * 2))) & LongSizeMask;
	}
	else {
		sz = hdr & SizeMask;
	}
	sz -= hdr & Size4Bit;
	if (fmt <= 4) {
		totalLength = ((usqInt) (sz - BaseHeaderSize)) >> ShiftForWord;
		goto l1;
	}
	if (fmt < 8) {
		totalLength = ((usqInt) (sz - BaseHeaderSize)) >> 2;
		goto l1;
	}
	else {
		totalLength = (sz - BaseHeaderSize) - (fmt & 3);
		goto l1;
	}
l1:	/* end lengthOf:baseHeader:format: */;
	/* begin fixedFieldsOf:format:length: */
	if ((fmt > 4)
	 || (fmt == 2)) {
		fixedFields = 0;
		goto l3;
	}
	if (fmt < 2) {
		fixedFields = totalLength;
		goto l3;
	}
	/* begin fetchClassOfNonInt: */
	if (((ccIndex = (((usqInt) (longAt(array))) >> 12) & 31)) == 0) {
		class = (longAt(array - BaseHeaderSize)) & AllButTypeMask;
		goto l2;
	}
	else {
		class = longAt(((longAt((GIV(specialObjectsOop) + BaseHeaderSize) + (CompactClasses << ShiftForWord))) + BaseHeaderSize) + ((ccIndex - 1) << ShiftForWord));
		goto l2;
	}
l2:	/* end fetchClassOfNonInt: */;
	classFormat = (longAt((class + BaseHeaderSize) + (InstanceSpecificationIndex << ShiftForWord))) - 1;
	fixedFields = (((((usqInt) classFormat) >> 11) & 192) + ((((usqInt) classFormat) >> 2) & 63)) - 1;
l3:	/* end fixedFieldsOf:format:length: */;
	if (fmt == 3) {
		assert(!(isContextHeader(hdr)));
	}
	stSize = totalLength - fixedFields;
	if (((((usqInt) index)) >= (((usqInt) 1)))
	 && ((((usqInt) index)) <= (((usqInt) stSize)))) {
		/* begin subscript:with:storing:format: */
		VM_LABEL(2subscriptwithstoringformat);
		if (fmt <= 4) {
			/* begin storePointer:ofObject:withValue: */
			if ((((usqInt) array)) < (((usqInt) GIV(youngStart)))) {
				possibleRootStoreIntovalue(array, value);
			}
			longAtput((array + BaseHeaderSize) + (((index + fixedFields) - 1) << ShiftForWord), value);
		}
		else {
			if (fmt < 8) {

				/* long-word type objects */

				valueToStore = positive32BitValueOf(value);
				if (GIV(primFailCode) == 0) {
					long32Atput((array + BaseHeaderSize) + (((index + fixedFields) - 1) << 2), valueToStore);
				}
			}
			else {
				if (!((value & 1))) {
					/* begin success: */
					if (!(0)) {
						if (GIV(primFailCode) == 0) {

							/* Don't overwrite an error code that has already been set. */

							GIV(primFailCode) = 1;
						}
					}
				}
				valueToStore = (value >> 1);
				if (!((valueToStore >= 0)
					 && (valueToStore <= 255))) {
					/* begin success: */
					if (!(0)) {
						if (GIV(primFailCode) == 0) {

							/* Don't overwrite an error code that has already been set. */

							GIV(primFailCode) = 1;
						}
					}
				}
				if (GIV(primFailCode) == 0) {
					byteAtput((array + BaseHeaderSize) + ((index + fixedFields) - 1), valueToStore);
				}
			}
		}
	}
	else {
		GIV(primFailCode) = PrimErrBadIndex;
	}
}


/*	This primitive will store a binary image segment (in the same format as
	the Squeak image file) of the receiver and every object in its proper tree
	of subParts (ie, that is not refered to from anywhere else outside the
	tree). All pointers from within the tree to objects outside the tree will
	be copied into the array of outpointers. In their place in the image
	segment will be an oop equal to the offset in the outPointer array (the
	first would be 4). but with the high bit set.
 */
/*	The primitive expects the array and wordArray to be more than adequately
	long. In this case it returns normally, and truncates the two arrays to
	exactly the right size. To simplify truncation, both incoming arrays are
	required to be 256 bytes or more long (ie with 3-word headers). If either
	array is too small, the primitive will fail, but in no other case.
	
	During operation of the primitive, it is necessary to convert from both
	internal and external oops to their mapped values. To make this fast, the
	headers of the original objects in question are replaced by the mapped
	values (and this is noted by adding the forbidden XX header type). Tables
	are kept of both kinds of oops, as well as of the original headers for
	restoration. 
	To be specific, there are two similar two-part tables, the outpointer
	array, and one in the upper fifth of the segmentWordArray. Each grows oops
	from the bottom up, and preserved headers from halfway up.
	
	In case of either success or failure, the headers must be restored. In the
	event of primitive failure, the table of outpointers must also be nilled
	out (since the garbage in the high half will not have been discarded.
 */

static sqInt
storeImageSegmentIntooutPointersroots(sqInt segmentWordArray, sqInt outPointerArray, sqInt arrayOfRoots)
{   DECL_MAYBE_SQ_GLOBAL_STRUCT
    sqInt doingClass;
    usqInt endSeg;
    sqInt extraSize;
    sqInt fieldOop;
    usqInt fieldPtr;
    usqInt firstIn;
    usqInt firstOut;
    usqInt hdrBaseIn;
    usqInt hdrBaseOut;
    sqInt hdrTypeBits;
    sqInt header;
    sqInt header1;
    sqInt i;
    sqInt i1;
    sqInt i2;
    sqInt i3;
    sqInt in;
    sqInt in1;
    sqInt lastAddr;
    sqInt lastAddr1;
    sqInt lastAddr2;
    sqInt lastAddr3;
    usqInt lastIn;
    sqInt lastIn1;
    sqInt lastIn2;
    usqInt lastOut;
    usqInt lastPtr;
    usqInt lastSeg;
    sqInt mapOop;
    sqInt out;
    sqInt out1;
    usqInt savedYoungStart;
    usqInt segOop;
    sqInt sz;
    sqInt versionOffset;

	if (!((((longAt(outPointerArray)) & TypeMask) == HeaderTypeSizeAndClass)
		 && (((longAt(segmentWordArray)) & TypeMask) == HeaderTypeSizeAndClass))) {
		return PrimErrGenericFailure;
	}
	if (DoAssertionChecks) {
		verifyCleanHeaders();
	}
	firstOut = outPointerArray + BaseHeaderSize;
	lastOut = firstOut - BytesPerWord;

	/* top half */

	hdrBaseOut = outPointerArray + (((lastPointerOf(outPointerArray)) / (BytesPerWord * 2)) * BytesPerWord);
	lastSeg = segmentWordArray;

	/* Write a version number for byte order and version check */

	endSeg = (segmentWordArray + (sizeBitsOf(segmentWordArray))) - BytesPerWord;
	versionOffset = BytesPerWord;
	lastSeg += versionOffset;
	if (lastSeg > endSeg) {
		return PrimErrGenericFailure;
	}
	longAtput(lastSeg, imageSegmentVersion());

	/* Take 1/8 of seg */

	firstIn = endSeg - (((sizeBitsOf(segmentWordArray)) / (BytesPerWord * 8)) * BytesPerWord);
	lastIn = firstIn - BytesPerWord;

	/* top half of that */
	/* First mark the rootArray and all root objects. */

	hdrBaseIn = firstIn + (((sizeBitsOf(segmentWordArray)) / (BytesPerWord * 16)) * BytesPerWord);
	longAtput(arrayOfRoots, (longAt(arrayOfRoots)) | MarkBit);
	lastPtr = arrayOfRoots + (lastPointerOf(arrayOfRoots));
	fieldPtr = arrayOfRoots + BaseHeaderSize;
	while (fieldPtr <= lastPtr) {
		fieldOop = longAt(fieldPtr);
		if (!((fieldOop & 1))) {
			longAtput(fieldOop, (longAt(fieldOop)) | MarkBit);
		}
		fieldPtr += BytesPerWord;
	}
	savedYoungStart = GIV(youngStart);

	/* process all of memory */

	GIV(youngStart) = heapBase;
	markAndTraceInterpreterOops(0);

	/* Finally unmark the rootArray and all root objects. */

	GIV(youngStart) = savedYoungStart;
	longAtput(arrayOfRoots, (longAt(arrayOfRoots)) & AllButMarkBit);
	fieldPtr = arrayOfRoots + BaseHeaderSize;
	while (fieldPtr <= lastPtr) {
		fieldOop = longAt(fieldPtr);
		if (!((fieldOop & 1))) {
			longAtput(fieldOop, (longAt(fieldOop)) & AllButMarkBit);
		}
		fieldPtr += BytesPerWord;
	}
	lastIn += BytesPerWord;
	if ((lastIn >= hdrBaseIn)
	 || (0 == ((lastSeg = copyObjtoSegmentaddrstopAtsaveOopAtheaderAt(arrayOfRoots, segmentWordArray, lastSeg, firstIn, lastIn, hdrBaseIn + (lastIn - firstIn)))))) {
		lastIn -= BytesPerWord;
		restoreHeadersFromtofromandtofrom(firstIn, lastIn, hdrBaseIn, firstOut, lastOut, hdrBaseOut);
		/* begin primitiveFailCodeAfterCleanup: */
		lastAddr = outPointerArray + (lastPointerOf(outPointerArray));
		i = outPointerArray + BaseHeaderSize;
		while (i <= lastAddr) {
			longAtput(i, GIV(nilObj));
			i += BytesPerWord;
		}
		if (DoAssertionChecks) {
			verifyCleanHeaders();
		}
		return PrimErrGenericFailure;
	}
	segOop = ((segmentWordArray + versionOffset) + BaseHeaderSize) + (headerTypeBytes[(longAt((segmentWordArray + versionOffset) + BaseHeaderSize)) & TypeMask]);
	while (segOop <= lastSeg) {
		if (((longAt(segOop)) & TypeMask) <= 1) {

			/* This object has a class field (type=0 or 1) -- start with that. */

			fieldPtr = segOop - BytesPerWord;
			doingClass = 1;
		}
		else {

			/* No class field -- start with first data field */

			fieldPtr = segOop + BaseHeaderSize;
			doingClass = 0;
		}

		/* last field */
		/* Go through all oops, remapping them... */

		lastPtr = segOop + (lastPointerOf(segOop));
		while (!(fieldPtr > lastPtr)) {

			/* Examine each pointer field */

			fieldOop = longAt(fieldPtr);
			if (doingClass) {
				hdrTypeBits = fieldOop & TypeMask;
				fieldOop -= hdrTypeBits;
			}
			if ((fieldOop & 1)) {

				/* Just an integer -- nothing to do */

				fieldPtr += BytesPerWord;
			}
			else {
				header = longAt(fieldOop);
				if ((header & TypeMask) == HeaderTypeFree) {

					/* Has already been forwarded -- this is the link */

					mapOop = header & AllButTypeMask;
				}
				else {
					if (((longAt(fieldOop)) & MarkBit) == 0) {

						/* Points to an unmarked obj -- an internal pointer.
							Copy the object into the segment, and forward its oop. */

						lastIn += BytesPerWord;
						if ((lastIn >= hdrBaseIn)
						 || (0 == ((lastSeg = copyObjtoSegmentaddrstopAtsaveOopAtheaderAt(fieldOop, segmentWordArray, lastSeg, firstIn, lastIn, hdrBaseIn + (lastIn - firstIn)))))) {

							/* Out of space in segment */

							lastIn -= BytesPerWord;
							restoreHeadersFromtofromandtofrom(firstIn, lastIn, hdrBaseIn, firstOut, lastOut, hdrBaseOut);
							/* begin primitiveFailCodeAfterCleanup: */
							lastAddr1 = outPointerArray + (lastPointerOf(outPointerArray));
							i1 = outPointerArray + BaseHeaderSize;
							while (i1 <= lastAddr1) {
								longAtput(i1, GIV(nilObj));
								i1 += BytesPerWord;
							}
							if (DoAssertionChecks) {
								verifyCleanHeaders();
							}
							return PrimErrGenericFailure;
						}
						mapOop = (longAt(fieldOop)) & AllButTypeMask;
					}
					else {

						/* Points to a marked obj -- an external pointer.
							Map it as a tagged index in outPointers, and forward its oop. */

						lastOut += BytesPerWord;
						if (lastOut >= hdrBaseOut) {

							/* Out of space in outPointerArray */

							lastOut -= BytesPerWord;
							restoreHeadersFromtofromandtofrom(firstIn, lastIn, hdrBaseIn, firstOut, lastOut, hdrBaseOut);
							/* begin primitiveFailCodeAfterCleanup: */
							lastAddr2 = outPointerArray + (lastPointerOf(outPointerArray));
							i2 = outPointerArray + BaseHeaderSize;
							while (i2 <= lastAddr2) {
								longAtput(i2, GIV(nilObj));
								i2 += BytesPerWord;
							}
							if (DoAssertionChecks) {
								verifyCleanHeaders();
							}
							return PrimErrGenericFailure;
						}
						mapOop = (lastOut - outPointerArray) | 2147483648UL;
						/* begin forward:to:savingOopAt:andHeaderAt: */
						longAtput(lastOut, fieldOop);
						longAtput(hdrBaseOut + (lastOut - firstOut), longAt(fieldOop));
						longAtput(fieldOop, mapOop + HeaderTypeFree);
					}
				}
				if (doingClass) {
					longAtput(fieldPtr, mapOop + hdrTypeBits);
					fieldPtr += BytesPerWord * 2;
					doingClass = 0;
				}
				else {
					longAtput(fieldPtr, mapOop);
					fieldPtr += BytesPerWord;
				}
			}
		}
		/* begin objectAfter: */
		if (DoAssertionChecks) {
			if ((((usqInt) segOop)) >= (((usqInt) GIV(endOfMemory)))) {
				error("no objects after the end of memory");
			}
		}
		if (((longAt(segOop)) & TypeMask) == HeaderTypeFree) {
			sz = (longAt(segOop)) & AllButTypeMask;
		}
		else {
			/* begin sizeBitsOf: */
			header1 = longAt(segOop);
			sz = ((header1 & TypeMask) == HeaderTypeSizeAndClass
				? (longAt(segOop - (BytesPerWord * 2))) & LongSizeMask
				: header1 & SizeMask);
		}
		segOop = ((sqInt) ((segOop + sz) + (headerTypeBytes[(longAt(segOop + sz)) & TypeMask])));
	}
	restoreHeadersFromtofromandtofrom(firstIn, lastIn, hdrBaseIn, firstOut, lastOut, hdrBaseOut);
	if ((((outPointerArray + (lastPointerOf(outPointerArray))) - lastOut) < 12)
	 || ((endSeg - lastSeg) < 12)) {
		/* begin primitiveFailCodeAfterCleanup: */
		lastAddr3 = outPointerArray + (lastPointerOf(outPointerArray));
		i3 = outPointerArray + BaseHeaderSize;
		while (i3 <= lastAddr3) {
			longAtput(i3, GIV(nilObj));
			i3 += BytesPerWord;
		}
		if (DoAssertionChecks) {
			verifyCleanHeaders();
		}
		return PrimErrGenericFailure;
	}
	extraSize = headerTypeBytes[(longAt(segmentWordArray)) & TypeMask];

	/* Copy the 3-word wordArray header to establish a free chunk. */

	hdrTypeBits = (longAt(segmentWordArray)) & TypeMask;
	/* begin transfer:from:to: */
	flag("Dan");
	in = (segmentWordArray - extraSize) - BytesPerWord;
	lastIn1 = in + (3 * BytesPerWord);
	out = (lastOut + BytesPerWord) - BytesPerWord;
	while ((((usqInt) in)) < (((usqInt) lastIn1))) {
		longAtput(out += BytesPerWord, longAt(in += BytesPerWord));
	}
	longAtput(lastOut + BytesPerWord, (((outPointerArray + (lastPointerOf(outPointerArray))) - lastOut) - extraSize) + hdrTypeBits);
	longAtput(outPointerArray - extraSize, ((lastOut - firstOut) + (BytesPerWord * 2)) + hdrTypeBits);
	beRootIfOld(outPointerArray);
	/* begin transfer:from:to: */
	flag("Dan");
	in1 = (segmentWordArray - extraSize) - BytesPerWord;
	lastIn2 = in1 + (3 * BytesPerWord);
	out1 = (lastSeg + BytesPerWord) - BytesPerWord;
	while ((((usqInt) in1)) < (((usqInt) lastIn2))) {
		longAtput(out1 += BytesPerWord, longAt(in1 += BytesPerWord));
	}
	longAtput(segmentWordArray - extraSize, ((lastSeg - segmentWordArray) + BaseHeaderSize) + hdrTypeBits);
	longAtput(lastSeg + BytesPerWord, ((endSeg - lastSeg) - extraSize) + hdrTypeBits);
	if (DoAssertionChecks) {
		verifyCleanHeaders();
	}
	return PrimNoErr;
}


/*	Note: May be called by translated primitive code. */

sqInt
storeIntegerofObjectwithValue(sqInt fieldIndex, sqInt objectPointer, sqInt integerValue)
{   DECL_MAYBE_SQ_GLOBAL_STRUCT
	if ((integerValue ^ (integerValue << 1)) >= 0) {
		longAtput((objectPointer + BaseHeaderSize) + (fieldIndex << ShiftForWord), ((integerValue << 1) | 1));
	}
	else {
		/* begin primitiveFail */
		if (GIV(primFailCode) == 0) {
			GIV(primFailCode) = 1;
		}
	}
	return null;
}


/*	Like storePointer:ofObject:withValue:, but the caller guarantees that the
	object being stored into is a young object or is already marked as a root. */

sqInt
storePointerUncheckedofObjectwithValue(sqInt fieldIndex, sqInt oop, sqInt valuePointer)
{
	return longAtput((oop + BaseHeaderSize) + (fieldIndex << ShiftForWord), valuePointer);
}


/*	Note must check here for stores of young objects into old ones. */

sqInt
storePointerofObjectwithValue(sqInt fieldIndex, sqInt oop, sqInt valuePointer)
{
	if ((((usqInt) oop)) < (((usqInt) GIV(youngStart)))) {
		possibleRootStoreIntovalue(oop, valuePointer);
	}
	return longAtput((oop + BaseHeaderSize) + (fieldIndex << ShiftForWord), valuePointer);
}


/*	Set the sender of a frame. If the frame is a base frame then this is
	trivial; merely store into the FoxCallerSavedIP/FoxCallerContext field. If
	not, then
	split the stack at the frame, moving the frame and those hotter than it to
	a new stack page. In the new stack page the frame will be the base frame
	and storing trivial. Answer the possibly changed location of theFP. */

static char *
storeSenderOfFramewithValue(char *theFP, sqInt anOop)
{   DECL_MAYBE_SQ_GLOBAL_STRUCT
    sqInt callerContextOrNil;
    char *callerFP;
    sqInt index;
    sqInt index1;
    StackPage *lruOrFree;
    StackPage *newPage;
    sqInt onCurrentPage;
    char *theMovedFP;
    StackPage *thePage;
    StackPage *thePage1;
    char *theSP;

	if ((longAt(theFP + FoxSavedFP)) == 0) {
		frameCallerContextput(theFP, anOop);
		return theFP;
	}
	/* begin ensureCallerContext: */
	/* begin frameCallerFP: */
	callerFP = pointerForOop(longAt(theFP + FoxSavedFP));
	if (callerFP == 0) {
		/* begin frameCallerContext: */
		assert(isBaseFrame(theFP));
		/* begin stackPageFor: */
		/* begin stackPageAt: */
		/* begin pageIndexFor: */
		assert((((((char *) theFP)) >= (GIV(stackBasePlus1) - 1)) && ((((char *) theFP)) <= (((char *) GIV(pages))))));
		index = pageIndexForstackBasePlus1bytesPerPage(theFP, GIV(stackBasePlus1), GIV(bytesPerPage));
		thePage1 = stackPageAtpages(index, GIV(pages));
		callerContextOrNil = longAt((thePage1->baseAddress));
		assert(addressCouldBeObj(callerContextOrNil));
		assert((callerContextOrNil == (nilObject()))
		 || (isContext(callerContextOrNil)));
		goto l1;
	}
	/* begin ensureFrameIsMarried:SP: */
	VM_LABEL(18ensureFrameIsMarriedSP);
	/* begin frameCallerStackPointer: */
	assert(!(isBaseFrame(theFP)));
	theSP = (theFP + ((FoxCallerSavedIP + BytesPerWord) + ((((((usqInt)(longAt(theFP + FoxMethod)))) < heapBase
	? (mframeCogMethod(theFP)->cmNumArgs)
	: byteAt((theFP + FoxIFrameFlags) + 1))) << ShiftForWord))) + BytesPerWord;
	if (((((usqInt)(longAt(callerFP + FoxMethod)))) < heapBase
		? ((longAt(callerFP + FoxMethod)) & MFMethodFlagHasContextFlag) != 0
		: (byteAt((callerFP + FoxIFrameFlags) + 2)) != 0)) {
		assert(isContext(frameContext(callerFP)));
		longAt(callerFP + FoxThisContext);
		goto l3;
	}
	marryFrameSP(callerFP, theSP);
l3:	/* end ensureFrameIsMarried:SP: */;
l1:	/* end ensureCallerContext: */;
	/* begin stackPageFor: */
	/* begin stackPageAt: */
	/* begin pageIndexFor: */
	assert((((((char *) theFP)) >= (GIV(stackBasePlus1) - 1)) && ((((char *) theFP)) <= (((char *) GIV(pages))))));
	index1 = pageIndexForstackBasePlus1bytesPerPage(theFP, GIV(stackBasePlus1), GIV(bytesPerPage));
	thePage = stackPageAtpages(index1, GIV(pages));
	assert(GIV(stackPage) == (mostRecentlyUsedPage()));
	onCurrentPage = thePage == GIV(stackPage);
	if (!(onCurrentPage)) {
		markStackPageNextMostRecentlyUsed(thePage);
	}
	/* begin newStackPage */
	lruOrFree = (mostRecentlyUsedPage()->nextPage);
	if (isFree(lruOrFree)) {
		newPage = lruOrFree;
		goto l2;
	}
	divorceFramesIn(lruOrFree);
	newPage = lruOrFree;
l2:	/* end newStackPage */;
	theMovedFP = moveFramesInthroughtoPage(thePage, theFP, newPage);
	if (onCurrentPage) {
		/* begin setStackPageAndLimit: */
		GIV(stackPage) = newPage;
		if (GIV(stackLimit) != (((char *) (((usqInt) -1))))) {
			GIV(stackLimit) = (GIV(stackPage)->stackLimit);
		}
		markStackPageMostRecentlyUsed(newPage);
	}
	else {
		markStackPageMostRecentlyUsed(newPage);
	}
	assert(isBaseFrame(theMovedFP));
	frameCallerContextput(theMovedFP, anOop);
	return theMovedFP;
}


/*	Answer a new String copied from a null-terminated C string,
	or nil if out of memory.
	Caution: This may invoke the garbage collector. */

sqInt
stringForCString(const char *aCString)
{
    sqInt len;
    sqInt newString;

	len = strlen(aCString);
	newString = instantiateClassindexableSize(longAt((GIV(specialObjectsOop) + BaseHeaderSize) + (ClassString << ShiftForWord)), len);
	if (!(newString == null)) {
		strncpy(arrayValueOf(newString), aCString, len);
	}
	return newString;
}


/*	Return the number of indexable fields in the given object. (i.e., what
	Smalltalk would return for <obj> size).
 */
/*	Note: Assume oop is not a SmallInteger! */

sqInt
stSizeOf(sqInt oop)
{
    sqInt ccIndex;
    sqInt class;
    sqInt classFormat;
    sqInt fixedFields;
    sqInt fmt;
    sqInt hdr;
    sqInt sz;
    sqInt totalLength;

	hdr = longAt(oop);
	fmt = (((usqInt) hdr) >> 8) & 15;
	/* begin lengthOf:baseHeader:format: */
	if ((hdr & TypeMask) == HeaderTypeSizeAndClass) {
		sz = (longAt(oop - (BytesPerWord * 2))) & LongSizeMask;
	}
	else {
		sz = hdr & SizeMask;
	}
	sz -= hdr & Size4Bit;
	if (fmt <= 4) {
		totalLength = ((usqInt) (sz - BaseHeaderSize)) >> ShiftForWord;
		goto l1;
	}
	if (fmt < 8) {
		totalLength = ((usqInt) (sz - BaseHeaderSize)) >> 2;
		goto l1;
	}
	else {
		totalLength = (sz - BaseHeaderSize) - (fmt & 3);
		goto l1;
	}
l1:	/* end lengthOf:baseHeader:format: */;
	/* begin fixedFieldsOf:format:length: */
	if ((fmt > 4)
	 || (fmt == 2)) {
		fixedFields = 0;
		goto l3;
	}
	if (fmt < 2) {
		fixedFields = totalLength;
		goto l3;
	}
	/* begin fetchClassOfNonInt: */
	if (((ccIndex = (((usqInt) (longAt(oop))) >> 12) & 31)) == 0) {
		class = (longAt(oop - BaseHeaderSize)) & AllButTypeMask;
		goto l2;
	}
	else {
		class = longAt(((longAt((GIV(specialObjectsOop) + BaseHeaderSize) + (CompactClasses << ShiftForWord))) + BaseHeaderSize) + ((ccIndex - 1) << ShiftForWord));
		goto l2;
	}
l2:	/* end fetchClassOfNonInt: */;
	classFormat = (longAt((class + BaseHeaderSize) + (InstanceSpecificationIndex << ShiftForWord))) - 1;
	fixedFields = (((((usqInt) classFormat) >> 11) & 192) + ((((usqInt) classFormat) >> 2) & 63)) - 1;
l3:	/* end fixedFieldsOf:format:length: */;
	if (fmt == 3) {
		assert(!(isContextHeader(hdr)));
	}
	return totalLength - fixedFields;
}


/*	Set the state of the primitive failure code/success flag, iff
	successBoolean is false. If primFailCode is non-zero a primitive has
	failed. If primFailCode
	is greater than one then its value indicates the reason for failure. */
/*	Use returnTypeC: #sqInt because that's the way it is defined in sq.h.
	Use no explicit return so that Slang doesn't fail an inlin ingtype-check
	when a primitive with return type void uses ^self success: false to exit. */

sqInt
success(sqInt successBoolean)
{   DECL_MAYBE_SQ_GLOBAL_STRUCT
	if (!(successBoolean)) {
		if (GIV(primFailCode) == 0) {

			/* Don't overwrite an error code that has already been set. */

			GIV(primFailCode) = 1;
		}
	}
}


/*	Return true if there is enough free space after doing a garbage
	collection. If not, signal that space is low.
 */

static sqInt
sufficientSpaceAfterGC(sqInt minFree)
{   DECL_MAYBE_SQ_GLOBAL_STRUCT
    sqInt delta;
    sqInt limit;

	incrementalGC();
	if ((((usqInt) (GIV(freeStart) + minFree))) <= (((usqInt) GIV(reserveStart)))) {
		return 1;
	}
	if (GIV(signalLowSpace)) {
		return 0;
	}
	fullGC();
	if ((((usqInt) ((GIV(freeStart) + minFree) + 15000))) < (((usqInt) GIV(reserveStart)))) {
		return 1;
	}
	/* begin growObjectMemory: */
	delta = (minFree - (((((usqInt) GIV(freeStart))) < (((usqInt) GIV(reserveStart)))
	? (((usqInt) GIV(reserveStart))) - (((usqInt) GIV(freeStart)))
	: 0))) + GIV(growHeadroom);
	GIV(statGrowMemory) += 1;
	limit = sqGrowMemoryBy(GIV(memoryLimit), delta);
	if (!(limit == GIV(memoryLimit))) {
		/* begin setMemoryLimit: */
		assert(((limit - 24) & (BytesPerWord - 1)) == 0);
		GIV(memoryLimit) = limit - 24;
		initializeMemoryFirstFree(GIV(freeStart));
		sqMakeMemoryNotExecutableFromTo(heapBase, GIV(memoryLimit));
	}
	return (((usqInt) ((GIV(freeStart) + minFree) + 15000))) < (((usqInt) GIV(reserveStart)));
}


/*	Return true if there is enough space to allocate the given number of
	bytes, perhaps after doing a garbage collection.
 */

static sqInt
sufficientSpaceToAllocate(sqInt bytes)
{   DECL_MAYBE_SQ_GLOBAL_STRUCT
    sqInt minFree;


	/* check for low-space */

	minFree = ((((GIV(lowSpaceThreshold) + bytes) + BaseHeaderSize) + BytesPerWord) - 1) & (~(BytesPerWord - 1));
	if ((((usqInt) (GIV(freeStart) + minFree))) <= (((usqInt) GIV(reserveStart)))) {
		return 1;
	}
	return sufficientSpaceAfterGC(minFree);
}

sqInt
superclassOf(sqInt classPointer)
{
	return longAt((classPointer + BaseHeaderSize) + (SuperclassIndex << ShiftForWord));
}


/*	Sweep memory from youngStart through the end of memory. Free all 
	inaccessible objects and coalesce adjacent free chunks. Clear the mark 
	bits of accessible objects. Compute the starting point for the first pass
	of 
	incremental compaction (compStart). Return the number of surviving 
	objects. */
/*	Details: Each time a non-free object is encountered, decrement the 
	number of available forward table entries. If all entries are spoken for 
	(i.e., entriesAvailable reaches zero), set compStart to the last free 
	chunk before that object or, if there is no free chunk before the given 
	object, the first free chunk after it. Thus, at the end of the sweep 
	phase, compStart through compEnd spans the highest collection of 
	non-free objects that can be accomodated by the forwarding table. This 
	information is used by the first pass of incremental compaction to 
	ensure that space is initially freed at the end of memory. Note that 
	there should always be at least one free chunk--the one at the end of 
	the heap. */

static sqInt
sweepPhase(void)
{   DECL_MAYBE_SQ_GLOBAL_STRUCT
    usqInt endOfMemoryLocal;
    sqInt entriesAvailable;
    sqInt firstFree;
    sqInt freeChunk;
    sqInt freeChunkSize;
    sqInt hdrBytes;
    usqInt oop;
    sqInt oopHeader;
    sqInt oopHeaderType;
    sqInt oopSize;
    sqInt survivors;

	entriesAvailable = fwdTableInit(BytesPerWord * 2);
	survivors = 0;
	freeChunk = null;

	/* will be updated later */

	firstFree = null;
	endOfMemoryLocal = GIV(endOfMemory);
	oop = GIV(youngStart) + (headerTypeBytes[(longAt(GIV(youngStart))) & TypeMask]);
	while (oop < endOfMemoryLocal) {

		/* get oop's header, header type, size, and header size */

		GIV(statSweepCount) += 1;
		oopHeader = longAt(oop);
		oopHeaderType = oopHeader & TypeMask;
		hdrBytes = headerTypeBytes[oopHeaderType];
		if ((oopHeaderType & 1) == 1) {
			oopSize = oopHeader & SizeMask;
		}
		else {
			if (oopHeaderType == HeaderTypeSizeAndClass) {
				oopSize = (longAt(oop - (BytesPerWord * 2))) & LongSizeMask;
			}
			else {

				/* free chunk */

				oopSize = oopHeader & LongSizeMask;
			}
		}
		if ((oopHeader & MarkBit) == 0) {
			longAtput(oop - hdrBytes, HeaderTypeFree);
			if (freeChunk != null) {

				/* enlarge current free chunk to include this oop */

				freeChunkSize = (freeChunkSize + oopSize) + hdrBytes;
			}
			else {

				/* start a new free chunk */
				/* chunk may start 4 or 8 bytes before oop */

				freeChunk = oop - hdrBytes;

				/* adjust size for possible extra header bytes */

				freeChunkSize = oopSize + (oop - freeChunk);
				if (firstFree == null) {
					firstFree = freeChunk;
				}
			}
		}
		else {
			longAtput(oop, oopHeader & AllButMarkBit);
			if (((((usqInt) (longAt(oop))) >> 8) & 15) == 4) {
				finalizeReference(oop);
			}
			if (entriesAvailable > 0) {
				entriesAvailable -= 1;
			}
			else {

				/* start compaction at the last free chunk before this object */

				firstFree = freeChunk;
			}
			if (freeChunk != null) {
				longAtput(freeChunk, (freeChunkSize & LongSizeMask) | HeaderTypeFree);
				freeChunk = null;
			}
			survivors += 1;
		}
		oop = (oop + oopSize) + (headerTypeBytes[(longAt(oop + oopSize)) & TypeMask]);
	}
	if (freeChunk != null) {
		longAtput(freeChunk, (freeChunkSize & LongSizeMask) | HeaderTypeFree);
	}
	if (!(oop == GIV(endOfMemory))) {
		error("sweep failed to find exact end of memory");
	}
	if (firstFree == null) {
		error("expected to find at least one free object");
	}
	else {
		GIV(compStart) = firstFree;
	}
	return survivors;
}


/*	Sweep memory from youngStart through the end of memory. Free all
	inaccessible objects and coalesce adjacent free chunks. Clear the mark
	bits of accessible objects. Compute the starting point for the first pass
	of incremental compaction (compStart). Return the number of surviving
	objects. Unlike sweepPhase this always leaves compStart pointing at the
	first free chunk. */

static sqInt
sweepPhaseForFullGC(void)
{   DECL_MAYBE_SQ_GLOBAL_STRUCT
    usqInt endOfMemoryLocal;
    sqInt firstFree;
    sqInt freeChunk;
    sqInt freeChunkSize;
    sqInt hdrBytes;
    usqInt oop;
    sqInt oopHeader;
    sqInt oopHeaderType;
    sqInt oopSize;
    sqInt survivors;

	fwdTableInit(BytesPerWord * 2);
	survivors = 0;
	freeChunk = null;

	/* will be updated later */

	firstFree = null;
	endOfMemoryLocal = GIV(endOfMemory);
	oop = GIV(youngStart) + (headerTypeBytes[(longAt(GIV(youngStart))) & TypeMask]);
	while (oop < endOfMemoryLocal) {

		/* get oop's header, header type, size, and header size */

		GIV(statSweepCount) += 1;
		oopHeader = longAt(oop);
		oopHeaderType = oopHeader & TypeMask;
		hdrBytes = headerTypeBytes[oopHeaderType];
		if ((oopHeaderType & 1) == 1) {
			oopSize = oopHeader & SizeMask;
		}
		else {
			if (oopHeaderType == HeaderTypeSizeAndClass) {
				oopSize = (longAt(oop - (BytesPerWord * 2))) & LongSizeMask;
			}
			else {
				assert((oopHeader & MarkBit) == 0);
				oopSize = oopHeader & LongSizeMask;
			}
		}
		if ((oopHeader & MarkBit) == 0) {
			longAtput(oop - hdrBytes, HeaderTypeFree);
			if (freeChunk != null) {

				/* enlarge current free chunk to include this oop */

				freeChunkSize = (freeChunkSize + oopSize) + hdrBytes;
			}
			else {

				/* start a new free chunk */
				/* chunk may start 4 or 8 bytes before oop */

				freeChunk = oop - hdrBytes;

				/* adjust size for possible extra header bytes */

				freeChunkSize = oopSize + (oop - freeChunk);
				if (firstFree == null) {
					firstFree = freeChunk;
				}
			}
		}
		else {
			longAtput(oop, oopHeader & AllButMarkBit);
			if (((((usqInt) (longAt(oop))) >> 8) & 15) == 4) {
				finalizeReference(oop);
			}
			if (freeChunk != null) {
				longAtput(freeChunk, (freeChunkSize & LongSizeMask) | HeaderTypeFree);
				freeChunk = null;
			}
			survivors += 1;
		}
		oop = (oop + oopSize) + (headerTypeBytes[(longAt(oop + oopSize)) & TypeMask]);
	}
	if (freeChunk != null) {
		longAtput(freeChunk, (freeChunkSize & LongSizeMask) | HeaderTypeFree);
	}
	if (!(oop == GIV(endOfMemory))) {
		error("sweep failed to find exact end of memory");
	}
	if (firstFree == null) {
		error("expected to find at least one free object");
	}
	else {
		GIV(compStart) = firstFree;
	}
	return survivors;
}


/*	Signal the given semaphore from within the interpreter.
	Answer if the current process was preempted.
	Override to add tracing info. */

static sqInt
synchronousSignal(sqInt aSemaphore)
{   DECL_MAYBE_SQ_GLOBAL_STRUCT
    sqInt excessSignals;

	if ((longAt((aSemaphore + BaseHeaderSize) + (FirstLinkIndex << ShiftForWord))) == GIV(nilObj)) {

		/* no process is waiting on this semaphore */

		excessSignals = fetchIntegerofObject(ExcessSignalsIndex, aSemaphore);
		/* begin storeInteger:ofObject:withValue: */
		if (((excessSignals + 1) ^ ((excessSignals + 1) << 1)) >= 0) {
			longAtput((aSemaphore + BaseHeaderSize) + (ExcessSignalsIndex << ShiftForWord), (((excessSignals + 1) << 1) | 1));
		}
		else {
			/* begin primitiveFail */
			if (GIV(primFailCode) == 0) {
				GIV(primFailCode) = 1;
			}
		}
		return 0;
	}
	return resumepreemptedYieldingIffrom(removeFirstLinkOfList(aSemaphore), GIV(preemptionYields), CSSignal);
}


/*	Handle the cannot return response for a base frame return to an invalid
	context. Build a new base frame for the context in the cannot resume state
	ready for the
	send of cannotReturn:.
	
	Since we have returned from the base frame of the page the context is
	effectively widowed.
	But its sender needs to be contextToReturnTo, and its pc needs to be the
	HasBeenReturnedFromMCPC marker. So bereave it (as a side-effect of
	isWidowedContext:), assign contextToReturnTo to
	sender, and rebuild its frame, which will have the ceCannotResumePC as its
	pc. Finally push
	returnValue and set instructionPointer to ceCannotResumePC in preparation
	for the send. */

static void
tearDownAndRebuildFrameForCannotReturnBaseFrameReturnFromtoreturnValue(sqInt contextToReturnFrom, sqInt contextToReturnTo, sqInt returnValue)
{   DECL_MAYBE_SQ_GLOBAL_STRUCT
    StackPage *newPage;

	assert((GIV(stackPage) != 0)
	 && (isFree(GIV(stackPage))));
	isWidowedContext(contextToReturnFrom);
	assert(!(isMarriedOrWidowedContext(contextToReturnFrom)));
	/* begin storePointer:ofObject:withValue: */
	if ((((usqInt) contextToReturnFrom)) < (((usqInt) GIV(youngStart)))) {
		possibleRootStoreIntovalue(contextToReturnFrom, contextToReturnTo);
	}
	longAtput((contextToReturnFrom + BaseHeaderSize) + (SenderIndex << ShiftForWord), contextToReturnTo);
	/* begin storePointer:ofObject:withValue: */
	if ((((usqInt) contextToReturnFrom)) < (((usqInt) GIV(youngStart)))) {
		possibleRootStoreIntovalue(contextToReturnFrom, HasBeenReturnedFromMCPC);
	}
	longAtput((contextToReturnFrom + BaseHeaderSize) + (InstructionPointerIndex << ShiftForWord), HasBeenReturnedFromMCPC);
	GIV(instructionPointer) = 0;
	newPage = makeBaseFrameFor(contextToReturnFrom);
	assert(GIV(stackPage) == newPage);
	/* begin setStackPageAndLimit: */
	GIV(stackPage) = newPage;
	if (GIV(stackLimit) != (((char *) (((usqInt) -1))))) {
		GIV(stackLimit) = (GIV(stackPage)->stackLimit);
	}
	markStackPageMostRecentlyUsed(newPage);
	GIV(framePointer) = (GIV(stackPage)->headFP);
	GIV(stackPointer) = (GIV(stackPage)->headSP);
	assert((stackTop()) == (ceCannotResumePC()));
	longAtPointerput(GIV(stackPointer), returnValue);
	GIV(instructionPointer) = ceCannotResumePC();
}

sqInt
tempCountOfMethodHeader(sqInt header)
{
	return (((usqInt) header) >> 19) & 63;
}

sqInt
tempCountOf(sqInt methodPointer)
{
    sqInt header;
    sqInt methodHeader;

	/* begin tempCountOfMethodHeader: */
	/* begin headerOf: */
	methodHeader = longAt((methodPointer + BaseHeaderSize) + (HeaderIndex << ShiftForWord));
	header = (isCogMethodReference(methodHeader)
		? (((CogMethod *) methodHeader)->methodHeader)
		: methodHeader);
	return (((usqInt) header) >> 19) & 63;
}


/*	Do an incremental GC that tenures all surviving young objects to old
	space. 
 */

void
tenuringIncrementalGC(void)
{
	GIV(forceTenureFlag) = 1;
	incrementalGC();
}


/*	Returns the top of the remappable oop. Useful when writing loops. */

sqInt
topRemappableOop(void)
{   DECL_MAYBE_SQ_GLOBAL_STRUCT
	return GIV(remapBuffer)[GIV(remapBufferCount)];
}


/*	Record a process to be awoken on the next interpreter cycle. */
/*	Record a process to be awoken on the next interpreter cycle.
	Reimplement to record the source of the switch for debugging. */

static void
transferTofrom(sqInt newProc, sqInt sourceCode)
{   DECL_MAYBE_SQ_GLOBAL_STRUCT
    sqInt activeContext;
    sqInt index;
    sqInt newContext;
    sqInt object;
    sqInt oldProc;
    sqInt sched;
    char *sp;
    char *theFP;
    char *theFrame;
    StackPage *thePage;
    char *theSP;
    sqInt top;
    sqInt value;

	GIV(statProcessSwitch) += 1;
	/* begin push: */
	object = GIV(instructionPointer);
	longAtput(sp = GIV(stackPointer) - BytesPerWord, object);
	GIV(stackPointer) = sp;
	/* begin externalWriteBackHeadFramePointers */
	assert((GIV(framePointer) - GIV(stackPointer)) < LargeContextSize);
	assert(GIV(stackPage) == (mostRecentlyUsedPage()));
	/* begin setHeadFP:andSP:inPage: */
	assert(GIV(stackPointer) < GIV(framePointer));
	assert((GIV(stackPointer) < ((GIV(stackPage)->baseAddress)))
	 && (GIV(stackPointer) > (((GIV(stackPage)->realStackLimit)) - LargeContextSize)));
	assert((GIV(framePointer) < ((GIV(stackPage)->baseAddress)))
	 && (GIV(framePointer) > (((GIV(stackPage)->realStackLimit)) - (((sqInt) LargeContextSize >> 1)))));
	(GIV(stackPage)->headFP = GIV(framePointer));
	(GIV(stackPage)->headSP = GIV(stackPointer));
	assert(pageListIsWellFormed());
	sched = longAt(((longAt((GIV(specialObjectsOop) + BaseHeaderSize) + (SchedulerAssociation << ShiftForWord))) + BaseHeaderSize) + (ValueIndex << ShiftForWord));
	oldProc = longAt((sched + BaseHeaderSize) + (ActiveProcessIndex << ShiftForWord));
	/* begin ensureFrameIsMarried:SP: */
	VM_LABEL(19ensureFrameIsMarriedSP);
	theFP = GIV(framePointer);
	theSP = GIV(stackPointer);
	if (((((usqInt)(longAt(theFP + FoxMethod)))) < heapBase
		? ((longAt(theFP + FoxMethod)) & MFMethodFlagHasContextFlag) != 0
		: (byteAt((theFP + FoxIFrameFlags) + 2)) != 0)) {
		assert(isContext(frameContext(theFP)));
		activeContext = longAt(theFP + FoxThisContext);
		goto l1;
	}
	activeContext = marryFrameSP(theFP, theSP);
l1:	/* end ensureFrameIsMarried:SP: */;
	/* begin storePointer:ofObject:withValue: */
	if ((((usqInt) oldProc)) < (((usqInt) GIV(youngStart)))) {
		possibleRootStoreIntovalue(oldProc, activeContext);
	}
	longAtput((oldProc + BaseHeaderSize) + (SuspendedContextIndex << ShiftForWord), activeContext);
	/* begin storePointer:ofObject:withValue: */
	if ((((usqInt) sched)) < (((usqInt) GIV(youngStart)))) {
		possibleRootStoreIntovalue(sched, newProc);
	}
	longAtput((sched + BaseHeaderSize) + (ActiveProcessIndex << ShiftForWord), newProc);
	longAtput((newProc + BaseHeaderSize) + (MyListIndex << ShiftForWord), GIV(nilObj));
	/* begin externalSetStackPageAndPointersForSuspendedContextOfProcess: */
	VM_LABEL(0externalSetStackPageAndPointersForSuspendedContextOfProcess);
	newContext = longAt((newProc + BaseHeaderSize) + (SuspendedContextIndex << ShiftForWord));
	assert(isContext(newContext));
	if (((longAt((newContext + BaseHeaderSize) + (SenderIndex << ShiftForWord))) & 1)) {
		assert(checkIsStillMarriedContextcurrentFP(newContext, GIV(framePointer)));
	}
	longAtput((newProc + BaseHeaderSize) + (SuspendedContextIndex << ShiftForWord), GIV(nilObj));
	if ((((longAt((newContext + BaseHeaderSize) + (SenderIndex << ShiftForWord))) & 1))
	 && (!(isWidowedContext(newContext)))) {
		/* begin frameOfMarriedContext: */
		value = longAt((newContext + BaseHeaderSize) + (SenderIndex << ShiftForWord));
		/* begin withoutSmallIntegerTags: */
		assert((value & 1));
		theFrame = pointerForOop(value - 1);
		/* begin stackPageFor: */
		/* begin stackPageAt: */
		/* begin pageIndexFor: */
		assert((((((char *) theFrame)) >= (GIV(stackBasePlus1) - 1)) && ((((char *) theFrame)) <= (((char *) GIV(pages))))));
		index = pageIndexForstackBasePlus1bytesPerPage(theFrame, GIV(stackBasePlus1), GIV(bytesPerPage));
		thePage = stackPageAtpages(index, GIV(pages));
	}
	else {
		thePage = makeBaseFrameFor(newContext);
		theFrame = (thePage->baseFP);
	}
	assert(((thePage->headFP)) == theFrame);
	/* begin setStackPageAndLimit: */
	GIV(stackPage) = thePage;
	if (GIV(stackLimit) != (((char *) (((usqInt) -1))))) {
		GIV(stackLimit) = (GIV(stackPage)->stackLimit);
	}
	markStackPageMostRecentlyUsed(thePage);
	GIV(stackPointer) = (thePage->headSP);
	GIV(framePointer) = (thePage->headFP);
	if (!((((usqInt)(longAt(GIV(framePointer) + FoxMethod)))) < heapBase)) {
		/* begin setMethod: */
		assert((((usqInt)(longAt(GIV(framePointer) + FoxMethod)))) >= (startOfMemory()));
		GIV(method) = longAt(GIV(framePointer) + FoxMethod);
	}
	/* begin assertValidExecutionPointe:r:s: */
	assertValidExecutionPointersimbar(((usqInt)(longAt(GIV(stackPointer)))), GIV(framePointer), GIV(stackPointer), !((((usqInt)(longAt(GIV(framePointer) + FoxMethod)))) < heapBase));
	/* begin popStack */
	top = longAt(GIV(stackPointer));
	GIV(stackPointer) += BytesPerWord;
	GIV(instructionPointer) = ((sqInt) top);
	/* begin recordContextSwitchFrom: */
	if (recordEventTrace()) {
		/* begin recordTrace:thing:source: */
		GIV(traceLog)[GIV(traceLogIndex)] = TraceContextSwitch;
		GIV(traceLog)[GIV(traceLogIndex) + 1] = TraceContextSwitch;
		GIV(traceLog)[GIV(traceLogIndex) + 2] = sourceCode;
		GIV(traceLogIndex) = (GIV(traceLogIndex) + 3) % TraceBufferSize;
	}
}

sqInt
trueObject(void)
{
	return GIV(trueObj);
}


/*	update pointers in the given memory range */

static void
updatePointersInRangeFromto(sqInt memStart, sqInt memEnd)
{   DECL_MAYBE_SQ_GLOBAL_STRUCT
    sqInt classHeader;
    sqInt classOop;
    sqInt contextSize;
    sqInt fieldOffset;
    sqInt fieldOop;
    sqInt fmt;
    sqInt fwdBlock;
    sqInt fwdBlock1;
    sqInt fwdBlock11;
    sqInt fwdBlock2;
    sqInt fwdBlock3;
    sqInt fwdBlock4;
    sqInt header;
    sqInt header1;
    sqInt header11;
    sqInt header12;
    sqInt header13;
    sqInt header2;
    sqInt header21;
    sqInt header3;
    sqInt header4;
    sqInt header5;
    sqInt methodHeader;
    sqInt newClassHeader;
    sqInt newClassOop;
    sqInt newOop;
    sqInt oop;
    sqInt realHeader;
    sqInt size;
    sqInt sp;
    sqInt sz;
    sqInt sz1;
    sqInt targetObj;
    sqInt targetObj1;

	oop = memStart + (headerTypeBytes[(longAt(memStart)) & TypeMask]);
	while ((((usqInt) oop)) < (((usqInt) memEnd))) {
		if (!(((longAt(oop)) & TypeMask) == HeaderTypeFree)) {
			/* begin remapFieldsAndClassOf: */
			VM_LABEL(0remapFieldsAndClassOf);
			/* begin lastPointerWhileForwarding: */
			VM_LABEL(0lastPointerWhileForwarding);
			/* begin headerWhileForwardingOf: */
			header11 = longAt(oop);
			if ((header11 & MarkBit) != 0) {

				/* oop is forwarded; get its real header from its forwarding table entry */

				fwdBlock2 = (header11 & AllButMarkBitAndTypeMask) << 1;
				assert(fwdBlockValid(fwdBlock2));
				header11 = longAt(fwdBlock2 + BytesPerWord);
			}
			header3 = header11;
			fmt = (((usqInt) header3) >> 8) & 15;
			if (fmt <= 4) {
				if ((fmt == 3)
				 && (((((usqInt) header3) >> 12) & 31) == ClassMethodContextCompactIndex)) {
					/* begin nacFetchStackPointerOf: */
					sp = longAt((oop + BaseHeaderSize) + (StackPointerIndex << ShiftForWord));
					if (!((sp & 1))) {
						contextSize = 0;
						goto l4;
					}
					contextSize = (sp >> 1);
				l4:	/* end nacFetchStackPointerOf: */;
					assert((ReceiverIndex + contextSize) < (lengthOfbaseHeaderformat(oop, header3, fmt)));
					fieldOffset = (CtxtTempFrameStart + contextSize) * BytesPerWord;
					goto l2;
				}
				size = ((header3 & TypeMask) == HeaderTypeSizeAndClass
					? (longAt(oop - (BytesPerWord * 2))) & AllButTypeMask
					: header3 & SizeMask);
				fieldOffset = size - BaseHeaderSize;
				goto l2;
			}
			if (fmt < 12) {
				fieldOffset = 0;
				goto l2;
			}
			methodHeader = longAt(oop + BaseHeaderSize);
			if (isCogMethodReference(methodHeader)) {
				assert(((((CogMethod *) methodHeader)->cmType)) == CMMethod);
				methodHeader = (((CogMethod *) methodHeader)->methodHeader);
			}
			fieldOffset = (((((usqInt) methodHeader) >> 10) & 255) * BytesPerWord) + BaseHeaderSize;
		l2:	/* end lastPointerWhileForwarding: */;
			while (fieldOffset >= BaseHeaderSize) {
				fieldOop = longAt(oop + fieldOffset);
				if (((fieldOop & 1) == 0)
				 && (((longAt(fieldOop)) & MarkBit) != 0)) {
					/* begin remappedObj: */
					fwdBlock1 = ((longAt(fieldOop)) & AllButMarkBitAndTypeMask) << 1;
					assert(fwdBlockValid(fwdBlock1));
					targetObj = longAt(fwdBlock1);
					assert(addressCouldBeObjWhileForwarding(targetObj));
					newOop = targetObj;
					longAtput(oop + fieldOffset, newOop);
					if (((((usqInt) oop)) < (((usqInt) GIV(youngStart))))
					 && ((((usqInt) newOop)) >= (((usqInt) GIV(youngStart))))) {
						/* begin beRootWhileForwarding: */
						header5 = longAt(oop);
						if ((header5 & MarkBit) != 0) {

							/* This oop is forwarded */

							fwdBlock4 = (header5 & AllButMarkBitAndTypeMask) << 1;
							assert(fwdBlockValid(fwdBlock4));
							/* begin noteAsRoot:headerLoc: */
							header13 = longAt(fwdBlock4 + BytesPerWord);
							if ((header13 & RootBit) == 0) {
								if (GIV(rootTableCount) < RootTableSize) {

									/* record oop as root only if not already recorded */
									/* record root if there is enough room in the roots  table  */

									GIV(rootTableCount) += 1;
									GIV(rootTable)[GIV(rootTableCount)] = oop;
									longAtput(fwdBlock4 + BytesPerWord, header13 | RootBit);
									if (GIV(rootTableCount) > RootTableRedZone) {
										/* begin scheduleIncrementalGC */
										GIV(needGCFlag) = 1;
										forceInterruptCheck();
									}
								}
							}
						}
						else {
							/* begin noteAsRoot:headerLoc: */
							header2 = longAt(oop);
							if ((header2 & RootBit) == 0) {
								if (GIV(rootTableCount) < RootTableSize) {

									/* record oop as root only if not already recorded */
									/* record root if there is enough room in the roots  table  */

									GIV(rootTableCount) += 1;
									GIV(rootTable)[GIV(rootTableCount)] = oop;
									longAtput(oop, header2 | RootBit);
									if (GIV(rootTableCount) > RootTableRedZone) {
										/* begin scheduleIncrementalGC */
										GIV(needGCFlag) = 1;
										forceInterruptCheck();
									}
								}
							}
						}
					}
				}
				fieldOffset -= BytesPerWord;
			}
			/* begin remapClassOf: */
			VM_LABEL(0remapClassOf);
			if (((longAt(oop)) & TypeMask) == HeaderTypeShort) {
				goto l3;
			}
			classHeader = longAt(oop - BytesPerWord);
			classOop = classHeader & AllButTypeMask;
			if (((classOop & 1) == 0)
			 && (((longAt(classOop)) & MarkBit) != 0)) {
				/* begin remappedObj: */
				fwdBlock11 = ((longAt(classOop)) & AllButMarkBitAndTypeMask) << 1;
				assert(fwdBlockValid(fwdBlock11));
				targetObj1 = longAt(fwdBlock11);
				assert(addressCouldBeObjWhileForwarding(targetObj1));
				newClassOop = targetObj1;
				newClassHeader = newClassOop | (classHeader & TypeMask);
				longAtput(oop - BytesPerWord, newClassHeader);
				if (((((usqInt) oop)) < (((usqInt) GIV(youngStart))))
				 && ((((usqInt) newClassOop)) >= (((usqInt) GIV(youngStart))))) {
					/* begin beRootWhileForwarding: */
					header4 = longAt(oop);
					if ((header4 & MarkBit) != 0) {

						/* This oop is forwarded */

						fwdBlock3 = (header4 & AllButMarkBitAndTypeMask) << 1;
						assert(fwdBlockValid(fwdBlock3));
						/* begin noteAsRoot:headerLoc: */
						header12 = longAt(fwdBlock3 + BytesPerWord);
						if ((header12 & RootBit) == 0) {
							if (GIV(rootTableCount) < RootTableSize) {

								/* record oop as root only if not already recorded */
								/* record root if there is enough room in the roots  table  */

								GIV(rootTableCount) += 1;
								GIV(rootTable)[GIV(rootTableCount)] = oop;
								longAtput(fwdBlock3 + BytesPerWord, header12 | RootBit);
								if (GIV(rootTableCount) > RootTableRedZone) {
									/* begin scheduleIncrementalGC */
									GIV(needGCFlag) = 1;
									forceInterruptCheck();
								}
							}
						}
					}
					else {
						/* begin noteAsRoot:headerLoc: */
						header21 = longAt(oop);
						if ((header21 & RootBit) == 0) {
							if (GIV(rootTableCount) < RootTableSize) {

								/* record oop as root only if not already recorded */
								/* record root if there is enough room in the roots  table  */

								GIV(rootTableCount) += 1;
								GIV(rootTable)[GIV(rootTableCount)] = oop;
								longAtput(oop, header21 | RootBit);
								if (GIV(rootTableCount) > RootTableRedZone) {
									/* begin scheduleIncrementalGC */
									GIV(needGCFlag) = 1;
									forceInterruptCheck();
								}
							}
						}
					}
				}
			}
		l3:	/* end remapClassOf: */;
		}
		/* begin objectAfterWhileForwarding: */
		header = longAt(oop);
		if ((header & MarkBit) == 0) {
			/* begin objectAfter: */
			if (DoAssertionChecks) {
				if ((((usqInt) oop)) >= (((usqInt) GIV(endOfMemory)))) {
					error("no objects after the end of memory");
				}
			}
			if (((longAt(oop)) & TypeMask) == HeaderTypeFree) {
				sz1 = (longAt(oop)) & AllButTypeMask;
			}
			else {
				/* begin sizeBitsOf: */
				header1 = longAt(oop);
				sz1 = ((header1 & TypeMask) == HeaderTypeSizeAndClass
					? (longAt(oop - (BytesPerWord * 2))) & LongSizeMask
					: header1 & SizeMask);
			}
			oop = (oop + sz1) + (headerTypeBytes[(longAt(oop + sz1)) & TypeMask]);
			goto l1;
		}
		fwdBlock = (header & AllButMarkBitAndTypeMask) << 1;
		assert(fwdBlockValid(fwdBlock));

		/* following code is like sizeBitsOf: */

		realHeader = longAt(fwdBlock + BytesPerWord);
		if ((realHeader & TypeMask) == HeaderTypeSizeAndClass) {
			sz = (longAt(oop - (BytesPerWord * 2))) & LongSizeMask;
		}
		else {
			sz = realHeader & SizeMask;
		}
		oop = (oop + sz) + (headerTypeBytes[(longAt(oop + sz)) & TypeMask]);
	l1:	/* end objectAfterWhileForwarding: */;
	}
}


/*	update pointers in root objects */

static void
updatePointersInRootObjectsFromto(sqInt memStart, sqInt memEnd)
{   DECL_MAYBE_SQ_GLOBAL_STRUCT
    sqInt classHeader;
    sqInt classOop;
    sqInt contextSize;
    sqInt fieldOffset;
    sqInt fieldOop;
    sqInt fmt;
    sqInt fwdBlock;
    sqInt fwdBlock1;
    sqInt fwdBlock11;
    sqInt fwdBlock2;
    sqInt fwdBlock3;
    sqInt header;
    sqInt header1;
    sqInt header11;
    sqInt header12;
    sqInt header2;
    sqInt header21;
    sqInt header3;
    sqInt header4;
    sqInt i;
    sqInt methodHeader;
    sqInt newClassHeader;
    sqInt newClassOop;
    sqInt newOop;
    sqInt oop;
    sqInt size;
    sqInt sp;
    sqInt targetObj;
    sqInt targetObj1;

	for (i = 1; i <= GIV(rootTableCount); i += 1) {
		oop = GIV(rootTable)[i];
		if (((((usqInt) oop)) < (((usqInt) memStart)))
		 || ((((usqInt) oop)) >= (((usqInt) memEnd)))) {
			/* begin remapFieldsAndClassOf: */
			VM_LABEL(1remapFieldsAndClassOf);
			/* begin lastPointerWhileForwarding: */
			VM_LABEL(1lastPointerWhileForwarding);
			/* begin headerWhileForwardingOf: */
			header11 = longAt(oop);
			if ((header11 & MarkBit) != 0) {

				/* oop is forwarded; get its real header from its forwarding table entry */

				fwdBlock2 = (header11 & AllButMarkBitAndTypeMask) << 1;
				assert(fwdBlockValid(fwdBlock2));
				header11 = longAt(fwdBlock2 + BytesPerWord);
			}
			header3 = header11;
			fmt = (((usqInt) header3) >> 8) & 15;
			if (fmt <= 4) {
				if ((fmt == 3)
				 && (((((usqInt) header3) >> 12) & 31) == ClassMethodContextCompactIndex)) {
					/* begin nacFetchStackPointerOf: */
					sp = longAt((oop + BaseHeaderSize) + (StackPointerIndex << ShiftForWord));
					if (!((sp & 1))) {
						contextSize = 0;
						goto l1;
					}
					contextSize = (sp >> 1);
				l1:	/* end nacFetchStackPointerOf: */;
					assert((ReceiverIndex + contextSize) < (lengthOfbaseHeaderformat(oop, header3, fmt)));
					fieldOffset = (CtxtTempFrameStart + contextSize) * BytesPerWord;
					goto l2;
				}
				size = ((header3 & TypeMask) == HeaderTypeSizeAndClass
					? (longAt(oop - (BytesPerWord * 2))) & AllButTypeMask
					: header3 & SizeMask);
				fieldOffset = size - BaseHeaderSize;
				goto l2;
			}
			if (fmt < 12) {
				fieldOffset = 0;
				goto l2;
			}
			methodHeader = longAt(oop + BaseHeaderSize);
			if (isCogMethodReference(methodHeader)) {
				assert(((((CogMethod *) methodHeader)->cmType)) == CMMethod);
				methodHeader = (((CogMethod *) methodHeader)->methodHeader);
			}
			fieldOffset = (((((usqInt) methodHeader) >> 10) & 255) * BytesPerWord) + BaseHeaderSize;
		l2:	/* end lastPointerWhileForwarding: */;
			while (fieldOffset >= BaseHeaderSize) {
				fieldOop = longAt(oop + fieldOffset);
				if (((fieldOop & 1) == 0)
				 && (((longAt(fieldOop)) & MarkBit) != 0)) {
					/* begin remappedObj: */
					fwdBlock1 = ((longAt(fieldOop)) & AllButMarkBitAndTypeMask) << 1;
					assert(fwdBlockValid(fwdBlock1));
					targetObj = longAt(fwdBlock1);
					assert(addressCouldBeObjWhileForwarding(targetObj));
					newOop = targetObj;
					longAtput(oop + fieldOffset, newOop);
					if (((((usqInt) oop)) < (((usqInt) GIV(youngStart))))
					 && ((((usqInt) newOop)) >= (((usqInt) GIV(youngStart))))) {
						/* begin beRootWhileForwarding: */
						header = longAt(oop);
						if ((header & MarkBit) != 0) {

							/* This oop is forwarded */

							fwdBlock = (header & AllButMarkBitAndTypeMask) << 1;
							assert(fwdBlockValid(fwdBlock));
							/* begin noteAsRoot:headerLoc: */
							header1 = longAt(fwdBlock + BytesPerWord);
							if ((header1 & RootBit) == 0) {
								if (GIV(rootTableCount) < RootTableSize) {

									/* record oop as root only if not already recorded */
									/* record root if there is enough room in the roots  table  */

									GIV(rootTableCount) += 1;
									GIV(rootTable)[GIV(rootTableCount)] = oop;
									longAtput(fwdBlock + BytesPerWord, header1 | RootBit);
									if (GIV(rootTableCount) > RootTableRedZone) {
										/* begin scheduleIncrementalGC */
										GIV(needGCFlag) = 1;
										forceInterruptCheck();
									}
								}
							}
						}
						else {
							/* begin noteAsRoot:headerLoc: */
							header2 = longAt(oop);
							if ((header2 & RootBit) == 0) {
								if (GIV(rootTableCount) < RootTableSize) {

									/* record oop as root only if not already recorded */
									/* record root if there is enough room in the roots  table  */

									GIV(rootTableCount) += 1;
									GIV(rootTable)[GIV(rootTableCount)] = oop;
									longAtput(oop, header2 | RootBit);
									if (GIV(rootTableCount) > RootTableRedZone) {
										/* begin scheduleIncrementalGC */
										GIV(needGCFlag) = 1;
										forceInterruptCheck();
									}
								}
							}
						}
					}
				}
				fieldOffset -= BytesPerWord;
			}
			/* begin remapClassOf: */
			VM_LABEL(1remapClassOf);
			if (((longAt(oop)) & TypeMask) == HeaderTypeShort) {
				goto l3;
			}
			classHeader = longAt(oop - BytesPerWord);
			classOop = classHeader & AllButTypeMask;
			if (((classOop & 1) == 0)
			 && (((longAt(classOop)) & MarkBit) != 0)) {
				/* begin remappedObj: */
				fwdBlock11 = ((longAt(classOop)) & AllButMarkBitAndTypeMask) << 1;
				assert(fwdBlockValid(fwdBlock11));
				targetObj1 = longAt(fwdBlock11);
				assert(addressCouldBeObjWhileForwarding(targetObj1));
				newClassOop = targetObj1;
				newClassHeader = newClassOop | (classHeader & TypeMask);
				longAtput(oop - BytesPerWord, newClassHeader);
				if (((((usqInt) oop)) < (((usqInt) GIV(youngStart))))
				 && ((((usqInt) newClassOop)) >= (((usqInt) GIV(youngStart))))) {
					/* begin beRootWhileForwarding: */
					header4 = longAt(oop);
					if ((header4 & MarkBit) != 0) {

						/* This oop is forwarded */

						fwdBlock3 = (header4 & AllButMarkBitAndTypeMask) << 1;
						assert(fwdBlockValid(fwdBlock3));
						/* begin noteAsRoot:headerLoc: */
						header12 = longAt(fwdBlock3 + BytesPerWord);
						if ((header12 & RootBit) == 0) {
							if (GIV(rootTableCount) < RootTableSize) {

								/* record oop as root only if not already recorded */
								/* record root if there is enough room in the roots  table  */

								GIV(rootTableCount) += 1;
								GIV(rootTable)[GIV(rootTableCount)] = oop;
								longAtput(fwdBlock3 + BytesPerWord, header12 | RootBit);
								if (GIV(rootTableCount) > RootTableRedZone) {
									/* begin scheduleIncrementalGC */
									GIV(needGCFlag) = 1;
									forceInterruptCheck();
								}
							}
						}
					}
					else {
						/* begin noteAsRoot:headerLoc: */
						header21 = longAt(oop);
						if ((header21 & RootBit) == 0) {
							if (GIV(rootTableCount) < RootTableSize) {

								/* record oop as root only if not already recorded */
								/* record root if there is enough room in the roots  table  */

								GIV(rootTableCount) += 1;
								GIV(rootTable)[GIV(rootTableCount)] = oop;
								longAtput(oop, header21 | RootBit);
								if (GIV(rootTableCount) > RootTableRedZone) {
									/* begin scheduleIncrementalGC */
									GIV(needGCFlag) = 1;
									forceInterruptCheck();
								}
							}
						}
					}
				}
			}
		l3:	/* end remapClassOf: */;
		}
	}
}

void
updateStackZoneReferencesToCompiledCodePreCompaction(void)
{   DECL_MAYBE_SQ_GLOBAL_STRUCT
    char *callerFP;
    sqInt i;
    sqInt theFlags;
    char *theFP;
    usqInt theIP;
    char *theIPPtr;
    CogMethod *theMethod;
    sqInt theMethodField;
    StackPage *thePage;

	for (i = 0; i <= (GIV(numStackPages) - 1); i += 1) {
		/* begin stackPageAt: */
		thePage = stackPageAtpages(i, GIV(pages));
		if (!(isFree(thePage))) {
			theIPPtr = (thePage->headSP);
			theFP = (thePage->headFP);
					while (1) {
				if ((((usqInt)(longAt(theFP + FoxMethod)))) < heapBase) {
					theMethodField = longAt(theFP + FoxMethod);
					theFlags = theMethodField & MFMethodFlagsMask;
					theMethod = ((CogMethod *) (theMethodField - theFlags));
					if (((theMethod->cmType)) == CMBlock) {
						theMethod = cmHomeMethod(((CogBlockMethod *) (theMethodField - theFlags)));
					}
					theIP = ((usqInt)(longAt(theIPPtr)));
					if ((theIP != (ceCannotResumePC()))
					 && (asserta((theIP >= (((usqInt)theMethod)))
 && (theIP < ((((usqInt)theMethod)) + ((theMethod->blockSize))))))) {
						longAtput(theIPPtr, theIP + (((sqInt) ((theMethod->objectHeader)))));
					}
					longAtput(theFP + FoxMethod, theMethodField + (((sqInt) ((theMethod->objectHeader)))));
				}
				if (!(((callerFP = frameCallerFP(theFP))) != 0)) break;
				theIPPtr = theFP + FoxCallerSavedIP;
				theFP = callerFP;
			}
		}
	}
}


/*	Update the frame's spouse context with the frame's current state except
	for the
	sender and instruction pointer, which are used to mark the context as
	married. 
 */

static void
updateStateOfSpouseContextForFrameWithSP(char *theFP, char *theSP)
{
    char *pointer;
    sqInt tempIndex;
    sqInt theContext;

	assert(frameHasContext(theFP));
	theContext = longAt(theFP + FoxThisContext);
	assert(isContext(theContext));
	assert((frameReceiver(theFP)) == (fetchPointerofObject(ReceiverIndex, theContext)));
	if ((((usqInt)(longAt(theFP + FoxMethod)))) < heapBase) {
		tempIndex = (mframeCogMethod(theFP)->cmNumArgs);
		pointer = (theFP + FoxMFReceiver) - BytesPerWord;
	}
	else {
		tempIndex = byteAt((theFP + FoxIFrameFlags) + 1);
		pointer = (theFP + FoxIFReceiver) - BytesPerWord;
	}
	while (pointer >= theSP) {
		assert(addressCouldBeOop(longAt(pointer)));
		tempIndex += 1;
		/* begin storePointer:ofObject:withValue: */
		if ((((usqInt) theContext)) < (((usqInt) GIV(youngStart)))) {
			possibleRootStoreIntovalue(theContext, longAt(pointer));
		}
		longAtput((theContext + BaseHeaderSize) + ((ReceiverIndex + tempIndex) << ShiftForWord), longAt(pointer));
		pointer -= BytesPerWord;
	}
	assert((ReceiverIndex + tempIndex) < (lengthOf(theContext)));
	longAtput((theContext + BaseHeaderSize) + (StackPointerIndex << ShiftForWord), ((tempIndex << 1) | 1));
}

static sqInt
validInstructionPointerinFrame(usqInt anInstrPointer, char *fp)
{
	return validInstructionPointerinMethodframePointer(anInstrPointer, ((((usqInt)(longAt(fp + FoxMethod)))) < heapBase
		? (mframeHomeMethod(fp)->methodObject)
		: longAt(fp + FoxMethod)), fp);
}

sqInt
validInstructionPointerinMethodframePointer(usqInt anInstrPointer, usqInt aMethod, char *fp)
{
    CogMethod *cogMethod;
    sqInt header;
    usqInt theInstrPointer;

	if (anInstrPointer == (ceCannotResumePC())) {
		return (((usqInt)(longAt(fp + FoxMethod)))) < heapBase;
	}
	if (anInstrPointer == (ceReturnToInterpreterPC())) {
		if ((((usqInt)(longAt(fp + FoxMethod)))) < heapBase) {
			return 0;
		}
		theInstrPointer = longAt(fp + FoxIFSavedIP);
	}
	else {
		theInstrPointer = anInstrPointer;
		header = longAt((aMethod + BaseHeaderSize) + (HeaderIndex << ShiftForWord));
		if ((isCogMethodReference(header))
		 && (theInstrPointer < heapBase)) {
			cogMethod = ((CogMethod *) header);
			return (theInstrPointer >= (header + (sizeof(CogMethod))))
			 && (theInstrPointer < (header + ((cogMethod->blockSize))));
		}
	}
	return (theInstrPointer >= (((aMethod + (lastPointerOf(aMethod))) + BytesPerWord) - 1))
	 && (theInstrPointer < ((aMethod + (byteLengthOf(aMethod))) + BaseHeaderSize));
}


/*	Check that the base frames in all in-use stack pages have a sender and a
	saved context.
 */

static sqInt
validStackPageBaseFrames(void)
{   DECL_MAYBE_SQ_GLOBAL_STRUCT
    StackPage *aPage;
    sqInt i;
    sqInt savedThisContext;
    sqInt senderContextOrNil;

	for (i = 0; i <= (GIV(numStackPages) - 1); i += 1) {
		/* begin stackPageAt: */
		aPage = stackPageAtpages(i, GIV(pages));
		if (!(isFree(aPage))) {
			senderContextOrNil = longAt((aPage->baseAddress));
			savedThisContext = longAt(((aPage->baseAddress)) - BytesPerWord);
			if (!(asserta(((((aPage->baseFP)) + (frameStackedReceiverOffset((aPage->baseFP)))) + (2 * BytesPerWord)) == ((aPage->baseAddress))))) {
				return 0;
			}
			if (!(asserta(((senderContextOrNil & 3) == 0)
				 && (((((usqInt)senderContextOrNil)) >= heapBase)
 && (((((usqInt)senderContextOrNil)) < GIV(freeStart))
 && (((longAt(senderContextOrNil)) & TypeMask) != HeaderTypeGC)))))) {
				return 0;
			}
			if (!(asserta(((savedThisContext & 3) == 0)
				 && (((((usqInt)savedThisContext)) >= heapBase)
 && (((((usqInt)savedThisContext)) < GIV(freeStart))
 && (((longAt(savedThisContext)) & TypeMask) != HeaderTypeGC)))))) {
				return 0;
			}
			if (!(asserta((senderContextOrNil == GIV(nilObj))
				 || (((senderContextOrNil & 1) == 0)
 && (((((usqInt) (longAt(senderContextOrNil))) >> 12) & 31) == ClassMethodContextCompactIndex))))) {
				return 0;
			}
			if (!(asserta(((savedThisContext & 1) == 0)
				 && (((((usqInt) (longAt(savedThisContext))) >> 12) & 31) == ClassMethodContextCompactIndex)))) {
				return 0;
			}
			if (!(asserta((frameCallerContext((aPage->baseFP))) == senderContextOrNil))) {
				return 0;
			}
			if (!(asserta((frameContext((aPage->baseFP))) == savedThisContext))) {
				return 0;
			}
		}
	}
	return 1;
}

static void
verifyCleanHeaders(void)
{   DECL_MAYBE_SQ_GLOBAL_STRUCT
    sqInt header;
    sqInt oop;
    sqInt sz;

	oop = heapBase + (headerTypeBytes[(longAt(heapBase)) & TypeMask]);
	while ((((usqInt) oop)) < (((usqInt) GIV(freeStart)))) {
		if (((longAt(oop)) & TypeMask) == HeaderTypeFree) {
			if (!((objectAfter(oop)) == GIV(endOfMemory))) {
				error("Invalid obj with HeaderTypeBits = Free.");
			}
		}
		else {
			if (((longAt(oop)) & MarkBit) != 0) {
				error("Invalid obj with MarkBit set.");
			}
		}
		/* begin objectAfter: */
		if (DoAssertionChecks) {
			if ((((usqInt) oop)) >= (((usqInt) GIV(endOfMemory)))) {
				error("no objects after the end of memory");
			}
		}
		if (((longAt(oop)) & TypeMask) == HeaderTypeFree) {
			sz = (longAt(oop)) & AllButTypeMask;
		}
		else {
			/* begin sizeBitsOf: */
			header = longAt(oop);
			sz = ((header & TypeMask) == HeaderTypeSizeAndClass
				? (longAt(oop - (BytesPerWord * 2))) & LongSizeMask
				: header & SizeMask);
		}
		oop = (oop + sz) + (headerTypeBytes[(longAt(oop + sz)) & TypeMask]);
	}
}


/*	return 0 for little endian, 1 for big endian */
/*	?!*#$%! _Terrible_ name. Call it what it is.
	VMBIGENDIAN or VMLITTLEENDIAN. Dont leave us guessing!!!!
	Alas this has to remain for backward compatibility. */

sqInt
vmEndianness(void)
{
	return (VMBIGENDIAN
		? 1
		: 0);
}


/*	Void the state associated with the long-running primitive check.
	This is done when a new semaphore is installed or when it appears
	that is longRunningPrimitiveCheckMethod is invalid, e.g. because it
	has eben sampled in the middle of a GC. */

static void
voidLongRunningPrimitive(char *reason)
{   DECL_MAYBE_SQ_GLOBAL_STRUCT
	GIV(longRunningPrimitiveCheckMethod) = null;
	GIV(longRunningPrimitiveCheckSequenceNumber) == 0;
	GIV(longRunningPrimitiveStartUsecs) = GIV(longRunningPrimitiveStopUsecs) = 0;
	GIV(longRunningPrimitiveSignalUndelivered) = 1;
	sqLowLevelMFence();
}


/*	Return the highest priority process that is ready to run.
	To save time looking at many empty lists before finding a
	runnable process the VM maintains a variable holding the
	highest priority runnable process. If this variable is 0 then the
	VM does not know the highest priority and must search all lists.
	Note: It is a fatal VM error if there is no runnable process. */

static sqInt
wakeHighestPriority(void)
{   DECL_MAYBE_SQ_GLOBAL_STRUCT
    sqInt header;
    sqInt p;
    sqInt processList;
    sqInt schedLists;
    sqInt sz;

	schedLists = longAt(((longAt(((longAt((GIV(specialObjectsOop) + BaseHeaderSize) + (SchedulerAssociation << ShiftForWord))) + BaseHeaderSize) + (ValueIndex << ShiftForWord))) + BaseHeaderSize) + (ProcessListsIndex << ShiftForWord));
	p = (GIV(highestRunnableProcessPriority) == 0
		? /* begin fetchWordLengthOf: *//* begin sizeBitsOf: */header = longAt(schedLists),sz = ((header & TypeMask) == HeaderTypeSizeAndClass
	? (longAt(schedLists - (BytesPerWord * 2))) & LongSizeMask
	: header & SizeMask),((usqInt) (sz - BaseHeaderSize)) >> ShiftForWord
		: GIV(highestRunnableProcessPriority));

	/* index of last indexable field */

	p -= 1;
	while (1) {
		processList = longAt((schedLists + BaseHeaderSize) + (p << ShiftForWord));
		if (!((longAt((processList + BaseHeaderSize) + (FirstLinkIndex << ShiftForWord))) == GIV(nilObj))) break;
		if (((p -= 1)) < 0) {
			error("scheduler could not find a runnable process");
		}
	}
	GIV(highestRunnableProcessPriority) = p + 1;
	return removeFirstLinkOfList(processList);
}

static sqInt
withSmallIntegerTags(char *value)
{
	assert(((oopForPointer(value)) & (BytesPerWord - 1)) == 0);
	return (oopForPointer(value)) + 1;
}


/*	Return the given 64-bit integer with its halves in the reverse order. */

static sqInt
wordSwapped(sqInt w)
{
	if (!(BytesPerWord == 8)) {
		error("This cannot happen.");
	}
	return ((((usqInt) w << 0)) & Bytes3to0Mask) + ((((usqInt) w << 0)) & Bytes7to4Mask);
}

static void
writeImageFileIO(sqInt imageBytes)
{   DECL_MAYBE_SQ_GLOBAL_STRUCT
    sqInt bytesWritten;
    sqImageFile f;
    sqInt headerSize;
    squeakFileOffsetType  headerStart;
    sqInt i;
    sqInt memStart;
    sqInt okToWrite;
    void *sCWIfn;


	/* If the security plugin can be loaded, use it to check for write permission.
	If not, assume it's ok */

	sCWIfn = ioLoadFunctionFrom("secCanWriteImage", "SecurityPlugin");
	if (sCWIfn != 0) {
		okToWrite = ((sqInt (*)(void))sCWIfn)();
		if (!(okToWrite)) {
			/* begin primitiveFail */
			if (GIV(primFailCode) == 0) {
				GIV(primFailCode) = 1;
			}
			return;
		}
	}
	headerStart = 0;

	/* header size in bytes; do not change! */

	headerSize = 64;
	f = sqImageFileOpen(imageName, "wb");
	if (f == null) {
		/* begin primitiveFail */
		if (GIV(primFailCode) == 0) {
			GIV(primFailCode) = 1;
		}
		return;
	}
	headerStart = sqImageFileStartLocation(f,imageName,headerSize+imageBytes);
	/* Note: on Unix systems one could put an exec command here, padded to 512 bytes */;
	sqImageFileSeek(f, headerStart);
	putLongtoFile((BytesPerWord == 4
		? 6505
		: 68003), f);
	putLongtoFile(headerSize, f);
	putLongtoFile(imageBytes, f);
	putLongtoFile(heapBase, f);
	putLongtoFile(GIV(specialObjectsOop), f);
	putLongtoFile(((usqInt) GIV(freeStart)) >> BytesPerWord, f);
	putLongtoFile(ioScreenSize(), f);
	putLongtoFile((((((GIV(fullScreenFlag) + ((VMBIGENDIAN
	? 0
	: 2))) + ((GIV(processHasThreadId)
	? 4
	: 0))) + ((GIV(flagInterpretedMethods)
	? 8
	: 0))) + ((GIV(preemptionYields)
	? 0
	: 16))) + ((GIV(noThreadingOfGUIThread)
	? 32
	: 0))) + (GIV(imageHeaderFlags) & (~63)), f);
	putLongtoFile(extraVMMemory, f);
	putShorttoFile(desiredNumStackPages, f);
	putShorttoFile(((sqInt) (desiredCogCodeSize + 1023) >> 10), f);
	putLongtoFile(desiredEdenBytes, f);
	putShorttoFile((GIV(maxExtSemTabSizeSet)
		? ioGetMaxExtSemTableSize()
		: 0), f);
	putShorttoFile(0, f);
	for (i = 1; i <= 4; i += 1) {
		putLongtoFile(0, f);
	}
	if (!(GIV(primFailCode) == 0)) {
		sqImageFileClose(f);
		return;
	}
	sqImageFileSeek(f, headerStart + headerSize);
	memStart = heapBase;
	bytesWritten = sqImageFileWrite(pointerForOop(memStart), sizeof(unsigned char), imageBytes, f);
	/* begin success: */
	if (!(bytesWritten == imageBytes)) {
		if (GIV(primFailCode) == 0) {

			/* Don't overwrite an error code that has already been set. */

			GIV(primFailCode) = 1;
		}
	}
	;
	sqImageFileClose(f);
}

static void
writeImageFile(sqInt imageBytes)
{
    void *fn;

	writeImageFileIO(imageBytes);
	fn = ioLoadFunctionFrom("setMacFileTypeAndCreator", "FilePlugin");
	if (!(fn == 0)) {
		((sqInt (*)(char*, char*, char*))fn)(imageName, "STim", "FAST");
	}
}

usqInt
youngStartAddress(void)
{
	return ((usqInt)((&GIV(youngStart))));
}


void* vm_exports[][3] = {
	{"", "addGCRoot", (void*)addGCRoot},
	{"", "callbackEnter", (void*)callbackEnter},
	{"", "callbackLeave", (void*)callbackLeave},
	{"", "dumpImage", (void*)dumpImage},
	{"", "moduleUnloaded", (void*)moduleUnloaded},
	{"", "primitiveAddLargeIntegers", (void*)primitiveAddLargeIntegers},
	{"", "primitiveBitAndLargeIntegers", (void*)primitiveBitAndLargeIntegers},
	{"", "primitiveBitOrLargeIntegers", (void*)primitiveBitOrLargeIntegers},
	{"", "primitiveBitShiftLargeIntegers", (void*)primitiveBitShiftLargeIntegers},
	{"", "primitiveBitXorLargeIntegers", (void*)primitiveBitXorLargeIntegers},
	{"", "primitiveClockLogAddresses", (void*)primitiveClockLogAddresses},
	{"", "primitiveCompareBytes", (void*)primitiveCompareBytes},
	{"", "primitiveCrashVM", (void*)primitiveCrashVM},
	{"", "primitiveDisablePowerManager", (void*)primitiveDisablePowerManager},
	{"", "primitiveDivideLargeIntegers", (void*)primitiveDivideLargeIntegers},
	{"", "primitiveDivLargeIntegers", (void*)primitiveDivLargeIntegers},
	{"", "primitiveEqualLargeIntegers", (void*)primitiveEqualLargeIntegers},
	{"", "primitiveEventProcessingControl", (void*)primitiveEventProcessingControl},
	{"", "primitiveForceTenure", (void*)primitiveForceTenure},
	{"", "primitiveGetLogDirectory", (void*)primitiveGetLogDirectory},
	{"", "primitiveGetWindowLabel", (void*)primitiveGetWindowLabel},
	{"", "primitiveGetWindowSize", (void*)primitiveGetWindowSize},
	{"", "primitiveGreaterOrEqualLargeIntegers", (void*)primitiveGreaterOrEqualLargeIntegers},
	{"", "primitiveGreaterThanLargeIntegers", (void*)primitiveGreaterThanLargeIntegers},
	{"", "primitiveHeartbeatFrequency", (void*)primitiveHeartbeatFrequency},
	{"", "primitiveHighResClock", (void*)primitiveHighResClock},
	{"", "primitiveInterruptChecksPerMSec", (void*)primitiveInterruptChecksPerMSec},
	{"", "primitiveIsRoot", (void*)primitiveIsRoot},
	{"", "primitiveIsWindowObscured", (void*)primitiveIsWindowObscured},
	{"", "primitiveIsYoung", (void*)primitiveIsYoung},
	{"", "primitiveLessOrEqualLargeIntegers", (void*)primitiveLessOrEqualLargeIntegers},
	{"", "primitiveLessThanLargeIntegers", (void*)primitiveLessThanLargeIntegers},
	{"", "primitiveLongRunningPrimitive", (void*)primitiveLongRunningPrimitive},
	{"", "primitiveLongRunningPrimitiveSemaphore", (void*)primitiveLongRunningPrimitiveSemaphore},
	{"", "primitiveModLargeIntegers", (void*)primitiveModLargeIntegers},
	{"", "primitiveMultiplyLargeIntegers", (void*)primitiveMultiplyLargeIntegers},
	{"", "primitiveNotEqualLargeIntegers", (void*)primitiveNotEqualLargeIntegers},
	{"", "primitiveOriginalMillisecondClock", (void*)primitiveOriginalMillisecondClock},
	{"", "primitiveProfilePrimitive", (void*)primitiveProfilePrimitive},
	{"", "primitiveProfileSample", (void*)primitiveProfileSample},
	{"", "primitiveProfileSemaphore", (void*)primitiveProfileSemaphore},
	{"", "primitiveProfileStart", (void*)primitiveProfileStart},
	{"", "primitiveQuoLargeIntegers", (void*)primitiveQuoLargeIntegers},
	{"", "primitiveRootTable", (void*)primitiveRootTable},
	{"", "primitiveRootTableAt", (void*)primitiveRootTableAt},
	{"", "primitiveScreenDepth", (void*)primitiveScreenDepth},
	{"", "primitiveSetGCBiasToGrow", (void*)primitiveSetGCBiasToGrow},
	{"", "primitiveSetGCBiasToGrowGCLimit", (void*)primitiveSetGCBiasToGrowGCLimit},
	{"", "primitiveSetGCSemaphore", (void*)primitiveSetGCSemaphore},
	{"", "primitiveSetLogDirectory", (void*)primitiveSetLogDirectory},
	{"", "primitiveSetWindowLabel", (void*)primitiveSetWindowLabel},
	{"", "primitiveSetWindowSize", (void*)primitiveSetWindowSize},
	{"", "primitiveSubtractLargeIntegers", (void*)primitiveSubtractLargeIntegers},
	{"", "primitiveVoidReceiver", (void*)primitiveVoidReceiver},
	{"", "reestablishContextPriorToCallback", (void*)reestablishContextPriorToCallback},
	{"", "removeGCRoot", (void*)removeGCRoot},
	{"", "returnAsThroughCallbackContext", (void*)returnAsThroughCallbackContext},
	{"", "sendInvokeCallbackContext", (void*)sendInvokeCallbackContext},
	{"", "sendInvokeCallbackStackRegistersJmpbuf", (void*)sendInvokeCallbackStackRegistersJmpbuf},
	{"", "setInterruptCheckChain", (void*)setInterruptCheckChain},
	{NULL, NULL, NULL}
};
