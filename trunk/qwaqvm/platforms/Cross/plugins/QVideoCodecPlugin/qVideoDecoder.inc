/**
 * Project OpenQwaq
 *
 * Copyright (c) 2005-2011, Teleplace, Inc., All Rights Reserved
 *
 * Redistributions in source code form must reproduce the above
 * copyright and this condition.
 *
 * The contents of this file are subject to the GNU General Public
 * License, Version 2 (the "License"); you may not use this file
 * except in compliance with the License. A copy of the License is
 * available at http://www.opensource.org/licenses/gpl-2.0.php.
 *
 */

/*
 * qVideoDecoder.inc
 * QVideoCodecPlugin
 *
 * Defines functions that are reused by "sub-plugins" of
 * (i.e. generated by subclasses of) QVideoCodecPlugin.  
 * Declares API-specific functions that must be implemented
 * in the sub-plugin.
 */

#include "qVideoCommon.h"
#include "qReadback.h"

#include "sqVirtualMachine.h"
extern struct VirtualMachine *interpreterProxy;

#define MAX_DECODERS 200
static QDecoder* decoders[MAX_DECODERS];

/******************** Private function declarations ********************/

/*	qFindUnusedDecoder:	Find an unused decoder slot.
	Arguments: none
	Return value: index of unused decoder, or -1 if none could be found.
*/ 
int qFindUnusedDecoderIndex();


/************* API-specific public function declarations ***************/
/*	The purposes of these functions are the same as the similarly-named,
	non-API-specific functions in qVideoDecoder.h, as are the return values.
	Only exceptions (compared with qVideoDecoder.h) will be documented.
	These functions are only declared here; they must be defined in API-
	specific "sub-plugins". */

/*	qCreateDecoderAPI: API-specific part of qCreateDecoder()
	Arguments: same as qCreateDecoder(), plus:
		dptr: slot to stash the created QDecoder
	Return value: 
		0 for success.  Same error codes as qCreateDecoder()
	Notes:
		On failure, must not store anything in 'dptr'.
*/
int qCreateDecoderAPI(QDecoder **dptr, char *args, int argsSize, int semaIndex, int width, int height);
void qDestroyDecoderAPI(QDecoder *decoder);
int qDecodeAPI(QDecoder *decoder, char* bytes, int byteSize);


/******************** Public function definitions **********************/

void qInitDecoderStorage(void)
{
	memset(decoders, 0, MAX_DECODERS*sizeof(QDecoder*));
}

int qCreateDecoder(char *args, int argsSize, int semaIndex, int width, int height)
{
	int index = qFindUnusedDecoderIndex();
	int err;
	if (index == -1) {
		qerr << endl << "qCreateDecoder: no available decoder slot";
		return -4; 
	}
	err = qCreateDecoderAPI(&decoders[index], args, argsSize, semaIndex, width, height);
	qerr.flush();
	if (err) return err;
	else {
		decoders[index]->decoderIndex = index;
		return index;
	}
}

void qDestroyDecoder(int decoderIndex)
{
	if (!qDecoderIsValid(decoderIndex)) return;
	qDestroyDecoderAPI(decoders[decoderIndex]);
	qerr.flush();
	decoders[decoderIndex] = NULL;
}

void qDestroyAllDecoders(void)
{
	int i;
	for(i=0; i<MAX_DECODERS; i++) {
		if (decoders[i] != NULL) qDestroyDecoder(i);
	}
}

int qDecoderIsValid(int decoderIndex)
{
	if (decoderIndex < 0 || decoderIndex >= MAX_DECODERS) return 0;
	return decoders[decoderIndex] != NULL;
}

int qDecode(int decoderIndex, char* bytes, int byteSize, int offset)
{
	int result;
	if (!qDecoderIsValid(decoderIndex)) return -1;
	decoders[decoderIndex]->inFrameCount++;
	result = qDecodeAPI(decoders[decoderIndex], bytes+offset, byteSize);
	qerr.flush();
	return result;
}

int qDecoderRead(int decoderIndex, char* frameBuffer, int bufferSize, char* metadata, int metadataSize)
{
	if (!qDecoderIsValid(decoderIndex)) return -1;
	QDecoder* decoder = decoders[decoderIndex];
	BufferPtr output = decoder->queue.next();
	size_t outputFrameSize = output->getUsedSize() - sizeof(QDecodedFrameMetadata);
	if (outputFrameSize > bufferSize) {
		// There is not enough space to copy the output data into.
		qerr << endl << "qDecoderRead: insufficient frame-buffer space (" << outputFrameSize << " required, " << bufferSize << " available)";
		return -2;
	}
	if (outputFrameSize == 0) {
		// Nothing to do
		return 0;
	}
	
	decoder->outFrameCount++;

	if (metadata != 0) {
		if (metadataSize != sizeof(QDecodedFrameMetadata)) {
			qerr << endl << "qDecoderRead: metadata-size mismatch (expected: " << sizeof(QDecodedFrameMetadata) << "  received: " << metadataSize << ")";
			decoder->outFrameCount--;  // to be consistent with all the other cases where no frame was read
			return -3;
		}
		output->copyTo(metadataSize, (unsigned char*)metadata);
	}
	output->copyFromOffsetTo(sizeof(QDecodedFrameMetadata), outputFrameSize, (unsigned char*)frameBuffer);
	return outputFrameSize;
}


/******************** Private function definitions *********************/

int qFindUnusedDecoderIndex()
{
	int i;
	for (i = 0; i < MAX_DECODERS; i++) {
		if (decoders[i] == NULL) return i;
	}
	return -1;
}
