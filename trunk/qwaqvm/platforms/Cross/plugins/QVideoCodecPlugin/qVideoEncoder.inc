/**
 * Project OpenQwaq
 *
 * Copyright (c) 2005-20011, Teleplace, Inc., All Rights Reserved
 *
 * Redistributions in source code form must reproduce the above
 * copyright and this condition.
 *
 * The contents of this file are subject to the GNU General Public
 * License, Version 2 (the "License"); you may not use this file
 * except in compliance with the License. A copy of the License is
 * available at http://www.opensource.org/licenses/gpl-2.0.php.
 *
 */

/*
 * qVideoEncoder.inc
 * QVideoCodecPlugin
 *
 * Defines functions that are reused by "sub-plugins" of
 * (i.e. generated by subclasses of) QVideoCodecPlugin.  
 * Declares API-specific functions that must be implemented
 * in the sub-plugin.
 */

#include "qVideoCommon.h"
#include "qReadback.h"

#include "sqVirtualMachine.h"
extern struct VirtualMachine *interpreterProxy;

#define MAX_ENCODERS 50
static QEncoder* encoders[MAX_ENCODERS];


/******************** Private function declarations ********************/
					
/*	qFindUnusedEncoder:	Find an unused encoder slot.
	Arguments: none
	Return value: index of unused encoder, or -1 if none could be found.
*/ 
int qFindUnusedEncoderIndex(); 


/************* API-specific public function declarations ***************/
/*	The purposes of these functions are the same as the similarly-named,
	non-API-specific functions in qVideoEncoder.h, as are the return values.
	Only exceptions (compared with qVideoEncoder.h) will be documented.
	These functions are only declared here; they must be defined in API-
	specific "sub-plugins". */

/*	qCreateEncoderAPI: API-specific part of qCreateEncoder()
	Arguments: same as qCreateEncoder(), plus:
		eptr: slot to stash the created QDecoder
	Return value: 
		0 for success.  Same error codes as qCreateEncoder()
	Notes:
		On failure, must not store anything in 'eptr'.
*/
int qCreateEncoderAPI(QEncoder **eptr, char *args, int argsSize, int semaIndex, int width, int height);
void qDestroyEncoderAPI(QEncoder *encoder);
int qEncodeAPI(QEncoder *encoder, char* bytes, int byteSize);
char* qEncoderGetPropertyAPI(QEncoder *encoder, char* propertyName, int* resultSize);


/******************** Public function definitions **********************/

void qInitEncoderStorage(void)
{
	memset(encoders, 0, MAX_ENCODERS*sizeof(QEncoder*));
}


int qEncoderIsValid(int encoderIndex)
{
	if (encoderIndex < 0 || encoderIndex >= MAX_ENCODERS) return 0;
	return encoders[encoderIndex] != NULL;
}


int qCreateEncoder(char* args, int argsSize, int semaIndex, int width, int height)
{
	int index = qFindUnusedEncoderIndex();
	int err;
	if (index == -1) {
		qerr << endl << "qCreateEncoder: no available encoder slot";
		return -4; 
	}
	err = qCreateEncoderAPI(&encoders[index], args, argsSize, semaIndex, width, height);
	if (err) return err;
	else {
		encoders[index]->encoderIndex = index;
		return index;
	}
}


void qDestroyEncoder(int encoderIndex)
{
	if (!qEncoderIsValid(encoderIndex)) return;
	qDestroyEncoderAPI(encoders[encoderIndex]);
	encoders[encoderIndex] = NULL;
}


void qDestroyAllEncoders(void)
{
	int i;
	for(i=0; i<MAX_ENCODERS; i++) {
		if (encoders[i] != NULL) qDestroyEncoder(i);
	}
}


int qEncode(int encoderIndex, char* bytes, int byteSize)
{
	if (!qEncoderIsValid(encoderIndex)) return -1;
	return qEncodeAPI(encoders[encoderIndex], bytes, byteSize);
}


// XXXXX: qDecoderRead() and qEncoderRead() are nearly identical...
// this can be refactored so that they use a common function.
int qEncoderRead(int encoderIndex, char* bytes, int maxLength)
{
	if (!qEncoderIsValid(encoderIndex)) return -1;
	QEncoder* encoder = encoders[encoderIndex];
	Qwaq::BufferPtr output = encoder->queue.next();
	size_t outputSize = output->getUsedSize();
	if (outputSize > maxLength) {
		// There is not enough space to copy the output data into.
		qerr << endl << "qEncoderRead: insufficient space (" << outputSize << " required, " << maxLength << " available)";
		return -2;
	}
	if (outputSize == 0) {
		// Nothing to do
		return 0;
	}
	output->copyTo(outputSize, (unsigned char*)bytes);
	return outputSize;
}


char* qEncoderGetProperty(int encoderIndex, char* propertyName, int* resultSize)
{
	if (!qEncoderIsValid(encoderIndex)) {
		*resultSize = 0;
		return NULL;
	}
	QEncoder* encoder = encoders[encoderIndex];
	return qEncoderGetPropertyAPI(encoder, propertyName, resultSize);
}

	 

/******************** Private function definitions *********************/

int qFindUnusedEncoderIndex()
{
	int i;
	for (i = 0; i < MAX_ENCODERS; i++) {
		if (encoders[i] == NULL) return i;
	}
	return -1;
}
